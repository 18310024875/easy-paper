(function() {
  "use strict";
  try {
    if (typeof document != "undefined") {
      var elementStyle = document.createElement("style");
      elementStyle.appendChild(document.createTextNode(`@charset "UTF-8";:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","微软雅黑",Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:0.3s;--el-transition-duration-fast:0.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(0.645,0.045,0.355,1);--el-transition-function-fast-bezier:cubic-bezier(0.23,1,0.32,1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px;color-scheme:light;--el-color-primary:#409eff;--el-color-primary-light-3:rgb(121,187,255);--el-color-primary-light-5:rgb(160,207,255);--el-color-primary-light-7:rgb(198,226,255);--el-color-primary-light-8:rgb(217,236,255);--el-color-primary-light-9:rgb(236,245,255);--el-color-primary-dark-2:rgb(51,126,204);--el-color-success:#67c23a;--el-color-success-light-3:rgb(149,212,117);--el-color-success-light-5:rgb(179,225,157);--el-color-success-light-7:rgb(209,237,196);--el-color-success-light-8:rgb(225,243,216);--el-color-success-light-9:rgb(240,249,235);--el-color-success-dark-2:rgb(82,155,46);--el-color-warning:#e6a23c;--el-color-warning-light-3:rgb(238,190,119);--el-color-warning-light-5:rgb(243,209,158);--el-color-warning-light-7:rgb(248,227,197);--el-color-warning-light-8:rgb(250,236,216);--el-color-warning-light-9:rgb(253,246,236);--el-color-warning-dark-2:rgb(184,130,48);--el-color-danger:#f56c6c;--el-color-danger-light-3:rgb(248,152,152);--el-color-danger-light-5:rgb(250,182,182);--el-color-danger-light-7:rgb(252,211,211);--el-color-danger-light-8:rgb(253,226,226);--el-color-danger-light-9:rgb(254,240,240);--el-color-danger-dark-2:rgb(196,86,86);--el-color-error:#f56c6c;--el-color-error-light-3:rgb(248,152,152);--el-color-error-light-5:rgb(250,182,182);--el-color-error-light-7:rgb(252,211,211);--el-color-error-light-8:rgb(253,226,226);--el-color-error-light-9:rgb(254,240,240);--el-color-error-dark-2:rgb(196,86,86);--el-color-info:#909399;--el-color-info-light-3:rgb(177,179,184);--el-color-info-light-5:rgb(200,201,204);--el-color-info-light-7:rgb(222,223,224);--el-color-info-light-8:rgb(233,233,235);--el-color-info-light-9:rgb(244,244,245);--el-color-info-dark-2:rgb(115,118,122);--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0,0,0,0.04),0px 8px 20px rgba(0,0,0,0.08);--el-box-shadow-light:0px 0px 12px rgba(0,0,0,0.12);--el-box-shadow-lighter:0px 0px 6px rgba(0,0,0,0.12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0,0,0,0.08),0px 12px 32px rgba(0,0,0,0.12),0px 8px 16px -8px rgba(0,0,0,0.16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0,0,0,0.8);--el-overlay-color-light:rgba(0,0,0,0.7);--el-overlay-color-lighter:rgba(0,0,0,0.5);--el-mask-color:rgba(255,255,255,0.9);--el-mask-color-extra-light:rgba(255,255,255,0.3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transform-origin:center top;transition:var(--el-transition-md-fade)}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transform-origin:center bottom;transition:var(--el-transition-md-fade)}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1);transform-origin:top left;transition:var(--el-transition-md-fade)}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@keyframes rotating{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.el-icon{--color:inherit;align-items:center;display:inline-flex;height:1em;justify-content:center;line-height:1em;position:relative;width:1em;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}.el-affix--fixed{position:fixed}.el-alert{--el-alert-padding:8px 16px;--el-alert-border-radius-base:var(--el-border-radius-base);--el-alert-title-font-size:14px;--el-alert-title-with-description-font-size:16px;--el-alert-description-font-size:14px;--el-alert-close-font-size:16px;--el-alert-close-customed-font-size:14px;--el-alert-icon-size:16px;--el-alert-icon-large-size:28px;align-items:center;background-color:var(--el-color-white);border-radius:var(--el-alert-border-radius-base);box-sizing:border-box;display:flex;margin:0;opacity:1;overflow:hidden;padding:var(--el-alert-padding);position:relative;transition:opacity var(--el-transition-duration-fast);width:100%}.el-alert.is-light .el-alert__close-btn{color:var(--el-text-color-placeholder)}.el-alert.is-dark .el-alert__close-btn,.el-alert.is-dark .el-alert__description{color:var(--el-color-white)}.el-alert.is-center{justify-content:center}.el-alert--primary{--el-alert-bg-color:var(--el-color-primary-light-9)}.el-alert--primary.is-light{background-color:var(--el-alert-bg-color)}.el-alert--primary.is-light,.el-alert--primary.is-light .el-alert__description{color:var(--el-color-primary)}.el-alert--primary.is-dark{background-color:var(--el-color-primary);color:var(--el-color-white)}.el-alert--success{--el-alert-bg-color:var(--el-color-success-light-9)}.el-alert--success.is-light{background-color:var(--el-alert-bg-color)}.el-alert--success.is-light,.el-alert--success.is-light .el-alert__description{color:var(--el-color-success)}.el-alert--success.is-dark{background-color:var(--el-color-success);color:var(--el-color-white)}.el-alert--info{--el-alert-bg-color:var(--el-color-info-light-9)}.el-alert--info.is-light{background-color:var(--el-alert-bg-color)}.el-alert--info.is-light,.el-alert--info.is-light .el-alert__description{color:var(--el-color-info)}.el-alert--info.is-dark{background-color:var(--el-color-info);color:var(--el-color-white)}.el-alert--warning{--el-alert-bg-color:var(--el-color-warning-light-9)}.el-alert--warning.is-light{background-color:var(--el-alert-bg-color)}.el-alert--warning.is-light,.el-alert--warning.is-light .el-alert__description{color:var(--el-color-warning)}.el-alert--warning.is-dark{background-color:var(--el-color-warning);color:var(--el-color-white)}.el-alert--error{--el-alert-bg-color:var(--el-color-error-light-9)}.el-alert--error.is-light{background-color:var(--el-alert-bg-color)}.el-alert--error.is-light,.el-alert--error.is-light .el-alert__description{color:var(--el-color-error)}.el-alert--error.is-dark{background-color:var(--el-color-error);color:var(--el-color-white)}.el-alert__content{display:flex;flex-direction:column;gap:4px}.el-alert .el-alert__icon{font-size:var(--el-alert-icon-size);margin-right:8px;width:var(--el-alert-icon-size)}.el-alert .el-alert__icon.is-big{font-size:var(--el-alert-icon-large-size);margin-right:12px;width:var(--el-alert-icon-large-size)}.el-alert__title{font-size:var(--el-alert-title-font-size);line-height:24px}.el-alert__title.with-description{font-size:var(--el-alert-title-with-description-font-size)}.el-alert .el-alert__description{font-size:var(--el-alert-description-font-size);margin:0}.el-alert .el-alert__close-btn{cursor:pointer;font-size:var(--el-alert-close-font-size);opacity:1;position:absolute;right:16px;top:12px}.el-alert .el-alert__close-btn.is-customed{font-size:var(--el-alert-close-customed-font-size);font-style:normal;line-height:24px;top:8px}.el-alert-fade-enter-from,.el-alert-fade-leave-active{opacity:0}.el-aside{box-sizing:border-box;flex-shrink:0;overflow:auto;width:var(--el-aside-width,300px)}.el-autocomplete{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;display:inline-block;position:relative;width:var(--el-input-width)}.el-autocomplete__popper.el-popper{background:var(--el-bg-color-overlay);box-shadow:var(--el-box-shadow-light)}.el-autocomplete__popper.el-popper,.el-autocomplete__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-autocomplete__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent;border-top-color:transparent}.el-autocomplete__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-autocomplete__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent;border-left-color:transparent}.el-autocomplete__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-autocomplete-suggestion{border-radius:var(--el-border-radius-base);box-sizing:border-box}.el-autocomplete-suggestion__header{border-bottom:1px solid var(--el-border-color-lighter);padding:10px}.el-autocomplete-suggestion__footer{border-top:1px solid var(--el-border-color-lighter);padding:10px}.el-autocomplete-suggestion__wrap{box-sizing:border-box;max-height:280px;padding:10px 0}.el-autocomplete-suggestion__list{margin:0;padding:0}.el-autocomplete-suggestion li{color:var(--el-text-color-regular);cursor:pointer;font-size:var(--el-font-size-base);line-height:34px;list-style:none;margin:0;overflow:hidden;padding:0 20px;text-align:left;text-overflow:ellipsis;white-space:nowrap}.el-autocomplete-suggestion li.highlighted,.el-autocomplete-suggestion li:hover{background-color:var(--el-fill-color-light)}.el-autocomplete-suggestion li.divider{border-top:1px solid var(--el-color-black);margin-top:6px}.el-autocomplete-suggestion li.divider:last-child{margin-bottom:-6px}.el-autocomplete-suggestion.is-loading li{color:var(--el-text-color-secondary);cursor:default;font-size:20px;height:100px;line-height:100px;text-align:center}.el-autocomplete-suggestion.is-loading li:after{content:"";display:inline-block;height:100%;vertical-align:middle}.el-autocomplete-suggestion.is-loading li:hover{background-color:var(--el-bg-color-overlay)}.el-avatar{--el-avatar-text-color:var(--el-color-white);--el-avatar-bg-color:var(--el-text-color-disabled);--el-avatar-text-size:14px;--el-avatar-icon-size:18px;--el-avatar-border-radius:var(--el-border-radius-base);--el-avatar-size-large:56px;--el-avatar-size-small:24px;--el-avatar-size:40px;align-items:center;background:var(--el-avatar-bg-color);box-sizing:border-box;color:var(--el-avatar-text-color);display:inline-flex;font-size:var(--el-avatar-text-size);height:var(--el-avatar-size);justify-content:center;outline:none;overflow:hidden;text-align:center;width:var(--el-avatar-size)}.el-avatar>img{display:block;height:100%;width:100%}.el-avatar--circle{border-radius:50%}.el-avatar--square{border-radius:var(--el-avatar-border-radius)}.el-avatar--icon{font-size:var(--el-avatar-icon-size)}.el-avatar--small{--el-avatar-size:24px}.el-avatar--large{--el-avatar-size:56px}.el-backtop{--el-backtop-bg-color:var(--el-bg-color-overlay);--el-backtop-text-color:var(--el-color-primary);--el-backtop-hover-bg-color:var(--el-border-color-extra-light);align-items:center;background-color:var(--el-backtop-bg-color);border-radius:50%;box-shadow:var(--el-box-shadow-lighter);color:var(--el-backtop-text-color);cursor:pointer;display:flex;font-size:20px;height:40px;justify-content:center;position:fixed;width:40px;z-index:5}.el-backtop:hover{background-color:var(--el-backtop-hover-bg-color)}.el-backtop__icon{font-size:20px}.el-badge{--el-badge-bg-color:var(--el-color-danger);--el-badge-radius:10px;--el-badge-font-size:12px;--el-badge-padding:6px;--el-badge-size:18px;display:inline-block;position:relative;vertical-align:middle;width:-moz-fit-content;width:fit-content}.el-badge__content{align-items:center;background-color:var(--el-badge-bg-color);border:1px solid var(--el-bg-color);border-radius:var(--el-badge-radius);color:var(--el-color-white);display:inline-flex;font-size:var(--el-badge-font-size);height:var(--el-badge-size);justify-content:center;padding:0 var(--el-badge-padding);white-space:nowrap}.el-badge__content.is-fixed{position:absolute;right:calc(1px + var(--el-badge-size)/2);top:0;transform:translateY(-50%) translateX(100%);z-index:var(--el-index-normal)}.el-badge__content.is-fixed.is-dot{right:5px}.el-badge__content.is-dot{border-radius:50%;height:8px;padding:0;right:0;width:8px}.el-badge__content.is-hide-zero{display:none}.el-badge__content--primary{background-color:var(--el-color-primary)}.el-badge__content--success{background-color:var(--el-color-success)}.el-badge__content--warning{background-color:var(--el-color-warning)}.el-badge__content--info{background-color:var(--el-color-info)}.el-badge__content--danger{background-color:var(--el-color-danger)}.el-breadcrumb{font-size:14px;line-height:1}.el-breadcrumb:after,.el-breadcrumb:before{content:"";display:table}.el-breadcrumb:after{clear:both}.el-breadcrumb__separator{color:var(--el-text-color-placeholder);font-weight:bold;margin:0 9px}.el-breadcrumb__separator.el-icon{font-weight:normal;margin:0 6px}.el-breadcrumb__separator.el-icon svg{vertical-align:middle}.el-breadcrumb__item{align-items:center;display:inline-flex;float:left}.el-breadcrumb__inner{color:var(--el-text-color-regular)}.el-breadcrumb__inner a,.el-breadcrumb__inner.is-link{color:var(--el-text-color-primary);font-weight:bold;text-decoration:none;transition:var(--el-transition-color)}.el-breadcrumb__inner a:hover,.el-breadcrumb__inner.is-link:hover{color:var(--el-color-primary);cursor:pointer}.el-breadcrumb__item:last-child .el-breadcrumb__inner,.el-breadcrumb__item:last-child .el-breadcrumb__inner a,.el-breadcrumb__item:last-child .el-breadcrumb__inner a:hover,.el-breadcrumb__item:last-child .el-breadcrumb__inner:hover{color:var(--el-text-color-regular);cursor:text;font-weight:normal}.el-breadcrumb__item:last-child .el-breadcrumb__separator{display:none}.el-button-group{display:inline-block;vertical-align:middle}.el-button-group:after,.el-button-group:before{content:"";display:table}.el-button-group:after{clear:both}.el-button-group>.el-button{float:left;position:relative}.el-button-group>.el-button+.el-button{margin-left:0}.el-button-group>.el-button:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.el-button-group>.el-button:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.el-button-group>.el-button:first-child:last-child{border-bottom-left-radius:var(--el-border-radius-base);border-bottom-right-radius:var(--el-border-radius-base);border-top-left-radius:var(--el-border-radius-base);border-top-right-radius:var(--el-border-radius-base)}.el-button-group>.el-button:first-child:last-child.is-round{border-radius:var(--el-border-radius-round)}.el-button-group>.el-button:first-child:last-child.is-circle{border-radius:50%}.el-button-group>.el-button:not(:first-child):not(:last-child){border-radius:0}.el-button-group>.el-button:not(:last-child){margin-right:-1px}.el-button-group>.el-button.is-active,.el-button-group>.el-button:active,.el-button-group>.el-button:focus,.el-button-group>.el-button:hover{z-index:1}.el-button-group>.el-dropdown>.el-button{border-bottom-left-radius:0;border-left-color:var(--el-button-divide-border-color);border-top-left-radius:0}.el-button-group .el-button--primary:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button{--el-button-font-weight:var(--el-font-weight-primary);--el-button-border-color:var(--el-border-color);--el-button-bg-color:var(--el-fill-color-blank);--el-button-text-color:var(--el-text-color-regular);--el-button-disabled-text-color:var(--el-disabled-text-color);--el-button-disabled-bg-color:var(--el-fill-color-blank);--el-button-disabled-border-color:var(--el-border-color-light);--el-button-divide-border-color:rgba(255,255,255,0.5);--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-color-primary-light-9);--el-button-hover-border-color:var(--el-color-primary-light-7);--el-button-active-text-color:var(--el-button-hover-text-color);--el-button-active-border-color:var(--el-color-primary);--el-button-active-bg-color:var(--el-button-hover-bg-color);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-hover-link-text-color:var(--el-text-color-secondary);--el-button-active-color:var(--el-text-color-primary);align-items:center;-webkit-appearance:none;background-color:var(--el-button-bg-color);border:var(--el-border);border-color:var(--el-button-border-color);box-sizing:border-box;color:var(--el-button-text-color);cursor:pointer;display:inline-flex;font-weight:var(--el-button-font-weight);height:32px;justify-content:center;line-height:1;outline:none;text-align:center;transition:.1s;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle;white-space:nowrap}.el-button:hover{background-color:var(--el-button-hover-bg-color);border-color:var(--el-button-hover-border-color);color:var(--el-button-hover-text-color);outline:none}.el-button:active{background-color:var(--el-button-active-bg-color);border-color:var(--el-button-active-border-color);color:var(--el-button-active-text-color);outline:none}.el-button:focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px;transition:outline-offset 0s,outline 0s}.el-button>span{align-items:center;display:inline-flex}.el-button+.el-button{margin-left:12px}.el-button{border-radius:var(--el-border-radius-base);font-size:var(--el-font-size-base)}.el-button,.el-button.is-round{padding:8px 15px}.el-button::-moz-focus-inner{border:0}.el-button [class*=el-icon]+span{margin-left:6px}.el-button [class*=el-icon] svg{vertical-align:bottom}.el-button.is-plain{--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-fill-color-blank);--el-button-hover-border-color:var(--el-color-primary)}.el-button.is-active{background-color:var(--el-button-active-bg-color);border-color:var(--el-button-active-border-color);color:var(--el-button-active-text-color);outline:none}.el-button.is-disabled,.el-button.is-disabled:hover{background-color:var(--el-button-disabled-bg-color);background-image:none;border-color:var(--el-button-disabled-border-color);color:var(--el-button-disabled-text-color);cursor:not-allowed}.el-button.is-loading{pointer-events:none;position:relative}.el-button.is-loading:before{background-color:var(--el-mask-color-extra-light);border-radius:inherit;bottom:-1px;content:"";left:-1px;pointer-events:none;position:absolute;right:-1px;top:-1px;z-index:1}.el-button.is-round{border-radius:var(--el-border-radius-round)}.el-button.is-circle{border-radius:50%;padding:8px;width:32px}.el-button.is-text{background-color:transparent;border:0 solid transparent;color:var(--el-button-text-color)}.el-button.is-text.is-disabled{background-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button.is-text:not(.is-disabled):hover{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled):focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px;transition:outline-offset 0s,outline 0s}.el-button.is-text:not(.is-disabled):active{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled).is-has-bg:hover{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg:active{background-color:var(--el-fill-color-dark)}.el-button__text--expand{letter-spacing:.3em;margin-right:-.3em}.el-button.is-link{background:transparent;border-color:transparent;color:var(--el-button-text-color);height:auto;padding:2px}.el-button.is-link:hover{color:var(--el-button-hover-link-text-color)}.el-button.is-link.is-disabled{background-color:transparent!important;border-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button.is-link:not(.is-disabled):active,.el-button.is-link:not(.is-disabled):hover{background-color:transparent;border-color:transparent}.el-button.is-link:not(.is-disabled):active{color:var(--el-button-active-color)}.el-button--text{background:transparent;border-color:transparent;color:var(--el-color-primary);padding-left:0;padding-right:0}.el-button--text.is-disabled{background-color:transparent!important;border-color:transparent!important;color:var(--el-button-disabled-text-color)}.el-button--text:not(.is-disabled):hover{background-color:transparent;border-color:transparent;color:var(--el-color-primary-light-3)}.el-button--text:not(.is-disabled):active{background-color:transparent;border-color:transparent;color:var(--el-color-primary-dark-2)}.el-button__link--expand{letter-spacing:.3em;margin-right:-.3em}.el-button--primary{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-primary);--el-button-border-color:var(--el-color-primary);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-active-color:var(--el-color-primary-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-primary-light-5);--el-button-hover-bg-color:var(--el-color-primary-light-3);--el-button-hover-border-color:var(--el-color-primary-light-3);--el-button-active-bg-color:var(--el-color-primary-dark-2);--el-button-active-border-color:var(--el-color-primary-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-primary-light-5);--el-button-disabled-border-color:var(--el-color-primary-light-5)}.el-button--primary.is-link,.el-button--primary.is-plain,.el-button--primary.is-text{--el-button-text-color:var(--el-color-primary);--el-button-bg-color:var(--el-color-primary-light-9);--el-button-border-color:var(--el-color-primary-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-primary);--el-button-hover-border-color:var(--el-color-primary);--el-button-active-text-color:var(--el-color-white)}.el-button--primary.is-link.is-disabled,.el-button--primary.is-link.is-disabled:active,.el-button--primary.is-link.is-disabled:focus,.el-button--primary.is-link.is-disabled:hover,.el-button--primary.is-plain.is-disabled,.el-button--primary.is-plain.is-disabled:active,.el-button--primary.is-plain.is-disabled:focus,.el-button--primary.is-plain.is-disabled:hover,.el-button--primary.is-text.is-disabled,.el-button--primary.is-text.is-disabled:active,.el-button--primary.is-text.is-disabled:focus,.el-button--primary.is-text.is-disabled:hover{background-color:var(--el-color-primary-light-9);border-color:var(--el-color-primary-light-8);color:var(--el-color-primary-light-5)}.el-button--success{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-success);--el-button-border-color:var(--el-color-success);--el-button-outline-color:var(--el-color-success-light-5);--el-button-active-color:var(--el-color-success-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-success-light-5);--el-button-hover-bg-color:var(--el-color-success-light-3);--el-button-hover-border-color:var(--el-color-success-light-3);--el-button-active-bg-color:var(--el-color-success-dark-2);--el-button-active-border-color:var(--el-color-success-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-success-light-5);--el-button-disabled-border-color:var(--el-color-success-light-5)}.el-button--success.is-link,.el-button--success.is-plain,.el-button--success.is-text{--el-button-text-color:var(--el-color-success);--el-button-bg-color:var(--el-color-success-light-9);--el-button-border-color:var(--el-color-success-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-success);--el-button-hover-border-color:var(--el-color-success);--el-button-active-text-color:var(--el-color-white)}.el-button--success.is-link.is-disabled,.el-button--success.is-link.is-disabled:active,.el-button--success.is-link.is-disabled:focus,.el-button--success.is-link.is-disabled:hover,.el-button--success.is-plain.is-disabled,.el-button--success.is-plain.is-disabled:active,.el-button--success.is-plain.is-disabled:focus,.el-button--success.is-plain.is-disabled:hover,.el-button--success.is-text.is-disabled,.el-button--success.is-text.is-disabled:active,.el-button--success.is-text.is-disabled:focus,.el-button--success.is-text.is-disabled:hover{background-color:var(--el-color-success-light-9);border-color:var(--el-color-success-light-8);color:var(--el-color-success-light-5)}.el-button--warning{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-warning);--el-button-border-color:var(--el-color-warning);--el-button-outline-color:var(--el-color-warning-light-5);--el-button-active-color:var(--el-color-warning-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-warning-light-5);--el-button-hover-bg-color:var(--el-color-warning-light-3);--el-button-hover-border-color:var(--el-color-warning-light-3);--el-button-active-bg-color:var(--el-color-warning-dark-2);--el-button-active-border-color:var(--el-color-warning-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-warning-light-5);--el-button-disabled-border-color:var(--el-color-warning-light-5)}.el-button--warning.is-link,.el-button--warning.is-plain,.el-button--warning.is-text{--el-button-text-color:var(--el-color-warning);--el-button-bg-color:var(--el-color-warning-light-9);--el-button-border-color:var(--el-color-warning-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-warning);--el-button-hover-border-color:var(--el-color-warning);--el-button-active-text-color:var(--el-color-white)}.el-button--warning.is-link.is-disabled,.el-button--warning.is-link.is-disabled:active,.el-button--warning.is-link.is-disabled:focus,.el-button--warning.is-link.is-disabled:hover,.el-button--warning.is-plain.is-disabled,.el-button--warning.is-plain.is-disabled:active,.el-button--warning.is-plain.is-disabled:focus,.el-button--warning.is-plain.is-disabled:hover,.el-button--warning.is-text.is-disabled,.el-button--warning.is-text.is-disabled:active,.el-button--warning.is-text.is-disabled:focus,.el-button--warning.is-text.is-disabled:hover{background-color:var(--el-color-warning-light-9);border-color:var(--el-color-warning-light-8);color:var(--el-color-warning-light-5)}.el-button--danger{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-danger);--el-button-border-color:var(--el-color-danger);--el-button-outline-color:var(--el-color-danger-light-5);--el-button-active-color:var(--el-color-danger-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-danger-light-5);--el-button-hover-bg-color:var(--el-color-danger-light-3);--el-button-hover-border-color:var(--el-color-danger-light-3);--el-button-active-bg-color:var(--el-color-danger-dark-2);--el-button-active-border-color:var(--el-color-danger-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-danger-light-5);--el-button-disabled-border-color:var(--el-color-danger-light-5)}.el-button--danger.is-link,.el-button--danger.is-plain,.el-button--danger.is-text{--el-button-text-color:var(--el-color-danger);--el-button-bg-color:var(--el-color-danger-light-9);--el-button-border-color:var(--el-color-danger-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-danger);--el-button-hover-border-color:var(--el-color-danger);--el-button-active-text-color:var(--el-color-white)}.el-button--danger.is-link.is-disabled,.el-button--danger.is-link.is-disabled:active,.el-button--danger.is-link.is-disabled:focus,.el-button--danger.is-link.is-disabled:hover,.el-button--danger.is-plain.is-disabled,.el-button--danger.is-plain.is-disabled:active,.el-button--danger.is-plain.is-disabled:focus,.el-button--danger.is-plain.is-disabled:hover,.el-button--danger.is-text.is-disabled,.el-button--danger.is-text.is-disabled:active,.el-button--danger.is-text.is-disabled:focus,.el-button--danger.is-text.is-disabled:hover{background-color:var(--el-color-danger-light-9);border-color:var(--el-color-danger-light-8);color:var(--el-color-danger-light-5)}.el-button--info{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-info);--el-button-border-color:var(--el-color-info);--el-button-outline-color:var(--el-color-info-light-5);--el-button-active-color:var(--el-color-info-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-info-light-5);--el-button-hover-bg-color:var(--el-color-info-light-3);--el-button-hover-border-color:var(--el-color-info-light-3);--el-button-active-bg-color:var(--el-color-info-dark-2);--el-button-active-border-color:var(--el-color-info-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-info-light-5);--el-button-disabled-border-color:var(--el-color-info-light-5)}.el-button--info.is-link,.el-button--info.is-plain,.el-button--info.is-text{--el-button-text-color:var(--el-color-info);--el-button-bg-color:var(--el-color-info-light-9);--el-button-border-color:var(--el-color-info-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-info);--el-button-hover-border-color:var(--el-color-info);--el-button-active-text-color:var(--el-color-white)}.el-button--info.is-link.is-disabled,.el-button--info.is-link.is-disabled:active,.el-button--info.is-link.is-disabled:focus,.el-button--info.is-link.is-disabled:hover,.el-button--info.is-plain.is-disabled,.el-button--info.is-plain.is-disabled:active,.el-button--info.is-plain.is-disabled:focus,.el-button--info.is-plain.is-disabled:hover,.el-button--info.is-text.is-disabled,.el-button--info.is-text.is-disabled:active,.el-button--info.is-text.is-disabled:focus,.el-button--info.is-text.is-disabled:hover{background-color:var(--el-color-info-light-9);border-color:var(--el-color-info-light-8);color:var(--el-color-info-light-5)}.el-button--large{--el-button-size:40px;height:var(--el-button-size)}.el-button--large [class*=el-icon]+span{margin-left:8px}.el-button--large{border-radius:var(--el-border-radius-base);font-size:var(--el-font-size-base);padding:12px 19px}.el-button--large.is-round{padding:12px 19px}.el-button--large.is-circle{padding:12px;width:var(--el-button-size)}.el-button--small{--el-button-size:24px;height:var(--el-button-size)}.el-button--small [class*=el-icon]+span{margin-left:4px}.el-button--small{border-radius:calc(var(--el-border-radius-base) - 1px);font-size:12px;padding:5px 11px}.el-button--small.is-round{padding:5px 11px}.el-button--small.is-circle{padding:5px;width:var(--el-button-size)}.el-calendar{--el-calendar-border:var(--el-table-border,1px solid var(--el-border-color-lighter));--el-calendar-header-border-bottom:var(--el-calendar-border);--el-calendar-selected-bg-color:var(--el-color-primary-light-9);--el-calendar-cell-width:85px;background-color:var(--el-fill-color-blank)}.el-calendar__header{border-bottom:var(--el-calendar-header-border-bottom);display:flex;justify-content:space-between;padding:12px 20px}.el-calendar__title{align-self:center;color:var(--el-text-color)}.el-calendar__body{padding:12px 20px 35px}.el-calendar-table{table-layout:fixed;width:100%}.el-calendar-table thead th{color:var(--el-text-color-regular);font-weight:normal;padding:12px 0}.el-calendar-table:not(.is-range) td.next,.el-calendar-table:not(.is-range) td.prev{color:var(--el-text-color-placeholder)}.el-calendar-table td{border-bottom:var(--el-calendar-border);border-right:var(--el-calendar-border);transition:background-color var(--el-transition-duration-fast) ease;vertical-align:top}.el-calendar-table td.is-selected{background-color:var(--el-calendar-selected-bg-color)}.el-calendar-table td.is-today{color:var(--el-color-primary)}.el-calendar-table tr:first-child td{border-top:var(--el-calendar-border)}.el-calendar-table tr td:first-child{border-left:var(--el-calendar-border)}.el-calendar-table tr.el-calendar-table__row--hide-border td{border-top:none}.el-calendar-table .el-calendar-day{box-sizing:border-box;height:var(--el-calendar-cell-width);padding:8px}.el-calendar-table .el-calendar-day:hover{background-color:var(--el-calendar-selected-bg-color);cursor:pointer}.el-card{--el-card-border-color:var(--el-border-color-light);--el-card-border-radius:4px;--el-card-padding:20px;--el-card-bg-color:var(--el-fill-color-blank);background-color:var(--el-card-bg-color);border:1px solid var(--el-card-border-color);border-radius:var(--el-card-border-radius);color:var(--el-text-color-primary);overflow:hidden;transition:var(--el-transition-duration)}.el-card.is-always-shadow,.el-card.is-hover-shadow:focus,.el-card.is-hover-shadow:hover{box-shadow:var(--el-box-shadow-light)}.el-card__header{border-bottom:1px solid var(--el-card-border-color);box-sizing:border-box;padding:calc(var(--el-card-padding) - 2px) var(--el-card-padding)}.el-card__body{padding:var(--el-card-padding)}.el-card__footer{border-top:1px solid var(--el-card-border-color);box-sizing:border-box;padding:calc(var(--el-card-padding) - 2px) var(--el-card-padding)}.el-carousel__item{display:inline-block;height:100%;left:0;overflow:hidden;position:absolute;top:0;width:100%}.el-carousel__item,.el-carousel__item.is-active{z-index:calc(var(--el-index-normal) - 1)}.el-carousel__item--card,.el-carousel__item.is-animating{transition:transform .4s ease-in-out}.el-carousel__item--card{width:50%}.el-carousel__item--card.is-in-stage{cursor:pointer;z-index:var(--el-index-normal)}.el-carousel__item--card.is-in-stage.is-hover .el-carousel__mask,.el-carousel__item--card.is-in-stage:hover .el-carousel__mask{opacity:.12}.el-carousel__item--card.is-active{z-index:calc(var(--el-index-normal) + 1)}.el-carousel__item--card-vertical{height:50%;width:100%}.el-carousel__mask{background-color:var(--el-color-white);height:100%;left:0;opacity:.24;position:absolute;top:0;transition:var(--el-transition-duration-fast);width:100%}.el-carousel{--el-carousel-arrow-font-size:12px;--el-carousel-arrow-size:36px;--el-carousel-arrow-background:rgba(31,45,61,0.11);--el-carousel-arrow-hover-background:rgba(31,45,61,0.23);--el-carousel-indicator-width:30px;--el-carousel-indicator-height:2px;--el-carousel-indicator-padding-horizontal:4px;--el-carousel-indicator-padding-vertical:12px;--el-carousel-indicator-out-color:var(--el-border-color-hover);position:relative}.el-carousel--horizontal,.el-carousel--vertical{overflow:hidden}.el-carousel__container{height:300px;position:relative}.el-carousel__arrow{align-items:center;background-color:var(--el-carousel-arrow-background);border:none;border-radius:50%;color:#ffffff;cursor:pointer;display:inline-flex;font-size:var(--el-carousel-arrow-font-size);height:var(--el-carousel-arrow-size);justify-content:center;margin:0;outline:none;padding:0;position:absolute;text-align:center;top:50%;transform:translateY(-50%);transition:var(--el-transition-duration);width:var(--el-carousel-arrow-size);z-index:10}.el-carousel__arrow--left{left:16px}.el-carousel__arrow--right{right:16px}.el-carousel__arrow:hover{background-color:var(--el-carousel-arrow-hover-background)}.el-carousel__arrow i{cursor:pointer}.el-carousel__indicators{list-style:none;margin:0;padding:0;position:absolute;z-index:calc(var(--el-index-normal) + 1)}.el-carousel__indicators--horizontal{bottom:0;left:50%;transform:translateX(-50%)}.el-carousel__indicators--vertical{right:0;top:50%;transform:translateY(-50%)}.el-carousel__indicators--outside{bottom:calc(var(--el-carousel-indicator-height) + var(--el-carousel-indicator-padding-vertical)*2);position:static;text-align:center;transform:none}.el-carousel__indicators--outside .el-carousel__indicator:hover button{opacity:.64}.el-carousel__indicators--outside button{background-color:var(--el-carousel-indicator-out-color);opacity:.24}.el-carousel__indicators--right{right:0}.el-carousel__indicators--labels{left:0;right:0;text-align:center;transform:none}.el-carousel__indicators--labels .el-carousel__button{color:#000000;font-size:12px;height:auto;padding:2px 18px;width:auto}.el-carousel__indicators--labels .el-carousel__indicator{padding:6px 4px}.el-carousel__indicator{background-color:transparent;cursor:pointer}.el-carousel__indicator:hover button{opacity:.72}.el-carousel__indicator--horizontal{display:inline-block;padding:var(--el-carousel-indicator-padding-vertical) var(--el-carousel-indicator-padding-horizontal)}.el-carousel__indicator--vertical{padding:var(--el-carousel-indicator-padding-horizontal) var(--el-carousel-indicator-padding-vertical)}.el-carousel__indicator--vertical .el-carousel__button{height:calc(var(--el-carousel-indicator-width)/2);width:var(--el-carousel-indicator-height)}.el-carousel__indicator.is-active button{opacity:1}.el-carousel__button{background-color:#ffffff;border:none;cursor:pointer;display:block;height:var(--el-carousel-indicator-height);margin:0;opacity:.48;outline:none;padding:0;transition:var(--el-transition-duration);width:var(--el-carousel-indicator-width)}.carousel-arrow-left-enter-from,.carousel-arrow-left-leave-active{opacity:0;transform:translateY(-50%) translateX(-10px)}.carousel-arrow-right-enter-from,.carousel-arrow-right-leave-active{opacity:0;transform:translateY(-50%) translateX(10px)}.el-transitioning{filter:url(#elCarouselHorizontal)}.el-transitioning-vertical{filter:url(#elCarouselVertical)}.el-cascader-panel{--el-cascader-menu-text-color:var(--el-text-color-regular);--el-cascader-menu-selected-text-color:var(--el-color-primary);--el-cascader-menu-fill:var(--el-bg-color-overlay);--el-cascader-menu-font-size:var(--el-font-size-base);--el-cascader-menu-radius:var(--el-border-radius-base);--el-cascader-menu-border:solid 1px var(--el-border-color-light);--el-cascader-menu-shadow:var(--el-box-shadow-light);--el-cascader-node-background-hover:var(--el-fill-color-light);--el-cascader-node-color-disabled:var(--el-text-color-placeholder);--el-cascader-color-empty:var(--el-text-color-placeholder);--el-cascader-tag-background:var(--el-fill-color);border-radius:var(--el-cascader-menu-radius);display:flex;font-size:var(--el-cascader-menu-font-size)}.el-cascader-panel.is-bordered{border:var(--el-cascader-menu-border);border-radius:var(--el-cascader-menu-radius)}.el-cascader-menu{border-right:var(--el-cascader-menu-border);box-sizing:border-box;color:var(--el-cascader-menu-text-color);min-width:180px}.el-cascader-menu:last-child{border-right:none}.el-cascader-menu:last-child .el-cascader-node{padding-right:20px}.el-cascader-menu__wrap.el-scrollbar__wrap{height:204px}.el-cascader-menu__list{box-sizing:border-box;list-style:none;margin:0;min-height:100%;padding:6px 0;position:relative}.el-cascader-menu__hover-zone{height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.el-cascader-menu__empty-text{align-items:center;color:var(--el-cascader-color-empty);display:flex;left:50%;position:absolute;top:50%;transform:translate(-50%,-50%)}.el-cascader-menu__empty-text .is-loading{margin-right:2px}.el-cascader-node{align-items:center;display:flex;height:34px;line-height:34px;outline:none;padding:0 30px 0 20px;position:relative}.el-cascader-node.is-selectable.in-active-path{color:var(--el-cascader-menu-text-color)}.el-cascader-node.in-active-path,.el-cascader-node.is-active,.el-cascader-node.is-selectable.in-checked-path{color:var(--el-cascader-menu-selected-text-color);font-weight:bold}.el-cascader-node:not(.is-disabled){cursor:pointer}.el-cascader-node:not(.is-disabled):focus,.el-cascader-node:not(.is-disabled):hover{background:var(--el-cascader-node-background-hover)}.el-cascader-node.is-disabled{color:var(--el-cascader-node-color-disabled);cursor:not-allowed}.el-cascader-node__prefix{left:10px;position:absolute}.el-cascader-node__postfix{position:absolute;right:10px}.el-cascader-node__label{flex:1;overflow:hidden;padding:0 8px;text-align:left;text-overflow:ellipsis;white-space:nowrap}.el-cascader-node>.el-checkbox,.el-cascader-node>.el-radio{margin-right:0}.el-cascader-node>.el-radio .el-radio__label{padding-left:0}.el-cascader{--el-cascader-menu-text-color:var(--el-text-color-regular);--el-cascader-menu-selected-text-color:var(--el-color-primary);--el-cascader-menu-fill:var(--el-bg-color-overlay);--el-cascader-menu-font-size:var(--el-font-size-base);--el-cascader-menu-radius:var(--el-border-radius-base);--el-cascader-menu-border:solid 1px var(--el-border-color-light);--el-cascader-menu-shadow:var(--el-box-shadow-light);--el-cascader-node-background-hover:var(--el-fill-color-light);--el-cascader-node-color-disabled:var(--el-text-color-placeholder);--el-cascader-color-empty:var(--el-text-color-placeholder);--el-cascader-tag-background:var(--el-fill-color);display:inline-block;font-size:var(--el-font-size-base);line-height:32px;outline:none;position:relative;vertical-align:middle}.el-cascader:not(.is-disabled):hover .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset;cursor:pointer}.el-cascader .el-input{cursor:pointer;display:flex}.el-cascader .el-input .el-input__inner{cursor:pointer;text-overflow:ellipsis}.el-cascader .el-input .el-input__suffix-inner .el-icon svg{vertical-align:middle}.el-cascader .el-input .icon-arrow-down{font-size:14px;transition:transform var(--el-transition-duration)}.el-cascader .el-input .icon-arrow-down.is-reverse{transform:rotate(180deg)}.el-cascader .el-input .icon-circle-close:hover{color:var(--el-input-clear-hover-color,var(--el-text-color-secondary))}.el-cascader .el-input.is-focus .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-border-color,var(--el-color-primary)) inset}.el-cascader--large{font-size:14px;line-height:40px}.el-cascader--large .el-cascader__tags{gap:6px;padding:8px}.el-cascader--large .el-cascader__search-input{height:24px;margin-left:7px}.el-cascader--small{font-size:12px;line-height:24px}.el-cascader--small .el-cascader__tags{gap:4px;padding:2px}.el-cascader--small .el-cascader__search-input{height:20px;margin-left:5px}.el-cascader.is-disabled .el-cascader__label{color:var(--el-disabled-text-color);z-index:calc(var(--el-index-normal) + 1)}.el-cascader__dropdown{--el-cascader-menu-text-color:var(--el-text-color-regular);--el-cascader-menu-selected-text-color:var(--el-color-primary);--el-cascader-menu-fill:var(--el-bg-color-overlay);--el-cascader-menu-font-size:var(--el-font-size-base);--el-cascader-menu-radius:var(--el-border-radius-base);--el-cascader-menu-border:solid 1px var(--el-border-color-light);--el-cascader-menu-shadow:var(--el-box-shadow-light);--el-cascader-node-background-hover:var(--el-fill-color-light);--el-cascader-node-color-disabled:var(--el-text-color-placeholder);--el-cascader-color-empty:var(--el-text-color-placeholder);--el-cascader-tag-background:var(--el-fill-color);border-radius:var(--el-cascader-menu-radius);font-size:var(--el-cascader-menu-font-size)}.el-cascader__dropdown.el-popper{background:var(--el-cascader-menu-fill)}.el-cascader__dropdown.el-popper,.el-cascader__dropdown.el-popper .el-popper__arrow:before{border:var(--el-cascader-menu-border)}.el-cascader__dropdown.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent;border-top-color:transparent}.el-cascader__dropdown.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-cascader__dropdown.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent;border-left-color:transparent}.el-cascader__dropdown.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-cascader__dropdown.el-popper{box-shadow:var(--el-cascader-menu-shadow)}.el-cascader__header{border-bottom:1px solid var(--el-border-color-light);padding:10px}.el-cascader__footer{border-top:1px solid var(--el-border-color-light);padding:10px}.el-cascader__tags{box-sizing:border-box;display:flex;flex-wrap:wrap;gap:6px;left:0;line-height:normal;padding:4px;position:absolute;right:30px;text-align:left;top:50%;transform:translateY(-50%)}.el-cascader__tags .el-tag{align-items:center;background:var(--el-cascader-tag-background);display:inline-flex;max-width:100%;text-overflow:ellipsis}.el-cascader__tags .el-tag.el-tag--dark,.el-cascader__tags .el-tag.el-tag--plain{background-color:var(--el-tag-bg-color)}.el-cascader__tags .el-tag:not(.is-hit){border-color:transparent}.el-cascader__tags .el-tag:not(.is-hit).el-tag--dark,.el-cascader__tags .el-tag:not(.is-hit).el-tag--plain{border-color:var(--el-tag-border-color)}.el-cascader__tags .el-tag>span{flex:1;line-height:normal;overflow:hidden;text-overflow:ellipsis}.el-cascader__tags .el-tag .el-icon-close{background-color:var(--el-text-color-placeholder);color:var(--el-color-white);flex:none}.el-cascader__tags .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-cascader__tags .el-tag+input{margin-left:0}.el-cascader__tags.is-validate{right:55px}.el-cascader__collapse-tags{white-space:normal;z-index:var(--el-index-normal)}.el-cascader__collapse-tags .el-tag{align-items:center;background:var(--el-fill-color);display:inline-flex;max-width:100%;text-overflow:ellipsis}.el-cascader__collapse-tags .el-tag.el-tag--dark,.el-cascader__collapse-tags .el-tag.el-tag--plain{background-color:var(--el-tag-bg-color)}.el-cascader__collapse-tags .el-tag:not(.is-hit){border-color:transparent}.el-cascader__collapse-tags .el-tag:not(.is-hit).el-tag--dark,.el-cascader__collapse-tags .el-tag:not(.is-hit).el-tag--plain{border-color:var(--el-tag-border-color)}.el-cascader__collapse-tags .el-tag>span{flex:1;line-height:normal;overflow:hidden;text-overflow:ellipsis}.el-cascader__collapse-tags .el-tag .el-icon-close{background-color:var(--el-text-color-placeholder);color:var(--el-color-white);flex:none}.el-cascader__collapse-tags .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-cascader__collapse-tags .el-tag+input{margin-left:0}.el-cascader__collapse-tags .el-tag{margin:2px 0}.el-cascader__suggestion-panel{border-radius:var(--el-cascader-menu-radius)}.el-cascader__suggestion-list{color:var(--el-cascader-menu-text-color);font-size:var(--el-font-size-base);margin:0;max-height:204px;padding:6px 0;text-align:center}.el-cascader__suggestion-item{align-items:center;cursor:pointer;display:flex;height:34px;justify-content:space-between;outline:none;padding:0 15px;text-align:left}.el-cascader__suggestion-item:focus,.el-cascader__suggestion-item:hover{background:var(--el-cascader-node-background-hover)}.el-cascader__suggestion-item.is-checked{color:var(--el-cascader-menu-selected-text-color);font-weight:bold}.el-cascader__suggestion-item>span{margin-right:10px}.el-cascader__empty-text{color:var(--el-cascader-color-empty);margin:10px 0}.el-cascader__search-input{background:transparent;border:none;box-sizing:border-box;color:var(--el-cascader-menu-text-color);flex:1;height:24px;margin-left:7px;min-width:60px;outline:none;padding:0}.el-cascader__search-input::-moz-placeholder{color:transparent}.el-cascader__search-input::placeholder{color:transparent}.el-check-tag{background-color:var(--el-color-info-light-9);border-radius:var(--el-border-radius-base);color:var(--el-color-info);cursor:pointer;display:inline-block;font-size:var(--el-font-size-base);font-weight:bold;line-height:var(--el-font-size-base);padding:7px 15px;transition:var(--el-transition-all)}.el-check-tag:hover{background-color:var(--el-color-info-light-7)}.el-check-tag.el-check-tag--primary.is-checked{background-color:var(--el-color-primary-light-8);color:var(--el-color-primary)}.el-check-tag.el-check-tag--primary.is-checked:hover{background-color:var(--el-color-primary-light-7)}.el-check-tag.el-check-tag--primary.is-checked.is-disabled{background-color:var(--el-color-primary-light-8);color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--primary.is-checked.is-disabled:hover{background-color:var(--el-color-primary-light-8)}.el-check-tag.el-check-tag--primary.is-disabled{background-color:var(--el-color-info-light-9);color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--primary.is-disabled:hover{background-color:var(--el-color-info-light-9)}.el-check-tag.el-check-tag--success.is-checked{background-color:var(--el-color-success-light-8);color:var(--el-color-success)}.el-check-tag.el-check-tag--success.is-checked:hover{background-color:var(--el-color-success-light-7)}.el-check-tag.el-check-tag--success.is-checked.is-disabled{background-color:var(--el-color-success-light-8);color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--success.is-checked.is-disabled:hover{background-color:var(--el-color-success-light-8)}.el-check-tag.el-check-tag--success.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--success.is-disabled,.el-check-tag.el-check-tag--success.is-disabled:hover{background-color:var(--el-color-success-light-9)}.el-check-tag.el-check-tag--warning.is-checked{background-color:var(--el-color-warning-light-8);color:var(--el-color-warning)}.el-check-tag.el-check-tag--warning.is-checked:hover{background-color:var(--el-color-warning-light-7)}.el-check-tag.el-check-tag--warning.is-checked.is-disabled{background-color:var(--el-color-warning-light-8);color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--warning.is-checked.is-disabled:hover{background-color:var(--el-color-warning-light-8)}.el-check-tag.el-check-tag--warning.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--warning.is-disabled,.el-check-tag.el-check-tag--warning.is-disabled:hover{background-color:var(--el-color-warning-light-9)}.el-check-tag.el-check-tag--danger.is-checked{background-color:var(--el-color-danger-light-8);color:var(--el-color-danger)}.el-check-tag.el-check-tag--danger.is-checked:hover{background-color:var(--el-color-danger-light-7)}.el-check-tag.el-check-tag--danger.is-checked.is-disabled{background-color:var(--el-color-danger-light-8);color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--danger.is-checked.is-disabled:hover{background-color:var(--el-color-danger-light-8)}.el-check-tag.el-check-tag--danger.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--danger.is-disabled,.el-check-tag.el-check-tag--danger.is-disabled:hover{background-color:var(--el-color-danger-light-9)}.el-check-tag.el-check-tag--error.is-checked{background-color:var(--el-color-error-light-8);color:var(--el-color-error)}.el-check-tag.el-check-tag--error.is-checked:hover{background-color:var(--el-color-error-light-7)}.el-check-tag.el-check-tag--error.is-checked.is-disabled{background-color:var(--el-color-error-light-8);color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--error.is-checked.is-disabled:hover{background-color:var(--el-color-error-light-8)}.el-check-tag.el-check-tag--error.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--error.is-disabled,.el-check-tag.el-check-tag--error.is-disabled:hover{background-color:var(--el-color-error-light-9)}.el-check-tag.el-check-tag--info.is-checked{background-color:var(--el-color-info-light-8);color:var(--el-color-info)}.el-check-tag.el-check-tag--info.is-checked:hover{background-color:var(--el-color-info-light-7)}.el-check-tag.el-check-tag--info.is-checked.is-disabled{background-color:var(--el-color-info-light-8);color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--info.is-checked.is-disabled:hover{background-color:var(--el-color-info-light-8)}.el-check-tag.el-check-tag--info.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-check-tag.el-check-tag--info.is-disabled,.el-check-tag.el-check-tag--info.is-disabled:hover{background-color:var(--el-color-info-light-9)}.el-checkbox-button{--el-checkbox-button-checked-bg-color:var(--el-color-primary);--el-checkbox-button-checked-text-color:var(--el-color-white);--el-checkbox-button-checked-border-color:var(--el-color-primary);display:inline-block;position:relative}.el-checkbox-button__inner{-webkit-appearance:none;background:var(--el-button-bg-color,var(--el-fill-color-blank));border:var(--el-border);border-left-color:transparent;border-radius:0;box-sizing:border-box;color:var(--el-button-text-color,var(--el-text-color-regular));cursor:pointer;display:inline-block;font-size:var(--el-font-size-base);font-weight:var(--el-checkbox-font-weight);line-height:1;margin:0;outline:none;padding:8px 15px;position:relative;text-align:center;transition:var(--el-transition-all);-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle;white-space:nowrap}.el-checkbox-button__inner.is-round{padding:8px 15px}.el-checkbox-button__inner:hover{color:var(--el-color-primary)}.el-checkbox-button__inner [class*=el-icon-]{line-height:.9}.el-checkbox-button__inner [class*=el-icon-]+span{margin-left:5px}.el-checkbox-button__original{margin:0;opacity:0;outline:none;position:absolute;z-index:-1}.el-checkbox-button.is-checked .el-checkbox-button__inner{background-color:var(--el-checkbox-button-checked-bg-color);border-color:var(--el-checkbox-button-checked-border-color);box-shadow:-1px 0 0 0 var(--el-color-primary-light-7);color:var(--el-checkbox-button-checked-text-color)}.el-checkbox-button.is-checked:first-child .el-checkbox-button__inner{border-left-color:var(--el-checkbox-button-checked-border-color)}.el-checkbox-button.is-disabled .el-checkbox-button__inner{background-color:var(--el-button-disabled-bg-color,var(--el-fill-color-blank));background-image:none;border-color:var(--el-button-disabled-border-color,var(--el-border-color-light));box-shadow:none;color:var(--el-disabled-text-color);cursor:not-allowed}.el-checkbox-button.is-disabled:first-child .el-checkbox-button__inner{border-left-color:var(--el-button-disabled-border-color,var(--el-border-color-light))}.el-checkbox-button:first-child .el-checkbox-button__inner{border-bottom-left-radius:var(--el-border-radius-base);border-left:var(--el-border);border-top-left-radius:var(--el-border-radius-base);box-shadow:none!important}.el-checkbox-button.is-focus .el-checkbox-button__inner{border-color:var(--el-checkbox-button-checked-border-color)}.el-checkbox-button:last-child .el-checkbox-button__inner{border-bottom-right-radius:var(--el-border-radius-base);border-top-right-radius:var(--el-border-radius-base)}.el-checkbox-button--large .el-checkbox-button__inner{border-radius:0;font-size:var(--el-font-size-base);padding:12px 19px}.el-checkbox-button--large .el-checkbox-button__inner.is-round{padding:12px 19px}.el-checkbox-button--small .el-checkbox-button__inner{border-radius:0;font-size:12px;padding:5px 11px}.el-checkbox-button--small .el-checkbox-button__inner.is-round{padding:5px 11px}.el-checkbox-group{font-size:0;line-height:0}.el-checkbox{--el-checkbox-font-size:14px;--el-checkbox-font-weight:var(--el-font-weight-primary);--el-checkbox-text-color:var(--el-text-color-regular);--el-checkbox-input-height:14px;--el-checkbox-input-width:14px;--el-checkbox-border-radius:var(--el-border-radius-small);--el-checkbox-bg-color:var(--el-fill-color-blank);--el-checkbox-input-border:var(--el-border);--el-checkbox-disabled-border-color:var(--el-border-color);--el-checkbox-disabled-input-fill:var(--el-fill-color-light);--el-checkbox-disabled-icon-color:var(--el-text-color-placeholder);--el-checkbox-disabled-checked-input-fill:var(--el-border-color-extra-light);--el-checkbox-disabled-checked-input-border-color:var(--el-border-color);--el-checkbox-disabled-checked-icon-color:var(--el-text-color-placeholder);--el-checkbox-checked-text-color:var(--el-color-primary);--el-checkbox-checked-input-border-color:var(--el-color-primary);--el-checkbox-checked-bg-color:var(--el-color-primary);--el-checkbox-checked-icon-color:var(--el-color-white);--el-checkbox-input-border-color-hover:var(--el-color-primary);align-items:center;color:var(--el-checkbox-text-color);cursor:pointer;display:inline-flex;font-size:var(--el-font-size-base);font-weight:var(--el-checkbox-font-weight);height:var(--el-checkbox-height,32px);margin-right:30px;position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;white-space:nowrap}.el-checkbox.is-disabled{cursor:not-allowed}.el-checkbox.is-bordered{border:var(--el-border);border-radius:var(--el-border-radius-base);box-sizing:border-box;padding:0 15px 0 9px}.el-checkbox.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-checkbox.is-bordered.is-disabled{border-color:var(--el-border-color-lighter)}.el-checkbox.is-bordered.el-checkbox--large{border-radius:var(--el-border-radius-base);padding:0 19px 0 11px}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__label{font-size:var(--el-font-size-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.is-bordered.el-checkbox--small{border-radius:calc(var(--el-border-radius-base) - 1px);padding:0 11px 0 7px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox input:focus-visible+.el-checkbox__inner{border-radius:var(--el-checkbox-border-radius);outline:2px solid var(--el-checkbox-input-border-color-hover);outline-offset:1px}.el-checkbox__input{cursor:pointer;display:inline-flex;outline:none;position:relative;white-space:nowrap}.el-checkbox__input.is-disabled .el-checkbox__inner{background-color:var(--el-checkbox-disabled-input-fill);border-color:var(--el-checkbox-disabled-border-color);cursor:not-allowed}.el-checkbox__input.is-disabled .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-icon-color);cursor:not-allowed}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-disabled-checked-icon-color);border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled+span.el-checkbox__label{color:var(--el-disabled-text-color);cursor:not-allowed}.el-checkbox__input.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-checked .el-checkbox__inner:after{border-color:var(--el-checkbox-checked-icon-color);transform:translate(-45%,-60%) rotate(45deg) scaleY(1)}.el-checkbox__input.is-checked+.el-checkbox__label{color:var(--el-checkbox-checked-text-color)}.el-checkbox__input.is-focus:not(.is-checked) .el-checkbox__original:not(:focus-visible){border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__input.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:before{background-color:var(--el-checkbox-checked-icon-color);content:"";display:block;height:2px;left:0;position:absolute;right:0;top:5px;transform:scale(.5)}.el-checkbox__input.is-indeterminate .el-checkbox__inner:after{display:none}.el-checkbox__inner{background-color:var(--el-checkbox-bg-color);border:var(--el-checkbox-input-border);border-radius:var(--el-checkbox-border-radius);box-sizing:border-box;display:inline-block;height:var(--el-checkbox-input-height);position:relative;transition:border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46),outline .25s cubic-bezier(.71,-.46,.29,1.46);width:var(--el-checkbox-input-width);z-index:var(--el-index-normal)}.el-checkbox__inner:hover{border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__inner:after{border:1px solid transparent;border-left:0;border-top:0;box-sizing:content-box;content:"";height:7px;left:50%;position:absolute;top:50%;transform:translate(-45%,-60%) rotate(45deg) scaleY(0);transform-origin:center;transition:transform .15s ease-in .05s;width:3px}.el-checkbox__original{height:0;margin:0;opacity:0;outline:none;position:absolute;width:0;z-index:-1}.el-checkbox__label{display:inline-block;font-size:var(--el-checkbox-font-size);line-height:1;padding-left:8px}.el-checkbox.el-checkbox--large{height:40px}.el-checkbox.el-checkbox--large .el-checkbox__label{font-size:14px}.el-checkbox.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.el-checkbox--small{height:24px}.el-checkbox.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.el-checkbox--small .el-checkbox__input.is-indeterminate .el-checkbox__inner:before{top:4px}.el-checkbox.el-checkbox--small .el-checkbox__inner:after{height:6px;width:2px}.el-checkbox:last-of-type{margin-right:0}[class*=el-col-]{box-sizing:border-box}[class*=el-col-].is-guttered{display:block;min-height:1px}.el-col-0{flex:0 0 0%;max-width:0}.el-col-0,.el-col-0.is-guttered{display:none}.el-col-offset-0{margin-left:0}.el-col-pull-0{position:relative;right:0}.el-col-push-0{left:0;position:relative}.el-col-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-1,.el-col-1.is-guttered{display:block}.el-col-offset-1{margin-left:4.1666666667%}.el-col-pull-1{position:relative;right:4.1666666667%}.el-col-push-1{left:4.1666666667%;position:relative}.el-col-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-2,.el-col-2.is-guttered{display:block}.el-col-offset-2{margin-left:8.3333333333%}.el-col-pull-2{position:relative;right:8.3333333333%}.el-col-push-2{left:8.3333333333%;position:relative}.el-col-3{flex:0 0 12.5%;max-width:12.5%}.el-col-3,.el-col-3.is-guttered{display:block}.el-col-offset-3{margin-left:12.5%}.el-col-pull-3{position:relative;right:12.5%}.el-col-push-3{left:12.5%;position:relative}.el-col-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-4,.el-col-4.is-guttered{display:block}.el-col-offset-4{margin-left:16.6666666667%}.el-col-pull-4{position:relative;right:16.6666666667%}.el-col-push-4{left:16.6666666667%;position:relative}.el-col-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-5,.el-col-5.is-guttered{display:block}.el-col-offset-5{margin-left:20.8333333333%}.el-col-pull-5{position:relative;right:20.8333333333%}.el-col-push-5{left:20.8333333333%;position:relative}.el-col-6{flex:0 0 25%;max-width:25%}.el-col-6,.el-col-6.is-guttered{display:block}.el-col-offset-6{margin-left:25%}.el-col-pull-6{position:relative;right:25%}.el-col-push-6{left:25%;position:relative}.el-col-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-7,.el-col-7.is-guttered{display:block}.el-col-offset-7{margin-left:29.1666666667%}.el-col-pull-7{position:relative;right:29.1666666667%}.el-col-push-7{left:29.1666666667%;position:relative}.el-col-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-8,.el-col-8.is-guttered{display:block}.el-col-offset-8{margin-left:33.3333333333%}.el-col-pull-8{position:relative;right:33.3333333333%}.el-col-push-8{left:33.3333333333%;position:relative}.el-col-9{flex:0 0 37.5%;max-width:37.5%}.el-col-9,.el-col-9.is-guttered{display:block}.el-col-offset-9{margin-left:37.5%}.el-col-pull-9{position:relative;right:37.5%}.el-col-push-9{left:37.5%;position:relative}.el-col-10{flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-10,.el-col-10.is-guttered{display:block}.el-col-offset-10{margin-left:41.6666666667%}.el-col-pull-10{position:relative;right:41.6666666667%}.el-col-push-10{left:41.6666666667%;position:relative}.el-col-11{flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-11,.el-col-11.is-guttered{display:block}.el-col-offset-11{margin-left:45.8333333333%}.el-col-pull-11{position:relative;right:45.8333333333%}.el-col-push-11{left:45.8333333333%;position:relative}.el-col-12{flex:0 0 50%;max-width:50%}.el-col-12,.el-col-12.is-guttered{display:block}.el-col-offset-12{margin-left:50%}.el-col-pull-12{position:relative;right:50%}.el-col-push-12{left:50%;position:relative}.el-col-13{flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-13,.el-col-13.is-guttered{display:block}.el-col-offset-13{margin-left:54.1666666667%}.el-col-pull-13{position:relative;right:54.1666666667%}.el-col-push-13{left:54.1666666667%;position:relative}.el-col-14{flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-14,.el-col-14.is-guttered{display:block}.el-col-offset-14{margin-left:58.3333333333%}.el-col-pull-14{position:relative;right:58.3333333333%}.el-col-push-14{left:58.3333333333%;position:relative}.el-col-15{flex:0 0 62.5%;max-width:62.5%}.el-col-15,.el-col-15.is-guttered{display:block}.el-col-offset-15{margin-left:62.5%}.el-col-pull-15{position:relative;right:62.5%}.el-col-push-15{left:62.5%;position:relative}.el-col-16{flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-16,.el-col-16.is-guttered{display:block}.el-col-offset-16{margin-left:66.6666666667%}.el-col-pull-16{position:relative;right:66.6666666667%}.el-col-push-16{left:66.6666666667%;position:relative}.el-col-17{flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-17,.el-col-17.is-guttered{display:block}.el-col-offset-17{margin-left:70.8333333333%}.el-col-pull-17{position:relative;right:70.8333333333%}.el-col-push-17{left:70.8333333333%;position:relative}.el-col-18{flex:0 0 75%;max-width:75%}.el-col-18,.el-col-18.is-guttered{display:block}.el-col-offset-18{margin-left:75%}.el-col-pull-18{position:relative;right:75%}.el-col-push-18{left:75%;position:relative}.el-col-19{flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-19,.el-col-19.is-guttered{display:block}.el-col-offset-19{margin-left:79.1666666667%}.el-col-pull-19{position:relative;right:79.1666666667%}.el-col-push-19{left:79.1666666667%;position:relative}.el-col-20{flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-20,.el-col-20.is-guttered{display:block}.el-col-offset-20{margin-left:83.3333333333%}.el-col-pull-20{position:relative;right:83.3333333333%}.el-col-push-20{left:83.3333333333%;position:relative}.el-col-21{flex:0 0 87.5%;max-width:87.5%}.el-col-21,.el-col-21.is-guttered{display:block}.el-col-offset-21{margin-left:87.5%}.el-col-pull-21{position:relative;right:87.5%}.el-col-push-21{left:87.5%;position:relative}.el-col-22{flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-22,.el-col-22.is-guttered{display:block}.el-col-offset-22{margin-left:91.6666666667%}.el-col-pull-22{position:relative;right:91.6666666667%}.el-col-push-22{left:91.6666666667%;position:relative}.el-col-23{flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-23,.el-col-23.is-guttered{display:block}.el-col-offset-23{margin-left:95.8333333333%}.el-col-pull-23{position:relative;right:95.8333333333%}.el-col-push-23{left:95.8333333333%;position:relative}.el-col-24{flex:0 0 100%;max-width:100%}.el-col-24,.el-col-24.is-guttered{display:block}.el-col-offset-24{margin-left:100%}.el-col-pull-24{position:relative;right:100%}.el-col-push-24{left:100%;position:relative}@media only screen and (max-width:767px){.el-col-xs-0{display:none;flex:0 0 0%;max-width:0}.el-col-xs-0.is-guttered{display:none}.el-col-xs-offset-0{margin-left:0}.el-col-xs-pull-0{position:relative;right:0}.el-col-xs-push-0{left:0;position:relative}.el-col-xs-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-xs-1,.el-col-xs-1.is-guttered{display:block}.el-col-xs-offset-1{margin-left:4.1666666667%}.el-col-xs-pull-1{position:relative;right:4.1666666667%}.el-col-xs-push-1{left:4.1666666667%;position:relative}.el-col-xs-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-xs-2,.el-col-xs-2.is-guttered{display:block}.el-col-xs-offset-2{margin-left:8.3333333333%}.el-col-xs-pull-2{position:relative;right:8.3333333333%}.el-col-xs-push-2{left:8.3333333333%;position:relative}.el-col-xs-3{flex:0 0 12.5%;max-width:12.5%}.el-col-xs-3,.el-col-xs-3.is-guttered{display:block}.el-col-xs-offset-3{margin-left:12.5%}.el-col-xs-pull-3{position:relative;right:12.5%}.el-col-xs-push-3{left:12.5%;position:relative}.el-col-xs-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-xs-4,.el-col-xs-4.is-guttered{display:block}.el-col-xs-offset-4{margin-left:16.6666666667%}.el-col-xs-pull-4{position:relative;right:16.6666666667%}.el-col-xs-push-4{left:16.6666666667%;position:relative}.el-col-xs-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-xs-5,.el-col-xs-5.is-guttered{display:block}.el-col-xs-offset-5{margin-left:20.8333333333%}.el-col-xs-pull-5{position:relative;right:20.8333333333%}.el-col-xs-push-5{left:20.8333333333%;position:relative}.el-col-xs-6{flex:0 0 25%;max-width:25%}.el-col-xs-6,.el-col-xs-6.is-guttered{display:block}.el-col-xs-offset-6{margin-left:25%}.el-col-xs-pull-6{position:relative;right:25%}.el-col-xs-push-6{left:25%;position:relative}.el-col-xs-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-xs-7,.el-col-xs-7.is-guttered{display:block}.el-col-xs-offset-7{margin-left:29.1666666667%}.el-col-xs-pull-7{position:relative;right:29.1666666667%}.el-col-xs-push-7{left:29.1666666667%;position:relative}.el-col-xs-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-xs-8,.el-col-xs-8.is-guttered{display:block}.el-col-xs-offset-8{margin-left:33.3333333333%}.el-col-xs-pull-8{position:relative;right:33.3333333333%}.el-col-xs-push-8{left:33.3333333333%;position:relative}.el-col-xs-9{flex:0 0 37.5%;max-width:37.5%}.el-col-xs-9,.el-col-xs-9.is-guttered{display:block}.el-col-xs-offset-9{margin-left:37.5%}.el-col-xs-pull-9{position:relative;right:37.5%}.el-col-xs-push-9{left:37.5%;position:relative}.el-col-xs-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-xs-10.is-guttered{display:block}.el-col-xs-offset-10{margin-left:41.6666666667%}.el-col-xs-pull-10{position:relative;right:41.6666666667%}.el-col-xs-push-10{left:41.6666666667%;position:relative}.el-col-xs-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-xs-11.is-guttered{display:block}.el-col-xs-offset-11{margin-left:45.8333333333%}.el-col-xs-pull-11{position:relative;right:45.8333333333%}.el-col-xs-push-11{left:45.8333333333%;position:relative}.el-col-xs-12{display:block;flex:0 0 50%;max-width:50%}.el-col-xs-12.is-guttered{display:block}.el-col-xs-offset-12{margin-left:50%}.el-col-xs-pull-12{position:relative;right:50%}.el-col-xs-push-12{left:50%;position:relative}.el-col-xs-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-xs-13.is-guttered{display:block}.el-col-xs-offset-13{margin-left:54.1666666667%}.el-col-xs-pull-13{position:relative;right:54.1666666667%}.el-col-xs-push-13{left:54.1666666667%;position:relative}.el-col-xs-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-xs-14.is-guttered{display:block}.el-col-xs-offset-14{margin-left:58.3333333333%}.el-col-xs-pull-14{position:relative;right:58.3333333333%}.el-col-xs-push-14{left:58.3333333333%;position:relative}.el-col-xs-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-xs-15.is-guttered{display:block}.el-col-xs-offset-15{margin-left:62.5%}.el-col-xs-pull-15{position:relative;right:62.5%}.el-col-xs-push-15{left:62.5%;position:relative}.el-col-xs-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-xs-16.is-guttered{display:block}.el-col-xs-offset-16{margin-left:66.6666666667%}.el-col-xs-pull-16{position:relative;right:66.6666666667%}.el-col-xs-push-16{left:66.6666666667%;position:relative}.el-col-xs-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-xs-17.is-guttered{display:block}.el-col-xs-offset-17{margin-left:70.8333333333%}.el-col-xs-pull-17{position:relative;right:70.8333333333%}.el-col-xs-push-17{left:70.8333333333%;position:relative}.el-col-xs-18{display:block;flex:0 0 75%;max-width:75%}.el-col-xs-18.is-guttered{display:block}.el-col-xs-offset-18{margin-left:75%}.el-col-xs-pull-18{position:relative;right:75%}.el-col-xs-push-18{left:75%;position:relative}.el-col-xs-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-xs-19.is-guttered{display:block}.el-col-xs-offset-19{margin-left:79.1666666667%}.el-col-xs-pull-19{position:relative;right:79.1666666667%}.el-col-xs-push-19{left:79.1666666667%;position:relative}.el-col-xs-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-xs-20.is-guttered{display:block}.el-col-xs-offset-20{margin-left:83.3333333333%}.el-col-xs-pull-20{position:relative;right:83.3333333333%}.el-col-xs-push-20{left:83.3333333333%;position:relative}.el-col-xs-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-xs-21.is-guttered{display:block}.el-col-xs-offset-21{margin-left:87.5%}.el-col-xs-pull-21{position:relative;right:87.5%}.el-col-xs-push-21{left:87.5%;position:relative}.el-col-xs-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-xs-22.is-guttered{display:block}.el-col-xs-offset-22{margin-left:91.6666666667%}.el-col-xs-pull-22{position:relative;right:91.6666666667%}.el-col-xs-push-22{left:91.6666666667%;position:relative}.el-col-xs-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-xs-23.is-guttered{display:block}.el-col-xs-offset-23{margin-left:95.8333333333%}.el-col-xs-pull-23{position:relative;right:95.8333333333%}.el-col-xs-push-23{left:95.8333333333%;position:relative}.el-col-xs-24{display:block;flex:0 0 100%;max-width:100%}.el-col-xs-24.is-guttered{display:block}.el-col-xs-offset-24{margin-left:100%}.el-col-xs-pull-24{position:relative;right:100%}.el-col-xs-push-24{left:100%;position:relative}}@media only screen and (min-width:768px){.el-col-sm-0{display:none;flex:0 0 0%;max-width:0}.el-col-sm-0.is-guttered{display:none}.el-col-sm-offset-0{margin-left:0}.el-col-sm-pull-0{position:relative;right:0}.el-col-sm-push-0{left:0;position:relative}.el-col-sm-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-sm-1,.el-col-sm-1.is-guttered{display:block}.el-col-sm-offset-1{margin-left:4.1666666667%}.el-col-sm-pull-1{position:relative;right:4.1666666667%}.el-col-sm-push-1{left:4.1666666667%;position:relative}.el-col-sm-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-sm-2,.el-col-sm-2.is-guttered{display:block}.el-col-sm-offset-2{margin-left:8.3333333333%}.el-col-sm-pull-2{position:relative;right:8.3333333333%}.el-col-sm-push-2{left:8.3333333333%;position:relative}.el-col-sm-3{flex:0 0 12.5%;max-width:12.5%}.el-col-sm-3,.el-col-sm-3.is-guttered{display:block}.el-col-sm-offset-3{margin-left:12.5%}.el-col-sm-pull-3{position:relative;right:12.5%}.el-col-sm-push-3{left:12.5%;position:relative}.el-col-sm-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-sm-4,.el-col-sm-4.is-guttered{display:block}.el-col-sm-offset-4{margin-left:16.6666666667%}.el-col-sm-pull-4{position:relative;right:16.6666666667%}.el-col-sm-push-4{left:16.6666666667%;position:relative}.el-col-sm-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-sm-5,.el-col-sm-5.is-guttered{display:block}.el-col-sm-offset-5{margin-left:20.8333333333%}.el-col-sm-pull-5{position:relative;right:20.8333333333%}.el-col-sm-push-5{left:20.8333333333%;position:relative}.el-col-sm-6{flex:0 0 25%;max-width:25%}.el-col-sm-6,.el-col-sm-6.is-guttered{display:block}.el-col-sm-offset-6{margin-left:25%}.el-col-sm-pull-6{position:relative;right:25%}.el-col-sm-push-6{left:25%;position:relative}.el-col-sm-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-sm-7,.el-col-sm-7.is-guttered{display:block}.el-col-sm-offset-7{margin-left:29.1666666667%}.el-col-sm-pull-7{position:relative;right:29.1666666667%}.el-col-sm-push-7{left:29.1666666667%;position:relative}.el-col-sm-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-sm-8,.el-col-sm-8.is-guttered{display:block}.el-col-sm-offset-8{margin-left:33.3333333333%}.el-col-sm-pull-8{position:relative;right:33.3333333333%}.el-col-sm-push-8{left:33.3333333333%;position:relative}.el-col-sm-9{flex:0 0 37.5%;max-width:37.5%}.el-col-sm-9,.el-col-sm-9.is-guttered{display:block}.el-col-sm-offset-9{margin-left:37.5%}.el-col-sm-pull-9{position:relative;right:37.5%}.el-col-sm-push-9{left:37.5%;position:relative}.el-col-sm-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-sm-10.is-guttered{display:block}.el-col-sm-offset-10{margin-left:41.6666666667%}.el-col-sm-pull-10{position:relative;right:41.6666666667%}.el-col-sm-push-10{left:41.6666666667%;position:relative}.el-col-sm-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-sm-11.is-guttered{display:block}.el-col-sm-offset-11{margin-left:45.8333333333%}.el-col-sm-pull-11{position:relative;right:45.8333333333%}.el-col-sm-push-11{left:45.8333333333%;position:relative}.el-col-sm-12{display:block;flex:0 0 50%;max-width:50%}.el-col-sm-12.is-guttered{display:block}.el-col-sm-offset-12{margin-left:50%}.el-col-sm-pull-12{position:relative;right:50%}.el-col-sm-push-12{left:50%;position:relative}.el-col-sm-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-sm-13.is-guttered{display:block}.el-col-sm-offset-13{margin-left:54.1666666667%}.el-col-sm-pull-13{position:relative;right:54.1666666667%}.el-col-sm-push-13{left:54.1666666667%;position:relative}.el-col-sm-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-sm-14.is-guttered{display:block}.el-col-sm-offset-14{margin-left:58.3333333333%}.el-col-sm-pull-14{position:relative;right:58.3333333333%}.el-col-sm-push-14{left:58.3333333333%;position:relative}.el-col-sm-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-sm-15.is-guttered{display:block}.el-col-sm-offset-15{margin-left:62.5%}.el-col-sm-pull-15{position:relative;right:62.5%}.el-col-sm-push-15{left:62.5%;position:relative}.el-col-sm-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-sm-16.is-guttered{display:block}.el-col-sm-offset-16{margin-left:66.6666666667%}.el-col-sm-pull-16{position:relative;right:66.6666666667%}.el-col-sm-push-16{left:66.6666666667%;position:relative}.el-col-sm-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-sm-17.is-guttered{display:block}.el-col-sm-offset-17{margin-left:70.8333333333%}.el-col-sm-pull-17{position:relative;right:70.8333333333%}.el-col-sm-push-17{left:70.8333333333%;position:relative}.el-col-sm-18{display:block;flex:0 0 75%;max-width:75%}.el-col-sm-18.is-guttered{display:block}.el-col-sm-offset-18{margin-left:75%}.el-col-sm-pull-18{position:relative;right:75%}.el-col-sm-push-18{left:75%;position:relative}.el-col-sm-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-sm-19.is-guttered{display:block}.el-col-sm-offset-19{margin-left:79.1666666667%}.el-col-sm-pull-19{position:relative;right:79.1666666667%}.el-col-sm-push-19{left:79.1666666667%;position:relative}.el-col-sm-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-sm-20.is-guttered{display:block}.el-col-sm-offset-20{margin-left:83.3333333333%}.el-col-sm-pull-20{position:relative;right:83.3333333333%}.el-col-sm-push-20{left:83.3333333333%;position:relative}.el-col-sm-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-sm-21.is-guttered{display:block}.el-col-sm-offset-21{margin-left:87.5%}.el-col-sm-pull-21{position:relative;right:87.5%}.el-col-sm-push-21{left:87.5%;position:relative}.el-col-sm-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-sm-22.is-guttered{display:block}.el-col-sm-offset-22{margin-left:91.6666666667%}.el-col-sm-pull-22{position:relative;right:91.6666666667%}.el-col-sm-push-22{left:91.6666666667%;position:relative}.el-col-sm-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-sm-23.is-guttered{display:block}.el-col-sm-offset-23{margin-left:95.8333333333%}.el-col-sm-pull-23{position:relative;right:95.8333333333%}.el-col-sm-push-23{left:95.8333333333%;position:relative}.el-col-sm-24{display:block;flex:0 0 100%;max-width:100%}.el-col-sm-24.is-guttered{display:block}.el-col-sm-offset-24{margin-left:100%}.el-col-sm-pull-24{position:relative;right:100%}.el-col-sm-push-24{left:100%;position:relative}}@media only screen and (min-width:992px){.el-col-md-0{display:none;flex:0 0 0%;max-width:0}.el-col-md-0.is-guttered{display:none}.el-col-md-offset-0{margin-left:0}.el-col-md-pull-0{position:relative;right:0}.el-col-md-push-0{left:0;position:relative}.el-col-md-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-md-1,.el-col-md-1.is-guttered{display:block}.el-col-md-offset-1{margin-left:4.1666666667%}.el-col-md-pull-1{position:relative;right:4.1666666667%}.el-col-md-push-1{left:4.1666666667%;position:relative}.el-col-md-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-md-2,.el-col-md-2.is-guttered{display:block}.el-col-md-offset-2{margin-left:8.3333333333%}.el-col-md-pull-2{position:relative;right:8.3333333333%}.el-col-md-push-2{left:8.3333333333%;position:relative}.el-col-md-3{flex:0 0 12.5%;max-width:12.5%}.el-col-md-3,.el-col-md-3.is-guttered{display:block}.el-col-md-offset-3{margin-left:12.5%}.el-col-md-pull-3{position:relative;right:12.5%}.el-col-md-push-3{left:12.5%;position:relative}.el-col-md-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-md-4,.el-col-md-4.is-guttered{display:block}.el-col-md-offset-4{margin-left:16.6666666667%}.el-col-md-pull-4{position:relative;right:16.6666666667%}.el-col-md-push-4{left:16.6666666667%;position:relative}.el-col-md-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-md-5,.el-col-md-5.is-guttered{display:block}.el-col-md-offset-5{margin-left:20.8333333333%}.el-col-md-pull-5{position:relative;right:20.8333333333%}.el-col-md-push-5{left:20.8333333333%;position:relative}.el-col-md-6{flex:0 0 25%;max-width:25%}.el-col-md-6,.el-col-md-6.is-guttered{display:block}.el-col-md-offset-6{margin-left:25%}.el-col-md-pull-6{position:relative;right:25%}.el-col-md-push-6{left:25%;position:relative}.el-col-md-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-md-7,.el-col-md-7.is-guttered{display:block}.el-col-md-offset-7{margin-left:29.1666666667%}.el-col-md-pull-7{position:relative;right:29.1666666667%}.el-col-md-push-7{left:29.1666666667%;position:relative}.el-col-md-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-md-8,.el-col-md-8.is-guttered{display:block}.el-col-md-offset-8{margin-left:33.3333333333%}.el-col-md-pull-8{position:relative;right:33.3333333333%}.el-col-md-push-8{left:33.3333333333%;position:relative}.el-col-md-9{flex:0 0 37.5%;max-width:37.5%}.el-col-md-9,.el-col-md-9.is-guttered{display:block}.el-col-md-offset-9{margin-left:37.5%}.el-col-md-pull-9{position:relative;right:37.5%}.el-col-md-push-9{left:37.5%;position:relative}.el-col-md-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-md-10.is-guttered{display:block}.el-col-md-offset-10{margin-left:41.6666666667%}.el-col-md-pull-10{position:relative;right:41.6666666667%}.el-col-md-push-10{left:41.6666666667%;position:relative}.el-col-md-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-md-11.is-guttered{display:block}.el-col-md-offset-11{margin-left:45.8333333333%}.el-col-md-pull-11{position:relative;right:45.8333333333%}.el-col-md-push-11{left:45.8333333333%;position:relative}.el-col-md-12{display:block;flex:0 0 50%;max-width:50%}.el-col-md-12.is-guttered{display:block}.el-col-md-offset-12{margin-left:50%}.el-col-md-pull-12{position:relative;right:50%}.el-col-md-push-12{left:50%;position:relative}.el-col-md-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-md-13.is-guttered{display:block}.el-col-md-offset-13{margin-left:54.1666666667%}.el-col-md-pull-13{position:relative;right:54.1666666667%}.el-col-md-push-13{left:54.1666666667%;position:relative}.el-col-md-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-md-14.is-guttered{display:block}.el-col-md-offset-14{margin-left:58.3333333333%}.el-col-md-pull-14{position:relative;right:58.3333333333%}.el-col-md-push-14{left:58.3333333333%;position:relative}.el-col-md-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-md-15.is-guttered{display:block}.el-col-md-offset-15{margin-left:62.5%}.el-col-md-pull-15{position:relative;right:62.5%}.el-col-md-push-15{left:62.5%;position:relative}.el-col-md-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-md-16.is-guttered{display:block}.el-col-md-offset-16{margin-left:66.6666666667%}.el-col-md-pull-16{position:relative;right:66.6666666667%}.el-col-md-push-16{left:66.6666666667%;position:relative}.el-col-md-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-md-17.is-guttered{display:block}.el-col-md-offset-17{margin-left:70.8333333333%}.el-col-md-pull-17{position:relative;right:70.8333333333%}.el-col-md-push-17{left:70.8333333333%;position:relative}.el-col-md-18{display:block;flex:0 0 75%;max-width:75%}.el-col-md-18.is-guttered{display:block}.el-col-md-offset-18{margin-left:75%}.el-col-md-pull-18{position:relative;right:75%}.el-col-md-push-18{left:75%;position:relative}.el-col-md-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-md-19.is-guttered{display:block}.el-col-md-offset-19{margin-left:79.1666666667%}.el-col-md-pull-19{position:relative;right:79.1666666667%}.el-col-md-push-19{left:79.1666666667%;position:relative}.el-col-md-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-md-20.is-guttered{display:block}.el-col-md-offset-20{margin-left:83.3333333333%}.el-col-md-pull-20{position:relative;right:83.3333333333%}.el-col-md-push-20{left:83.3333333333%;position:relative}.el-col-md-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-md-21.is-guttered{display:block}.el-col-md-offset-21{margin-left:87.5%}.el-col-md-pull-21{position:relative;right:87.5%}.el-col-md-push-21{left:87.5%;position:relative}.el-col-md-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-md-22.is-guttered{display:block}.el-col-md-offset-22{margin-left:91.6666666667%}.el-col-md-pull-22{position:relative;right:91.6666666667%}.el-col-md-push-22{left:91.6666666667%;position:relative}.el-col-md-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-md-23.is-guttered{display:block}.el-col-md-offset-23{margin-left:95.8333333333%}.el-col-md-pull-23{position:relative;right:95.8333333333%}.el-col-md-push-23{left:95.8333333333%;position:relative}.el-col-md-24{display:block;flex:0 0 100%;max-width:100%}.el-col-md-24.is-guttered{display:block}.el-col-md-offset-24{margin-left:100%}.el-col-md-pull-24{position:relative;right:100%}.el-col-md-push-24{left:100%;position:relative}}@media only screen and (min-width:1200px){.el-col-lg-0{display:none;flex:0 0 0%;max-width:0}.el-col-lg-0.is-guttered{display:none}.el-col-lg-offset-0{margin-left:0}.el-col-lg-pull-0{position:relative;right:0}.el-col-lg-push-0{left:0;position:relative}.el-col-lg-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-lg-1,.el-col-lg-1.is-guttered{display:block}.el-col-lg-offset-1{margin-left:4.1666666667%}.el-col-lg-pull-1{position:relative;right:4.1666666667%}.el-col-lg-push-1{left:4.1666666667%;position:relative}.el-col-lg-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-lg-2,.el-col-lg-2.is-guttered{display:block}.el-col-lg-offset-2{margin-left:8.3333333333%}.el-col-lg-pull-2{position:relative;right:8.3333333333%}.el-col-lg-push-2{left:8.3333333333%;position:relative}.el-col-lg-3{flex:0 0 12.5%;max-width:12.5%}.el-col-lg-3,.el-col-lg-3.is-guttered{display:block}.el-col-lg-offset-3{margin-left:12.5%}.el-col-lg-pull-3{position:relative;right:12.5%}.el-col-lg-push-3{left:12.5%;position:relative}.el-col-lg-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-lg-4,.el-col-lg-4.is-guttered{display:block}.el-col-lg-offset-4{margin-left:16.6666666667%}.el-col-lg-pull-4{position:relative;right:16.6666666667%}.el-col-lg-push-4{left:16.6666666667%;position:relative}.el-col-lg-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-lg-5,.el-col-lg-5.is-guttered{display:block}.el-col-lg-offset-5{margin-left:20.8333333333%}.el-col-lg-pull-5{position:relative;right:20.8333333333%}.el-col-lg-push-5{left:20.8333333333%;position:relative}.el-col-lg-6{flex:0 0 25%;max-width:25%}.el-col-lg-6,.el-col-lg-6.is-guttered{display:block}.el-col-lg-offset-6{margin-left:25%}.el-col-lg-pull-6{position:relative;right:25%}.el-col-lg-push-6{left:25%;position:relative}.el-col-lg-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-lg-7,.el-col-lg-7.is-guttered{display:block}.el-col-lg-offset-7{margin-left:29.1666666667%}.el-col-lg-pull-7{position:relative;right:29.1666666667%}.el-col-lg-push-7{left:29.1666666667%;position:relative}.el-col-lg-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-lg-8,.el-col-lg-8.is-guttered{display:block}.el-col-lg-offset-8{margin-left:33.3333333333%}.el-col-lg-pull-8{position:relative;right:33.3333333333%}.el-col-lg-push-8{left:33.3333333333%;position:relative}.el-col-lg-9{flex:0 0 37.5%;max-width:37.5%}.el-col-lg-9,.el-col-lg-9.is-guttered{display:block}.el-col-lg-offset-9{margin-left:37.5%}.el-col-lg-pull-9{position:relative;right:37.5%}.el-col-lg-push-9{left:37.5%;position:relative}.el-col-lg-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-lg-10.is-guttered{display:block}.el-col-lg-offset-10{margin-left:41.6666666667%}.el-col-lg-pull-10{position:relative;right:41.6666666667%}.el-col-lg-push-10{left:41.6666666667%;position:relative}.el-col-lg-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-lg-11.is-guttered{display:block}.el-col-lg-offset-11{margin-left:45.8333333333%}.el-col-lg-pull-11{position:relative;right:45.8333333333%}.el-col-lg-push-11{left:45.8333333333%;position:relative}.el-col-lg-12{display:block;flex:0 0 50%;max-width:50%}.el-col-lg-12.is-guttered{display:block}.el-col-lg-offset-12{margin-left:50%}.el-col-lg-pull-12{position:relative;right:50%}.el-col-lg-push-12{left:50%;position:relative}.el-col-lg-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-lg-13.is-guttered{display:block}.el-col-lg-offset-13{margin-left:54.1666666667%}.el-col-lg-pull-13{position:relative;right:54.1666666667%}.el-col-lg-push-13{left:54.1666666667%;position:relative}.el-col-lg-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-lg-14.is-guttered{display:block}.el-col-lg-offset-14{margin-left:58.3333333333%}.el-col-lg-pull-14{position:relative;right:58.3333333333%}.el-col-lg-push-14{left:58.3333333333%;position:relative}.el-col-lg-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-lg-15.is-guttered{display:block}.el-col-lg-offset-15{margin-left:62.5%}.el-col-lg-pull-15{position:relative;right:62.5%}.el-col-lg-push-15{left:62.5%;position:relative}.el-col-lg-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-lg-16.is-guttered{display:block}.el-col-lg-offset-16{margin-left:66.6666666667%}.el-col-lg-pull-16{position:relative;right:66.6666666667%}.el-col-lg-push-16{left:66.6666666667%;position:relative}.el-col-lg-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-lg-17.is-guttered{display:block}.el-col-lg-offset-17{margin-left:70.8333333333%}.el-col-lg-pull-17{position:relative;right:70.8333333333%}.el-col-lg-push-17{left:70.8333333333%;position:relative}.el-col-lg-18{display:block;flex:0 0 75%;max-width:75%}.el-col-lg-18.is-guttered{display:block}.el-col-lg-offset-18{margin-left:75%}.el-col-lg-pull-18{position:relative;right:75%}.el-col-lg-push-18{left:75%;position:relative}.el-col-lg-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-lg-19.is-guttered{display:block}.el-col-lg-offset-19{margin-left:79.1666666667%}.el-col-lg-pull-19{position:relative;right:79.1666666667%}.el-col-lg-push-19{left:79.1666666667%;position:relative}.el-col-lg-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-lg-20.is-guttered{display:block}.el-col-lg-offset-20{margin-left:83.3333333333%}.el-col-lg-pull-20{position:relative;right:83.3333333333%}.el-col-lg-push-20{left:83.3333333333%;position:relative}.el-col-lg-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-lg-21.is-guttered{display:block}.el-col-lg-offset-21{margin-left:87.5%}.el-col-lg-pull-21{position:relative;right:87.5%}.el-col-lg-push-21{left:87.5%;position:relative}.el-col-lg-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-lg-22.is-guttered{display:block}.el-col-lg-offset-22{margin-left:91.6666666667%}.el-col-lg-pull-22{position:relative;right:91.6666666667%}.el-col-lg-push-22{left:91.6666666667%;position:relative}.el-col-lg-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-lg-23.is-guttered{display:block}.el-col-lg-offset-23{margin-left:95.8333333333%}.el-col-lg-pull-23{position:relative;right:95.8333333333%}.el-col-lg-push-23{left:95.8333333333%;position:relative}.el-col-lg-24{display:block;flex:0 0 100%;max-width:100%}.el-col-lg-24.is-guttered{display:block}.el-col-lg-offset-24{margin-left:100%}.el-col-lg-pull-24{position:relative;right:100%}.el-col-lg-push-24{left:100%;position:relative}}@media only screen and (min-width:1920px){.el-col-xl-0{display:none;flex:0 0 0%;max-width:0}.el-col-xl-0.is-guttered{display:none}.el-col-xl-offset-0{margin-left:0}.el-col-xl-pull-0{position:relative;right:0}.el-col-xl-push-0{left:0;position:relative}.el-col-xl-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-xl-1,.el-col-xl-1.is-guttered{display:block}.el-col-xl-offset-1{margin-left:4.1666666667%}.el-col-xl-pull-1{position:relative;right:4.1666666667%}.el-col-xl-push-1{left:4.1666666667%;position:relative}.el-col-xl-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-xl-2,.el-col-xl-2.is-guttered{display:block}.el-col-xl-offset-2{margin-left:8.3333333333%}.el-col-xl-pull-2{position:relative;right:8.3333333333%}.el-col-xl-push-2{left:8.3333333333%;position:relative}.el-col-xl-3{flex:0 0 12.5%;max-width:12.5%}.el-col-xl-3,.el-col-xl-3.is-guttered{display:block}.el-col-xl-offset-3{margin-left:12.5%}.el-col-xl-pull-3{position:relative;right:12.5%}.el-col-xl-push-3{left:12.5%;position:relative}.el-col-xl-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-xl-4,.el-col-xl-4.is-guttered{display:block}.el-col-xl-offset-4{margin-left:16.6666666667%}.el-col-xl-pull-4{position:relative;right:16.6666666667%}.el-col-xl-push-4{left:16.6666666667%;position:relative}.el-col-xl-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-xl-5,.el-col-xl-5.is-guttered{display:block}.el-col-xl-offset-5{margin-left:20.8333333333%}.el-col-xl-pull-5{position:relative;right:20.8333333333%}.el-col-xl-push-5{left:20.8333333333%;position:relative}.el-col-xl-6{flex:0 0 25%;max-width:25%}.el-col-xl-6,.el-col-xl-6.is-guttered{display:block}.el-col-xl-offset-6{margin-left:25%}.el-col-xl-pull-6{position:relative;right:25%}.el-col-xl-push-6{left:25%;position:relative}.el-col-xl-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-xl-7,.el-col-xl-7.is-guttered{display:block}.el-col-xl-offset-7{margin-left:29.1666666667%}.el-col-xl-pull-7{position:relative;right:29.1666666667%}.el-col-xl-push-7{left:29.1666666667%;position:relative}.el-col-xl-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-xl-8,.el-col-xl-8.is-guttered{display:block}.el-col-xl-offset-8{margin-left:33.3333333333%}.el-col-xl-pull-8{position:relative;right:33.3333333333%}.el-col-xl-push-8{left:33.3333333333%;position:relative}.el-col-xl-9{flex:0 0 37.5%;max-width:37.5%}.el-col-xl-9,.el-col-xl-9.is-guttered{display:block}.el-col-xl-offset-9{margin-left:37.5%}.el-col-xl-pull-9{position:relative;right:37.5%}.el-col-xl-push-9{left:37.5%;position:relative}.el-col-xl-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-xl-10.is-guttered{display:block}.el-col-xl-offset-10{margin-left:41.6666666667%}.el-col-xl-pull-10{position:relative;right:41.6666666667%}.el-col-xl-push-10{left:41.6666666667%;position:relative}.el-col-xl-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-xl-11.is-guttered{display:block}.el-col-xl-offset-11{margin-left:45.8333333333%}.el-col-xl-pull-11{position:relative;right:45.8333333333%}.el-col-xl-push-11{left:45.8333333333%;position:relative}.el-col-xl-12{display:block;flex:0 0 50%;max-width:50%}.el-col-xl-12.is-guttered{display:block}.el-col-xl-offset-12{margin-left:50%}.el-col-xl-pull-12{position:relative;right:50%}.el-col-xl-push-12{left:50%;position:relative}.el-col-xl-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-xl-13.is-guttered{display:block}.el-col-xl-offset-13{margin-left:54.1666666667%}.el-col-xl-pull-13{position:relative;right:54.1666666667%}.el-col-xl-push-13{left:54.1666666667%;position:relative}.el-col-xl-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-xl-14.is-guttered{display:block}.el-col-xl-offset-14{margin-left:58.3333333333%}.el-col-xl-pull-14{position:relative;right:58.3333333333%}.el-col-xl-push-14{left:58.3333333333%;position:relative}.el-col-xl-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-xl-15.is-guttered{display:block}.el-col-xl-offset-15{margin-left:62.5%}.el-col-xl-pull-15{position:relative;right:62.5%}.el-col-xl-push-15{left:62.5%;position:relative}.el-col-xl-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-xl-16.is-guttered{display:block}.el-col-xl-offset-16{margin-left:66.6666666667%}.el-col-xl-pull-16{position:relative;right:66.6666666667%}.el-col-xl-push-16{left:66.6666666667%;position:relative}.el-col-xl-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-xl-17.is-guttered{display:block}.el-col-xl-offset-17{margin-left:70.8333333333%}.el-col-xl-pull-17{position:relative;right:70.8333333333%}.el-col-xl-push-17{left:70.8333333333%;position:relative}.el-col-xl-18{display:block;flex:0 0 75%;max-width:75%}.el-col-xl-18.is-guttered{display:block}.el-col-xl-offset-18{margin-left:75%}.el-col-xl-pull-18{position:relative;right:75%}.el-col-xl-push-18{left:75%;position:relative}.el-col-xl-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-xl-19.is-guttered{display:block}.el-col-xl-offset-19{margin-left:79.1666666667%}.el-col-xl-pull-19{position:relative;right:79.1666666667%}.el-col-xl-push-19{left:79.1666666667%;position:relative}.el-col-xl-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-xl-20.is-guttered{display:block}.el-col-xl-offset-20{margin-left:83.3333333333%}.el-col-xl-pull-20{position:relative;right:83.3333333333%}.el-col-xl-push-20{left:83.3333333333%;position:relative}.el-col-xl-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-xl-21.is-guttered{display:block}.el-col-xl-offset-21{margin-left:87.5%}.el-col-xl-pull-21{position:relative;right:87.5%}.el-col-xl-push-21{left:87.5%;position:relative}.el-col-xl-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-xl-22.is-guttered{display:block}.el-col-xl-offset-22{margin-left:91.6666666667%}.el-col-xl-pull-22{position:relative;right:91.6666666667%}.el-col-xl-push-22{left:91.6666666667%;position:relative}.el-col-xl-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-xl-23.is-guttered{display:block}.el-col-xl-offset-23{margin-left:95.8333333333%}.el-col-xl-pull-23{position:relative;right:95.8333333333%}.el-col-xl-push-23{left:95.8333333333%;position:relative}.el-col-xl-24{display:block;flex:0 0 100%;max-width:100%}.el-col-xl-24.is-guttered{display:block}.el-col-xl-offset-24{margin-left:100%}.el-col-xl-pull-24{position:relative;right:100%}.el-col-xl-push-24{left:100%;position:relative}}.el-collapse{--el-collapse-border-color:var(--el-border-color-lighter);--el-collapse-header-height:48px;--el-collapse-header-bg-color:var(--el-fill-color-blank);--el-collapse-header-text-color:var(--el-text-color-primary);--el-collapse-header-font-size:13px;--el-collapse-content-bg-color:var(--el-fill-color-blank);--el-collapse-content-font-size:13px;--el-collapse-content-text-color:var(--el-text-color-primary);border-bottom:1px solid var(--el-collapse-border-color);border-top:1px solid var(--el-collapse-border-color)}.el-collapse-item.is-disabled .el-collapse-item__header{color:var(--el-text-color-disabled);cursor:not-allowed}.el-collapse-item__header{align-items:center;background-color:var(--el-collapse-header-bg-color);border:none;border-bottom:1px solid var(--el-collapse-border-color);color:var(--el-collapse-header-text-color);cursor:pointer;display:flex;font-size:var(--el-collapse-header-font-size);font-weight:500;height:var(--el-collapse-header-height);line-height:var(--el-collapse-header-height);outline:none;padding:0;transition:border-bottom-color var(--el-transition-duration);width:100%}.el-collapse-item__arrow{font-weight:300;transition:transform var(--el-transition-duration)}.el-collapse-item__arrow.is-active{transform:rotate(90deg)}.el-collapse-item__title{flex:auto;text-align:left}.el-collapse-item__header.focusing:focus:not(:hover){color:var(--el-color-primary)}.el-collapse-item__header.is-active{border-bottom-color:transparent}.el-collapse-item__wrap{background-color:var(--el-collapse-content-bg-color);border-bottom:1px solid var(--el-collapse-border-color);box-sizing:border-box;overflow:hidden;will-change:height}.el-collapse-item__content{color:var(--el-collapse-content-text-color);font-size:var(--el-collapse-content-font-size);line-height:1.7692307692;padding-bottom:25px}.el-collapse-item:last-child{margin-bottom:-1px}.el-collapse-icon-position-left .el-collapse-item__header{gap:8px}.el-collapse-icon-position-left .el-collapse-item__title{order:1}.el-collapse-icon-position-right .el-collapse-item__header{padding-right:8px}.el-color-predefine{display:flex;font-size:12px;margin-top:8px;width:280px}.el-color-predefine__colors{display:flex;flex:1;flex-wrap:wrap}.el-color-predefine__color-selector{border-radius:4px;cursor:pointer;height:20px;margin:0 0 8px 8px;width:20px}.el-color-predefine__color-selector:nth-child(10n+1){margin-left:0}.el-color-predefine__color-selector.selected{box-shadow:0 0 3px 2px var(--el-color-primary)}.el-color-predefine__color-selector>div{border-radius:3px;display:flex;height:100%}.el-color-predefine__color-selector.is-alpha{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==)}.el-color-hue-slider{background-color:#f00;box-sizing:border-box;float:right;height:12px;padding:0 2px;position:relative;width:280px}.el-color-hue-slider__bar{background:linear-gradient(90deg,#f00 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,#f00);height:100%;position:relative}.el-color-hue-slider__thumb{background:#fff;border:1px solid var(--el-border-color-lighter);border-radius:1px;box-shadow:0 0 2px rgba(0,0,0,.6);box-sizing:border-box;cursor:pointer;height:100%;left:0;position:absolute;top:0;width:4px;z-index:1}.el-color-hue-slider__thumb:focus-visible{outline:2px solid var(--el-color-primary);outline-offset:1px}.el-color-hue-slider.is-vertical{height:180px;padding:2px 0;width:12px}.el-color-hue-slider.is-vertical .el-color-hue-slider__bar{background:linear-gradient(180deg,#f00 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,#f00)}.el-color-hue-slider.is-vertical .el-color-hue-slider__thumb{height:4px;left:0;top:0;width:100%}.el-color-svpanel{height:180px;position:relative;width:280px}.el-color-svpanel__black,.el-color-svpanel__white{bottom:0;left:0;position:absolute;right:0;top:0}.el-color-svpanel__white{background:linear-gradient(90deg,#fff,rgba(255,255,255,0))}.el-color-svpanel__black{background:linear-gradient(0deg,#000,rgba(0,0,0,0))}.el-color-svpanel__cursor{position:absolute}.el-color-svpanel__cursor>div{border-radius:50%;box-shadow:0 0 0 1.5px #fff,inset 0 0 1px 1px rgba(0,0,0,.3),0 0 1px 2px rgba(0,0,0,.4);cursor:head;height:4px;transform:translate(-2px,-2px);width:4px}.el-color-alpha-slider{background-image:linear-gradient(45deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(45deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%);background-position:0 0,6px 0,6px -6px,0 6px;background-size:12px 12px;box-sizing:border-box;height:12px;position:relative;width:280px}.el-color-alpha-slider__bar{background:linear-gradient(to right,rgba(255,255,255,0) 0,var(--el-bg-color) 100%);height:100%;position:relative}.el-color-alpha-slider__thumb{background:#fff;border:1px solid var(--el-border-color-lighter);border-radius:1px;box-shadow:0 0 2px rgba(0,0,0,.6);box-sizing:border-box;cursor:pointer;height:100%;left:0;position:absolute;top:0;width:4px;z-index:1}.el-color-alpha-slider__thumb:focus-visible{outline:2px solid var(--el-color-primary);outline-offset:1px}.el-color-alpha-slider.is-vertical{height:180px;width:20px}.el-color-alpha-slider.is-vertical .el-color-alpha-slider__bar{background:linear-gradient(180deg,rgba(255,255,255,0) 0,rgb(255,255,255))}.el-color-alpha-slider.is-vertical .el-color-alpha-slider__thumb{height:4px;left:0;top:0;width:100%}.el-color-dropdown{width:300px}.el-color-dropdown__main-wrapper{margin-bottom:6px}.el-color-dropdown__main-wrapper:after{clear:both;content:"";display:table}.el-color-dropdown__btns{margin-top:12px;text-align:right}.el-color-dropdown__value{color:#000000;float:left;font-size:12px;line-height:26px;width:160px}.el-color-picker{display:inline-block;height:32px;line-height:normal;outline:none;position:relative;width:32px}.el-color-picker:hover:not(.is-disabled,.is-focused) .el-color-picker__trigger{border-color:var(--el-border-color-hover)}.el-color-picker:focus-visible:not(.is-disabled) .el-color-picker__trigger{outline:2px solid var(--el-color-primary);outline-offset:1px}.el-color-picker.is-focused .el-color-picker__trigger{border-color:var(--el-color-primary)}.el-color-picker.is-disabled .el-color-picker__trigger{background-color:var(--el-fill-color-light);cursor:not-allowed}.el-color-picker.is-disabled .el-color-picker__color{opacity:.3}.el-color-picker--large{height:40px;width:40px}.el-color-picker--small{height:24px;width:24px}.el-color-picker--small .el-color-picker__empty,.el-color-picker--small .el-color-picker__icon{transform:scale(.8)}.el-color-picker__trigger{align-items:center;border:1px solid var(--el-border-color);border-radius:4px;cursor:pointer;display:inline-flex;font-size:0;justify-content:center;padding:4px}.el-color-picker__color,.el-color-picker__trigger{box-sizing:border-box;height:100%;position:relative;width:100%}.el-color-picker__color{border:1px solid var(--el-text-color-secondary);border-radius:var(--el-border-radius-small);display:block;text-align:center}.el-color-picker__color.is-alpha{background-image:linear-gradient(45deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(45deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%);background-position:0 0,6px 0,6px -6px,0 6px;background-size:12px 12px}.el-color-picker__color-inner{align-items:center;display:inline-flex;height:100%;justify-content:center;width:100%}.el-color-picker .el-color-picker__empty{color:var(--el-text-color-secondary);font-size:12px}.el-color-picker .el-color-picker__icon{align-items:center;color:#ffffff;display:inline-flex;font-size:12px;justify-content:center}.el-color-picker__panel{background-color:#ffffff;border-radius:var(--el-border-radius-base);box-shadow:var(--el-box-shadow-light);box-sizing:content-box;padding:6px;position:absolute;z-index:10}.el-color-picker__panel.el-popper{border:1px solid var(--el-border-color-lighter)}.el-color-picker,.el-color-picker__panel{--el-color-picker-alpha-bg-a:#ccc;--el-color-picker-alpha-bg-b:transparent}.dark .el-color-picker,.dark .el-color-picker__panel{--el-color-picker-alpha-bg-a:#333333}.el-container{box-sizing:border-box;display:flex;flex:1;flex-basis:auto;flex-direction:row;min-width:0}.el-container.is-vertical{flex-direction:column}.el-date-table{font-size:12px;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-date-table.is-week-mode .el-date-table__row:hover .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-date-table.is-week-mode .el-date-table__row:hover td.available:hover{color:var(--el-datepicker-text-color)}.el-date-table.is-week-mode .el-date-table__row:hover td:first-child .el-date-table-cell{border-bottom-left-radius:15px;border-top-left-radius:15px;margin-left:5px}.el-date-table.is-week-mode .el-date-table__row:hover td:last-child .el-date-table-cell{border-bottom-right-radius:15px;border-top-right-radius:15px;margin-right:5px}.el-date-table.is-week-mode .el-date-table__row.current .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-date-table td{box-sizing:border-box;cursor:pointer;height:30px;padding:4px 0;position:relative;text-align:center;width:32px}.el-date-table td .el-date-table-cell{box-sizing:border-box;height:30px;padding:3px 0}.el-date-table td .el-date-table-cell .el-date-table-cell__text{border-radius:50%;display:block;height:24px;left:50%;line-height:24px;margin:0 auto;position:absolute;transform:translateX(-50%);width:24px}.el-date-table td.next-month,.el-date-table td.prev-month{color:var(--el-datepicker-off-text-color)}.el-date-table td.today{position:relative}.el-date-table td.today .el-date-table-cell__text{color:var(--el-color-primary);font-weight:bold}.el-date-table td.today.end-date .el-date-table-cell__text,.el-date-table td.today.start-date .el-date-table-cell__text{color:#ffffff}.el-date-table td.available:hover{color:var(--el-datepicker-hover-text-color)}.el-date-table td.in-range .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-date-table td.in-range .el-date-table-cell:hover{background-color:var(--el-datepicker-inrange-hover-bg-color)}.el-date-table td.current:not(.disabled) .el-date-table-cell__text{background-color:var(--el-datepicker-active-color);color:#ffffff}.el-date-table td.current:not(.disabled):focus-visible .el-date-table-cell__text{outline:2px solid var(--el-datepicker-active-color);outline-offset:1px}.el-date-table td.end-date .el-date-table-cell,.el-date-table td.start-date .el-date-table-cell{color:#ffffff}.el-date-table td.end-date .el-date-table-cell__text,.el-date-table td.start-date .el-date-table-cell__text{background-color:var(--el-datepicker-active-color)}.el-date-table td.start-date .el-date-table-cell{border-bottom-left-radius:15px;border-top-left-radius:15px;margin-left:5px}.el-date-table td.end-date .el-date-table-cell{border-bottom-right-radius:15px;border-top-right-radius:15px;margin-right:5px}.el-date-table td.disabled .el-date-table-cell{background-color:var(--el-fill-color-light);color:var(--el-text-color-placeholder);cursor:not-allowed;opacity:1}.el-date-table td.selected .el-date-table-cell{border-radius:15px;margin-left:5px;margin-right:5px}.el-date-table td.selected .el-date-table-cell__text{background-color:var(--el-datepicker-active-color);border-radius:15px;color:#ffffff}.el-date-table td.week{color:var(--el-datepicker-off-text-color);cursor:default;font-size:80%}.el-date-table td:focus{outline:none}.el-date-table th{border-bottom:1px solid var(--el-border-color-lighter);color:var(--el-datepicker-header-text-color);font-weight:400;padding:5px}.el-date-table th.el-date-table__week-header{padding:0;width:24px}.el-month-table{border-collapse:collapse;font-size:12px;margin:-1px}.el-month-table td{cursor:pointer;padding:8px 0;position:relative;text-align:center;width:68px}.el-month-table td .el-date-table-cell{box-sizing:border-box;height:48px;padding:6px 0}.el-month-table td.today .el-date-table-cell__text{color:var(--el-color-primary);font-weight:bold}.el-month-table td.today.end-date .el-date-table-cell__text,.el-month-table td.today.start-date .el-date-table-cell__text{color:#ffffff}.el-month-table td.disabled .el-date-table-cell__text{background-color:var(--el-fill-color-light);color:var(--el-text-color-placeholder);cursor:not-allowed}.el-month-table td.disabled .el-date-table-cell__text:hover{color:var(--el-text-color-placeholder)}.el-month-table td .el-date-table-cell__text{border-radius:18px;color:var(--el-datepicker-text-color);display:block;height:36px;left:50%;line-height:36px;margin:0 auto;position:absolute;transform:translateX(-50%);width:54px}.el-month-table td .el-date-table-cell__text:hover{color:var(--el-datepicker-hover-text-color)}.el-month-table td.in-range .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-month-table td.in-range .el-date-table-cell:hover{background-color:var(--el-datepicker-inrange-hover-bg-color)}.el-month-table td.end-date .el-date-table-cell,.el-month-table td.start-date .el-date-table-cell{color:#ffffff}.el-month-table td.end-date .el-date-table-cell__text,.el-month-table td.start-date .el-date-table-cell__text{background-color:var(--el-datepicker-active-color);color:#ffffff}.el-month-table td.start-date .el-date-table-cell{border-bottom-left-radius:24px;border-top-left-radius:24px;margin-left:3px}.el-month-table td.end-date .el-date-table-cell{border-bottom-right-radius:24px;border-top-right-radius:24px;margin-right:3px}.el-month-table td.current:not(.disabled) .el-date-table-cell{border-radius:24px;margin-left:3px;margin-right:3px}.el-month-table td.current:not(.disabled) .el-date-table-cell__text{background-color:var(--el-datepicker-active-color);color:#ffffff}.el-month-table td:focus-visible{outline:none}.el-month-table td:focus-visible .el-date-table-cell__text{outline:2px solid var(--el-datepicker-active-color);outline-offset:1px}.el-year-table{border-collapse:collapse;font-size:12px;margin:-1px}.el-year-table .el-icon{color:var(--el-datepicker-icon-color)}.el-year-table td{cursor:pointer;padding:8px 0;position:relative;text-align:center;width:68px}.el-year-table td .el-date-table-cell{box-sizing:border-box;height:48px;padding:6px 0}.el-year-table td.today .el-date-table-cell__text{color:var(--el-color-primary);font-weight:bold}.el-year-table td.today.end-date .el-date-table-cell__text,.el-year-table td.today.start-date .el-date-table-cell__text{color:#ffffff}.el-year-table td.disabled .el-date-table-cell__text{background-color:var(--el-fill-color-light);color:var(--el-text-color-placeholder);cursor:not-allowed}.el-year-table td.disabled .el-date-table-cell__text:hover{color:var(--el-text-color-placeholder)}.el-year-table td .el-date-table-cell__text{border-radius:18px;color:var(--el-datepicker-text-color);display:block;height:36px;left:50%;line-height:36px;margin:0 auto;position:absolute;transform:translateX(-50%);width:60px}.el-year-table td .el-date-table-cell__text:hover{color:var(--el-datepicker-hover-text-color)}.el-year-table td.in-range .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-year-table td.in-range .el-date-table-cell:hover{background-color:var(--el-datepicker-inrange-hover-bg-color)}.el-year-table td.end-date .el-date-table-cell,.el-year-table td.start-date .el-date-table-cell{color:#ffffff}.el-year-table td.end-date .el-date-table-cell__text,.el-year-table td.start-date .el-date-table-cell__text{background-color:var(--el-datepicker-active-color);color:#ffffff}.el-year-table td.start-date .el-date-table-cell{border-bottom-left-radius:24px;border-top-left-radius:24px}.el-year-table td.end-date .el-date-table-cell{border-bottom-right-radius:24px;border-top-right-radius:24px}.el-year-table td.current:not(.disabled) .el-date-table-cell__text{background-color:var(--el-datepicker-active-color);color:#ffffff}.el-year-table td:focus-visible{outline:none}.el-year-table td:focus-visible .el-date-table-cell__text{outline:2px solid var(--el-datepicker-active-color);outline-offset:1px}.el-time-spinner.has-seconds .el-time-spinner__wrapper{width:33.3%}.el-time-spinner__wrapper{display:inline-block;max-height:192px;overflow:auto;position:relative;vertical-align:top;width:50%}.el-time-spinner__wrapper.el-scrollbar__wrap:not(.el-scrollbar__wrap--hidden-default){padding-bottom:15px}.el-time-spinner__wrapper.is-arrow{box-sizing:border-box;overflow:hidden;text-align:center}.el-time-spinner__wrapper.is-arrow .el-time-spinner__list{transform:translateY(-32px)}.el-time-spinner__wrapper.is-arrow .el-time-spinner__item:hover:not(.is-disabled):not(.is-active){background:var(--el-fill-color-light);cursor:default}.el-time-spinner__arrow{color:var(--el-text-color-secondary);cursor:pointer;font-size:12px;height:30px;left:0;line-height:30px;position:absolute;text-align:center;width:100%;z-index:var(--el-index-normal)}.el-time-spinner__arrow:hover{color:var(--el-color-primary)}.el-time-spinner__arrow.arrow-up{top:10px}.el-time-spinner__arrow.arrow-down{bottom:10px}.el-time-spinner__input.el-input{width:70%}.el-time-spinner__input.el-input .el-input__inner,.el-time-spinner__list{padding:0;text-align:center}.el-time-spinner__list{list-style:none;margin:0}.el-time-spinner__list:after,.el-time-spinner__list:before{content:"";display:block;height:80px;width:100%}.el-time-spinner__item{color:var(--el-text-color-regular);font-size:12px;height:32px;line-height:32px}.el-time-spinner__item:hover:not(.is-disabled):not(.is-active){background:var(--el-fill-color-light);cursor:pointer}.el-time-spinner__item.is-active:not(.is-disabled){color:var(--el-text-color-primary);font-weight:bold}.el-time-spinner__item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-picker__popper{--el-datepicker-border-color:var(--el-disabled-border-color)}.el-picker__popper.el-popper{background:var(--el-bg-color-overlay);box-shadow:var(--el-box-shadow-light)}.el-picker__popper.el-popper,.el-picker__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-datepicker-border-color)}.el-picker__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent;border-top-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent;border-left-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-date-editor{--el-date-editor-width:220px;--el-date-editor-monthrange-width:300px;--el-date-editor-daterange-width:350px;--el-date-editor-datetimerange-width:400px;--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;position:relative;text-align:left;vertical-align:middle}.el-date-editor.el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset}.el-date-editor.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-date-editor.el-input,.el-date-editor.el-input__wrapper{height:var(--el-input-height,var(--el-component-size));width:var(--el-date-editor-width)}.el-date-editor--monthrange{--el-date-editor-width:var(--el-date-editor-monthrange-width)}.el-date-editor--daterange,.el-date-editor--timerange{--el-date-editor-width:var(--el-date-editor-daterange-width)}.el-date-editor--datetimerange{--el-date-editor-width:var(--el-date-editor-datetimerange-width)}.el-date-editor--dates .el-input__wrapper{text-overflow:ellipsis;white-space:nowrap}.el-date-editor .clear-icon,.el-date-editor .close-icon{cursor:pointer}.el-date-editor .clear-icon:hover{color:var(--el-input-clear-hover-color)}.el-date-editor .el-range__icon{color:var(--el-text-color-placeholder);float:left;font-size:14px;height:inherit}.el-date-editor .el-range__icon svg{vertical-align:middle}.el-date-editor .el-range-input{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:none;color:var(--el-text-color-regular);display:inline-block;font-size:var(--el-font-size-base);height:30px;line-height:30px;margin:0;outline:none;padding:0;text-align:center;width:39%}.el-date-editor .el-range-input::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-input::placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-separator{align-items:center;color:var(--el-text-color-primary);display:inline-flex;flex:1;font-size:14px;height:100%;justify-content:center;margin:0;overflow-wrap:break-word;padding:0 5px}.el-date-editor .el-range__close-icon{color:var(--el-text-color-placeholder);cursor:pointer;font-size:14px;height:inherit;width:unset}.el-date-editor .el-range__close-icon:hover{color:var(--el-input-clear-hover-color)}.el-date-editor .el-range__close-icon svg{vertical-align:middle}.el-date-editor .el-range__close-icon--hidden{opacity:0;visibility:hidden}.el-range-editor.el-input__wrapper{align-items:center;display:inline-flex;padding:0 10px;vertical-align:middle}.el-range-editor.is-active,.el-range-editor.is-active:hover{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-range-editor--large{line-height:var(--el-component-size-large)}.el-range-editor--large.el-input__wrapper{height:var(--el-component-size-large)}.el-range-editor--large .el-range-separator{font-size:14px;line-height:40px}.el-range-editor--large .el-range-input{font-size:14px;height:38px;line-height:38px}.el-range-editor--small{line-height:var(--el-component-size-small)}.el-range-editor--small.el-input__wrapper{height:var(--el-component-size-small)}.el-range-editor--small .el-range-separator{font-size:12px;line-height:24px}.el-range-editor--small .el-range-input{font-size:12px;height:22px;line-height:22px}.el-range-editor.is-disabled{background-color:var(--el-disabled-bg-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-range-editor.is-disabled,.el-range-editor.is-disabled:focus,.el-range-editor.is-disabled:hover{border-color:var(--el-disabled-border-color)}.el-range-editor.is-disabled input{background-color:var(--el-disabled-bg-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-range-editor.is-disabled input::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled input::placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled .el-range-separator{color:var(--el-disabled-text-color)}.el-picker-panel{background:var(--el-bg-color-overlay);border-radius:var(--el-popper-border-radius,var(--el-border-radius-base));color:var(--el-text-color-regular);line-height:30px}.el-picker-panel .el-time-panel{background-color:var(--el-bg-color-overlay);border:1px solid var(--el-datepicker-border-color);box-shadow:var(--el-box-shadow-light);margin:5px 0}.el-picker-panel__body-wrapper:after,.el-picker-panel__body:after{clear:both;content:"";display:table}.el-picker-panel__content{margin:15px;position:relative}.el-picker-panel__footer{background-color:var(--el-bg-color-overlay);border-top:1px solid var(--el-datepicker-inner-border-color);font-size:0;padding:4px 12px;position:relative;text-align:right}.el-picker-panel__shortcut{background-color:transparent;border:0;color:var(--el-datepicker-text-color);cursor:pointer;display:block;font-size:14px;line-height:28px;outline:none;padding-left:12px;text-align:left;width:100%}.el-picker-panel__shortcut:hover{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__shortcut.active{background-color:#e6f1fe;color:var(--el-datepicker-active-color)}.el-picker-panel__btn{background-color:transparent;border:1px solid var(--el-fill-color-darker);border-radius:2px;color:var(--el-text-color-primary);cursor:pointer;font-size:12px;line-height:24px;outline:none;padding:0 20px}.el-picker-panel__btn[disabled]{color:var(--el-text-color-disabled);cursor:not-allowed}.el-picker-panel__icon-btn{background:transparent;border:0;color:var(--el-datepicker-icon-color);cursor:pointer;font-size:12px;margin-top:8px;outline:none}.el-picker-panel__icon-btn:hover{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__icon-btn:focus-visible{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__icon-btn.is-disabled{color:var(--el-text-color-disabled)}.el-picker-panel__icon-btn.is-disabled:hover{cursor:not-allowed}.el-picker-panel__icon-btn .el-icon{cursor:pointer;font-size:inherit}.el-picker-panel__link-btn{vertical-align:middle}.el-picker-panel [slot=sidebar],.el-picker-panel__sidebar{border-right:1px solid var(--el-datepicker-inner-border-color);bottom:0;box-sizing:border-box;overflow:auto;padding-top:6px;position:absolute;top:0;width:110px}.el-picker-panel [slot=sidebar]+.el-picker-panel__body,.el-picker-panel__sidebar+.el-picker-panel__body{margin-left:110px}.el-date-picker{--el-datepicker-text-color:var(--el-text-color-regular);--el-datepicker-off-text-color:var(--el-text-color-placeholder);--el-datepicker-header-text-color:var(--el-text-color-regular);--el-datepicker-icon-color:var(--el-text-color-primary);--el-datepicker-border-color:var(--el-disabled-border-color);--el-datepicker-inner-border-color:var(--el-border-color-light);--el-datepicker-inrange-bg-color:var(--el-border-color-extra-light);--el-datepicker-inrange-hover-bg-color:var(--el-border-color-extra-light);--el-datepicker-active-color:var(--el-color-primary);--el-datepicker-hover-text-color:var(--el-color-primary);width:322px}.el-date-picker.has-sidebar.has-time{width:434px}.el-date-picker.has-sidebar{width:438px}.el-date-picker.has-time .el-picker-panel__body-wrapper{position:relative}.el-date-picker .el-picker-panel__content{width:292px}.el-date-picker table{table-layout:fixed;width:100%}.el-date-picker__editor-wrap{display:table-cell;padding:0 5px;position:relative}.el-date-picker__time-header{border-bottom:1px solid var(--el-datepicker-inner-border-color);box-sizing:border-box;display:table;font-size:12px;padding:8px 5px 5px;position:relative;width:100%}.el-date-picker__header{padding:12px 12px 0;text-align:center}.el-date-picker__header--bordered{border-bottom:1px solid var(--el-border-color-lighter);margin-bottom:0;padding-bottom:12px}.el-date-picker__header--bordered+.el-picker-panel__content{margin-top:0}.el-date-picker__header-label{color:var(--el-text-color-regular);cursor:pointer;font-size:16px;font-weight:500;line-height:22px;padding:0 5px;text-align:center}.el-date-picker__header-label:hover{color:var(--el-datepicker-hover-text-color)}.el-date-picker__header-label:focus-visible{color:var(--el-datepicker-hover-text-color);outline:none}.el-date-picker__header-label.active{color:var(--el-datepicker-active-color)}.el-date-picker__prev-btn{float:left}.el-date-picker__next-btn{float:right}.el-date-picker__time-wrap{padding:10px;text-align:center}.el-date-picker__time-label{cursor:pointer;float:left;line-height:30px;margin-left:10px}.el-date-picker .el-time-panel{position:absolute}.el-date-range-picker{--el-datepicker-text-color:var(--el-text-color-regular);--el-datepicker-off-text-color:var(--el-text-color-placeholder);--el-datepicker-header-text-color:var(--el-text-color-regular);--el-datepicker-icon-color:var(--el-text-color-primary);--el-datepicker-border-color:var(--el-disabled-border-color);--el-datepicker-inner-border-color:var(--el-border-color-light);--el-datepicker-inrange-bg-color:var(--el-border-color-extra-light);--el-datepicker-inrange-hover-bg-color:var(--el-border-color-extra-light);--el-datepicker-active-color:var(--el-color-primary);--el-datepicker-hover-text-color:var(--el-color-primary);width:646px}.el-date-range-picker.has-sidebar{width:756px}.el-date-range-picker.has-time .el-picker-panel__body-wrapper{position:relative}.el-date-range-picker table{table-layout:fixed;width:100%}.el-date-range-picker .el-picker-panel__body{min-width:513px}.el-date-range-picker .el-picker-panel__content{margin:0}.el-date-range-picker__header{height:28px;position:relative;text-align:center}.el-date-range-picker__header [class*=arrow-left]{float:left}.el-date-range-picker__header [class*=arrow-right]{float:right}.el-date-range-picker__header div{font-size:16px;font-weight:500;margin-right:50px}.el-date-range-picker__header-label{color:var(--el-text-color-regular);cursor:pointer;font-size:16px;font-weight:500;line-height:22px;padding:0 5px;text-align:center}.el-date-range-picker__header-label:hover{color:var(--el-datepicker-hover-text-color)}.el-date-range-picker__header-label:focus-visible{color:var(--el-datepicker-hover-text-color);outline:none}.el-date-range-picker__header-label.active{color:var(--el-datepicker-active-color)}.el-date-range-picker__content{box-sizing:border-box;float:left;margin:0;padding:16px;width:50%}.el-date-range-picker__content.is-left{border-right:1px solid var(--el-datepicker-inner-border-color)}.el-date-range-picker__content .el-date-range-picker__header div{margin-left:50px;margin-right:50px}.el-date-range-picker__editors-wrap{box-sizing:border-box;display:table-cell}.el-date-range-picker__editors-wrap.is-right{text-align:right}.el-date-range-picker__time-header{border-bottom:1px solid var(--el-datepicker-inner-border-color);box-sizing:border-box;display:table;font-size:12px;padding:8px 5px 5px;position:relative;width:100%}.el-date-range-picker__time-header>.el-icon-arrow-right{color:var(--el-datepicker-icon-color);display:table-cell;font-size:20px;vertical-align:middle}.el-date-range-picker__time-picker-wrap{display:table-cell;padding:0 5px;position:relative}.el-date-range-picker__time-picker-wrap .el-picker-panel{background:#ffffff;position:absolute;right:0;top:13px;z-index:1}.el-date-range-picker__time-picker-wrap .el-time-panel{position:absolute}.el-time-range-picker{overflow:visible;width:354px}.el-time-range-picker__content{padding:10px;position:relative;text-align:center;z-index:1}.el-time-range-picker__cell{box-sizing:border-box;display:inline-block;margin:0;padding:4px 7px 7px;width:50%}.el-time-range-picker__header{font-size:14px;margin-bottom:5px;text-align:center}.el-time-range-picker__body{border:1px solid var(--el-datepicker-border-color);border-radius:2px}.el-time-panel{border-radius:2px;box-sizing:content-box;left:0;position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:180px;z-index:var(--el-index-top)}.el-time-panel__content{font-size:0;overflow:hidden;position:relative}.el-time-panel__content:after,.el-time-panel__content:before{box-sizing:border-box;content:"";height:32px;left:0;margin-top:-16px;padding-top:6px;position:absolute;right:0;text-align:left;top:50%;z-index:-1}.el-time-panel__content:after{left:50%;margin-left:12%;margin-right:12%}.el-time-panel__content:before{border-bottom:1px solid var(--el-border-color-light);border-top:1px solid var(--el-border-color-light);margin-left:12%;margin-right:12%;padding-left:50%}.el-time-panel__content.has-seconds:after{left:66.6666666667%}.el-time-panel__content.has-seconds:before{padding-left:33.3333333333%}.el-time-panel__footer{border-top:1px solid var(--el-timepicker-inner-border-color,var(--el-border-color-light));box-sizing:border-box;height:36px;line-height:25px;padding:4px;text-align:right}.el-time-panel__btn{background-color:transparent;border:none;color:var(--el-text-color-primary);cursor:pointer;font-size:12px;line-height:28px;margin:0 5px;outline:none;padding:0 5px}.el-time-panel__btn.confirm{color:var(--el-timepicker-active-color,var(--el-color-primary));font-weight:800}.el-descriptions{--el-descriptions-table-border:1px solid var(--el-border-color-lighter);--el-descriptions-item-bordered-label-background:var(--el-fill-color-light);box-sizing:border-box;color:var(--el-text-color-primary);font-size:var(--el-font-size-base)}.el-descriptions__header{align-items:center;display:flex;justify-content:space-between;margin-bottom:16px}.el-descriptions__title{color:var(--el-text-color-primary);font-size:16px;font-weight:bold}.el-descriptions__body{background-color:var(--el-fill-color-blank)}.el-descriptions__body .el-descriptions__table{border-collapse:collapse;width:100%}.el-descriptions__body .el-descriptions__table .el-descriptions__cell{box-sizing:border-box;font-size:14px;line-height:23px;text-align:left}.el-descriptions__body .el-descriptions__table .el-descriptions__cell.is-left{text-align:left}.el-descriptions__body .el-descriptions__table .el-descriptions__cell.is-center{text-align:center}.el-descriptions__body .el-descriptions__table .el-descriptions__cell.is-right{text-align:right}.el-descriptions__body .el-descriptions__table.is-bordered .el-descriptions__cell{border:var(--el-descriptions-table-border);padding:8px 11px}.el-descriptions__body .el-descriptions__table:not(.is-bordered) .el-descriptions__cell{padding-bottom:12px}.el-descriptions--large{font-size:14px}.el-descriptions--large .el-descriptions__header{margin-bottom:20px}.el-descriptions--large .el-descriptions__header .el-descriptions__title{font-size:16px}.el-descriptions--large .el-descriptions__body .el-descriptions__table .el-descriptions__cell{font-size:14px}.el-descriptions--large .el-descriptions__body .el-descriptions__table.is-bordered .el-descriptions__cell{padding:12px 15px}.el-descriptions--large .el-descriptions__body .el-descriptions__table:not(.is-bordered) .el-descriptions__cell{padding-bottom:16px}.el-descriptions--small{font-size:12px}.el-descriptions--small .el-descriptions__header{margin-bottom:12px}.el-descriptions--small .el-descriptions__header .el-descriptions__title{font-size:14px}.el-descriptions--small .el-descriptions__body .el-descriptions__table .el-descriptions__cell{font-size:12px}.el-descriptions--small .el-descriptions__body .el-descriptions__table.is-bordered .el-descriptions__cell{padding:4px 7px}.el-descriptions--small .el-descriptions__body .el-descriptions__table:not(.is-bordered) .el-descriptions__cell{padding-bottom:8px}.el-descriptions__label.el-descriptions__cell.is-bordered-label{background:var(--el-descriptions-item-bordered-label-background);color:var(--el-text-color-regular);font-weight:bold}.el-descriptions__label:not(.is-bordered-label){color:var(--el-text-color-primary);margin-right:16px}.el-descriptions__label.el-descriptions__cell:not(.is-bordered-label).is-vertical-label{padding-bottom:6px}.el-descriptions__content.el-descriptions__cell.is-bordered-content{color:var(--el-text-color-primary)}.el-descriptions__content:not(.is-bordered-label){color:var(--el-text-color-regular)}.el-descriptions--large .el-descriptions__label:not(.is-bordered-label){margin-right:16px}.el-descriptions--large .el-descriptions__label.el-descriptions__cell:not(.is-bordered-label).is-vertical-label{padding-bottom:8px}.el-descriptions--small .el-descriptions__label:not(.is-bordered-label){margin-right:12px}.el-descriptions--small .el-descriptions__label.el-descriptions__cell:not(.is-bordered-label).is-vertical-label{padding-bottom:4px}:root{--el-popup-modal-bg-color:var(--el-color-black);--el-popup-modal-opacity:0.5}.v-modal-enter{animation:v-modal-in var(--el-transition-duration-fast) ease}.v-modal-leave{animation:v-modal-out var(--el-transition-duration-fast) ease forwards}@keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-out{to{opacity:0}}.v-modal{background:var(--el-popup-modal-bg-color);height:100%;left:0;opacity:var(--el-popup-modal-opacity);position:fixed;top:0;width:100%}.el-popup-parent--hidden{overflow:hidden}.el-dialog{--el-dialog-width:50%;--el-dialog-margin-top:15vh;--el-dialog-bg-color:var(--el-bg-color);--el-dialog-box-shadow:var(--el-box-shadow);--el-dialog-title-font-size:var(--el-font-size-large);--el-dialog-content-font-size:14px;--el-dialog-font-line-height:var(--el-font-line-height-primary);--el-dialog-padding-primary:16px;--el-dialog-border-radius:var(--el-border-radius-base);background:var(--el-dialog-bg-color);border-radius:var(--el-dialog-border-radius);box-shadow:var(--el-dialog-box-shadow);box-sizing:border-box;margin:var(--el-dialog-margin-top,15vh) auto 50px;overflow-wrap:break-word;padding:var(--el-dialog-padding-primary);position:relative;width:var(--el-dialog-width,50%)}.el-dialog:focus{outline:none!important}.el-dialog.is-align-center{margin:auto}.el-dialog.is-fullscreen{--el-dialog-width:100%;--el-dialog-margin-top:0;border-radius:0;height:100%;margin-bottom:0;overflow:auto}.el-dialog__wrapper{bottom:0;left:0;margin:0;overflow:auto;position:fixed;right:0;top:0}.el-dialog.is-draggable .el-dialog__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-dialog__header{padding-bottom:var(--el-dialog-padding-primary)}.el-dialog__header.show-close{padding-right:calc(var(--el-dialog-padding-primary) + var(--el-message-close-size, 16px))}.el-dialog__headerbtn{background:transparent;border:none;cursor:pointer;font-size:var(--el-message-close-size,16px);height:48px;outline:none;padding:0;position:absolute;right:0;top:0;width:48px}.el-dialog__headerbtn .el-dialog__close{color:var(--el-color-info);font-size:inherit}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:var(--el-color-primary)}.el-dialog__title{color:var(--el-text-color-primary);font-size:var(--el-dialog-title-font-size);line-height:var(--el-dialog-font-line-height)}.el-dialog__body{color:var(--el-text-color-regular);font-size:var(--el-dialog-content-font-size)}.el-dialog__footer{box-sizing:border-box;padding-top:var(--el-dialog-padding-primary);text-align:right}.el-dialog--center{text-align:center}.el-dialog--center .el-dialog__body{text-align:initial}.el-dialog--center .el-dialog__footer{text-align:inherit}.el-modal-dialog.is-penetrable{pointer-events:none}.el-modal-dialog.is-penetrable .el-dialog{pointer-events:auto}.el-overlay-dialog{bottom:0;left:0;overflow:auto;position:fixed;right:0;top:0}.dialog-fade-enter-active{animation:modal-fade-in var(--el-transition-duration)}.dialog-fade-enter-active .el-overlay-dialog{animation:dialog-fade-in var(--el-transition-duration)}.dialog-fade-leave-active{animation:modal-fade-out var(--el-transition-duration)}.dialog-fade-leave-active .el-overlay-dialog{animation:dialog-fade-out var(--el-transition-duration)}@keyframes dialog-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}@keyframes dialog-fade-out{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20px,0)}}@keyframes modal-fade-in{0%{opacity:0}to{opacity:1}}@keyframes modal-fade-out{0%{opacity:1}to{opacity:0}}.el-divider{position:relative}.el-divider--horizontal{border-top:1px var(--el-border-color) var(--el-border-style);display:block;height:1px;margin:24px 0;width:100%}.el-divider--vertical{border-left:1px var(--el-border-color) var(--el-border-style);display:inline-block;height:1em;margin:0 8px;position:relative;vertical-align:middle;width:1px}.el-divider__text{background-color:var(--el-bg-color);color:var(--el-text-color-primary);font-size:14px;font-weight:500;padding:0 20px;position:absolute}.el-divider__text.is-left{left:20px;transform:translateY(-50%)}.el-divider__text.is-center{left:50%;transform:translateX(-50%) translateY(-50%)}.el-divider__text.is-right{right:20px;transform:translateY(-50%)}.el-drawer{--el-drawer-bg-color:var(--el-dialog-bg-color,var(--el-bg-color));--el-drawer-padding-primary:var(--el-dialog-padding-primary,20px);background-color:var(--el-drawer-bg-color);box-shadow:var(--el-box-shadow-dark);box-sizing:border-box;display:flex;flex-direction:column;overflow:hidden;position:absolute;transition:all var(--el-transition-duration)}.el-drawer .btt,.el-drawer .ltr,.el-drawer .rtl,.el-drawer .ttb{transform:translate(0)}.el-drawer__sr-focus:focus{outline:none!important}.el-drawer__header{align-items:center;color:var(--el-text-color-primary);display:flex;margin-bottom:32px;padding:var(--el-drawer-padding-primary);padding-bottom:0}.el-drawer__header>:first-child{flex:1}.el-drawer__title{flex:1;font-size:16px;line-height:inherit;margin:0}.el-drawer__footer{padding:var(--el-drawer-padding-primary);padding-top:10px;text-align:right}.el-drawer__close-btn{background-color:transparent;border:none;color:inherit;cursor:pointer;display:inline-flex;font-size:var(--el-font-size-extra-large);outline:none}.el-drawer__close-btn:focus i,.el-drawer__close-btn:hover i{color:var(--el-color-primary)}.el-drawer__body{flex:1;overflow:auto;padding:var(--el-drawer-padding-primary)}.el-drawer__body>*{box-sizing:border-box}.el-drawer.ltr,.el-drawer.rtl{bottom:0;height:100%;top:0}.el-drawer.btt,.el-drawer.ttb{left:0;right:0;width:100%}.el-drawer.ltr{left:0}.el-drawer.rtl{right:0}.el-drawer.ttb{top:0}.el-drawer.btt{bottom:0}.el-drawer-fade-enter-active,.el-drawer-fade-leave-active{transition:all var(--el-transition-duration)}.el-drawer-fade-enter-active,.el-drawer-fade-enter-from,.el-drawer-fade-enter-to,.el-drawer-fade-leave-active,.el-drawer-fade-leave-from,.el-drawer-fade-leave-to{overflow:hidden!important}.el-drawer-fade-enter-from,.el-drawer-fade-leave-to{background-color:transparent!important}.el-drawer-fade-enter-from .rtl,.el-drawer-fade-leave-to .rtl{transform:translateX(100%)}.el-drawer-fade-enter-from .ltr,.el-drawer-fade-leave-to .ltr{transform:translateX(-100%)}.el-drawer-fade-enter-from .ttb,.el-drawer-fade-leave-to .ttb{transform:translateY(-100%)}.el-drawer-fade-enter-from .btt,.el-drawer-fade-leave-to .btt{transform:translateY(100%)}.el-dropdown{--el-dropdown-menu-box-shadow:var(--el-box-shadow-light);--el-dropdown-menuItem-hover-fill:var(--el-color-primary-light-9);--el-dropdown-menuItem-hover-color:var(--el-color-primary);--el-dropdown-menu-index:10;color:var(--el-text-color-regular);display:inline-flex;font-size:var(--el-font-size-base);line-height:1;position:relative;vertical-align:top}.el-dropdown.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-dropdown__popper{--el-dropdown-menu-box-shadow:var(--el-box-shadow-light);--el-dropdown-menuItem-hover-fill:var(--el-color-primary-light-9);--el-dropdown-menuItem-hover-color:var(--el-color-primary);--el-dropdown-menu-index:10}.el-dropdown__popper.el-popper{background:var(--el-bg-color-overlay);box-shadow:var(--el-dropdown-menu-box-shadow)}.el-dropdown__popper.el-popper,.el-dropdown__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-dropdown__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent;border-top-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent;border-left-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-dropdown__popper .el-dropdown-menu{border:none}.el-dropdown__popper .el-dropdown__popper-selfdefine{outline:none}.el-dropdown__popper .el-scrollbar__bar{z-index:calc(var(--el-dropdown-menu-index) + 1)}.el-dropdown__popper .el-dropdown__list{box-sizing:border-box;list-style:none;margin:0;padding:0}.el-dropdown .el-dropdown__caret-button{align-items:center;border-left:none;display:inline-flex;justify-content:center;padding-left:0;padding-right:0;width:32px}.el-dropdown .el-dropdown__caret-button>span{display:inline-flex}.el-dropdown .el-dropdown__caret-button:before{background:var(--el-overlay-color-lighter);bottom:-1px;content:"";display:block;left:0;position:absolute;top:-1px;width:1px}.el-dropdown .el-dropdown__caret-button.el-button:before{background:var(--el-border-color);opacity:.5}.el-dropdown .el-dropdown__caret-button .el-dropdown__icon{font-size:inherit;padding-left:0}.el-dropdown .el-dropdown-selfdefine{outline:none}.el-dropdown--large .el-dropdown__caret-button{width:40px}.el-dropdown--small .el-dropdown__caret-button{width:24px}.el-dropdown-menu{background-color:var(--el-bg-color-overlay);border:none;border-radius:var(--el-border-radius-base);box-shadow:none;left:0;list-style:none;margin:0;padding:5px 0;position:relative;top:0;z-index:var(--el-dropdown-menu-index)}.el-dropdown-menu__item{align-items:center;color:var(--el-text-color-regular);cursor:pointer;display:flex;font-size:var(--el-font-size-base);line-height:22px;list-style:none;margin:0;outline:none;padding:5px 16px;white-space:nowrap}.el-dropdown-menu__item:not(.is-disabled):focus,.el-dropdown-menu__item:not(.is-disabled):hover{background-color:var(--el-dropdown-menuItem-hover-fill);color:var(--el-dropdown-menuItem-hover-color)}.el-dropdown-menu__item i{margin-right:5px}.el-dropdown-menu__item--divided{border-top:1px solid var(--el-border-color-lighter);margin:6px 0}.el-dropdown-menu__item.is-disabled{color:var(--el-text-color-disabled);cursor:not-allowed}.el-dropdown-menu--large{padding:7px 0}.el-dropdown-menu--large .el-dropdown-menu__item{font-size:14px;line-height:22px;padding:7px 20px}.el-dropdown-menu--large .el-dropdown-menu__item--divided{margin:8px 0}.el-dropdown-menu--small{padding:3px 0}.el-dropdown-menu--small .el-dropdown-menu__item{font-size:12px;line-height:20px;padding:2px 12px}.el-dropdown-menu--small .el-dropdown-menu__item--divided{margin:4px 0}.el-empty{--el-empty-padding:40px 0;--el-empty-image-width:160px;--el-empty-description-margin-top:20px;--el-empty-bottom-margin-top:20px;--el-empty-fill-color-0:var(--el-color-white);--el-empty-fill-color-1:#fcfcfd;--el-empty-fill-color-2:#f8f9fb;--el-empty-fill-color-3:#f7f8fc;--el-empty-fill-color-4:#eeeff3;--el-empty-fill-color-5:#edeef2;--el-empty-fill-color-6:#e9ebef;--el-empty-fill-color-7:#e5e7e9;--el-empty-fill-color-8:#e0e3e9;--el-empty-fill-color-9:#d5d7de;align-items:center;box-sizing:border-box;display:flex;flex-direction:column;justify-content:center;padding:var(--el-empty-padding);text-align:center}.el-empty__image{width:var(--el-empty-image-width)}.el-empty__image img{height:100%;-o-object-fit:contain;object-fit:contain;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:top;width:100%}.el-empty__image svg{color:var(--el-svg-monochrome-grey);fill:currentColor;height:100%;vertical-align:top;width:100%}.el-empty__description{margin-top:var(--el-empty-description-margin-top)}.el-empty__description p{color:var(--el-text-color-secondary);font-size:var(--el-font-size-base);margin:0}.el-empty__bottom{margin-top:var(--el-empty-bottom-margin-top)}.el-footer{--el-footer-padding:0 20px;--el-footer-height:60px;box-sizing:border-box;flex-shrink:0;height:var(--el-footer-height);padding:var(--el-footer-padding)}.el-form{--el-form-label-font-size:var(--el-font-size-base);--el-form-inline-content-width:220px}.el-form--inline .el-form-item{display:inline-flex;margin-right:32px;vertical-align:middle}.el-form--inline.el-form--label-top{display:flex;flex-wrap:wrap}.el-form--inline.el-form--label-top .el-form-item{display:block}.el-form-item{display:flex;--font-size:14px;margin-bottom:18px}.el-form-item .el-form-item{margin-bottom:0}.el-form-item .el-input__validateIcon{display:none}.el-form-item--large{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:22px}.el-form-item--large .el-form-item__label{height:40px;line-height:40px}.el-form-item--large .el-form-item__content{line-height:40px}.el-form-item--large .el-form-item__error{padding-top:4px}.el-form-item--default{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--default .el-form-item__label{height:32px;line-height:32px}.el-form-item--default .el-form-item__content{line-height:32px}.el-form-item--default .el-form-item__error{padding-top:2px}.el-form-item--small{--font-size:12px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--small .el-form-item__label{height:24px;line-height:24px}.el-form-item--small .el-form-item__content{line-height:24px}.el-form-item--small .el-form-item__error{padding-top:2px}.el-form-item--label-left .el-form-item__label{justify-content:flex-start;text-align:left}.el-form-item--label-right .el-form-item__label{justify-content:flex-end;text-align:right}.el-form-item--label-top{display:block}.el-form-item--label-top .el-form-item__label{display:block;height:auto;line-height:22px;margin-bottom:8px;text-align:left;width:-moz-fit-content;width:fit-content}.el-form-item__label-wrap{display:flex}.el-form-item__label{align-items:flex-start;box-sizing:border-box;color:var(--el-text-color-regular);display:inline-flex;flex:0 0 auto;font-size:var(--el-form-label-font-size);height:32px;line-height:32px;padding:0 12px 0 0}.el-form-item__content{align-items:center;display:flex;flex:1;flex-wrap:wrap;font-size:var(--font-size);line-height:32px;min-width:0;position:relative}.el-form-item__content .el-input-group{vertical-align:top}.el-form-item__error{color:var(--el-color-danger);font-size:12px;left:0;line-height:1;padding-top:2px;position:absolute;top:100%}.el-form-item__error--inline{display:inline-block;left:auto;margin-left:10px;position:relative;top:auto}.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label-wrap>.el-form-item__label:before,.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label:before{color:var(--el-color-danger);content:"*";margin-right:4px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label-wrap>.el-form-item__label:after,.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label:after{color:var(--el-color-danger);content:"*";margin-left:4px}.el-form-item.is-error .el-form-item__content .el-input-tag__wrapper,.el-form-item.is-error .el-form-item__content .el-input-tag__wrapper.is-focus,.el-form-item.is-error .el-form-item__content .el-input-tag__wrapper:focus,.el-form-item.is-error .el-form-item__content .el-input-tag__wrapper:hover,.el-form-item.is-error .el-form-item__content .el-input__wrapper,.el-form-item.is-error .el-form-item__content .el-input__wrapper.is-focus,.el-form-item.is-error .el-form-item__content .el-input__wrapper:focus,.el-form-item.is-error .el-form-item__content .el-input__wrapper:hover,.el-form-item.is-error .el-form-item__content .el-select__wrapper,.el-form-item.is-error .el-form-item__content .el-select__wrapper.is-focus,.el-form-item.is-error .el-form-item__content .el-select__wrapper:focus,.el-form-item.is-error .el-form-item__content .el-select__wrapper:hover,.el-form-item.is-error .el-form-item__content .el-textarea__inner,.el-form-item.is-error .el-form-item__content .el-textarea__inner.is-focus,.el-form-item.is-error .el-form-item__content .el-textarea__inner:focus,.el-form-item.is-error .el-form-item__content .el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-form-item__content .el-input-group__append .el-input__wrapper,.el-form-item.is-error .el-form-item__content .el-input-group__prepend .el-input__wrapper{box-shadow:inset 0 0 0 1px transparent}.el-form-item.is-error .el-form-item__content .el-input-group__append .el-input__validateIcon,.el-form-item.is-error .el-form-item__content .el-input-group__prepend .el-input__validateIcon{display:none}.el-form-item.is-error .el-form-item__content .el-input__validateIcon{color:var(--el-color-danger)}.el-form-item--feedback .el-input__validateIcon{display:inline-flex}.el-header{--el-header-padding:0 20px;--el-header-height:60px;box-sizing:border-box;flex-shrink:0;height:var(--el-header-height);padding:var(--el-header-padding)}.el-image-viewer__wrapper{bottom:0;left:0;position:fixed;right:0;top:0}.el-image-viewer__wrapper:focus{outline:none!important}.el-image-viewer__btn{align-items:center;border-radius:50%;box-sizing:border-box;cursor:pointer;display:flex;justify-content:center;opacity:.8;position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none;z-index:1}.el-image-viewer__btn .el-icon{cursor:pointer}.el-image-viewer__close{font-size:40px;height:40px;right:40px;top:40px;width:40px}.el-image-viewer__canvas{align-items:center;display:flex;height:100%;justify-content:center;position:static;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:100%}.el-image-viewer__actions{background-color:var(--el-text-color-regular);border-color:#fff;border-radius:22px;bottom:30px;height:44px;left:50%;padding:0 23px;transform:translateX(-50%)}.el-image-viewer__actions__inner{align-items:center;color:#fff;cursor:default;display:flex;font-size:23px;gap:22px;height:100%;justify-content:space-around;padding:0 6px;width:100%}.el-image-viewer__actions__divider{margin:0 -6px}.el-image-viewer__progress{bottom:90px;color:#fff;cursor:default;left:50%;transform:translateX(-50%)}.el-image-viewer__prev{left:40px}.el-image-viewer__next,.el-image-viewer__prev{background-color:var(--el-text-color-regular);border-color:#fff;color:#fff;font-size:24px;height:44px;top:50%;transform:translateY(-50%);width:44px}.el-image-viewer__next{right:40px;text-indent:2px}.el-image-viewer__close{background-color:var(--el-text-color-regular);border-color:#fff;color:#fff;font-size:24px;height:44px;width:44px}.el-image-viewer__mask{background:#000;height:100%;left:0;opacity:.5;position:absolute;top:0;width:100%}.viewer-fade-enter-active{animation:viewer-fade-in var(--el-transition-duration)}.viewer-fade-leave-active{animation:viewer-fade-out var(--el-transition-duration)}@keyframes viewer-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}@keyframes viewer-fade-out{0%{opacity:1;transform:translateZ(0)}to{opacity:0;transform:translate3d(0,-20px,0)}}.el-image__error,.el-image__inner,.el-image__placeholder,.el-image__wrapper{height:100%;width:100%}.el-image{display:inline-block;overflow:hidden;position:relative}.el-image__inner{opacity:1;vertical-align:top}.el-image__inner.is-loading{opacity:0}.el-image__wrapper{left:0;position:absolute;top:0}.el-image__error,.el-image__placeholder{background:var(--el-fill-color-light)}.el-image__error{align-items:center;color:var(--el-text-color-placeholder);display:flex;font-size:14px;justify-content:center;vertical-align:middle}.el-image__preview{cursor:pointer}.el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;display:inline-block;font-size:var(--el-font-size-base);position:relative;vertical-align:bottom;width:100%}.el-textarea__inner{-webkit-appearance:none;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;box-sizing:border-box;color:var(--el-input-text-color,var(--el-text-color-regular));display:block;font-family:inherit;font-size:inherit;line-height:1.5;padding:5px 11px;position:relative;resize:vertical;transition:var(--el-transition-box-shadow);width:100%}.el-textarea__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset;outline:none}.el-textarea .el-input__count{background:var(--el-fill-color-blank);bottom:5px;color:var(--el-color-info);font-size:12px;line-height:14px;position:absolute;right:10px}.el-textarea.is-disabled .el-textarea__inner{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset;color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;--el-input-height:var(--el-component-size);box-sizing:border-box;display:inline-flex;font-size:var(--el-font-size-base);line-height:var(--el-input-height);position:relative;vertical-align:middle;width:var(--el-input-width)}.el-input::-webkit-scrollbar{width:6px;z-index:11}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{background:var(--el-text-color-disabled);border-radius:5px;width:6px}.el-input::-webkit-scrollbar-corner,.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);cursor:pointer;font-size:14px}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{align-items:center;color:var(--el-color-info);display:inline-flex;font-size:12px;height:100%}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);display:inline-block;line-height:normal;padding-left:8px}.el-input__wrapper{align-items:center;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;cursor:text;display:inline-flex;flex-grow:1;justify-content:center;padding:1px 11px;transform:translateZ(0);transition:var(--el-transition-box-shadow)}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px)}.el-input__inner{-webkit-appearance:none;background:none;border:none;box-sizing:border-box;color:var(--el-input-text-color,var(--el-text-color-regular));flex-grow:1;font-size:inherit;height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);outline:none;padding:0;width:100%}.el-input__inner:focus{outline:none}.el-input__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__inner[type=number]{line-height:1}.el-input__prefix{color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:inline-flex;flex-shrink:0;flex-wrap:nowrap;height:100%;line-height:var(--el-input-inner-height);pointer-events:none;text-align:center;transition:all var(--el-transition-duration);white-space:nowrap}.el-input__prefix-inner{align-items:center;display:inline-flex;justify-content:center;pointer-events:all}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:inline-flex;flex-shrink:0;flex-wrap:nowrap;height:100%;line-height:var(--el-input-inner-height);pointer-events:none;text-align:center;transition:all var(--el-transition-duration);white-space:nowrap}.el-input__suffix-inner{align-items:center;display:inline-flex;justify-content:center;pointer-events:all}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{align-items:center;display:flex;height:inherit;justify-content:center;line-height:inherit;margin-left:8px;transition:all var(--el-transition-duration)}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color, ) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset;cursor:not-allowed}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);-webkit-text-fill-color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-disabled .el-input__prefix-inner,.el-input.is-disabled .el-input__suffix-inner{pointer-events:none}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{align-items:stretch;display:inline-flex;width:100%}.el-input-group__append,.el-input-group__prepend{align-items:center;background-color:var(--el-fill-color-light);border-radius:var(--el-input-border-radius);color:var(--el-color-info);display:inline-flex;justify-content:center;min-height:100%;padding:0 20px;position:relative;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:none}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;flex:1;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-select__wrapper,.el-input-group__append div.el-select:hover .el-select__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-select__wrapper,.el-input-group__prepend div.el-select:hover .el-select__wrapper{background-color:transparent;border-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-bottom-right-radius:0;border-right:0;border-top-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-left:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper,.el-input-group__append{border-bottom-left-radius:0;border-top-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-select__wrapper{border-bottom-right-radius:0;border-top-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--append>.el-input__wrapper{border-bottom-right-radius:0;border-top-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-select__wrapper{border-bottom-left-radius:0;border-top-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-hidden{display:none!important}.el-input-number{display:inline-flex;line-height:30px;position:relative;vertical-align:middle;width:150px}.el-input-number .el-input__wrapper{padding-left:42px;padding-right:42px}.el-input-number .el-input__inner{-webkit-appearance:none;-moz-appearance:textfield;line-height:1;text-align:center}.el-input-number .el-input__inner::-webkit-inner-spin-button,.el-input-number .el-input__inner::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.el-input-number.is-left .el-input__inner{text-align:left}.el-input-number.is-right .el-input__inner{text-align:right}.el-input-number.is-center .el-input__inner{text-align:center}.el-input-number__decrease,.el-input-number__increase{align-items:center;background:var(--el-fill-color-light);bottom:1px;color:var(--el-text-color-regular);cursor:pointer;display:flex;font-size:13px;height:auto;justify-content:center;position:absolute;top:1px;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:32px;z-index:1}.el-input-number__decrease:hover,.el-input-number__increase:hover{color:var(--el-color-primary)}.el-input-number__decrease:hover~.el-input:not(.is-disabled) .el-input__wrapper,.el-input-number__increase:hover~.el-input:not(.is-disabled) .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-border-color,var(--el-color-primary)) inset}.el-input-number__decrease.is-disabled,.el-input-number__increase.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-input-number__increase{border-left:var(--el-border);border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0;right:1px}.el-input-number__decrease{border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);border-right:var(--el-border);left:1px}.el-input-number.is-disabled .el-input-number__decrease,.el-input-number.is-disabled .el-input-number__increase{border-color:var(--el-disabled-border-color);color:var(--el-disabled-border-color)}.el-input-number.is-disabled .el-input-number__decrease:hover,.el-input-number.is-disabled .el-input-number__increase:hover{color:var(--el-disabled-border-color);cursor:not-allowed}.el-input-number--large{line-height:38px;width:180px}.el-input-number--large .el-input-number__decrease,.el-input-number--large .el-input-number__increase{font-size:14px;width:40px}.el-input-number--large.is-controls-right .el-input--large .el-input__wrapper{padding-right:47px}.el-input-number--large .el-input--large .el-input__wrapper{padding-left:47px;padding-right:47px}.el-input-number--small{line-height:22px;width:120px}.el-input-number--small .el-input-number__decrease,.el-input-number--small .el-input-number__increase{font-size:12px;width:24px}.el-input-number--small.is-controls-right .el-input--small .el-input__wrapper{padding-right:31px}.el-input-number--small .el-input--small .el-input__wrapper{padding-left:31px;padding-right:31px}.el-input-number--small .el-input-number__decrease [class*=el-icon],.el-input-number--small .el-input-number__increase [class*=el-icon]{transform:scale(.9)}.el-input-number.is-without-controls .el-input__wrapper{padding-left:15px;padding-right:15px}.el-input-number.is-controls-right .el-input__wrapper{padding-left:15px;padding-right:42px}.el-input-number.is-controls-right .el-input-number__decrease,.el-input-number.is-controls-right .el-input-number__increase{--el-input-number-controls-height:15px;height:var(--el-input-number-controls-height);line-height:var(--el-input-number-controls-height)}.el-input-number.is-controls-right .el-input-number__decrease [class*=el-icon],.el-input-number.is-controls-right .el-input-number__increase [class*=el-icon]{transform:scale(.8)}.el-input-number.is-controls-right .el-input-number__increase{border-bottom:var(--el-border);border-radius:0 var(--el-border-radius-base) 0 0;bottom:auto;left:auto}.el-input-number.is-controls-right .el-input-number__decrease{border-left:var(--el-border);border-radius:0 0 var(--el-border-radius-base) 0;border-right:none;left:auto;right:1px;top:auto}.el-input-number.is-controls-right[class*=large] [class*=decrease],.el-input-number.is-controls-right[class*=large] [class*=increase]{--el-input-number-controls-height:19px}.el-input-number.is-controls-right[class*=small] [class*=decrease],.el-input-number.is-controls-right[class*=small] [class*=increase]{--el-input-number-controls-height:11px}.el-input-tag{--el-input-tag-border-color-hover:var(--el-border-color-hover);--el-input-tag-placeholder-color:var(--el-text-color-placeholder);--el-input-tag-disabled-color:var(--el-disabled-text-color);--el-input-tag-disabled-border:var(--el-disabled-border-color);--el-input-tag-font-size:var(--el-font-size-base);--el-input-tag-close-hover-color:var(--el-text-color-secondary);--el-input-tag-text-color:var(--el-text-color-regular);--el-input-tag-input-focus-border-color:var(--el-color-primary);--el-input-tag-width:100%;--el-input-tag-mini-height:var(--el-component-size);--el-input-tag-gap:6px;--el-input-tag-padding:4px;--el-input-tag-inner-padding:8px;--el-input-tag-line-height:24px;align-items:center;background-color:var(--el-fill-color-blank);border-radius:var(--el-border-radius-base);box-shadow:0 0 0 1px var(--el-border-color) inset;box-sizing:border-box;cursor:pointer;display:flex;font-size:var(--el-input-tag-font-size);line-height:var(--el-input-tag-line-height);min-height:var(--el-input-tag-mini-height);padding:var(--el-input-tag-padding);transform:translateZ(0);transition:var(--el-transition-duration);width:var(--el-input-tag-width)}.el-input-tag.is-focused{box-shadow:0 0 0 1px var(--el-color-primary) inset}.el-input-tag.is-hovering:not(.is-focused){box-shadow:0 0 0 1px var(--el-border-color-hover) inset}.el-input-tag.is-disabled{background-color:var(--el-fill-color-light);cursor:not-allowed}.el-input-tag.is-disabled,.el-input-tag.is-disabled:hover{box-shadow:0 0 0 1px var(--el-input-tag-disabled-border) inset}.el-input-tag.is-disabled.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input-tag.is-disabled .el-input-tag__inner .el-input-tag__input,.el-input-tag.is-disabled .el-input-tag__inner .el-tag{cursor:not-allowed}.el-input-tag__prefix,.el-input-tag__suffix{align-items:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:flex;flex-shrink:0;padding:0 var(--el-input-tag-inner-padding)}.el-input-tag__suffix{gap:8px}.el-input-tag__inner{align-items:center;display:flex;flex:1;flex-wrap:wrap;gap:var(--el-input-tag-gap);max-width:100%;min-width:0;position:relative}.el-input-tag__inner.is-left-space{margin-left:var(--el-input-tag-inner-padding)}.el-input-tag__inner.is-right-space{margin-right:var(--el-input-tag-inner-padding)}.el-input-tag__inner.is-draggable .el-tag{cursor:move;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-input-tag__drop-indicator{background-color:var(--el-color-primary);height:var(--el-input-tag-line-height);position:absolute;top:0;width:1px}.el-input-tag__inner .el-tag{border-color:transparent;cursor:pointer;max-width:100%}.el-input-tag__inner .el-tag.el-tag--plain{border-color:var(--el-tag-border-color)}.el-input-tag__inner .el-tag .el-tag__content{line-height:normal;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-input-tag__input-wrapper{flex:1}.el-input-tag__input{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:none;color:var(--el-input-tag-text-color);font-family:inherit;font-size:inherit;line-height:inherit;outline:none;padding:0;width:100%}.el-input-tag__input::-moz-placeholder{color:var(--el-input-tag-placeholder-color)}.el-input-tag__input::placeholder{color:var(--el-input-tag-placeholder-color)}.el-input-tag__input-calculator{left:0;max-width:100%;overflow:hidden;position:absolute;top:0;visibility:hidden;white-space:pre}.el-input-tag--large{--el-input-tag-gap:6px;--el-input-tag-padding:8px;--el-input-tag-padding-left:8px;--el-input-tag-font-size:14px}.el-input-tag--small{--el-input-tag-gap:4px;--el-input-tag-padding:2px;--el-input-tag-padding-left:6px;--el-input-tag-font-size:12px;--el-input-tag-line-height:20px;--el-input-tag-mini-height:var(--el-component-size-small)}.el-link{--el-link-font-size:var(--el-font-size-base);--el-link-font-weight:var(--el-font-weight-primary);--el-link-text-color:var(--el-text-color-regular);--el-link-hover-text-color:var(--el-color-primary);--el-link-disabled-text-color:var(--el-text-color-placeholder);align-items:center;color:var(--el-link-text-color);cursor:pointer;display:inline-flex;flex-direction:row;font-size:var(--el-link-font-size);font-weight:var(--el-link-font-weight);justify-content:center;outline:none;padding:0;position:relative;text-decoration:none;vertical-align:middle}.el-link.is-hover-underline:hover:after{border-bottom:1px solid var(--el-link-hover-text-color);bottom:0;content:"";height:0;left:0;position:absolute;right:0}.el-link.is-underline:after{border-bottom:1px solid var(--el-link-text-color);bottom:0;content:"";height:0;left:0;position:absolute;right:0}.el-link:hover{color:var(--el-link-hover-text-color)}.el-link:hover:after{border-color:var(--el-link-hover-text-color)}.el-link [class*=el-icon-]+span{margin-left:5px}.el-link__inner{align-items:center;display:inline-flex;justify-content:center}.el-link.el-link--primary{--el-link-text-color:var(--el-color-primary);--el-link-hover-text-color:var(--el-color-primary-light-3);--el-link-disabled-text-color:var(--el-color-primary-light-5)}.el-link.el-link--success{--el-link-text-color:var(--el-color-success);--el-link-hover-text-color:var(--el-color-success-light-3);--el-link-disabled-text-color:var(--el-color-success-light-5)}.el-link.el-link--warning{--el-link-text-color:var(--el-color-warning);--el-link-hover-text-color:var(--el-color-warning-light-3);--el-link-disabled-text-color:var(--el-color-warning-light-5)}.el-link.el-link--danger{--el-link-text-color:var(--el-color-danger);--el-link-hover-text-color:var(--el-color-danger-light-3);--el-link-disabled-text-color:var(--el-color-danger-light-5)}.el-link.el-link--error{--el-link-text-color:var(--el-color-error);--el-link-hover-text-color:var(--el-color-error-light-3);--el-link-disabled-text-color:var(--el-color-error-light-5)}.el-link.el-link--info{--el-link-text-color:var(--el-color-info);--el-link-hover-text-color:var(--el-color-info-light-3);--el-link-disabled-text-color:var(--el-color-info-light-5)}.el-link.is-disabled{color:var(--el-link-disabled-text-color);cursor:not-allowed}.el-link.is-disabled:after{border-color:var(--el-link-disabled-text-color)}:root{--el-loading-spinner-size:42px;--el-loading-fullscreen-spinner-size:50px}.el-loading-parent--relative{position:relative!important}.el-loading-parent--hidden{overflow:hidden!important}.el-loading-mask{background-color:var(--el-mask-color);bottom:0;left:0;margin:0;position:absolute;right:0;top:0;transition:opacity var(--el-transition-duration);z-index:2000}.el-loading-mask.is-fullscreen{position:fixed}.el-loading-mask.is-fullscreen .el-loading-spinner{margin-top:calc((0px - var(--el-loading-fullscreen-spinner-size))/2)}.el-loading-mask.is-fullscreen .el-loading-spinner .circular{height:var(--el-loading-fullscreen-spinner-size);width:var(--el-loading-fullscreen-spinner-size)}.el-loading-spinner{margin-top:calc((0px - var(--el-loading-spinner-size))/2);position:absolute;text-align:center;top:50%;width:100%}.el-loading-spinner .el-loading-text{color:var(--el-color-primary);font-size:14px;margin:3px 0}.el-loading-spinner .circular{animation:loading-rotate 2s linear infinite;display:inline;height:var(--el-loading-spinner-size);width:var(--el-loading-spinner-size)}.el-loading-spinner .path{animation:loading-dash 1.5s ease-in-out infinite;stroke-dasharray:90,150;stroke-dashoffset:0;stroke-width:2;stroke:var(--el-color-primary);stroke-linecap:round}.el-loading-spinner i{color:var(--el-color-primary)}.el-loading-fade-enter-from,.el-loading-fade-leave-to{opacity:0}@keyframes loading-rotate{to{transform:rotate(1turn)}}@keyframes loading-dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-40px}to{stroke-dasharray:90,150;stroke-dashoffset:-120px}}.el-main{--el-main-padding:20px;box-sizing:border-box;display:block;flex:1;flex-basis:auto;overflow:auto;padding:var(--el-main-padding)}:root{--el-menu-active-color:var(--el-color-primary);--el-menu-text-color:var(--el-text-color-primary);--el-menu-hover-text-color:var(--el-color-primary);--el-menu-bg-color:var(--el-fill-color-blank);--el-menu-hover-bg-color:var(--el-color-primary-light-9);--el-menu-item-height:56px;--el-menu-sub-item-height:calc(var(--el-menu-item-height) - 6px);--el-menu-horizontal-height:60px;--el-menu-horizontal-sub-item-height:36px;--el-menu-item-font-size:var(--el-font-size-base);--el-menu-item-hover-fill:var(--el-color-primary-light-9);--el-menu-border-color:var(--el-border-color);--el-menu-base-level-padding:20px;--el-menu-level-padding:20px;--el-menu-icon-width:24px}.el-menu{background-color:var(--el-menu-bg-color);border-right:1px solid var(--el-menu-border-color);box-sizing:border-box;list-style:none;margin:0;padding-left:0;position:relative}.el-menu--vertical:not(.el-menu--collapse):not(.el-menu--popup-container) .el-menu-item,.el-menu--vertical:not(.el-menu--collapse):not(.el-menu--popup-container) .el-menu-item-group__title,.el-menu--vertical:not(.el-menu--collapse):not(.el-menu--popup-container) .el-sub-menu__title{padding-left:calc(var(--el-menu-base-level-padding) + var(--el-menu-level)*var(--el-menu-level-padding));white-space:nowrap}.el-menu:not(.el-menu--collapse) .el-sub-menu__title{padding-right:calc(var(--el-menu-base-level-padding) + var(--el-menu-icon-width))}.el-menu--horizontal{border-right:none;display:flex;flex-wrap:nowrap;height:var(--el-menu-horizontal-height)}.el-menu--horizontal.el-menu--popup-container{height:unset}.el-menu--horizontal.el-menu{border-bottom:1px solid var(--el-menu-border-color)}.el-menu--horizontal>.el-menu-item{align-items:center;border-bottom:2px solid transparent;color:var(--el-menu-text-color);display:inline-flex;height:100%;justify-content:center;margin:0}.el-menu--horizontal>.el-menu-item a,.el-menu--horizontal>.el-menu-item a:hover{color:inherit}.el-menu--horizontal>.el-sub-menu:focus,.el-menu--horizontal>.el-sub-menu:hover{outline:none}.el-menu--horizontal>.el-sub-menu:hover .el-sub-menu__title{color:var(--el-menu-hover-text-color)}.el-menu--horizontal>.el-sub-menu.is-active .el-sub-menu__title{border-bottom:2px solid var(--el-menu-active-color);color:var(--el-menu-active-color)}.el-menu--horizontal>.el-sub-menu .el-sub-menu__title{border-bottom:2px solid transparent;color:var(--el-menu-text-color);height:100%}.el-menu--horizontal>.el-sub-menu .el-sub-menu__title:hover{background-color:var(--el-menu-bg-color)}.el-menu--horizontal .el-menu .el-menu-item,.el-menu--horizontal .el-menu .el-sub-menu__title{align-items:center;background-color:var(--el-menu-bg-color);color:var(--el-menu-text-color);display:flex;height:var(--el-menu-horizontal-sub-item-height);line-height:var(--el-menu-horizontal-sub-item-height);padding:0 10px}.el-menu--horizontal .el-menu .el-sub-menu__title{padding-right:40px}.el-menu--horizontal .el-menu .el-menu-item.is-active,.el-menu--horizontal .el-menu .el-menu-item.is-active:hover,.el-menu--horizontal .el-menu .el-sub-menu.is-active>.el-sub-menu__title,.el-menu--horizontal .el-menu .el-sub-menu.is-active>.el-sub-menu__title:hover{color:var(--el-menu-active-color)}.el-menu--horizontal .el-menu-item:not(.is-disabled):focus,.el-menu--horizontal .el-menu-item:not(.is-disabled):hover{background-color:var(--el-menu-hover-bg-color);color:var(--el-menu-active-color,var(--el-menu-hover-text-color));outline:none}.el-menu--horizontal>.el-menu-item.is-active{border-bottom:2px solid var(--el-menu-active-color);color:var(--el-menu-active-color)!important}.el-menu--collapse{width:calc(var(--el-menu-icon-width) + var(--el-menu-base-level-padding)*2)}.el-menu--collapse>.el-menu-item [class^=el-icon],.el-menu--collapse>.el-menu-item-group>ul>.el-sub-menu>.el-sub-menu__title [class^=el-icon],.el-menu--collapse>.el-sub-menu>.el-sub-menu__title [class^=el-icon]{margin:0;text-align:center;vertical-align:middle;width:var(--el-menu-icon-width)}.el-menu--collapse>.el-menu-item .el-sub-menu__icon-arrow,.el-menu--collapse>.el-menu-item-group>ul>.el-sub-menu>.el-sub-menu__title .el-sub-menu__icon-arrow,.el-menu--collapse>.el-sub-menu>.el-sub-menu__title .el-sub-menu__icon-arrow{display:none}.el-menu--collapse>.el-menu-item-group>ul>.el-sub-menu>.el-sub-menu__title>span,.el-menu--collapse>.el-menu-item>span,.el-menu--collapse>.el-sub-menu>.el-sub-menu__title>span{display:inline-block;height:0;overflow:hidden;visibility:hidden;width:0}.el-menu--collapse>.el-menu-item.is-active i{color:inherit}.el-menu--collapse .el-menu .el-sub-menu{min-width:200px}.el-menu--collapse .el-sub-menu.is-active .el-sub-menu__title{color:var(--el-menu-active-color)}.el-menu--popup{border:none;border-radius:var(--el-border-radius-small);box-shadow:var(--el-box-shadow-light);min-width:200px;padding:5px 0;z-index:100}.el-menu .el-icon{flex-shrink:0}.el-menu-item{align-items:center;box-sizing:border-box;color:var(--el-menu-text-color);cursor:pointer;display:flex;font-size:var(--el-menu-item-font-size);height:var(--el-menu-item-height);line-height:var(--el-menu-item-height);list-style:none;padding:0 var(--el-menu-base-level-padding);position:relative;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration),color var(--el-transition-duration);white-space:nowrap}.el-menu-item *{vertical-align:bottom}.el-menu-item i{color:inherit}.el-menu-item:focus,.el-menu-item:hover{outline:none}.el-menu-item:hover{background-color:var(--el-menu-hover-bg-color)}.el-menu-item.is-disabled{background:none!important;cursor:not-allowed;opacity:.25}.el-menu-item [class^=el-icon]{font-size:18px;margin-right:5px;text-align:center;vertical-align:middle;width:var(--el-menu-icon-width)}.el-menu-item.is-active{color:var(--el-menu-active-color)}.el-menu-item.is-active i{color:inherit}.el-menu-item .el-menu-tooltip__trigger{align-items:center;box-sizing:border-box;display:inline-flex;height:100%;left:0;padding:0 var(--el-menu-base-level-padding);position:absolute;top:0;width:100%}.el-sub-menu{list-style:none;margin:0;padding-left:0}.el-sub-menu__title{align-items:center;box-sizing:border-box;color:var(--el-menu-text-color);cursor:pointer;display:flex;font-size:var(--el-menu-item-font-size);height:var(--el-menu-item-height);line-height:var(--el-menu-item-height);list-style:none;padding:0 var(--el-menu-base-level-padding);position:relative;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration),color var(--el-transition-duration);white-space:nowrap}.el-sub-menu__title *{vertical-align:bottom}.el-sub-menu__title i{color:inherit}.el-sub-menu__title:focus,.el-sub-menu__title:hover{outline:none}.el-sub-menu__title.is-disabled{background:none!important;cursor:not-allowed;opacity:.25}.el-sub-menu__title:hover{background-color:var(--el-menu-hover-bg-color)}.el-sub-menu .el-menu{border:none}.el-sub-menu .el-menu-item{height:var(--el-menu-sub-item-height);line-height:var(--el-menu-sub-item-height)}.el-sub-menu.el-sub-menu__hide-arrow .el-sub-menu__title{padding-right:var(--el-menu-base-level-padding)}.el-sub-menu__hide-arrow .el-sub-menu__icon-arrow{display:none!important}.el-sub-menu.is-active .el-sub-menu__title{border-bottom-color:var(--el-menu-active-color)}.el-sub-menu.is-disabled .el-menu-item,.el-sub-menu.is-disabled .el-sub-menu__title{background:none!important;cursor:not-allowed;opacity:.25}.el-sub-menu .el-icon{font-size:18px;margin-right:5px;text-align:center;vertical-align:middle;width:var(--el-menu-icon-width)}.el-sub-menu .el-icon.el-sub-menu__icon-more{margin-right:0!important}.el-sub-menu .el-sub-menu__icon-arrow{font-size:12px;margin-right:0;margin-top:-6px;position:absolute;right:var(--el-menu-base-level-padding);top:50%;transition:transform var(--el-transition-duration);width:inherit}.el-menu-item-group>ul{padding:0}.el-menu-item-group__title{color:var(--el-text-color-secondary);font-size:12px;line-height:normal;padding:7px 0 7px var(--el-menu-base-level-padding)}.horizontal-collapse-transition .el-sub-menu__title .el-sub-menu__icon-arrow{opacity:0;transition:var(--el-transition-duration-fast)}.el-message-box{--el-messagebox-title-color:var(--el-text-color-primary);--el-messagebox-width:420px;--el-messagebox-border-radius:4px;--el-messagebox-box-shadow:var(--el-box-shadow);--el-messagebox-font-size:var(--el-font-size-large);--el-messagebox-content-font-size:var(--el-font-size-base);--el-messagebox-content-color:var(--el-text-color-regular);--el-messagebox-error-font-size:12px;--el-messagebox-padding-primary:12px;--el-messagebox-font-line-height:var(--el-font-line-height-primary);backface-visibility:hidden;background-color:var(--el-bg-color);border-radius:var(--el-messagebox-border-radius);box-shadow:var(--el-messagebox-box-shadow);box-sizing:border-box;display:inline-block;font-size:var(--el-messagebox-font-size);max-width:var(--el-messagebox-width);overflow:hidden;overflow-wrap:break-word;padding:var(--el-messagebox-padding-primary);position:relative;text-align:left;vertical-align:middle;width:100%}.el-message-box:focus{outline:none!important}.el-overlay.is-message-box .el-overlay-message-box{bottom:0;left:0;overflow:auto;padding:16px;position:fixed;right:0;text-align:center;top:0}.el-overlay.is-message-box .el-overlay-message-box:after{content:"";display:inline-block;height:100%;vertical-align:middle;width:0}.el-message-box.is-draggable .el-message-box__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-message-box__header{padding-bottom:var(--el-messagebox-padding-primary)}.el-message-box__header.show-close{padding-right:calc(var(--el-messagebox-padding-primary) + var(--el-message-close-size, 16px))}.el-message-box__title{color:var(--el-messagebox-title-color);font-size:var(--el-messagebox-font-size);line-height:var(--el-messagebox-font-line-height)}.el-message-box__headerbtn{background:transparent;border:none;cursor:pointer;font-size:var(--el-message-close-size,16px);height:40px;outline:none;padding:0;position:absolute;right:0;top:0;width:40px}.el-message-box__headerbtn .el-message-box__close{color:var(--el-color-info);font-size:inherit}.el-message-box__headerbtn:focus .el-message-box__close,.el-message-box__headerbtn:hover .el-message-box__close{color:var(--el-color-primary)}.el-message-box__content{color:var(--el-messagebox-content-color);font-size:var(--el-messagebox-content-font-size)}.el-message-box__container{align-items:center;display:flex;gap:12px}.el-message-box__input{padding-top:12px}.el-message-box__input div.invalid>input,.el-message-box__input div.invalid>input:focus{border-color:var(--el-color-error)}.el-message-box__status{font-size:24px}.el-message-box__status.el-message-box-icon--primary{--el-messagebox-color:var(--el-color-primary);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--success{--el-messagebox-color:var(--el-color-success);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--info{--el-messagebox-color:var(--el-color-info);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--warning{--el-messagebox-color:var(--el-color-warning);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--error{--el-messagebox-color:var(--el-color-error);color:var(--el-messagebox-color)}.el-message-box__message{margin:0;min-width:0}.el-message-box__message p{line-height:var(--el-messagebox-font-line-height);margin:0}.el-message-box__errormsg{color:var(--el-color-error);font-size:var(--el-messagebox-error-font-size);line-height:var(--el-messagebox-font-line-height)}.el-message-box__btns{align-items:center;display:flex;flex-wrap:wrap;justify-content:flex-end;padding-top:var(--el-messagebox-padding-primary)}.el-message-box--center .el-message-box__title{align-items:center;display:flex;gap:6px;justify-content:center}.el-message-box--center .el-message-box__status{font-size:inherit}.el-message-box--center .el-message-box__btns,.el-message-box--center .el-message-box__container{justify-content:center}.fade-in-linear-enter-active .el-overlay-message-box{animation:msgbox-fade-in var(--el-transition-duration)}.fade-in-linear-leave-active .el-overlay-message-box{animation:msgbox-fade-in var(--el-transition-duration) reverse}@keyframes msgbox-fade-in{0%{opacity:0;transform:translate3d(0,-20px,0)}to{opacity:1;transform:translateZ(0)}}.el-message{--el-message-bg-color:var(--el-color-info-light-9);--el-message-border-color:var(--el-border-color-lighter);--el-message-padding:11px 15px;--el-message-close-size:16px;--el-message-close-icon-color:var(--el-text-color-placeholder);--el-message-close-hover-color:var(--el-text-color-secondary);align-items:center;background-color:var(--el-message-bg-color);border-color:var(--el-message-border-color);border-radius:var(--el-border-radius-base);border-style:var(--el-border-style);border-width:var(--el-border-width);box-sizing:border-box;display:flex;gap:8px;left:50%;max-width:calc(100% - 32px);padding:var(--el-message-padding);position:fixed;top:20px;transform:translateX(-50%);transition:opacity var(--el-transition-duration),transform .4s,top .4s;width:-moz-fit-content;width:fit-content}.el-message.is-plain{background-color:var(--el-bg-color-overlay);border-color:var(--el-bg-color-overlay);box-shadow:var(--el-box-shadow-light)}.el-message p{margin:0}.el-message--primary{--el-message-bg-color:var(--el-color-primary-light-9);--el-message-border-color:var(--el-color-primary-light-8);--el-message-text-color:var(--el-color-primary)}.el-message--primary .el-message__content{color:var(--el-message-text-color);overflow-wrap:break-word}.el-message .el-message-icon--primary{color:var(--el-message-text-color)}.el-message--success{--el-message-bg-color:var(--el-color-success-light-9);--el-message-border-color:var(--el-color-success-light-8);--el-message-text-color:var(--el-color-success)}.el-message--success .el-message__content{color:var(--el-message-text-color);overflow-wrap:break-word}.el-message .el-message-icon--success{color:var(--el-message-text-color)}.el-message--info{--el-message-bg-color:var(--el-color-info-light-9);--el-message-border-color:var(--el-color-info-light-8);--el-message-text-color:var(--el-color-info)}.el-message--info .el-message__content{color:var(--el-message-text-color);overflow-wrap:break-word}.el-message .el-message-icon--info{color:var(--el-message-text-color)}.el-message--warning{--el-message-bg-color:var(--el-color-warning-light-9);--el-message-border-color:var(--el-color-warning-light-8);--el-message-text-color:var(--el-color-warning)}.el-message--warning .el-message__content{color:var(--el-message-text-color);overflow-wrap:break-word}.el-message .el-message-icon--warning{color:var(--el-message-text-color)}.el-message--error{--el-message-bg-color:var(--el-color-error-light-9);--el-message-border-color:var(--el-color-error-light-8);--el-message-text-color:var(--el-color-error)}.el-message--error .el-message__content{color:var(--el-message-text-color);overflow-wrap:break-word}.el-message .el-message-icon--error{color:var(--el-message-text-color)}.el-message .el-message__badge{position:absolute;right:-8px;top:-8px}.el-message__content{font-size:14px;line-height:1;padding:0}.el-message__content:focus{outline-width:0}.el-message .el-message__closeBtn{color:var(--el-message-close-icon-color);cursor:pointer;font-size:var(--el-message-close-size)}.el-message .el-message__closeBtn:focus{outline-width:0}.el-message .el-message__closeBtn:hover{color:var(--el-message-close-hover-color)}.el-message-fade-enter-from,.el-message-fade-leave-to{opacity:0;transform:translate(-50%,-100%)}.el-notification{--el-notification-width:330px;--el-notification-padding:14px 26px 14px 13px;--el-notification-radius:8px;--el-notification-shadow:var(--el-box-shadow-light);--el-notification-border-color:var(--el-border-color-lighter);--el-notification-icon-size:24px;--el-notification-close-font-size:var(--el-message-close-size,16px);--el-notification-group-margin-left:13px;--el-notification-group-margin-right:8px;--el-notification-content-font-size:var(--el-font-size-base);--el-notification-content-color:var(--el-text-color-regular);--el-notification-title-font-size:16px;--el-notification-title-color:var(--el-text-color-primary);--el-notification-close-color:var(--el-text-color-secondary);--el-notification-close-hover-color:var(--el-text-color-regular);background-color:var(--el-bg-color-overlay);border:1px solid var(--el-notification-border-color);border-radius:var(--el-notification-radius);box-shadow:var(--el-notification-shadow);box-sizing:border-box;display:flex;overflow:hidden;overflow-wrap:break-word;padding:var(--el-notification-padding);position:fixed;transition:opacity var(--el-transition-duration),transform var(--el-transition-duration),left var(--el-transition-duration),right var(--el-transition-duration),top .4s,bottom var(--el-transition-duration);width:var(--el-notification-width);z-index:9999}.el-notification.right{right:16px}.el-notification.left{left:16px}.el-notification__group{flex:1;margin-left:var(--el-notification-group-margin-left);margin-right:var(--el-notification-group-margin-right);min-width:0}.el-notification__title{color:var(--el-notification-title-color);font-size:var(--el-notification-title-font-size);font-weight:bold;line-height:var(--el-notification-icon-size);margin:0}.el-notification__content{color:var(--el-notification-content-color);font-size:var(--el-notification-content-font-size);line-height:24px;margin:6px 0 0}.el-notification__content p{margin:0}.el-notification .el-notification__icon{flex-shrink:0;font-size:var(--el-notification-icon-size);height:var(--el-notification-icon-size);width:var(--el-notification-icon-size)}.el-notification .el-notification__closeBtn{color:var(--el-notification-close-color);cursor:pointer;font-size:var(--el-notification-close-font-size);position:absolute;right:15px;top:18px}.el-notification .el-notification__closeBtn:hover{color:var(--el-notification-close-hover-color)}.el-notification .el-notification--primary{--el-notification-icon-color:var(--el-color-primary);color:var(--el-notification-icon-color)}.el-notification .el-notification--success{--el-notification-icon-color:var(--el-color-success);color:var(--el-notification-icon-color)}.el-notification .el-notification--info{--el-notification-icon-color:var(--el-color-info);color:var(--el-notification-icon-color)}.el-notification .el-notification--warning{--el-notification-icon-color:var(--el-color-warning);color:var(--el-notification-icon-color)}.el-notification .el-notification--error{--el-notification-icon-color:var(--el-color-error);color:var(--el-notification-icon-color)}.el-notification-fade-enter-from.right{right:0;transform:translateX(100%)}.el-notification-fade-enter-from.left{left:0;transform:translateX(-100%)}.el-notification-fade-leave-to{opacity:0}.el-overlay{background-color:var(--el-overlay-color-lighter);bottom:0;height:100%;left:0;overflow:auto;position:fixed;right:0;top:0;z-index:2000}.el-overlay .el-overlay-root{height:0}.el-page-header.is-contentful .el-page-header__main{border-top:1px solid var(--el-border-color-light);margin-top:16px}.el-page-header__header{align-items:center;display:flex;justify-content:space-between;line-height:24px}.el-page-header__left{align-items:center;display:flex;margin-right:40px;position:relative}.el-page-header__back{align-items:center;cursor:pointer;display:flex}.el-page-header__left .el-divider--vertical{margin:0 16px}.el-page-header__icon{align-items:center;display:flex;font-size:16px;margin-right:10px}.el-page-header__icon .el-icon{font-size:inherit}.el-page-header__title{font-size:14px;font-weight:500}.el-page-header__content{color:var(--el-text-color-primary);font-size:18px}.el-page-header__breadcrumb{margin-bottom:16px}.el-pagination{--el-pagination-font-size:14px;--el-pagination-bg-color:var(--el-fill-color-blank);--el-pagination-text-color:var(--el-text-color-primary);--el-pagination-border-radius:2px;--el-pagination-button-color:var(--el-text-color-primary);--el-pagination-button-width:32px;--el-pagination-button-height:32px;--el-pagination-button-disabled-color:var(--el-text-color-placeholder);--el-pagination-button-disabled-bg-color:var(--el-fill-color-blank);--el-pagination-button-bg-color:var(--el-fill-color);--el-pagination-hover-color:var(--el-color-primary);--el-pagination-font-size-small:12px;--el-pagination-button-width-small:24px;--el-pagination-button-height-small:24px;--el-pagination-button-width-large:40px;--el-pagination-button-height-large:40px;--el-pagination-item-gap:16px;align-items:center;color:var(--el-pagination-text-color);display:flex;font-size:var(--el-pagination-font-size);font-weight:normal;white-space:nowrap}.el-pagination .el-input__inner{-moz-appearance:textfield;text-align:center}.el-pagination .el-select{width:128px}.el-pagination button{align-items:center;background:var(--el-pagination-bg-color);border:none;border-radius:var(--el-pagination-border-radius);box-sizing:border-box;color:var(--el-pagination-button-color);cursor:pointer;display:flex;font-size:var(--el-pagination-font-size);height:var(--el-pagination-button-height);justify-content:center;line-height:var(--el-pagination-button-height);min-width:var(--el-pagination-button-width);padding:0 4px;text-align:center}.el-pagination button *{pointer-events:none}.el-pagination button:focus{outline:none}.el-pagination button.is-active,.el-pagination button:hover{color:var(--el-pagination-hover-color)}.el-pagination button.is-active{cursor:default;font-weight:bold}.el-pagination button.is-active.is-disabled{color:var(--el-text-color-secondary);font-weight:bold}.el-pagination button.is-disabled,.el-pagination button:disabled{background-color:var(--el-pagination-button-disabled-bg-color);color:var(--el-pagination-button-disabled-color);cursor:not-allowed}.el-pagination button:focus-visible{outline:1px solid var(--el-pagination-hover-color);outline-offset:-1px}.el-pagination .btn-next .el-icon,.el-pagination .btn-prev .el-icon{display:block;font-size:12px;font-weight:bold;width:inherit}.el-pagination>.is-first{margin-left:0!important}.el-pagination>.is-last{margin-right:0!important}.el-pagination .btn-prev{margin-left:var(--el-pagination-item-gap)}.el-pagination__sizes,.el-pagination__total{color:var(--el-text-color-regular);font-weight:normal;margin-left:var(--el-pagination-item-gap)}.el-pagination__total[disabled=true]{color:var(--el-text-color-placeholder)}.el-pagination__jump{align-items:center;color:var(--el-text-color-regular);display:flex;font-weight:normal;margin-left:var(--el-pagination-item-gap)}.el-pagination__jump[disabled=true]{color:var(--el-text-color-placeholder)}.el-pagination__goto{margin-right:8px}.el-pagination__editor{box-sizing:border-box;text-align:center}.el-pagination__editor.el-input{width:56px}.el-pagination__editor .el-input__inner::-webkit-inner-spin-button,.el-pagination__editor .el-input__inner::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.el-pagination__classifier{margin-left:8px}.el-pagination__rightwrapper{align-items:center;display:flex;flex:1;justify-content:flex-end}.el-pagination.is-background .btn-next,.el-pagination.is-background .btn-prev,.el-pagination.is-background .el-pager li{background-color:var(--el-pagination-button-bg-color);margin:0 4px}.el-pagination.is-background .btn-next.is-active,.el-pagination.is-background .btn-prev.is-active,.el-pagination.is-background .el-pager li.is-active{background-color:var(--el-color-primary);color:var(--el-color-white)}.el-pagination.is-background .btn-next.is-disabled,.el-pagination.is-background .btn-next:disabled,.el-pagination.is-background .btn-prev.is-disabled,.el-pagination.is-background .btn-prev:disabled,.el-pagination.is-background .el-pager li.is-disabled,.el-pagination.is-background .el-pager li:disabled{background-color:var(--el-disabled-bg-color);color:var(--el-text-color-placeholder)}.el-pagination.is-background .btn-next.is-disabled.is-active,.el-pagination.is-background .btn-next:disabled.is-active,.el-pagination.is-background .btn-prev.is-disabled.is-active,.el-pagination.is-background .btn-prev:disabled.is-active,.el-pagination.is-background .el-pager li.is-disabled.is-active,.el-pagination.is-background .el-pager li:disabled.is-active{background-color:var(--el-fill-color-dark);color:var(--el-text-color-secondary)}.el-pagination.is-background .btn-prev{margin-left:var(--el-pagination-item-gap)}.el-pagination--small .btn-next,.el-pagination--small .btn-prev,.el-pagination--small .el-pager li{font-size:var(--el-pagination-font-size-small);height:var(--el-pagination-button-height-small);line-height:var(--el-pagination-button-height-small);min-width:var(--el-pagination-button-width-small)}.el-pagination--small button,.el-pagination--small span:not([class*=suffix]){font-size:var(--el-pagination-font-size-small)}.el-pagination--small .el-select{width:100px}.el-pagination--large .btn-next,.el-pagination--large .btn-prev,.el-pagination--large .el-pager li{height:var(--el-pagination-button-height-large);line-height:var(--el-pagination-button-height-large);min-width:var(--el-pagination-button-width-large)}.el-pagination--large .el-select .el-input{width:160px}.el-pager{font-size:0;list-style:none;margin:0;padding:0;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-pager,.el-pager li{align-items:center;display:flex}.el-pager li{background:var(--el-pagination-bg-color);border:none;border-radius:var(--el-pagination-border-radius);box-sizing:border-box;color:var(--el-pagination-button-color);cursor:pointer;font-size:var(--el-pagination-font-size);height:var(--el-pagination-button-height);justify-content:center;line-height:var(--el-pagination-button-height);min-width:var(--el-pagination-button-width);padding:0 4px;text-align:center}.el-pager li *{pointer-events:none}.el-pager li:focus{outline:none}.el-pager li.is-active,.el-pager li:hover{color:var(--el-pagination-hover-color)}.el-pager li.is-active{cursor:default;font-weight:bold}.el-pager li.is-active.is-disabled{color:var(--el-text-color-secondary);font-weight:bold}.el-pager li.is-disabled,.el-pager li:disabled{background-color:var(--el-pagination-button-disabled-bg-color);color:var(--el-pagination-button-disabled-color);cursor:not-allowed}.el-pager li:focus-visible{outline:1px solid var(--el-pagination-hover-color);outline-offset:-1px}.el-popconfirm__main{align-items:center;display:flex}.el-popconfirm__icon{margin-right:5px}.el-popconfirm__action{margin-top:8px;text-align:right}.el-popover{--el-popover-bg-color:var(--el-bg-color-overlay);--el-popover-font-size:var(--el-font-size-base);--el-popover-border-color:var(--el-border-color-lighter);--el-popover-padding:12px;--el-popover-padding-large:18px 20px;--el-popover-title-font-size:16px;--el-popover-title-text-color:var(--el-text-color-primary);--el-popover-border-radius:4px}.el-popover.el-popper{background:var(--el-popover-bg-color);border:1px solid var(--el-popover-border-color);border-radius:var(--el-popover-border-radius);box-shadow:var(--el-box-shadow-light);box-sizing:border-box;color:var(--el-text-color-regular);font-size:var(--el-popover-font-size);line-height:1.4;min-width:150px;overflow-wrap:break-word;padding:var(--el-popover-padding);z-index:var(--el-index-popper)}.el-popover.el-popper--plain{padding:var(--el-popover-padding-large)}.el-popover__title{color:var(--el-popover-title-text-color);font-size:var(--el-popover-title-font-size);line-height:1;margin-bottom:12px}.el-popover__reference:focus:hover,.el-popover__reference:focus:not(.focusing){outline-width:0}.el-popover.el-popper.is-dark{--el-popover-bg-color:var(--el-text-color-primary);--el-popover-border-color:var(--el-text-color-primary);--el-popover-title-text-color:var(--el-bg-color);color:var(--el-bg-color)}.el-popover.el-popper:focus,.el-popover.el-popper:focus:active{outline-width:0}.el-progress{align-items:center;display:flex;line-height:1;position:relative}.el-progress__text{color:var(--el-text-color-regular);font-size:14px;line-height:1;margin-left:5px;min-width:50px}.el-progress__text i{display:block;vertical-align:middle}.el-progress--circle,.el-progress--dashboard{display:inline-block}.el-progress--circle .el-progress__text,.el-progress--dashboard .el-progress__text{left:0;margin:0;position:absolute;text-align:center;top:50%;transform:translateY(-50%);width:100%}.el-progress--circle .el-progress__text i,.el-progress--dashboard .el-progress__text i{display:inline-block;vertical-align:middle}.el-progress--without-text .el-progress__text{display:none}.el-progress--without-text .el-progress-bar{display:block;margin-right:0;padding-right:0}.el-progress--text-inside .el-progress-bar{margin-right:0;padding-right:0}.el-progress.is-success .el-progress-bar__inner{background-color:var(--el-color-success)}.el-progress.is-success .el-progress__text{color:var(--el-color-success)}.el-progress.is-warning .el-progress-bar__inner{background-color:var(--el-color-warning)}.el-progress.is-warning .el-progress__text{color:var(--el-color-warning)}.el-progress.is-exception .el-progress-bar__inner{background-color:var(--el-color-danger)}.el-progress.is-exception .el-progress__text{color:var(--el-color-danger)}.el-progress-bar{box-sizing:border-box;flex-grow:1}.el-progress-bar__outer{background-color:var(--el-border-color-lighter);border-radius:100px;height:6px;overflow:hidden;position:relative;vertical-align:middle}.el-progress-bar__inner{background-color:var(--el-color-primary);border-radius:100px;height:100%;left:0;line-height:1;position:absolute;text-align:right;top:0;transition:width .6s ease;white-space:nowrap}.el-progress-bar__inner:after{content:"";display:inline-block;height:100%;vertical-align:middle}.el-progress-bar__inner--indeterminate{animation:indeterminate 3s infinite;transform:translateZ(0)}.el-progress-bar__inner--striped{background-image:linear-gradient(45deg,rgba(0,0,0,.1) 25%,transparent 0,transparent 50%,rgba(0,0,0,.1) 0,rgba(0,0,0,.1) 75%,transparent 0,transparent);background-size:1.25em 1.25em}.el-progress-bar__inner--striped.el-progress-bar__inner--striped-flow{animation:striped-flow 3s linear infinite}.el-progress-bar__innerText{color:#ffffff;display:inline-block;font-size:12px;margin:0 5px;vertical-align:middle}@keyframes progress{0%{background-position:0 0}to{background-position:32px 0}}@keyframes indeterminate{0%{left:-100%}to{left:100%}}@keyframes striped-flow{0%{background-position:-100%}to{background-position:100%}}.el-radio-button{--el-radio-button-checked-bg-color:var(--el-color-primary);--el-radio-button-checked-text-color:var(--el-color-white);--el-radio-button-checked-border-color:var(--el-color-primary);--el-radio-button-disabled-checked-fill:var(--el-border-color-extra-light)}.el-radio-button,.el-radio-button__inner{display:inline-block;outline:none;position:relative}.el-radio-button__inner{-webkit-appearance:none;background:var(--el-button-bg-color,var(--el-fill-color-blank));border:var(--el-border);border-left:0;border-radius:0;box-sizing:border-box;color:var(--el-button-text-color,var(--el-text-color-regular));cursor:pointer;font-size:var(--el-font-size-base);font-weight:var(--el-button-font-weight,var(--el-font-weight-primary));line-height:1;margin:0;padding:8px 15px;text-align:center;transition:var(--el-transition-all);-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle;white-space:nowrap}.el-radio-button__inner.is-round{padding:8px 15px}.el-radio-button__inner:hover{color:var(--el-color-primary)}.el-radio-button__inner [class*=el-icon-]{line-height:.9}.el-radio-button__inner [class*=el-icon-]+span{margin-left:5px}.el-radio-button:first-child .el-radio-button__inner{border-left:var(--el-border);border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);box-shadow:none!important}.el-radio-button.is-active .el-radio-button__original-radio:not(:disabled)+.el-radio-button__inner{background-color:var(--el-radio-button-checked-bg-color,var(--el-color-primary));border-color:var(--el-radio-button-checked-border-color,var(--el-color-primary));box-shadow:-1px 0 0 0 var(--el-radio-button-checked-border-color,var(--el-color-primary));color:var(--el-radio-button-checked-text-color,var(--el-color-white))}.el-radio-button__original-radio{opacity:0;outline:none;position:absolute;z-index:-1}.el-radio-button__original-radio:focus-visible+.el-radio-button__inner{border-left:var(--el-border);border-left-color:var(--el-radio-button-checked-border-color,var(--el-color-primary));border-radius:var(--el-border-radius-base);box-shadow:none;outline:2px solid var(--el-radio-button-checked-border-color);outline-offset:1px;z-index:2}.el-radio-button__original-radio:disabled+.el-radio-button__inner{background-color:var(--el-button-disabled-bg-color,var(--el-fill-color-blank));background-image:none;border-color:var(--el-button-disabled-border-color,var(--el-border-color-light));box-shadow:none;color:var(--el-disabled-text-color);cursor:not-allowed}.el-radio-button__original-radio:disabled:checked+.el-radio-button__inner{background-color:var(--el-radio-button-disabled-checked-fill)}.el-radio-button:last-child .el-radio-button__inner{border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0}.el-radio-button:first-child:last-child .el-radio-button__inner{border-radius:var(--el-border-radius-base)}.el-radio-button--large .el-radio-button__inner{border-radius:0;font-size:var(--el-font-size-base);padding:12px 19px}.el-radio-button--large .el-radio-button__inner.is-round{padding:12px 19px}.el-radio-button--small .el-radio-button__inner{border-radius:0;font-size:12px;padding:5px 11px}.el-radio-button--small .el-radio-button__inner.is-round{padding:5px 11px}.el-radio-group{align-items:center;display:inline-flex;flex-wrap:wrap;font-size:0}.el-radio{--el-radio-font-size:var(--el-font-size-base);--el-radio-text-color:var(--el-text-color-regular);--el-radio-font-weight:var(--el-font-weight-primary);--el-radio-input-height:14px;--el-radio-input-width:14px;--el-radio-input-border-radius:var(--el-border-radius-circle);--el-radio-input-bg-color:var(--el-fill-color-blank);--el-radio-input-border:var(--el-border);--el-radio-input-border-color:var(--el-border-color);--el-radio-input-border-color-hover:var(--el-color-primary);align-items:center;color:var(--el-radio-text-color);cursor:pointer;display:inline-flex;font-size:var(--el-font-size-base);font-weight:var(--el-radio-font-weight);height:32px;margin-right:30px;outline:none;position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;white-space:nowrap}.el-radio.el-radio--large{height:40px}.el-radio.el-radio--small{height:24px}.el-radio.is-bordered{border:var(--el-border);border-radius:var(--el-border-radius-base);box-sizing:border-box;padding:0 15px 0 9px}.el-radio.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-radio.is-bordered.is-disabled{border-color:var(--el-border-color-lighter);cursor:not-allowed}.el-radio.is-bordered.el-radio--large{border-radius:var(--el-border-radius-base);padding:0 19px 0 11px}.el-radio.is-bordered.el-radio--large .el-radio__label{font-size:var(--el-font-size-base)}.el-radio.is-bordered.el-radio--large .el-radio__inner{height:14px;width:14px}.el-radio.is-bordered.el-radio--small{border-radius:var(--el-border-radius-base);padding:0 11px 0 7px}.el-radio.is-bordered.el-radio--small .el-radio__label{font-size:12px}.el-radio.is-bordered.el-radio--small .el-radio__inner{height:12px;width:12px}.el-radio:last-child{margin-right:0}.el-radio__input{cursor:pointer;display:inline-flex;outline:none;position:relative;vertical-align:middle;white-space:nowrap}.el-radio__input.is-disabled .el-radio__inner{border-color:var(--el-disabled-border-color)}.el-radio__input.is-disabled .el-radio__inner,.el-radio__input.is-disabled .el-radio__inner:after{background-color:var(--el-disabled-bg-color);cursor:not-allowed}.el-radio__input.is-disabled .el-radio__inner+.el-radio__label{cursor:not-allowed}.el-radio__input.is-disabled.is-checked .el-radio__inner{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color)}.el-radio__input.is-disabled.is-checked .el-radio__inner:after{background-color:var(--el-text-color-placeholder)}.el-radio__input.is-disabled+span.el-radio__label{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-radio__input.is-checked .el-radio__inner{background:var(--el-color-primary);border-color:var(--el-color-primary)}.el-radio__input.is-checked .el-radio__inner:after{background-color:var(--el-color-white);transform:translate(-50%,-50%) scale(1)}.el-radio__input.is-checked+.el-radio__label{color:var(--el-color-primary)}.el-radio__input.is-focus .el-radio__inner{border-color:var(--el-radio-input-border-color-hover)}.el-radio__inner{background-color:var(--el-radio-input-bg-color);border:var(--el-radio-input-border);border-radius:var(--el-radio-input-border-radius);box-sizing:border-box;cursor:pointer;display:inline-block;height:var(--el-radio-input-height);position:relative;width:var(--el-radio-input-width)}.el-radio__inner:hover{border-color:var(--el-radio-input-border-color-hover)}.el-radio__inner:after{border-radius:var(--el-radio-input-border-radius);content:"";height:4px;left:50%;position:absolute;top:50%;transform:translate(-50%,-50%) scale(0);transition:transform .15s ease-in;width:4px}.el-radio__original{bottom:0;left:0;margin:0;opacity:0;outline:none;position:absolute;right:0;top:0;z-index:-1}.el-radio__original:focus-visible+.el-radio__inner{border-radius:var(--el-radio-input-border-radius);outline:2px solid var(--el-radio-input-border-color-hover);outline-offset:1px}.el-radio:focus:not(:focus-visible):not(.is-focus):not(:active):not(.is-disabled) .el-radio__inner{box-shadow:0 0 2px 2px var(--el-radio-input-border-color-hover)}.el-radio__label{font-size:var(--el-radio-font-size);padding-left:8px}.el-radio.el-radio--large .el-radio__label{font-size:14px}.el-radio.el-radio--large .el-radio__inner{height:14px;width:14px}.el-radio.el-radio--small .el-radio__label{font-size:12px}.el-radio.el-radio--small .el-radio__inner{height:12px;width:12px}.el-rate{--el-rate-height:20px;--el-rate-font-size:var(--el-font-size-base);--el-rate-icon-size:18px;--el-rate-icon-margin:6px;--el-rate-void-color:var(--el-border-color-darker);--el-rate-fill-color:#f7ba2a;--el-rate-disabled-void-color:var(--el-fill-color);--el-rate-text-color:var(--el-text-color-primary);align-items:center;display:inline-flex;height:32px}.el-rate:active,.el-rate:focus{outline:none}.el-rate__item{color:var(--el-rate-void-color);cursor:pointer;display:inline-block;font-size:0;line-height:normal;position:relative;vertical-align:middle}.el-rate .el-rate__icon{display:inline-block;font-size:var(--el-rate-icon-size);margin-right:var(--el-rate-icon-margin);position:relative;transition:var(--el-transition-duration)}.el-rate .el-rate__icon.hover{transform:scale(1.15)}.el-rate .el-rate__icon .path2{left:0;position:absolute;top:0}.el-rate .el-rate__icon.is-active{color:var(--el-rate-fill-color)}.el-rate__decimal{color:var(--el-rate-fill-color);display:inline-block;overflow:hidden}.el-rate__decimal,.el-rate__decimal--box{left:0;position:absolute;top:0}.el-rate__text{color:var(--el-rate-text-color);font-size:var(--el-rate-font-size);vertical-align:middle}.el-rate--large{height:40px}.el-rate--small{height:24px}.el-rate--small .el-rate__icon{font-size:14px}.el-rate.is-disabled .el-rate__item{color:var(--el-rate-disabled-void-color);cursor:auto}.el-result{--el-result-padding:40px 30px;--el-result-icon-font-size:64px;--el-result-title-font-size:20px;--el-result-title-margin-top:20px;--el-result-subtitle-margin-top:10px;--el-result-extra-margin-top:30px;align-items:center;box-sizing:border-box;display:flex;flex-direction:column;justify-content:center;padding:var(--el-result-padding);text-align:center}.el-result__icon svg{height:var(--el-result-icon-font-size);width:var(--el-result-icon-font-size)}.el-result__title{margin-top:var(--el-result-title-margin-top)}.el-result__title p{color:var(--el-text-color-primary);font-size:var(--el-result-title-font-size);line-height:1.3;margin:0}.el-result__subtitle{margin-top:var(--el-result-subtitle-margin-top)}.el-result__subtitle p{color:var(--el-text-color-regular);font-size:var(--el-font-size-base);line-height:1.3;margin:0}.el-result__extra{margin-top:var(--el-result-extra-margin-top)}.el-result .icon-primary{--el-result-color:var(--el-color-primary);color:var(--el-result-color)}.el-result .icon-success{--el-result-color:var(--el-color-success);color:var(--el-result-color)}.el-result .icon-warning{--el-result-color:var(--el-color-warning);color:var(--el-result-color)}.el-result .icon-danger{--el-result-color:var(--el-color-danger);color:var(--el-result-color)}.el-result .icon-error{--el-result-color:var(--el-color-error);color:var(--el-result-color)}.el-result .icon-info{--el-result-color:var(--el-color-info);color:var(--el-result-color)}.el-row{box-sizing:border-box;display:flex;flex-wrap:wrap;position:relative}.el-row.is-justify-center{justify-content:center}.el-row.is-justify-end{justify-content:flex-end}.el-row.is-justify-space-between{justify-content:space-between}.el-row.is-justify-space-around{justify-content:space-around}.el-row.is-justify-space-evenly{justify-content:space-evenly}.el-row.is-align-top{align-items:flex-start}.el-row.is-align-middle{align-items:center}.el-row.is-align-bottom{align-items:flex-end}.el-scrollbar{--el-scrollbar-opacity:0.3;--el-scrollbar-bg-color:var(--el-text-color-secondary);--el-scrollbar-hover-opacity:0.5;--el-scrollbar-hover-bg-color:var(--el-text-color-secondary);height:100%;overflow:hidden;position:relative}.el-scrollbar__wrap{height:100%;overflow:auto}.el-scrollbar__wrap--hidden-default{scrollbar-width:none}.el-scrollbar__wrap--hidden-default::-webkit-scrollbar{display:none}.el-scrollbar__thumb{background-color:var(--el-scrollbar-bg-color,var(--el-text-color-secondary));border-radius:inherit;cursor:pointer;display:block;height:0;opacity:var(--el-scrollbar-opacity,.3);position:relative;transition:var(--el-transition-duration) background-color;width:0}.el-scrollbar__thumb:hover{background-color:var(--el-scrollbar-hover-bg-color,var(--el-text-color-secondary));opacity:var(--el-scrollbar-hover-opacity,.5)}.el-scrollbar__bar{border-radius:4px;bottom:2px;position:absolute;right:2px;z-index:1}.el-scrollbar__bar.is-vertical{top:2px;width:6px}.el-scrollbar__bar.is-vertical>div{width:100%}.el-scrollbar__bar.is-horizontal{height:6px;left:2px}.el-scrollbar__bar.is-horizontal>div{height:100%}.el-scrollbar-fade-enter-active{transition:opacity .34s ease-out}.el-scrollbar-fade-leave-active{transition:opacity .12s ease-out}.el-scrollbar-fade-enter-from,.el-scrollbar-fade-leave-active{opacity:0}.el-select-dropdown{border-radius:var(--el-border-radius-base);box-sizing:border-box;z-index:calc(var(--el-index-top) + 1)}.el-select-dropdown .el-scrollbar.is-empty .el-select-dropdown__list{padding:0}.el-select-dropdown__empty,.el-select-dropdown__loading{color:var(--el-text-color-secondary);font-size:var(--el-select-font-size);margin:0;padding:10px 0;text-align:center}.el-select-dropdown__wrap{max-height:274px}.el-select-dropdown__list{box-sizing:border-box;list-style:none;margin:0;padding:6px 0}.el-select-dropdown__list.el-vl__window{margin:6px 0;padding:0}.el-select-dropdown__header{border-bottom:1px solid var(--el-border-color-light);padding:10px}.el-select-dropdown__footer{border-top:1px solid var(--el-border-color-light);padding:10px}.el-select-dropdown__item{box-sizing:border-box;color:var(--el-text-color-regular);cursor:pointer;font-size:var(--el-font-size-base);height:34px;line-height:34px;overflow:hidden;padding:0 32px 0 20px;position:relative;text-overflow:ellipsis;white-space:nowrap}.el-select-dropdown__item.is-hovering{background-color:var(--el-fill-color-light)}.el-select-dropdown__item.is-selected{color:var(--el-color-primary);font-weight:bold}.el-select-dropdown__item.is-disabled{background-color:unset;color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-selected:after{background-color:var(--el-color-primary);background-position:50%;background-repeat:no-repeat;border-right:none;border-top:none;content:"";height:12px;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;position:absolute;right:20px;top:50%;transform:translateY(-50%);width:12px}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-disabled:after{background-color:var(--el-text-color-placeholder)}.el-select-group{margin:0;padding:0}.el-select-group__wrap{list-style:none;margin:0;padding:0;position:relative}.el-select-group__title{box-sizing:border-box;color:var(--el-color-info);font-size:12px;line-height:34px;overflow:hidden;padding:0 20px;text-overflow:ellipsis;white-space:nowrap}.el-select-group .el-select-dropdown__item{padding-left:20px}.el-select{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-color:var(--el-disabled-text-color);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px;--el-select-width:100%;display:inline-block;position:relative;vertical-align:middle;width:var(--el-select-width)}.el-select__wrapper{align-items:center;background-color:var(--el-fill-color-blank);border-radius:var(--el-border-radius-base);box-shadow:0 0 0 1px var(--el-border-color) inset;box-sizing:border-box;cursor:pointer;display:flex;font-size:14px;gap:6px;line-height:24px;min-height:32px;padding:4px 12px;position:relative;text-align:left;transform:translateZ(0);transition:var(--el-transition-duration)}.el-select__wrapper.is-filterable{cursor:text}.el-select__wrapper.is-focused{box-shadow:0 0 0 1px var(--el-color-primary) inset}.el-select__wrapper.is-hovering:not(.is-focused){box-shadow:0 0 0 1px var(--el-border-color-hover) inset}.el-select__wrapper.is-disabled{background-color:var(--el-fill-color-light);color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select__wrapper.is-disabled,.el-select__wrapper.is-disabled:hover{box-shadow:0 0 0 1px var(--el-select-disabled-border) inset}.el-select__wrapper.is-disabled.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-select__wrapper.is-disabled .el-select__selected-item{color:var(--el-select-disabled-color)}.el-select__wrapper.is-disabled .el-select__caret,.el-select__wrapper.is-disabled .el-tag,.el-select__wrapper.is-disabled input{cursor:not-allowed}.el-select__wrapper.is-disabled .el-select__prefix,.el-select__wrapper.is-disabled .el-select__suffix{pointer-events:none}.el-select__prefix,.el-select__suffix{align-items:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:flex;flex-shrink:0;gap:6px}.el-select__caret{color:var(--el-select-input-color);cursor:pointer;font-size:var(--el-select-input-font-size);transform:rotate(0deg);transition:var(--el-transition-duration)}.el-select__caret.is-reverse{transform:rotate(180deg)}.el-select__clear{cursor:pointer}.el-select__clear:hover{color:var(--el-select-close-hover-color)}.el-select__selection{align-items:center;display:flex;flex:1;flex-wrap:wrap;gap:6px;min-width:0;position:relative}.el-select__selection.is-near{margin-left:-8px}.el-select__selection .el-tag{border-color:transparent;cursor:pointer}.el-select__selection .el-tag.el-tag--plain{border-color:var(--el-tag-border-color)}.el-select__selection .el-tag .el-tag__content{min-width:0}.el-select__selected-item{display:flex;flex-wrap:wrap;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-select__tags-text{line-height:normal}.el-select__placeholder,.el-select__tags-text{display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select__placeholder{color:var(--el-input-text-color,var(--el-text-color-regular));position:absolute;top:50%;transform:translateY(-50%);width:100%;z-index:-1}.el-select__placeholder.is-transparent{color:var(--el-text-color-placeholder);-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-select__popper.el-popper{background:var(--el-bg-color-overlay);box-shadow:var(--el-box-shadow-light)}.el-select__popper.el-popper,.el-select__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-select__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent;border-top-color:transparent}.el-select__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-select__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent;border-left-color:transparent}.el-select__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-select__input-wrapper{flex:1}.el-select__input-wrapper.is-hidden{opacity:0;position:absolute;z-index:-1}.el-select__input{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:transparent;border:none;color:var(--el-select-multiple-input-color);font-family:inherit;font-size:inherit;height:24px;outline:none;padding:0;width:100%}.el-select__input.is-disabled{cursor:not-allowed}.el-select__input-calculator{left:0;max-width:100%;overflow:hidden;position:absolute;top:0;visibility:hidden;white-space:pre}.el-select--large .el-select__wrapper{font-size:14px;gap:6px;line-height:24px;min-height:40px;padding:8px 16px}.el-select--large .el-select__selection{gap:6px}.el-select--large .el-select__selection.is-near{margin-left:-8px}.el-select--large .el-select__prefix,.el-select--large .el-select__suffix{gap:6px}.el-select--large .el-select__input{height:24px}.el-select--small .el-select__wrapper{font-size:12px;gap:4px;line-height:20px;min-height:24px;padding:2px 8px}.el-select--small .el-select__selection{gap:4px}.el-select--small .el-select__selection.is-near{margin-left:-6px}.el-select--small .el-select__prefix,.el-select--small .el-select__suffix{gap:4px}.el-select--small .el-select__input{height:20px}.el-skeleton{--el-skeleton-circle-size:var(--el-avatar-size)}.el-skeleton__item{background:var(--el-skeleton-color);border-radius:var(--el-border-radius-base);display:inline-block;height:16px;width:100%}.el-skeleton__circle{border-radius:50%;height:var(--el-skeleton-circle-size);line-height:var(--el-skeleton-circle-size);width:var(--el-skeleton-circle-size)}.el-skeleton__button{border-radius:4px;height:40px;width:64px}.el-skeleton__p{width:100%}.el-skeleton__p.is-last{width:61%}.el-skeleton__p.is-first{width:33%}.el-skeleton__text{height:var(--el-font-size-small);width:100%}.el-skeleton__caption{height:var(--el-font-size-extra-small)}.el-skeleton__h1{height:var(--el-font-size-extra-large)}.el-skeleton__h3{height:var(--el-font-size-large)}.el-skeleton__h5{height:var(--el-font-size-medium)}.el-skeleton__image{align-items:center;border-radius:0;display:flex;justify-content:center;width:unset}.el-skeleton__image svg{color:var(--el-svg-monochrome-grey);fill:currentColor;height:22%;width:22%}.el-skeleton{--el-skeleton-color:var(--el-fill-color);--el-skeleton-to-color:var(--el-fill-color-darker)}@keyframes el-skeleton-loading{0%{background-position:100% 50%}to{background-position:0 50%}}.el-skeleton{width:100%}.el-skeleton__first-line,.el-skeleton__paragraph{background:var(--el-skeleton-color);height:16px;margin-top:16px}.el-skeleton.is-animated .el-skeleton__item{animation:el-skeleton-loading 1.4s ease infinite;background:linear-gradient(90deg,var(--el-skeleton-color) 25%,var(--el-skeleton-to-color) 37%,var(--el-skeleton-color) 63%);background-size:400% 100%}.el-slider{--el-slider-main-bg-color:var(--el-color-primary);--el-slider-runway-bg-color:var(--el-border-color-light);--el-slider-stop-bg-color:var(--el-color-white);--el-slider-disabled-color:var(--el-text-color-placeholder);--el-slider-border-radius:3px;--el-slider-height:6px;--el-slider-button-size:20px;--el-slider-button-wrapper-size:36px;--el-slider-button-wrapper-offset:-15px;align-items:center;display:flex;height:32px;width:100%}.el-slider__runway{background-color:var(--el-slider-runway-bg-color);border-radius:var(--el-slider-border-radius);cursor:pointer;flex:1;height:var(--el-slider-height);position:relative}.el-slider__runway.show-input{margin-right:30px;width:auto}.el-slider__runway.is-disabled{cursor:default}.el-slider__runway.is-disabled .el-slider__bar{background-color:var(--el-slider-disabled-color)}.el-slider__runway.is-disabled .el-slider__button{border-color:var(--el-slider-disabled-color)}.el-slider__runway.is-disabled .el-slider__button-wrapper.dragging,.el-slider__runway.is-disabled .el-slider__button-wrapper.hover,.el-slider__runway.is-disabled .el-slider__button-wrapper:hover{cursor:not-allowed}.el-slider__runway.is-disabled .el-slider__button.dragging,.el-slider__runway.is-disabled .el-slider__button.hover,.el-slider__runway.is-disabled .el-slider__button:hover{transform:scale(1)}.el-slider__runway.is-disabled .el-slider__button.dragging,.el-slider__runway.is-disabled .el-slider__button.hover,.el-slider__runway.is-disabled .el-slider__button:hover{cursor:not-allowed}.el-slider__input{flex-shrink:0;width:130px}.el-slider__bar{background-color:var(--el-slider-main-bg-color);border-bottom-left-radius:var(--el-slider-border-radius);border-top-left-radius:var(--el-slider-border-radius);height:var(--el-slider-height);position:absolute}.el-slider__button-wrapper{background-color:transparent;height:var(--el-slider-button-wrapper-size);line-height:normal;outline:none;position:absolute;text-align:center;top:var(--el-slider-button-wrapper-offset);transform:translateX(-50%);-webkit-user-select:none;-moz-user-select:none;user-select:none;width:var(--el-slider-button-wrapper-size);z-index:1}.el-slider__button-wrapper:after{content:"";display:inline-block;height:100%;vertical-align:middle}.el-slider__button-wrapper.hover,.el-slider__button-wrapper:hover{cursor:grab}.el-slider__button-wrapper.dragging{cursor:grabbing}.el-slider__button{background-color:var(--el-color-white);border:2px solid var(--el-slider-main-bg-color);border-radius:50%;box-sizing:border-box;display:inline-block;height:var(--el-slider-button-size);transition:var(--el-transition-duration-fast);-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle;width:var(--el-slider-button-size)}.el-slider__button.dragging,.el-slider__button.hover,.el-slider__button:hover{transform:scale(1.2)}.el-slider__button.hover,.el-slider__button:hover{cursor:grab}.el-slider__button.dragging{cursor:grabbing}.el-slider__stop{background-color:var(--el-slider-stop-bg-color);border-radius:var(--el-border-radius-circle);height:var(--el-slider-height);position:absolute;transform:translateX(-50%);width:var(--el-slider-height)}.el-slider__marks{height:100%;left:12px;top:0;width:18px}.el-slider__marks-text{color:var(--el-color-info);font-size:14px;margin-top:15px;position:absolute;transform:translateX(-50%);white-space:pre}.el-slider.is-vertical{display:inline-flex;flex:0;height:100%;position:relative;width:auto}.el-slider.is-vertical .el-slider__runway{height:100%;margin:0 16px;width:var(--el-slider-height)}.el-slider.is-vertical .el-slider__bar{border-radius:0 0 3px 3px;height:auto;width:var(--el-slider-height)}.el-slider.is-vertical .el-slider__button-wrapper{left:var(--el-slider-button-wrapper-offset);top:auto;transform:translateY(50%)}.el-slider.is-vertical .el-slider__stop{transform:translateY(50%)}.el-slider.is-vertical .el-slider__marks-text{left:15px;margin-top:0;transform:translateY(50%)}.el-slider--large{height:40px}.el-slider--small{height:24px}.el-space{display:inline-flex;vertical-align:top}.el-space__item{display:flex;flex-wrap:wrap}.el-space__item>*{flex:1}.el-space--vertical{flex-direction:column}.el-time-spinner{white-space:nowrap;width:100%}.el-spinner{display:inline-block;vertical-align:middle}.el-spinner-inner{animation:rotate 2s linear infinite;height:50px;width:50px}.el-spinner-inner .path{stroke:var(--el-border-color-lighter);stroke-linecap:round;animation:dash 1.5s ease-in-out infinite}@keyframes rotate{to{transform:rotate(1turn)}}@keyframes dash{0%{stroke-dasharray:1,150;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-35}to{stroke-dasharray:90,150;stroke-dashoffset:-124}}.el-step{flex-shrink:1;position:relative}.el-step:last-of-type .el-step__line{display:none}.el-step:last-of-type.is-flex{flex-basis:auto!important;flex-grow:0;flex-shrink:0}.el-step:last-of-type .el-step__description,.el-step:last-of-type .el-step__main{padding-right:0}.el-step__head{position:relative;width:100%}.el-step__head.is-process{border-color:var(--el-text-color-primary);color:var(--el-text-color-primary)}.el-step__head.is-wait{border-color:var(--el-text-color-placeholder);color:var(--el-text-color-placeholder)}.el-step__head.is-success{border-color:var(--el-color-success);color:var(--el-color-success)}.el-step__head.is-error{border-color:var(--el-color-danger);color:var(--el-color-danger)}.el-step__head.is-finish{border-color:var(--el-color-primary);color:var(--el-color-primary)}.el-step__icon{align-items:center;background:var(--el-bg-color);box-sizing:border-box;display:inline-flex;font-size:14px;height:24px;justify-content:center;position:relative;transition:.15s ease-out;width:24px;z-index:1}.el-step__icon.is-text{border:2px solid;border-radius:50%}.el-step__icon.is-icon{width:40px}.el-step__icon-inner{color:inherit;display:inline-block;font-weight:bold;line-height:1;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-step__icon-inner[class*=el-icon]:not(.is-status){font-size:25px;font-weight:normal}.el-step__icon-inner.is-status{transform:translateY(1px)}.el-step__line{background-color:var(--el-text-color-placeholder);border-color:currentColor;position:absolute}.el-step__line-inner{border:1px solid;box-sizing:border-box;display:block;height:0;transition:.15s ease-out;width:0}.el-step__main{text-align:left;white-space:normal}.el-step__title{font-size:16px;line-height:38px}.el-step__title.is-process{color:var(--el-text-color-primary);font-weight:bold}.el-step__title.is-wait{color:var(--el-text-color-placeholder)}.el-step__title.is-success{color:var(--el-color-success)}.el-step__title.is-error{color:var(--el-color-danger)}.el-step__title.is-finish{color:var(--el-color-primary)}.el-step__description{font-size:12px;font-weight:normal;line-height:20px;margin-top:-5px;padding-right:10%}.el-step__description.is-process{color:var(--el-text-color-primary)}.el-step__description.is-wait{color:var(--el-text-color-placeholder)}.el-step__description.is-success{color:var(--el-color-success)}.el-step__description.is-error{color:var(--el-color-danger)}.el-step__description.is-finish{color:var(--el-color-primary)}.el-step.is-horizontal{display:inline-block}.el-step.is-horizontal .el-step__line{height:2px;left:0;right:0;top:11px}.el-step.is-vertical{display:flex}.el-step.is-vertical .el-step__head{flex-grow:0;width:24px}.el-step.is-vertical .el-step__main{flex-grow:1;padding-left:10px}.el-step.is-vertical .el-step__title{line-height:24px;padding-bottom:8px}.el-step.is-vertical .el-step__line{bottom:0;left:11px;top:0;width:2px}.el-step.is-vertical .el-step__icon.is-icon{width:24px}.el-step.is-center .el-step__head,.el-step.is-center .el-step__main{text-align:center}.el-step.is-center .el-step__description{padding-left:20%;padding-right:20%}.el-step.is-center .el-step__line{left:50%;right:-50%}.el-step.is-simple{align-items:center;display:flex}.el-step.is-simple .el-step__head{font-size:0;padding-right:10px;width:auto}.el-step.is-simple .el-step__icon{background:transparent;font-size:12px;height:16px;width:16px}.el-step.is-simple .el-step__icon-inner[class*=el-icon]:not(.is-status){font-size:18px}.el-step.is-simple .el-step__icon-inner.is-status{transform:scale(.8) translateY(1px)}.el-step.is-simple .el-step__main{align-items:stretch;display:flex;flex-grow:1;position:relative}.el-step.is-simple .el-step__title{font-size:16px;line-height:20px}.el-step.is-simple:not(:last-of-type) .el-step__title{max-width:50%;overflow-wrap:break-word}.el-step.is-simple .el-step__arrow{align-items:center;display:flex;flex-grow:1;justify-content:center}.el-step.is-simple .el-step__arrow:after,.el-step.is-simple .el-step__arrow:before{background:var(--el-text-color-placeholder);content:"";display:inline-block;height:15px;position:absolute;width:1px}.el-step.is-simple .el-step__arrow:before{transform:rotate(-45deg) translateY(-4px);transform-origin:0 0}.el-step.is-simple .el-step__arrow:after{transform:rotate(45deg) translateY(4px);transform-origin:100% 100%}.el-step.is-simple:last-of-type .el-step__arrow{display:none}.el-steps{display:flex}.el-steps--simple{background:var(--el-fill-color-light);border-radius:4px;padding:13px 8%}.el-steps--horizontal{white-space:nowrap}.el-steps--vertical{flex-flow:column;height:100%}.el-switch{--el-switch-on-color:var(--el-color-primary);--el-switch-off-color:var(--el-border-color);align-items:center;display:inline-flex;font-size:14px;height:32px;line-height:20px;position:relative;vertical-align:middle}.el-switch.is-disabled .el-switch__core,.el-switch.is-disabled .el-switch__label{cursor:not-allowed}.el-switch__label{color:var(--el-text-color-primary);cursor:pointer;display:inline-block;font-size:14px;font-weight:500;height:20px;transition:var(--el-transition-duration-fast);vertical-align:middle}.el-switch__label.is-active{color:var(--el-color-primary)}.el-switch__label--left{margin-right:10px}.el-switch__label--right{margin-left:10px}.el-switch__label *{display:inline-block;font-size:14px;line-height:1}.el-switch__label .el-icon{height:inherit}.el-switch__label .el-icon svg{vertical-align:middle}.el-switch__input{height:0;margin:0;opacity:0;position:absolute;width:0}.el-switch__input:focus-visible~.el-switch__core{outline:2px solid var(--el-switch-on-color);outline-offset:1px}.el-switch__core{align-items:center;background:var(--el-switch-off-color);border:1px solid var(--el-switch-border-color,var(--el-switch-off-color));border-radius:10px;box-sizing:border-box;cursor:pointer;display:inline-flex;height:20px;min-width:40px;outline:none;position:relative;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration)}.el-switch__core .el-switch__inner{align-items:center;display:flex;height:16px;justify-content:center;overflow:hidden;padding:0 4px 0 18px;transition:all var(--el-transition-duration);width:100%}.el-switch__core .el-switch__inner .is-icon,.el-switch__core .el-switch__inner .is-text{color:var(--el-color-white);font-size:12px;overflow:hidden;text-overflow:ellipsis;-webkit-user-select:none;-moz-user-select:none;user-select:none;white-space:nowrap}.el-switch__core .el-switch__action{align-items:center;background-color:var(--el-color-white);border-radius:var(--el-border-radius-circle);color:var(--el-switch-off-color);display:flex;height:16px;justify-content:center;left:1px;position:absolute;transition:all var(--el-transition-duration);width:16px}.el-switch.is-checked .el-switch__core{background-color:var(--el-switch-on-color);border-color:var(--el-switch-border-color,var(--el-switch-on-color))}.el-switch.is-checked .el-switch__core .el-switch__action{color:var(--el-switch-on-color);left:calc(100% - 17px)}.el-switch.is-checked .el-switch__core .el-switch__inner{padding:0 18px 0 4px}.el-switch.is-disabled{opacity:.6}.el-switch--wide .el-switch__label.el-switch__label--left span{left:10px}.el-switch--wide .el-switch__label.el-switch__label--right span{right:10px}.el-switch .label-fade-enter-from,.el-switch .label-fade-leave-active{opacity:0}.el-switch--large{font-size:14px;height:40px;line-height:24px}.el-switch--large .el-switch__label{font-size:14px;height:24px}.el-switch--large .el-switch__label *{font-size:14px}.el-switch--large .el-switch__core{border-radius:12px;height:24px;min-width:50px}.el-switch--large .el-switch__core .el-switch__inner{height:20px;padding:0 6px 0 22px}.el-switch--large .el-switch__core .el-switch__action{height:20px;width:20px}.el-switch--large.is-checked .el-switch__core .el-switch__action{left:calc(100% - 21px)}.el-switch--large.is-checked .el-switch__core .el-switch__inner{padding:0 22px 0 6px}.el-switch--small{font-size:12px;height:24px;line-height:16px}.el-switch--small .el-switch__label{font-size:12px;height:16px}.el-switch--small .el-switch__label *{font-size:12px}.el-switch--small .el-switch__core{border-radius:8px;height:16px;min-width:30px}.el-switch--small .el-switch__core .el-switch__inner{height:12px;padding:0 2px 0 14px}.el-switch--small .el-switch__core .el-switch__action{height:12px;width:12px}.el-switch--small.is-checked .el-switch__core .el-switch__action{left:calc(100% - 13px)}.el-switch--small.is-checked .el-switch__core .el-switch__inner{padding:0 14px 0 2px}.el-table-column--selection .cell{padding-left:14px;padding-right:14px}.el-table-filter{background-color:#ffffff;border:1px solid var(--el-border-color-lighter);border-radius:2px;box-shadow:var(--el-box-shadow-light);box-sizing:border-box}.el-table-filter__list{list-style:none;margin:0;min-width:100px;padding:5px 0}.el-table-filter__list-item{cursor:pointer;font-size:var(--el-font-size-base);line-height:36px;padding:0 10px}.el-table-filter__list-item:hover{background-color:var(--el-color-primary-light-9);color:var(--el-color-primary)}.el-table-filter__list-item.is-active{background-color:var(--el-color-primary);color:#ffffff}.el-table-filter__content{min-width:100px}.el-table-filter__bottom{border-top:1px solid var(--el-border-color-lighter);padding:8px}.el-table-filter__bottom button{background:transparent;border:none;color:var(--el-text-color-regular);cursor:pointer;font-size:var(--el-font-size-small);padding:0 3px}.el-table-filter__bottom button:hover{color:var(--el-color-primary)}.el-table-filter__bottom button:focus{outline:none}.el-table-filter__bottom button.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-table-filter__wrap{max-height:280px}.el-table-filter__checkbox-group{padding:10px}.el-table-filter__checkbox-group label.el-checkbox{align-items:center;display:flex;height:unset;margin-bottom:12px;margin-left:5px;margin-right:5px}.el-table-filter__checkbox-group .el-checkbox:last-child{margin-bottom:0}.el-table{--el-table-border-color:var(--el-border-color-lighter);--el-table-border:1px solid var(--el-table-border-color);--el-table-text-color:var(--el-text-color-regular);--el-table-header-text-color:var(--el-text-color-secondary);--el-table-row-hover-bg-color:var(--el-fill-color-light);--el-table-current-row-bg-color:var(--el-color-primary-light-9);--el-table-header-bg-color:var(--el-bg-color);--el-table-fixed-box-shadow:var(--el-box-shadow-light);--el-table-bg-color:var(--el-fill-color-blank);--el-table-tr-bg-color:var(--el-bg-color);--el-table-expanded-cell-bg-color:var(--el-fill-color-blank);--el-table-fixed-left-column:inset 10px 0 10px -10px rgba(0,0,0,0.15);--el-table-fixed-right-column:inset -10px 0 10px -10px rgba(0,0,0,0.15);--el-table-index:var(--el-index-normal);background-color:var(--el-table-bg-color);box-sizing:border-box;color:var(--el-table-text-color);font-size:var(--el-font-size-base);height:-moz-fit-content;height:fit-content;max-width:100%;overflow:hidden;position:relative;width:100%}.el-table__inner-wrapper{display:flex;flex-direction:column;height:100%;position:relative}.el-table__inner-wrapper:before{bottom:0;height:1px;left:0}.el-table tbody:focus-visible{outline:none}.el-table.has-footer.el-table--fluid-height tr:last-child td.el-table__cell,.el-table.has-footer.el-table--scrollable-y tr:last-child td.el-table__cell{border-bottom-color:transparent}.el-table__empty-block{align-items:center;display:flex;justify-content:center;left:0;min-height:60px;position:sticky;text-align:center;width:100%}.el-table__empty-text{color:var(--el-text-color-secondary);line-height:60px;width:50%}.el-table__expand-column .cell{padding:0;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-table__expand-icon{color:var(--el-text-color-regular);cursor:pointer;font-size:12px;height:20px;position:relative;transition:transform var(--el-transition-duration-fast) ease-in-out}.el-table__expand-icon--expanded{transform:rotate(90deg)}.el-table__expand-icon>.el-icon{font-size:12px}.el-table__expanded-cell{background-color:var(--el-table-expanded-cell-bg-color)}.el-table__expanded-cell[class*=cell]{padding:20px 50px}.el-table__expanded-cell:hover{background-color:transparent!important}.el-table__placeholder{display:inline-block;width:20px}.el-table__append-wrapper{overflow:hidden}.el-table--fit{border-bottom:0;border-right:0}.el-table--fit .el-table__cell.gutter{border-right-width:1px}.el-table--fit .el-table__inner-wrapper:before{width:100%}.el-table thead{color:var(--el-table-header-text-color)}.el-table thead th{font-weight:600}.el-table thead.is-group th.el-table__cell{background:var(--el-fill-color-light)}.el-table .el-table__cell{box-sizing:border-box;min-width:0;padding:8px 0;position:relative;text-align:left;text-overflow:ellipsis;vertical-align:middle;z-index:var(--el-table-index)}.el-table .el-table__cell.is-center{text-align:center}.el-table .el-table__cell.is-right{text-align:right}.el-table .el-table__cell.gutter{border-bottom-width:0;border-right-width:0;padding:0;width:15px}.el-table .el-table__cell.is-hidden>*{visibility:hidden}.el-table .cell{box-sizing:border-box;line-height:23px;overflow:hidden;overflow-wrap:break-word;padding:0 12px;text-overflow:ellipsis;white-space:normal}.el-table .cell.el-tooltip{min-width:50px;white-space:nowrap}.el-table--large{font-size:var(--el-font-size-base)}.el-table--large .el-table__cell{padding:12px 0}.el-table--large .cell{padding:0 16px}.el-table--default{font-size:var(--el-font-size-base)}.el-table--default .el-table__cell{padding:8px 0}.el-table--default .cell{padding:0 12px}.el-table--small{font-size:var(--el-font-size-extra-small)}.el-table--small .el-table__cell{padding:4px 0}.el-table--small .cell{padding:0 8px}.el-table tr{background-color:var(--el-table-tr-bg-color)}.el-table tr input[type=checkbox]{margin:0}.el-table td.el-table__cell,.el-table th.el-table__cell.is-leaf{border-bottom:var(--el-table-border)}.el-table th.el-table__cell.is-sortable{cursor:pointer}.el-table th.el-table__cell{background-color:var(--el-table-header-bg-color)}.el-table th.el-table__cell>.cell.highlight{color:var(--el-color-primary)}.el-table th.el-table__cell.required>div:before{background:#ff4d51;border-radius:50%;content:"";display:inline-block;height:8px;margin-right:5px;vertical-align:middle;width:8px}.el-table td.el-table__cell div{box-sizing:border-box}.el-table td.el-table__cell.gutter{width:0}.el-table--border .el-table__inner-wrapper:after,.el-table--border:after,.el-table--border:before,.el-table__inner-wrapper:before{background-color:var(--el-table-border-color);content:"";position:absolute;z-index:calc(var(--el-table-index) + 2)}.el-table--border .el-table__inner-wrapper:after{height:1px;left:0;top:0;width:100%;z-index:calc(var(--el-table-index) + 2)}.el-table--border:before{height:100%;left:0;top:-1px;width:1px}.el-table--border:after{height:100%;right:0;top:-1px;width:1px}.el-table--border .el-table__inner-wrapper{border-bottom:none;border-right:none}.el-table--border .el-table__footer-wrapper{flex-shrink:0;position:relative}.el-table--border .el-table__cell{border-right:var(--el-table-border)}.el-table--border th.el-table__cell.gutter:last-of-type{border-bottom:var(--el-table-border);border-bottom-width:1px}.el-table--border th.el-table__cell{border-bottom:var(--el-table-border)}.el-table--hidden{visibility:hidden}.el-table__body-wrapper,.el-table__footer-wrapper,.el-table__header-wrapper{width:100%}.el-table__body-wrapper tr td.el-table-fixed-column--left,.el-table__body-wrapper tr td.el-table-fixed-column--right,.el-table__body-wrapper tr th.el-table-fixed-column--left,.el-table__body-wrapper tr th.el-table-fixed-column--right,.el-table__footer-wrapper tr td.el-table-fixed-column--left,.el-table__footer-wrapper tr td.el-table-fixed-column--right,.el-table__footer-wrapper tr th.el-table-fixed-column--left,.el-table__footer-wrapper tr th.el-table-fixed-column--right,.el-table__header-wrapper tr td.el-table-fixed-column--left,.el-table__header-wrapper tr td.el-table-fixed-column--right,.el-table__header-wrapper tr th.el-table-fixed-column--left,.el-table__header-wrapper tr th.el-table-fixed-column--right{background:inherit;position:sticky!important;z-index:calc(var(--el-table-index) + 1)}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-last-column:before{bottom:-1px;box-shadow:none;content:"";overflow-x:hidden;overflow-y:hidden;pointer-events:none;position:absolute;top:0;touch-action:none;width:10px}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-first-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-first-column:before{left:-10px}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-last-column:before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-last-column:before{right:-10px}.el-table__body-wrapper tr td.el-table__fixed-right-patch,.el-table__body-wrapper tr th.el-table__fixed-right-patch,.el-table__footer-wrapper tr td.el-table__fixed-right-patch,.el-table__footer-wrapper tr th.el-table__fixed-right-patch,.el-table__header-wrapper tr td.el-table__fixed-right-patch,.el-table__header-wrapper tr th.el-table__fixed-right-patch{background:#fff;position:sticky!important;right:0;z-index:calc(var(--el-table-index) + 1)}.el-table__header-wrapper{flex-shrink:0}.el-table__header-wrapper tr th.el-table-fixed-column--left,.el-table__header-wrapper tr th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table__body,.el-table__footer,.el-table__header{border-collapse:separate;table-layout:fixed}.el-table__header-wrapper{overflow:hidden}.el-table__header-wrapper tbody td.el-table__cell{background-color:var(--el-table-row-hover-bg-color);color:var(--el-table-text-color)}.el-table__footer-wrapper{flex-shrink:0;overflow:hidden}.el-table__footer-wrapper tfoot td.el-table__cell{background-color:var(--el-table-row-hover-bg-color);color:var(--el-table-text-color)}.el-table__body-wrapper .el-table-column--selection>.cell,.el-table__header-wrapper .el-table-column--selection>.cell{align-items:center;display:inline-flex;height:23px}.el-table__body-wrapper .el-table-column--selection .el-checkbox,.el-table__header-wrapper .el-table-column--selection .el-checkbox{height:unset}.el-table.is-scrolling-left .el-table-fixed-column--right.is-first-column:before{box-shadow:var(--el-table-fixed-right-column)}.el-table.is-scrolling-left.el-table--border .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:var(--el-table-border)}.el-table.is-scrolling-left th.el-table-fixed-column--left{background-color:var(--el-table-header-bg-color)}.el-table.is-scrolling-right .el-table-fixed-column--left.is-last-column:before{box-shadow:var(--el-table-fixed-left-column)}.el-table.is-scrolling-right .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:none}.el-table.is-scrolling-right th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table.is-scrolling-middle .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:none}.el-table.is-scrolling-middle .el-table-fixed-column--right.is-first-column:before{box-shadow:var(--el-table-fixed-right-column)}.el-table.is-scrolling-middle .el-table-fixed-column--left.is-last-column:before{box-shadow:var(--el-table-fixed-left-column)}.el-table.is-scrolling-none .el-table-fixed-column--left.is-first-column:before,.el-table.is-scrolling-none .el-table-fixed-column--left.is-last-column:before,.el-table.is-scrolling-none .el-table-fixed-column--right.is-first-column:before,.el-table.is-scrolling-none .el-table-fixed-column--right.is-last-column:before{box-shadow:none}.el-table.is-scrolling-none th.el-table-fixed-column--left,.el-table.is-scrolling-none th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table__body-wrapper{flex:1;overflow:hidden;position:relative}.el-table__body-wrapper .el-scrollbar__bar{z-index:calc(var(--el-table-index) + 2)}.el-table .caret-wrapper{align-items:center;cursor:pointer;display:inline-flex;flex-direction:column;height:14px;overflow:initial;position:relative;vertical-align:middle;width:24px}.el-table .sort-caret{border:5px solid transparent;height:0;left:7px;position:absolute;width:0}.el-table .sort-caret.ascending{border-bottom-color:var(--el-text-color-placeholder);top:-5px}.el-table .sort-caret.descending{border-top-color:var(--el-text-color-placeholder);bottom:-3px}.el-table .ascending .sort-caret.ascending{border-bottom-color:var(--el-color-primary)}.el-table .descending .sort-caret.descending{border-top-color:var(--el-color-primary)}.el-table .hidden-columns{position:absolute;visibility:hidden;z-index:-1}.el-table--striped .el-table__body tr.el-table__row--striped td.el-table__cell{background:var(--el-fill-color-lighter)}.el-table--striped .el-table__body tr.el-table__row--striped.current-row td.el-table__cell{background-color:var(--el-table-current-row-bg-color)}.el-table__body tr.hover-row.current-row>td.el-table__cell,.el-table__body tr.hover-row.el-table__row--striped.current-row>td.el-table__cell,.el-table__body tr.hover-row.el-table__row--striped>td.el-table__cell,.el-table__body tr.hover-row>td.el-table__cell,.el-table__body tr>td.hover-cell{background-color:var(--el-table-row-hover-bg-color)}.el-table__body tr.current-row>td.el-table__cell{background-color:var(--el-table-current-row-bg-color)}.el-table.el-table--scrollable-y .el-table__body-header{position:sticky;top:0;z-index:calc(var(--el-table-index) + 2)}.el-table.el-table--scrollable-y .el-table__body-footer{bottom:0;position:sticky;z-index:calc(var(--el-table-index) + 2)}.el-table__column-resize-proxy{border-left:var(--el-table-border);bottom:0;left:200px;position:absolute;top:0;width:0;z-index:calc(var(--el-table-index) + 9)}.el-table__column-filter-trigger{cursor:pointer;display:inline-block}.el-table__column-filter-trigger i{color:var(--el-color-info);font-size:14px;vertical-align:middle}.el-table__border-left-patch{height:100%;top:0;width:1px}.el-table__border-bottom-patch,.el-table__border-left-patch{background-color:var(--el-table-border-color);left:0;position:absolute;z-index:calc(var(--el-table-index) + 2)}.el-table__border-bottom-patch{height:1px}.el-table__border-right-patch{background-color:var(--el-table-border-color);height:100%;position:absolute;top:0;width:1px;z-index:calc(var(--el-table-index) + 2)}.el-table--enable-row-transition .el-table__body td.el-table__cell{transition:background-color .25s ease}.el-table--enable-row-hover .el-table__body tr:hover>td.el-table__cell{background-color:var(--el-table-row-hover-bg-color)}.el-table [class*=el-table__row--level] .el-table__expand-icon{display:inline-block;height:12px;line-height:12px;margin-right:8px;text-align:center;width:12px}.el-table .el-table.el-table--border .el-table__cell{border-right:var(--el-table-border)}.el-table:not(.el-table--border) .el-table__cell{border-right:none}.el-table:not(.el-table--border)>.el-table__inner-wrapper:after{content:none}.el-table-v2{--el-table-border-color:var(--el-border-color-lighter);--el-table-border:1px solid var(--el-table-border-color);--el-table-text-color:var(--el-text-color-regular);--el-table-header-text-color:var(--el-text-color-secondary);--el-table-row-hover-bg-color:var(--el-fill-color-light);--el-table-current-row-bg-color:var(--el-color-primary-light-9);--el-table-header-bg-color:var(--el-bg-color);--el-table-fixed-box-shadow:var(--el-box-shadow-light);--el-table-bg-color:var(--el-fill-color-blank);--el-table-tr-bg-color:var(--el-bg-color);--el-table-expanded-cell-bg-color:var(--el-fill-color-blank);--el-table-fixed-left-column:inset 10px 0 10px -10px rgba(0,0,0,0.15);--el-table-fixed-right-column:inset -10px 0 10px -10px rgba(0,0,0,0.15);--el-table-index:var(--el-index-normal);font-size:var(--el-font-size-base)}.el-table-v2 *{box-sizing:border-box}.el-table-v2__root{position:relative}.el-table-v2__root:hover .el-table-v2__main .el-virtual-scrollbar{opacity:1}.el-table-v2__main{background-color:var(--el-bg-color);display:flex;flex-direction:column-reverse;left:0;overflow:hidden;position:absolute;top:0}.el-table-v2__main .el-vl__horizontal,.el-table-v2__main .el-vl__vertical{z-index:2}.el-table-v2__left{background-color:var(--el-bg-color);box-shadow:2px 0 4px 0 rgba(0,0,0,.06);display:flex;flex-direction:column-reverse;left:0;overflow:hidden;position:absolute;top:0}.el-table-v2__left .el-virtual-scrollbar{opacity:0}.el-table-v2__left .el-vl__horizontal,.el-table-v2__left .el-vl__vertical{z-index:-1}.el-table-v2__right{background-color:var(--el-bg-color);box-shadow:-2px 0 4px 0 rgba(0,0,0,.06);display:flex;flex-direction:column-reverse;overflow:hidden;position:absolute;right:0;top:0}.el-table-v2__right .el-virtual-scrollbar{opacity:0}.el-table-v2__right .el-vl__horizontal,.el-table-v2__right .el-vl__vertical{z-index:-1}.el-table-v2__header-row,.el-table-v2__row{padding-inline-end:var(--el-table-scrollbar-size)}.el-table-v2__header-wrapper{overflow:hidden}.el-table-v2__header{overflow:hidden;position:relative}.el-table-v2__header .el-checkbox{z-index:0}.el-table-v2__footer{bottom:0;overflow:hidden;right:0}.el-table-v2__empty,.el-table-v2__footer,.el-table-v2__overlay{left:0;position:absolute}.el-table-v2__overlay{bottom:0;right:0;top:0;z-index:9999}.el-table-v2__header-row{border-bottom:var(--el-table-border);display:flex}.el-table-v2__header-cell{align-items:center;background-color:var(--el-table-header-bg-color);color:var(--el-table-header-text-color);display:flex;font-weight:bold;height:100%;overflow:hidden;padding:0 8px;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-table-v2__header-cell.is-align-center{justify-content:center;text-align:center}.el-table-v2__header-cell.is-align-right{justify-content:flex-end;text-align:right}.el-table-v2__header-cell.is-sortable{cursor:pointer}.el-table-v2__header-cell:hover .el-icon{display:block}.el-table-v2__sort-icon{display:none;opacity:.6;transition:opacity,display var(--el-transition-duration)}.el-table-v2__sort-icon.is-sorting{display:block;opacity:1}.el-table-v2__row{align-items:center;border-bottom:var(--el-table-border);display:flex;transition:background-color var(--el-transition-duration)}.el-table-v2__row.is-hovered,.el-table-v2__row:hover{background-color:var(--el-table-row-hover-bg-color)}.el-table-v2__row-cell{align-items:center;display:flex;height:100%;overflow:hidden;padding:0 8px}.el-table-v2__row-cell.is-align-center{justify-content:center;text-align:center}.el-table-v2__row-cell.is-align-right{justify-content:flex-end;text-align:right}.el-table-v2__expand-icon{cursor:pointer;margin:0 4px;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-table-v2__expand-icon svg{transition:transform var(--el-transition-duration)}.el-table-v2__expand-icon.is-expanded svg{transform:rotate(90deg)}.el-table-v2:not(.is-dynamic) .el-table-v2__cell-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-table-v2.is-dynamic .el-table-v2__row{align-items:stretch;overflow:hidden}.el-table-v2.is-dynamic .el-table-v2__row .el-table-v2__row-cell{overflow-wrap:break-word}.el-tabs{--el-tabs-header-height:40px;display:flex}.el-tabs__header{align-items:center;display:flex;justify-content:space-between;margin:0 0 15px;padding:0;position:relative}.el-tabs__header-vertical{flex-direction:column}.el-tabs__active-bar{background-color:var(--el-color-primary);bottom:0;height:2px;left:0;list-style:none;position:absolute;transition:width var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier),transform var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);z-index:1}.el-tabs__new-tab{align-items:center;border:1px solid var(--el-border-color);border-radius:3px;color:var(--el-text-color-primary);cursor:pointer;display:flex;flex-shrink:0;font-size:12px;height:20px;justify-content:center;line-height:20px;margin:10px 0 10px 10px;text-align:center;transition:all .15s;width:20px}.el-tabs__new-tab .is-icon-plus{height:inherit;transform:scale(.8);width:inherit}.el-tabs__new-tab .is-icon-plus svg{vertical-align:middle}.el-tabs__new-tab:hover{color:var(--el-color-primary)}.el-tabs__new-tab-vertical{margin-left:0}.el-tabs__nav-wrap{flex:1 auto;margin-bottom:-1px;overflow:hidden;position:relative}.el-tabs__nav-wrap:after{background-color:var(--el-border-color-light);bottom:0;content:"";height:2px;left:0;position:absolute;width:100%;z-index:var(--el-index-normal)}.el-tabs__nav-wrap.is-scrollable{box-sizing:border-box;padding:0 20px}.el-tabs__nav-scroll{overflow:hidden}.el-tabs__nav-next,.el-tabs__nav-prev{color:var(--el-text-color-secondary);cursor:pointer;font-size:12px;line-height:44px;position:absolute;text-align:center;width:20px}.el-tabs__nav-next{right:0}.el-tabs__nav-prev{left:0}.el-tabs__nav{display:flex;float:left;position:relative;transition:transform var(--el-transition-duration);white-space:nowrap;z-index:calc(var(--el-index-normal) + 1)}.el-tabs__nav.is-stretch{display:flex;min-width:100%}.el-tabs__nav.is-stretch>*{flex:1;text-align:center}.el-tabs__item{align-items:center;box-sizing:border-box;color:var(--el-text-color-primary);display:flex;font-size:var(--el-font-size-base);font-weight:500;height:var(--el-tabs-header-height);justify-content:center;list-style:none;padding:0 20px;position:relative}.el-tabs__item:focus,.el-tabs__item:focus:active{outline:none}.el-tabs__item:focus-visible{border-radius:3px;box-shadow:0 0 2px 2px var(--el-color-primary) inset}.el-tabs__item .is-icon-close{border-radius:50%;margin-left:5px;text-align:center;transition:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier)}.el-tabs__item .is-icon-close:before{display:inline-block;transform:scale(.9)}.el-tabs__item .is-icon-close:hover{background-color:var(--el-text-color-placeholder);color:#ffffff}.el-tabs__item.is-active,.el-tabs__item:hover{color:var(--el-color-primary)}.el-tabs__item:hover{cursor:pointer}.el-tabs__item.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-tabs__content{flex-grow:1;overflow:hidden;position:relative}.el-tabs--bottom>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top>.el-tabs__header .el-tabs__item:nth-child(2){padding-left:0}.el-tabs--bottom>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top>.el-tabs__header .el-tabs__item:last-child{padding-right:0}.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2){padding-left:20px}.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:last-child{padding-right:20px}.el-tabs--card>.el-tabs__header{border-bottom:1px solid var(--el-border-color-light);box-sizing:border-box;height:var(--el-tabs-header-height)}.el-tabs--card>.el-tabs__header .el-tabs__nav-wrap:after{content:none}.el-tabs--card>.el-tabs__header .el-tabs__nav{border:1px solid var(--el-border-color-light);border-bottom:none;border-radius:4px 4px 0 0;box-sizing:border-box}.el-tabs--card>.el-tabs__header .el-tabs__active-bar{display:none}.el-tabs--card>.el-tabs__header .el-tabs__item .is-icon-close{font-size:12px;height:14px;overflow:hidden;position:relative;right:-2px;transform-origin:100% 50%;width:0}.el-tabs--card>.el-tabs__header .el-tabs__item{border-bottom:1px solid transparent;border-left:1px solid var(--el-border-color-light);margin-top:-1px;transition:color var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier),padding var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier)}.el-tabs--card>.el-tabs__header .el-tabs__item:first-child{border-left:none}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover{padding-left:13px;padding-right:13px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover .is-icon-close{width:14px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active{border-bottom-color:var(--el-bg-color)}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable{padding-left:20px;padding-right:20px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable .is-icon-close{width:14px}.el-tabs--border-card{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color)}.el-tabs--border-card>.el-tabs__content{padding:15px}.el-tabs--border-card>.el-tabs__header{background-color:var(--el-fill-color-light);border-bottom:1px solid var(--el-border-color-light);margin:0}.el-tabs--border-card>.el-tabs__header .el-tabs__nav-wrap:after{content:none}.el-tabs--border-card>.el-tabs__header .el-tabs__item{border:1px solid transparent;color:var(--el-text-color-secondary);margin-top:-1px;transition:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier)}.el-tabs--border-card>.el-tabs__header .el-tabs__item+.el-tabs__item,.el-tabs--border-card>.el-tabs__header .el-tabs__item:first-child{margin-left:-1px}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-active{background-color:var(--el-bg-color-overlay);border-left-color:var(--el-border-color);border-right-color:var(--el-border-color);color:var(--el-color-primary)}.el-tabs--border-card>.el-tabs__header .el-tabs__item:not(.is-disabled):hover{color:var(--el-color-primary)}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-disabled{color:var(--el-disabled-text-color)}.el-tabs--border-card>.el-tabs__header .is-scrollable .el-tabs__item:first-child{margin-left:0}.el-tabs--bottom{flex-direction:column}.el-tabs--bottom .el-tabs__header.is-bottom{margin-bottom:0;margin-top:10px}.el-tabs--bottom.el-tabs--border-card .el-tabs__header.is-bottom{border-bottom:0;border-top:1px solid var(--el-border-color)}.el-tabs--bottom.el-tabs--border-card .el-tabs__nav-wrap.is-bottom{margin-bottom:0;margin-top:-1px}.el-tabs--bottom.el-tabs--border-card .el-tabs__item.is-bottom:not(.is-active){border:1px solid transparent}.el-tabs--bottom.el-tabs--border-card .el-tabs__item.is-bottom{margin:0 -1px -1px}.el-tabs--left,.el-tabs--right{overflow:hidden}.el-tabs--left .el-tabs__header.is-left,.el-tabs--left .el-tabs__header.is-right,.el-tabs--left .el-tabs__nav-scroll,.el-tabs--left .el-tabs__nav-wrap.is-left,.el-tabs--left .el-tabs__nav-wrap.is-right,.el-tabs--right .el-tabs__header.is-left,.el-tabs--right .el-tabs__header.is-right,.el-tabs--right .el-tabs__nav-scroll,.el-tabs--right .el-tabs__nav-wrap.is-left,.el-tabs--right .el-tabs__nav-wrap.is-right{height:100%}.el-tabs--left .el-tabs__active-bar.is-left,.el-tabs--left .el-tabs__active-bar.is-right,.el-tabs--right .el-tabs__active-bar.is-left,.el-tabs--right .el-tabs__active-bar.is-right{bottom:auto;height:auto;top:0;width:2px}.el-tabs--left .el-tabs__nav-wrap.is-left,.el-tabs--left .el-tabs__nav-wrap.is-right,.el-tabs--right .el-tabs__nav-wrap.is-left,.el-tabs--right .el-tabs__nav-wrap.is-right{margin-bottom:0}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev{cursor:pointer;height:30px;line-height:30px;text-align:center;width:100%}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next i,.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev i,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next i,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev i,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next i,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev i,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next i,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev i{transform:rotate(90deg)}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev{left:auto;top:0}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next{bottom:0;right:auto}.el-tabs--left .el-tabs__nav-wrap.is-left.is-scrollable,.el-tabs--left .el-tabs__nav-wrap.is-right.is-scrollable,.el-tabs--right .el-tabs__nav-wrap.is-left.is-scrollable,.el-tabs--right .el-tabs__nav-wrap.is-right.is-scrollable{padding:30px 0}.el-tabs--left .el-tabs__nav-wrap.is-left:after,.el-tabs--left .el-tabs__nav-wrap.is-right:after,.el-tabs--right .el-tabs__nav-wrap.is-left:after,.el-tabs--right .el-tabs__nav-wrap.is-right:after{bottom:auto;height:100%;top:0;width:2px}.el-tabs--left .el-tabs__nav.is-left,.el-tabs--left .el-tabs__nav.is-right,.el-tabs--right .el-tabs__nav.is-left,.el-tabs--right .el-tabs__nav.is-right{flex-direction:column}.el-tabs--left .el-tabs__item.is-left,.el-tabs--right .el-tabs__item.is-left{justify-content:flex-end}.el-tabs--left .el-tabs__item.is-right,.el-tabs--right .el-tabs__item.is-right{justify-content:flex-start}.el-tabs--left{flex-direction:row}.el-tabs--left .el-tabs__header.is-left{margin-bottom:0;margin-right:10px}.el-tabs--left .el-tabs__nav-wrap.is-left{margin-right:-1px}.el-tabs--left .el-tabs__active-bar.is-left,.el-tabs--left .el-tabs__nav-wrap.is-left:after{left:auto;right:0}.el-tabs--left .el-tabs__item.is-left{text-align:right}.el-tabs--left.el-tabs--card .el-tabs__active-bar.is-left{display:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left{border-bottom:none;border-left:none;border-right:1px solid var(--el-border-color-light);border-top:1px solid var(--el-border-color-light);text-align:left}.el-tabs--left.el-tabs--card .el-tabs__item.is-left:first-child{border-right:1px solid var(--el-border-color-light);border-top:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active{border:1px solid var(--el-border-color-light);border-bottom:none;border-left:none;border-right:1px solid #fff}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active:first-child{border-top:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active:last-child{border-bottom:none}.el-tabs--left.el-tabs--card .el-tabs__nav{border-bottom:1px solid var(--el-border-color-light);border-radius:4px 0 0 4px;border-right:none}.el-tabs--left.el-tabs--card .el-tabs__new-tab{float:none}.el-tabs--left.el-tabs--border-card .el-tabs__header.is-left{border-right:1px solid var(--el-border-color)}.el-tabs--left.el-tabs--border-card .el-tabs__item.is-left{border:1px solid transparent;margin:-1px 0 -1px -1px}.el-tabs--left.el-tabs--border-card .el-tabs__item.is-left.is-active{border-color:rgb(209,219,229) transparent}.el-tabs--left>.el-tabs__content+.el-tabs__header{order:-1}.el-tabs--right .el-tabs__header.is-right{margin-bottom:0;margin-left:10px}.el-tabs--right .el-tabs__nav-wrap.is-right{margin-left:-1px}.el-tabs--right .el-tabs__nav-wrap.is-right:after{left:0;right:auto}.el-tabs--right .el-tabs__active-bar.is-right{left:0}.el-tabs--right.el-tabs--card .el-tabs__active-bar.is-right{display:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right{border-bottom:none;border-top:1px solid var(--el-border-color-light)}.el-tabs--right.el-tabs--card .el-tabs__item.is-right:first-child{border-left:1px solid var(--el-border-color-light);border-top:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active{border:1px solid var(--el-border-color-light);border-bottom:none;border-left:1px solid #fff;border-right:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active:first-child{border-top:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active:last-child{border-bottom:none}.el-tabs--right.el-tabs--card .el-tabs__nav{border-bottom:1px solid var(--el-border-color-light);border-left:none;border-radius:0 4px 4px 0}.el-tabs--right.el-tabs--border-card .el-tabs__header.is-right{border-left:1px solid var(--el-border-color)}.el-tabs--right.el-tabs--border-card .el-tabs__item.is-right{border:1px solid transparent;margin:-1px -1px -1px 0}.el-tabs--right.el-tabs--border-card .el-tabs__item.is-right.is-active{border-color:rgb(209,219,229) transparent}.el-tabs--top{flex-direction:column}.el-tabs--top>.el-tabs__content+.el-tabs__header{order:-1}.slideInLeft-transition,.slideInRight-transition{display:inline-block}.slideInRight-enter{animation:slideInRight-enter var(--el-transition-duration)}.slideInRight-leave{animation:slideInRight-leave var(--el-transition-duration);left:0;position:absolute;right:0}.slideInLeft-enter{animation:slideInLeft-enter var(--el-transition-duration)}.slideInLeft-leave{animation:slideInLeft-leave var(--el-transition-duration);left:0;position:absolute;right:0}@keyframes slideInRight-enter{0%{opacity:0;transform:translateX(100%);transform-origin:0 0}to{opacity:1;transform:translateX(0);transform-origin:0 0}}@keyframes slideInRight-leave{0%{opacity:1;transform:translateX(0);transform-origin:0 0}to{opacity:0;transform:translateX(100%);transform-origin:0 0}}@keyframes slideInLeft-enter{0%{opacity:0;transform:translateX(-100%);transform-origin:0 0}to{opacity:1;transform:translateX(0);transform-origin:0 0}}@keyframes slideInLeft-leave{0%{opacity:1;transform:translateX(0);transform-origin:0 0}to{opacity:0;transform:translateX(-100%);transform-origin:0 0}}.el-tag{--el-tag-font-size:12px;--el-tag-border-radius:4px;--el-tag-border-radius-rounded:9999px;align-items:center;background-color:var(--el-tag-bg-color);border-color:var(--el-tag-border-color);border-radius:var(--el-tag-border-radius);border-style:solid;border-width:1px;box-sizing:border-box;color:var(--el-tag-text-color);display:inline-flex;font-size:var(--el-tag-font-size);height:24px;justify-content:center;line-height:1;padding:0 9px;vertical-align:middle;white-space:nowrap;--el-icon-size:14px}.el-tag,.el-tag.el-tag--primary{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-bg-color:var(--el-color-success-light-9);--el-tag-border-color:var(--el-color-success-light-8);--el-tag-hover-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-bg-color:var(--el-color-warning-light-9);--el-tag-border-color:var(--el-color-warning-light-8);--el-tag-hover-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-bg-color:var(--el-color-danger-light-9);--el-tag-border-color:var(--el-color-danger-light-8);--el-tag-hover-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-bg-color:var(--el-color-error-light-9);--el-tag-border-color:var(--el-color-error-light-8);--el-tag-hover-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-bg-color:var(--el-color-info-light-9);--el-tag-border-color:var(--el-color-info-light-8);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-hit{border-color:var(--el-color-primary)}.el-tag.is-round{border-radius:var(--el-tag-border-radius-rounded)}.el-tag .el-tag__close{color:var(--el-tag-text-color);flex-shrink:0}.el-tag .el-tag__close:hover{background-color:var(--el-tag-hover-color);color:var(--el-color-white)}.el-tag.el-tag--primary{--el-tag-text-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-text-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-text-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-text-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-text-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-text-color:var(--el-color-info)}.el-tag .el-icon{border-radius:50%;cursor:pointer;font-size:calc(var(--el-icon-size) - 2px);height:var(--el-icon-size);width:var(--el-icon-size)}.el-tag .el-tag__close{margin-left:6px}.el-tag--dark{--el-tag-text-color:var(--el-color-white)}.el-tag--dark,.el-tag--dark.el-tag--primary{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3)}.el-tag--dark.el-tag--success{--el-tag-bg-color:var(--el-color-success);--el-tag-border-color:var(--el-color-success);--el-tag-hover-color:var(--el-color-success-light-3)}.el-tag--dark.el-tag--warning{--el-tag-bg-color:var(--el-color-warning);--el-tag-border-color:var(--el-color-warning);--el-tag-hover-color:var(--el-color-warning-light-3)}.el-tag--dark.el-tag--danger{--el-tag-bg-color:var(--el-color-danger);--el-tag-border-color:var(--el-color-danger);--el-tag-hover-color:var(--el-color-danger-light-3)}.el-tag--dark.el-tag--error{--el-tag-bg-color:var(--el-color-error);--el-tag-border-color:var(--el-color-error);--el-tag-hover-color:var(--el-color-error-light-3)}.el-tag--dark.el-tag--info{--el-tag-bg-color:var(--el-color-info);--el-tag-border-color:var(--el-color-info);--el-tag-hover-color:var(--el-color-info-light-3)}.el-tag--dark.el-tag--danger,.el-tag--dark.el-tag--error,.el-tag--dark.el-tag--info,.el-tag--dark.el-tag--primary,.el-tag--dark.el-tag--success,.el-tag--dark.el-tag--warning{--el-tag-text-color:var(--el-color-white)}.el-tag--plain,.el-tag--plain.el-tag--primary{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary)}.el-tag--plain.el-tag--success{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-success-light-5);--el-tag-hover-color:var(--el-color-success)}.el-tag--plain.el-tag--warning{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-warning-light-5);--el-tag-hover-color:var(--el-color-warning)}.el-tag--plain.el-tag--danger{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-danger-light-5);--el-tag-hover-color:var(--el-color-danger)}.el-tag--plain.el-tag--error{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-error-light-5);--el-tag-hover-color:var(--el-color-error)}.el-tag--plain.el-tag--info{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-info-light-5);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-closable{padding-right:5px}.el-tag--large{height:32px;padding:0 11px;--el-icon-size:16px}.el-tag--large .el-tag__close{margin-left:8px}.el-tag--large.is-closable{padding-right:7px}.el-tag--small{height:20px;padding:0 7px;--el-icon-size:12px}.el-tag--small .el-tag__close{margin-left:4px}.el-tag--small.is-closable{padding-right:3px}.el-tag--small .el-icon-close{transform:scale(.8)}.el-tag.el-tag--primary.is-hit{border-color:var(--el-color-primary)}.el-tag.el-tag--success.is-hit{border-color:var(--el-color-success)}.el-tag.el-tag--warning.is-hit{border-color:var(--el-color-warning)}.el-tag.el-tag--danger.is-hit{border-color:var(--el-color-danger)}.el-tag.el-tag--error.is-hit{border-color:var(--el-color-error)}.el-tag.el-tag--info.is-hit{border-color:var(--el-color-info)}.el-text{--el-text-font-size:var(--el-font-size-base);--el-text-color:var(--el-text-color-regular);align-self:center;color:var(--el-text-color);font-size:var(--el-text-font-size);margin:0;overflow-wrap:break-word;padding:0}.el-text.is-truncated{display:inline-block;max-width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-text.is-line-clamp{display:-webkit-inline-box;-webkit-box-orient:vertical;overflow:hidden}.el-text--large{--el-text-font-size:var(--el-font-size-medium)}.el-text--default{--el-text-font-size:var(--el-font-size-base)}.el-text--small{--el-text-font-size:var(--el-font-size-extra-small)}.el-text.el-text--primary{--el-text-color:var(--el-color-primary)}.el-text.el-text--success{--el-text-color:var(--el-color-success)}.el-text.el-text--warning{--el-text-color:var(--el-color-warning)}.el-text.el-text--danger{--el-text-color:var(--el-color-danger)}.el-text.el-text--error{--el-text-color:var(--el-color-error)}.el-text.el-text--info{--el-text-color:var(--el-color-info)}.el-text>.el-icon{vertical-align:-2px}.time-select{margin:5px 0;min-width:0}.time-select .el-picker-panel__content{margin:0;max-height:200px}.time-select-item{font-size:14px;line-height:20px;padding:8px 10px}.time-select-item.disabled{color:var(--el-datepicker-border-color);cursor:not-allowed}.time-select-item:hover{background-color:var(--el-fill-color-light);cursor:pointer;font-weight:bold}.time-select .time-select-item.selected:not(.disabled){color:var(--el-color-primary);font-weight:bold}.el-timeline-item{padding-bottom:20px;position:relative}.el-timeline-item__wrapper{padding-left:28px;position:relative;top:-3px}.el-timeline-item__tail{border-left:2px solid var(--el-timeline-node-color);height:100%;left:4px;position:absolute}.el-timeline-item .el-timeline-item__icon{color:var(--el-color-white);font-size:var(--el-font-size-small)}.el-timeline-item__node{align-items:center;background-color:var(--el-timeline-node-color);border-color:var(--el-timeline-node-color);border-radius:50%;box-sizing:border-box;display:flex;justify-content:center;position:absolute}.el-timeline-item__node--normal{height:var(--el-timeline-node-size-normal);left:-1px;width:var(--el-timeline-node-size-normal)}.el-timeline-item__node--large{height:var(--el-timeline-node-size-large);left:-2px;width:var(--el-timeline-node-size-large)}.el-timeline-item__node.is-hollow{background:var(--el-color-white);border-style:solid;border-width:2px}.el-timeline-item__node--primary{background-color:var(--el-color-primary);border-color:var(--el-color-primary)}.el-timeline-item__node--success{background-color:var(--el-color-success);border-color:var(--el-color-success)}.el-timeline-item__node--warning{background-color:var(--el-color-warning);border-color:var(--el-color-warning)}.el-timeline-item__node--danger{background-color:var(--el-color-danger);border-color:var(--el-color-danger)}.el-timeline-item__node--info{background-color:var(--el-color-info);border-color:var(--el-color-info)}.el-timeline-item__dot{align-items:center;display:flex;justify-content:center;position:absolute}.el-timeline-item__content{color:var(--el-text-color-primary)}.el-timeline-item__timestamp{color:var(--el-text-color-secondary);font-size:var(--el-font-size-small);line-height:1}.el-timeline-item__timestamp.is-top{margin-bottom:8px;padding-top:4px}.el-timeline-item__timestamp.is-bottom{margin-top:8px}.el-timeline{--el-timeline-node-size-normal:12px;--el-timeline-node-size-large:14px;--el-timeline-node-color:var(--el-border-color-light);font-size:var(--el-font-size-base);list-style:none;margin:0}.el-timeline .el-timeline-item:last-child .el-timeline-item__tail{display:none}.el-timeline .el-timeline-item__center{align-items:center;display:flex}.el-timeline .el-timeline-item__center .el-timeline-item__wrapper{width:100%}.el-timeline .el-timeline-item__center .el-timeline-item__tail{top:0}.el-timeline .el-timeline-item__center:first-child .el-timeline-item__tail{height:calc(50% + 10px);top:calc(50% - 10px)}.el-timeline .el-timeline-item__center:last-child .el-timeline-item__tail{display:block;height:calc(50% - 10px)}.el-tooltip-v2__content{--el-tooltip-v2-padding:5px 10px;--el-tooltip-v2-border-radius:4px;--el-tooltip-v2-border-color:var(--el-border-color);background-color:var(--el-color-white);border:1px solid var(--el-border-color);border-radius:var(--el-tooltip-v2-border-radius);color:var(--el-color-black);padding:var(--el-tooltip-v2-padding)}.el-tooltip-v2__arrow{color:var(--el-color-white);height:var(--el-tooltip-v2-arrow-height);left:var(--el-tooltip-v2-arrow-x);pointer-events:none;position:absolute;top:var(--el-tooltip-v2-arrow-y);width:var(--el-tooltip-v2-arrow-width)}.el-tooltip-v2__arrow:after,.el-tooltip-v2__arrow:before{border:var(--el-tooltip-v2-arrow-border-width) solid transparent;content:"";height:0;position:absolute;width:0}.el-tooltip-v2__content[data-side^=top] .el-tooltip-v2__arrow{bottom:0}.el-tooltip-v2__content[data-side^=top] .el-tooltip-v2__arrow:before{border-bottom:0;border-top-color:var(--el-color-white);border-top-width:var(--el-tooltip-v2-arrow-border-width);top:calc(100% - 1px)}.el-tooltip-v2__content[data-side^=top] .el-tooltip-v2__arrow:after{border-bottom:0;border-top-color:var(--el-border-color);border-top-width:var(--el-tooltip-v2-arrow-border-width);top:100%;z-index:-1}.el-tooltip-v2__content[data-side^=bottom] .el-tooltip-v2__arrow{top:0}.el-tooltip-v2__content[data-side^=bottom] .el-tooltip-v2__arrow:before{border-bottom-color:var(--el-color-white);border-bottom-width:var(--el-tooltip-v2-arrow-border-width);border-top:0;bottom:calc(100% - 1px)}.el-tooltip-v2__content[data-side^=bottom] .el-tooltip-v2__arrow:after{border-bottom-color:var(--el-border-color);border-bottom-width:var(--el-tooltip-v2-arrow-border-width);border-top:0;bottom:100%;z-index:-1}.el-tooltip-v2__content[data-side^=left] .el-tooltip-v2__arrow{right:0}.el-tooltip-v2__content[data-side^=left] .el-tooltip-v2__arrow:before{border-left-color:var(--el-color-white);border-left-width:var(--el-tooltip-v2-arrow-border-width);border-right:0;left:calc(100% - 1px)}.el-tooltip-v2__content[data-side^=left] .el-tooltip-v2__arrow:after{border-left-color:var(--el-border-color);border-left-width:var(--el-tooltip-v2-arrow-border-width);border-right:0;left:100%;z-index:-1}.el-tooltip-v2__content[data-side^=right] .el-tooltip-v2__arrow{left:0}.el-tooltip-v2__content[data-side^=right] .el-tooltip-v2__arrow:before{border-left:0;border-right-color:var(--el-color-white);border-right-width:var(--el-tooltip-v2-arrow-border-width);right:calc(100% - 1px)}.el-tooltip-v2__content[data-side^=right] .el-tooltip-v2__arrow:after{border-left:0;border-right-color:var(--el-border-color);border-right-width:var(--el-tooltip-v2-arrow-border-width);right:100%;z-index:-1}.el-tooltip-v2__content.is-dark{--el-tooltip-v2-border-color:transparent;color:var(--el-color-white)}.el-tooltip-v2__content.is-dark,.el-tooltip-v2__content.is-dark .el-tooltip-v2__arrow{background-color:var(--el-color-black);border-color:transparent}.el-transfer{--el-transfer-border-color:var(--el-border-color-lighter);--el-transfer-border-radius:var(--el-border-radius-base);--el-transfer-panel-width:200px;--el-transfer-panel-header-height:40px;--el-transfer-panel-header-bg-color:var(--el-fill-color-light);--el-transfer-panel-footer-height:40px;--el-transfer-panel-body-height:278px;--el-transfer-item-height:30px;--el-transfer-filter-height:32px;font-size:var(--el-font-size-base)}.el-transfer__buttons{display:inline-block;padding:0 30px;vertical-align:middle}.el-transfer__button{vertical-align:top}.el-transfer__button:nth-child(2){margin:0 0 0 10px}.el-transfer__button i,.el-transfer__button span{font-size:14px}.el-transfer__button .el-icon+span{margin-left:0}.el-transfer-panel{background:var(--el-bg-color-overlay);box-sizing:border-box;display:inline-block;max-height:100%;overflow:hidden;position:relative;text-align:left;vertical-align:middle;width:var(--el-transfer-panel-width)}.el-transfer-panel__body{border-bottom:1px solid var(--el-transfer-border-color);border-bottom-left-radius:var(--el-transfer-border-radius);border-bottom-right-radius:var(--el-transfer-border-radius);border-left:1px solid var(--el-transfer-border-color);border-right:1px solid var(--el-transfer-border-color);height:var(--el-transfer-panel-body-height);overflow:hidden}.el-transfer-panel__body.is-with-footer{border-bottom:none;border-bottom-left-radius:0;border-bottom-right-radius:0}.el-transfer-panel__list{box-sizing:border-box;height:var(--el-transfer-panel-body-height);list-style:none;margin:0;overflow:auto;padding:6px 0}.el-transfer-panel__list.is-filterable{height:calc(100% - var(--el-transfer-filter-height) - 30px);padding-top:0}.el-transfer-panel__item{display:block!important;height:var(--el-transfer-item-height);line-height:var(--el-transfer-item-height);padding-left:15px}.el-transfer-panel__item+.el-transfer-panel__item{margin-left:0}.el-transfer-panel__item.el-checkbox{color:var(--el-text-color-regular);margin-right:30px}.el-transfer-panel__item:hover{color:var(--el-color-primary)}.el-transfer-panel__item.el-checkbox .el-checkbox__label{box-sizing:border-box;display:block;line-height:var(--el-transfer-item-height);overflow:hidden;padding-left:22px;text-overflow:ellipsis;white-space:nowrap;width:100%}.el-transfer-panel__item .el-checkbox__input{position:absolute;top:8px}.el-transfer-panel__filter{box-sizing:border-box;padding:15px;text-align:center}.el-transfer-panel__filter .el-input__inner{box-sizing:border-box;display:inline-block;font-size:12px;height:var(--el-transfer-filter-height);width:100%}.el-transfer-panel__filter .el-icon-circle-close{cursor:pointer}.el-transfer-panel .el-transfer-panel__header{align-items:center;background:var(--el-transfer-panel-header-bg-color);border:1px solid var(--el-transfer-border-color);border-top-left-radius:var(--el-transfer-border-radius);border-top-right-radius:var(--el-transfer-border-radius);box-sizing:border-box;color:var(--el-color-black);display:flex;height:var(--el-transfer-panel-header-height);margin:0;padding-left:15px}.el-transfer-panel .el-transfer-panel__header .el-checkbox{align-items:center;display:flex;position:relative;width:100%}.el-transfer-panel .el-transfer-panel__header .el-checkbox .el-checkbox__label{color:var(--el-text-color-primary);font-size:16px;font-weight:normal}.el-transfer-panel .el-transfer-panel__header .el-checkbox .el-checkbox__label span{color:var(--el-text-color-secondary);font-size:12px;font-weight:normal;position:absolute;right:15px;top:50%;transform:translate3d(0,-50%,0)}.el-transfer-panel .el-transfer-panel__footer{background:var(--el-bg-color-overlay);border:1px solid var(--el-transfer-border-color);border-bottom-left-radius:var(--el-transfer-border-radius);border-bottom-right-radius:var(--el-transfer-border-radius);height:var(--el-transfer-panel-footer-height);margin:0;padding:0}.el-transfer-panel .el-transfer-panel__footer:after{content:"";display:inline-block;height:100%;vertical-align:middle}.el-transfer-panel .el-transfer-panel__footer .el-checkbox{color:var(--el-text-color-regular);padding-left:20px}.el-transfer-panel .el-transfer-panel__empty{color:var(--el-text-color-secondary);height:var(--el-transfer-item-height);line-height:var(--el-transfer-item-height);margin:0;padding:6px 15px 0;text-align:center}.el-transfer-panel .el-checkbox__label{padding-left:8px}.el-tree{--el-tree-node-content-height:26px;--el-tree-node-hover-bg-color:var(--el-fill-color-light);--el-tree-text-color:var(--el-text-color-regular);--el-tree-expand-icon-color:var(--el-text-color-placeholder);background:var(--el-fill-color-blank);color:var(--el-tree-text-color);cursor:default;font-size:var(--el-font-size-base);position:relative}.el-tree__empty-block{height:100%;min-height:60px;position:relative;text-align:center;width:100%}.el-tree__empty-text{color:var(--el-text-color-secondary);font-size:var(--el-font-size-base);left:50%;position:absolute;top:50%;transform:translate(-50%,-50%)}.el-tree__drop-indicator{background-color:var(--el-color-primary);height:1px;left:0;position:absolute;right:0}.el-tree-node{outline:none;white-space:nowrap}.el-tree-node:focus>.el-tree-node__content{background-color:var(--el-tree-node-hover-bg-color)}.el-tree-node.is-drop-inner>.el-tree-node__content .el-tree-node__label{background-color:var(--el-color-primary);color:#fff}.el-tree-node__content{--el-checkbox-height:var(--el-tree-node-content-height);align-items:center;cursor:pointer;display:flex;height:var(--el-tree-node-content-height)}.el-tree-node__content>.el-tree-node__expand-icon{box-sizing:content-box;padding:6px}.el-tree-node__content>label.el-checkbox{margin-right:8px}.el-tree-node__content:hover{background-color:var(--el-tree-node-hover-bg-color)}.el-tree.is-dragging .el-tree-node__content{cursor:move}.el-tree.is-dragging .el-tree-node__content *{pointer-events:none}.el-tree.is-dragging.is-drop-not-allow .el-tree-node__content{cursor:not-allowed}.el-tree-node__expand-icon{color:var(--el-tree-expand-icon-color);cursor:pointer;font-size:12px;transform:rotate(0deg);transition:transform var(--el-transition-duration) ease-in-out}.el-tree-node__expand-icon.expanded{transform:rotate(90deg)}.el-tree-node__expand-icon.is-leaf{color:transparent;cursor:default;visibility:hidden}.el-tree-node__expand-icon.is-hidden{visibility:hidden}.el-tree-node__loading-icon{color:var(--el-tree-expand-icon-color);font-size:var(--el-font-size-base);margin-right:8px}.el-tree-node>.el-tree-node__children{background-color:transparent;overflow:hidden}.el-tree-node.is-expanded>.el-tree-node__children{display:block}.el-tree--highlight-current .el-tree-node.is-current>.el-tree-node__content{background-color:var(--el-color-primary-light-9)}.el-tree-select{--el-tree-node-content-height:26px;--el-tree-node-hover-bg-color:var(--el-fill-color-light);--el-tree-text-color:var(--el-text-color-regular);--el-tree-expand-icon-color:var(--el-text-color-placeholder)}.el-tree-select__popper .el-tree-node__expand-icon{margin-left:8px}.el-tree-select__popper .el-tree-node.is-checked>.el-tree-node__content .el-select-dropdown__item.selected:after{content:none}.el-tree-select__popper .el-select-dropdown__list>.el-select-dropdown__item{padding-left:32px}.el-tree-select__popper .el-select-dropdown__item{background:transparent!important;flex:1;height:20px;line-height:20px;padding-left:0}.el-upload{--el-upload-dragger-padding-horizontal:40px;--el-upload-dragger-padding-vertical:10px;align-items:center;cursor:pointer;display:inline-flex;justify-content:center;outline:none}.el-upload.is-disabled{cursor:not-allowed}.el-upload.is-disabled:focus{color:inherit}.el-upload.is-disabled:focus,.el-upload.is-disabled:focus .el-upload-dragger{border-color:var(--el-border-color-darker)}.el-upload.is-disabled .el-upload-dragger{background-color:var(--el-disabled-bg-color);cursor:not-allowed}.el-upload.is-disabled .el-upload-dragger .el-upload__text{color:var(--el-text-color-placeholder)}.el-upload.is-disabled .el-upload-dragger .el-upload__text em{color:var(--el-disabled-text-color)}.el-upload.is-disabled .el-upload-dragger:hover{border-color:var(--el-border-color-darker)}.el-upload__input{display:none}.el-upload__tip{color:var(--el-text-color-regular);font-size:12px;margin-top:7px}.el-upload iframe{filter:alpha(opacity=0);left:0;opacity:0;position:absolute;top:0;z-index:-1}.el-upload--picture-card{--el-upload-picture-card-size:148px;align-items:center;background-color:var(--el-fill-color-lighter);border:1px dashed var(--el-border-color-darker);border-radius:6px;box-sizing:border-box;cursor:pointer;display:inline-flex;height:var(--el-upload-picture-card-size);justify-content:center;vertical-align:top;width:var(--el-upload-picture-card-size)}.el-upload--picture-card>i{color:var(--el-text-color-secondary);font-size:28px}.el-upload--picture-card:hover{border-color:var(--el-color-primary);color:var(--el-color-primary)}.el-upload.is-drag{display:block}.el-upload:focus{color:var(--el-color-primary)}.el-upload:focus,.el-upload:focus .el-upload-dragger{border-color:var(--el-color-primary)}.el-upload-dragger{background-color:var(--el-fill-color-blank);border:1px dashed var(--el-border-color);border-radius:6px;box-sizing:border-box;cursor:pointer;overflow:hidden;padding:var(--el-upload-dragger-padding-horizontal) var(--el-upload-dragger-padding-vertical);position:relative;text-align:center}.el-upload-dragger .el-icon--upload{color:var(--el-text-color-placeholder);font-size:67px;line-height:50px;margin-bottom:16px}.el-upload-dragger+.el-upload__tip{text-align:center}.el-upload-dragger~.el-upload__files{border-top:var(--el-border);margin-top:7px;padding-top:5px}.el-upload-dragger .el-upload__text{color:var(--el-text-color-regular);font-size:14px;text-align:center}.el-upload-dragger .el-upload__text em{color:var(--el-color-primary);font-style:normal}.el-upload-dragger:hover{border-color:var(--el-color-primary)}.el-upload-dragger.is-dragover{background-color:var(--el-color-primary-light-9);border:2px dashed var(--el-color-primary);padding:calc(var(--el-upload-dragger-padding-horizontal) - 1px) calc(var(--el-upload-dragger-padding-vertical) - 1px)}.el-upload-list{list-style:none;margin:10px 0 0;padding:0;position:relative}.el-upload-list__item{border-radius:4px;box-sizing:border-box;color:var(--el-text-color-regular);font-size:14px;margin-bottom:5px;position:relative;transition:all .5s cubic-bezier(.55,0,.1,1);width:100%}.el-upload-list__item .el-progress{position:absolute;top:20px;width:100%}.el-upload-list__item .el-progress__text{position:absolute;right:0;top:-13px}.el-upload-list__item .el-progress-bar{margin-right:0;padding-right:0}.el-upload-list__item .el-icon--upload-success{color:var(--el-color-success)}.el-upload-list__item .el-icon--close{color:var(--el-text-color-regular);cursor:pointer;display:none;opacity:.75;position:absolute;right:5px;top:50%;transform:translateY(-50%);transition:opacity var(--el-transition-duration)}.el-upload-list__item .el-icon--close:hover{color:var(--el-color-primary);opacity:1}.el-upload-list__item .el-icon--close-tip{color:var(--el-color-primary);cursor:pointer;display:none;font-size:12px;font-style:normal;opacity:1;position:absolute;right:5px;top:1px}.el-upload-list__item:hover{background-color:var(--el-fill-color-light)}.el-upload-list__item:hover .el-icon--close{display:inline-flex}.el-upload-list__item:hover .el-progress__text{display:none}.el-upload-list__item .el-upload-list__item-info{display:inline-flex;flex-direction:column;justify-content:center;margin-left:4px;width:calc(100% - 30px)}.el-upload-list__item.is-success .el-upload-list__item-status-label{display:inline-flex}.el-upload-list__item.is-success .el-upload-list__item-name:focus,.el-upload-list__item.is-success .el-upload-list__item-name:hover{color:var(--el-color-primary);cursor:pointer}.el-upload-list__item.is-success:focus:not(:hover) .el-icon--close-tip{display:inline-block}.el-upload-list__item.is-success:active,.el-upload-list__item.is-success:not(.focusing):focus{outline-width:0}.el-upload-list__item.is-success:active .el-icon--close-tip,.el-upload-list__item.is-success:not(.focusing):focus .el-icon--close-tip{display:none}.el-upload-list__item.is-success:focus .el-upload-list__item-status-label,.el-upload-list__item.is-success:hover .el-upload-list__item-status-label{display:none;opacity:0}.el-upload-list__item-name{align-items:center;color:var(--el-text-color-regular);display:inline-flex;font-size:var(--el-font-size-base);padding:0 4px;text-align:center;transition:color var(--el-transition-duration)}.el-upload-list__item-name .el-icon{color:var(--el-text-color-secondary);margin-right:6px}.el-upload-list__item-file-name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-upload-list__item-status-label{align-items:center;display:none;height:100%;justify-content:center;line-height:inherit;position:absolute;right:5px;top:0;transition:opacity var(--el-transition-duration)}.el-upload-list__item-delete{color:var(--el-text-color-regular);display:none;font-size:12px;position:absolute;right:10px;top:0}.el-upload-list__item-delete:hover{color:var(--el-color-primary)}.el-upload-list--picture-card{--el-upload-list-picture-card-size:148px;display:inline-flex;flex-wrap:wrap;margin:0}.el-upload-list--picture-card .el-upload-list__item{background-color:var(--el-fill-color-blank);border:1px solid var(--el-border-color);border-radius:6px;box-sizing:border-box;display:inline-flex;height:var(--el-upload-list-picture-card-size);margin:0 8px 8px 0;overflow:hidden;padding:0;width:var(--el-upload-list-picture-card-size)}.el-upload-list--picture-card .el-upload-list__item .el-icon--check,.el-upload-list--picture-card .el-upload-list__item .el-icon--circle-check{color:#ffffff}.el-upload-list--picture-card .el-upload-list__item .el-icon--close{display:none}.el-upload-list--picture-card .el-upload-list__item:hover .el-upload-list__item-status-label{display:block;opacity:0}.el-upload-list--picture-card .el-upload-list__item:hover .el-progress__text{display:block}.el-upload-list--picture-card .el-upload-list__item .el-upload-list__item-name{display:none}.el-upload-list--picture-card .el-upload-list__item-thumbnail{height:100%;-o-object-fit:contain;object-fit:contain;width:100%}.el-upload-list--picture-card .el-upload-list__item-status-label{background:var(--el-color-success);height:24px;right:-15px;text-align:center;top:-6px;transform:rotate(45deg);width:40px}.el-upload-list--picture-card .el-upload-list__item-status-label i{font-size:12px;margin-top:11px;transform:rotate(-45deg)}.el-upload-list--picture-card .el-upload-list__item-actions{align-items:center;background-color:var(--el-overlay-color-lighter);color:#fff;cursor:default;display:inline-flex;font-size:20px;height:100%;justify-content:center;left:0;opacity:0;position:absolute;top:0;transition:opacity var(--el-transition-duration);width:100%}.el-upload-list--picture-card .el-upload-list__item-actions span{cursor:pointer;display:none}.el-upload-list--picture-card .el-upload-list__item-actions span+span{margin-left:16px}.el-upload-list--picture-card .el-upload-list__item-actions .el-upload-list__item-delete{color:inherit;font-size:inherit;position:static}.el-upload-list--picture-card .el-upload-list__item-actions:hover{opacity:1}.el-upload-list--picture-card .el-upload-list__item-actions:hover span{display:inline-flex}.el-upload-list--picture-card .el-progress{bottom:auto;left:50%;top:50%;transform:translate(-50%,-50%);width:126px}.el-upload-list--picture-card .el-progress .el-progress__text{top:50%}.el-upload-list--picture .el-upload-list__item{align-items:center;background-color:var(--el-fill-color-blank);border:1px solid var(--el-border-color);border-radius:6px;box-sizing:border-box;display:flex;margin-top:10px;overflow:hidden;padding:10px;z-index:0}.el-upload-list--picture .el-upload-list__item .el-icon--check,.el-upload-list--picture .el-upload-list__item .el-icon--circle-check{color:#ffffff}.el-upload-list--picture .el-upload-list__item:hover .el-upload-list__item-status-label{display:inline-flex;opacity:0}.el-upload-list--picture .el-upload-list__item:hover .el-progress__text{display:block}.el-upload-list--picture .el-upload-list__item.is-success .el-upload-list__item-name i{display:none}.el-upload-list--picture .el-upload-list__item .el-icon--close{top:5px;transform:translateY(0)}.el-upload-list--picture .el-upload-list__item-thumbnail{align-items:center;background-color:var(--el-color-white);display:inline-flex;height:70px;justify-content:center;-o-object-fit:contain;object-fit:contain;position:relative;width:70px;z-index:1}.el-upload-list--picture .el-upload-list__item-status-label{background:var(--el-color-success);height:26px;position:absolute;right:-17px;text-align:center;top:-7px;transform:rotate(45deg);width:46px}.el-upload-list--picture .el-upload-list__item-status-label i{font-size:12px;margin-top:12px;transform:rotate(-45deg)}.el-upload-list--picture .el-progress{position:relative;top:-7px}.el-upload-cover{cursor:default;height:100%;left:0;overflow:hidden;position:absolute;top:0;width:100%;z-index:10}.el-upload-cover:after{content:"";display:inline-block;height:100%;vertical-align:middle}.el-upload-cover img{display:block;height:100%;width:100%}.el-upload-cover__label{background:var(--el-color-success);height:24px;right:-15px;text-align:center;top:-6px;transform:rotate(45deg);width:40px}.el-upload-cover__label i{color:#fff;font-size:12px;margin-top:11px;transform:rotate(-45deg)}.el-upload-cover__progress{display:inline-block;position:static;vertical-align:middle;width:243px}.el-upload-cover__progress+.el-upload__inner{opacity:0}.el-upload-cover__content{height:100%;left:0;position:absolute;top:0;width:100%}.el-upload-cover__interact{background-color:var(--el-overlay-color-light);bottom:0;height:100%;left:0;position:absolute;text-align:center;width:100%}.el-upload-cover__interact .btn{color:#ffffff;cursor:pointer;display:inline-block;font-size:14px;margin-top:60px;transition:var(--el-transition-md-fade);vertical-align:middle}.el-upload-cover__interact .btn i{margin-top:0}.el-upload-cover__interact .btn span{opacity:0;transition:opacity .15s linear}.el-upload-cover__interact .btn:not(:first-child){margin-left:35px}.el-upload-cover__interact .btn:hover{transform:translateY(-13px)}.el-upload-cover__interact .btn:hover span{opacity:1}.el-upload-cover__interact .btn i{color:#ffffff;display:block;font-size:24px;line-height:inherit;margin:0 auto 5px}.el-upload-cover__title{background-color:#ffffff;bottom:0;color:var(--el-text-color-primary);font-size:14px;font-weight:normal;height:36px;left:0;line-height:36px;margin:0;overflow:hidden;padding:0 10px;position:absolute;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%}.el-upload-cover+.el-upload__inner{opacity:0;position:relative;z-index:1}.el-vl__wrapper{position:relative}.el-vl__wrapper.always-on .el-virtual-scrollbar,.el-vl__wrapper:hover .el-virtual-scrollbar{opacity:1}.el-vl__window{scrollbar-width:none}.el-vl__window::-webkit-scrollbar{display:none}.el-virtual-scrollbar{opacity:0;transition:opacity .34s ease-out}.el-virtual-scrollbar.always-on{opacity:1}.el-vg__wrapper{position:relative}.el-popper{--el-popper-border-radius:var(--el-popover-border-radius,4px);border-radius:var(--el-popper-border-radius);font-size:12px;line-height:20px;min-width:10px;overflow-wrap:break-word;padding:5px 11px;position:absolute;visibility:visible;word-break:normal;z-index:2000}.el-popper.is-dark{color:var(--el-bg-color)}.el-popper.is-dark,.el-popper.is-dark>.el-popper__arrow:before{background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary)}.el-popper.is-dark>.el-popper__arrow:before{right:0}.el-popper.is-light,.el-popper.is-light>.el-popper__arrow:before{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light)}.el-popper.is-light>.el-popper__arrow:before{right:0}.el-popper.is-pure{padding:0}.el-popper__arrow,.el-popper__arrow:before{height:10px;position:absolute;width:10px;z-index:-1}.el-popper__arrow:before{background:var(--el-text-color-primary);box-sizing:border-box;content:" ";transform:rotate(45deg)}.el-popper[data-popper-placement^=top]>.el-popper__arrow{bottom:-5px}.el-popper[data-popper-placement^=top]>.el-popper__arrow:before{border-bottom-right-radius:2px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow{top:-5px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow:before{border-top-left-radius:2px}.el-popper[data-popper-placement^=left]>.el-popper__arrow{right:-5px}.el-popper[data-popper-placement^=left]>.el-popper__arrow:before{border-top-right-radius:2px}.el-popper[data-popper-placement^=right]>.el-popper__arrow{left:-5px}.el-popper[data-popper-placement^=right]>.el-popper__arrow:before{border-bottom-left-radius:2px}.el-popper[data-popper-placement^=top]>.el-popper__arrow:before{border-left-color:transparent!important;border-top-color:transparent!important}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow:before{border-bottom-color:transparent!important;border-right-color:transparent!important}.el-popper[data-popper-placement^=left]>.el-popper__arrow:before{border-bottom-color:transparent!important;border-left-color:transparent!important}.el-popper[data-popper-placement^=right]>.el-popper__arrow:before{border-right-color:transparent!important;border-top-color:transparent!important}.el-statistic{--el-statistic-title-font-weight:400;--el-statistic-title-font-size:var(--el-font-size-extra-small);--el-statistic-title-color:var(--el-text-color-regular);--el-statistic-content-font-weight:400;--el-statistic-content-font-size:var(--el-font-size-extra-large);--el-statistic-content-color:var(--el-text-color-primary)}.el-statistic__head{color:var(--el-statistic-title-color);font-size:var(--el-statistic-title-font-size);font-weight:var(--el-statistic-title-font-weight);line-height:20px;margin-bottom:4px}.el-statistic__content{color:var(--el-statistic-content-color);font-size:var(--el-statistic-content-font-size);font-weight:var(--el-statistic-content-font-weight)}.el-statistic__value{display:inline-block}.el-statistic__prefix{display:inline-block;margin-right:4px}.el-statistic__suffix{display:inline-block;margin-left:4px}.el-tour{--el-tour-width:520px;--el-tour-padding-primary:12px;--el-tour-font-line-height:var(--el-font-line-height-primary);--el-tour-title-font-size:16px;--el-tour-title-text-color:var(--el-text-color-primary);--el-tour-title-font-weight:400;--el-tour-close-color:var(--el-color-info);--el-tour-font-size:14px;--el-tour-color:var(--el-text-color-primary);--el-tour-bg-color:var(--el-bg-color);--el-tour-border-radius:4px}.el-tour__hollow{transition:all var(--el-transition-duration) ease}.el-tour__content{border-radius:var(--el-tour-border-radius);box-shadow:var(--el-box-shadow-light);outline:none;overflow-wrap:break-word;padding:var(--el-tour-padding-primary);width:var(--el-tour-width)}.el-tour__arrow,.el-tour__content{background:var(--el-tour-bg-color);box-sizing:border-box}.el-tour__arrow{height:10px;pointer-events:none;position:absolute;transform:rotate(45deg);width:10px}.el-tour__content[data-side^=top] .el-tour__arrow{border-left-color:transparent;border-top-color:transparent}.el-tour__content[data-side^=bottom] .el-tour__arrow{border-bottom-color:transparent;border-right-color:transparent}.el-tour__content[data-side^=left] .el-tour__arrow{border-bottom-color:transparent;border-left-color:transparent}.el-tour__content[data-side^=right] .el-tour__arrow{border-right-color:transparent;border-top-color:transparent}.el-tour__content[data-side^=top] .el-tour__arrow{bottom:-5px}.el-tour__content[data-side^=bottom] .el-tour__arrow{top:-5px}.el-tour__content[data-side^=left] .el-tour__arrow{right:-5px}.el-tour__content[data-side^=right] .el-tour__arrow{left:-5px}.el-tour__closebtn{background:transparent;border:none;cursor:pointer;font-size:var(--el-message-close-size,16px);height:40px;outline:none;padding:0;position:absolute;right:0;top:0;width:40px}.el-tour__closebtn .el-tour__close{color:var(--el-tour-close-color);font-size:inherit}.el-tour__closebtn:focus .el-tour__close,.el-tour__closebtn:hover .el-tour__close{color:var(--el-color-primary)}.el-tour__header{padding-bottom:var(--el-tour-padding-primary)}.el-tour__header.show-close{padding-right:calc(var(--el-tour-padding-primary) + var(--el-message-close-size, 16px))}.el-tour__title{color:var(--el-tour-title-text-color);font-size:var(--el-tour-title-font-size);font-weight:var(--el-tour-title-font-weight);line-height:var(--el-tour-font-line-height)}.el-tour__body{color:var(--el-tour-text-color);font-size:var(--el-tour-font-size)}.el-tour__body img,.el-tour__body video{max-width:100%}.el-tour__footer{box-sizing:border-box;display:flex;justify-content:space-between;padding-top:var(--el-tour-padding-primary)}.el-tour__content .el-tour-indicators{display:inline-block;flex:1}.el-tour__content .el-tour-indicator{background:var(--el-color-info-light-9);border-radius:50%;display:inline-block;height:6px;margin-right:6px;width:6px}.el-tour__content .el-tour-indicator.is-active{background:var(--el-color-primary)}.el-tour.el-tour--primary{--el-tour-title-text-color:#fff;--el-tour-text-color:#fff;--el-tour-bg-color:var(--el-color-primary);--el-tour-close-color:#fff}.el-tour.el-tour--primary .el-tour__closebtn:focus .el-tour__close,.el-tour.el-tour--primary .el-tour__closebtn:hover .el-tour__close{color:var(--el-tour-title-text-color)}.el-tour.el-tour--primary .el-button--default{background:#fff;border-color:var(--el-color-primary);color:var(--el-color-primary)}.el-tour.el-tour--primary .el-button--primary{border-color:#fff}.el-tour.el-tour--primary .el-tour-indicator{background:rgba(255,255,255,.15)}.el-tour.el-tour--primary .el-tour-indicator.is-active{background:#fff}.el-tour-parent--hidden{overflow:hidden}.el-anchor{--el-anchor-bg-color:var(--el-bg-color);--el-anchor-padding-indent:14px;--el-anchor-line-height:22px;--el-anchor-font-size:12px;--el-anchor-color:var(--el-text-color-secondary);--el-anchor-active-color:var(--el-color-primary);--el-anchor-marker-bg-color:var(--el-color-primary);background-color:var(--el-anchor-bg-color);position:relative}.el-anchor__marker{background-color:var(--el-anchor-marker-bg-color);border-radius:4px;opacity:0;position:absolute;z-index:0}.el-anchor.el-anchor--vertical .el-anchor__marker{height:14px;left:0;top:8px;transition:top .25s ease-in-out,opacity .25s;width:4px}.el-anchor.el-anchor--vertical .el-anchor__list{padding-left:var(--el-anchor-padding-indent)}.el-anchor.el-anchor--vertical.el-anchor--underline:before{background-color:rgba(5,5,5,.06);content:"";height:100%;left:0;position:absolute;width:2px}.el-anchor.el-anchor--vertical.el-anchor--underline .el-anchor__marker{border-radius:unset;width:2px}.el-anchor.el-anchor--horizontal .el-anchor__marker{bottom:0;height:2px;transition:left .25s ease-in-out,opacity .25s,width .25s;width:20px}.el-anchor.el-anchor--horizontal .el-anchor__list{display:flex;padding-bottom:4px}.el-anchor.el-anchor--horizontal .el-anchor__list .el-anchor__item{padding-left:16px}.el-anchor.el-anchor--horizontal .el-anchor__list .el-anchor__item:first-child{padding-left:0}.el-anchor.el-anchor--horizontal.el-anchor--underline:before{background-color:rgba(5,5,5,.06);bottom:0;content:"";height:2px;position:absolute;width:100%}.el-anchor.el-anchor--horizontal.el-anchor--underline .el-anchor__marker{border-radius:unset;height:2px}.el-anchor__item{display:flex;flex-direction:column;overflow:hidden}.el-anchor__link{cursor:pointer;font-size:var(--el-anchor-font-size);line-height:var(--el-anchor-line-height);max-width:100%;outline:none;overflow:hidden;padding:4px 0;text-decoration:none;text-overflow:ellipsis;transition:color var(--el-transition-duration);white-space:nowrap}.el-anchor__link,.el-anchor__link:focus,.el-anchor__link:hover{color:var(--el-anchor-color)}.el-anchor__link.is-active{color:var(--el-anchor-active-color)}.el-anchor .el-anchor__list .el-anchor__item a{display:inline-block}.el-segmented--vertical{flex-direction:column}.el-segmented--vertical .el-segmented__item{padding:11px}.el-segmented{--el-segmented-color:var(--el-text-color-regular);--el-segmented-bg-color:var(--el-fill-color-light);--el-segmented-padding:2px;--el-segmented-item-selected-color:var(--el-color-white);--el-segmented-item-selected-bg-color:var(--el-color-primary);--el-segmented-item-selected-disabled-bg-color:var(--el-color-primary-light-5);--el-segmented-item-hover-color:var(--el-text-color-primary);--el-segmented-item-hover-bg-color:var(--el-fill-color-dark);--el-segmented-item-active-bg-color:var(--el-fill-color-darker);--el-segmented-item-disabled-color:var(--el-text-color-placeholder);align-items:stretch;background:var(--el-segmented-bg-color);border-radius:var(--el-border-radius-base);box-sizing:border-box;color:var(--el-segmented-color);display:inline-flex;font-size:14px;min-height:32px;padding:var(--el-segmented-padding)}.el-segmented__group{align-items:stretch;display:flex;position:relative;width:100%}.el-segmented__item-selected{background:var(--el-segmented-item-selected-bg-color);border-radius:calc(var(--el-border-radius-base) - 2px);height:100%;left:0;pointer-events:none;position:absolute;top:0;transition:all .3s;width:10px}.el-segmented__item-selected.is-disabled{background:var(--el-segmented-item-selected-disabled-bg-color)}.el-segmented__item-selected.is-focus-visible:before{border-radius:inherit;bottom:0;content:"";left:0;outline:2px solid var(--el-segmented-item-selected-bg-color);outline-offset:1px;position:absolute;right:0;top:0}.el-segmented__item{align-items:center;border-radius:calc(var(--el-border-radius-base) - 2px);cursor:pointer;display:flex;flex:1;padding:0 11px}.el-segmented__item:not(.is-disabled):not(.is-selected):hover{background:var(--el-segmented-item-hover-bg-color);color:var(--el-segmented-item-hover-color)}.el-segmented__item:not(.is-disabled):not(.is-selected):active{background:var(--el-segmented-item-active-bg-color)}.el-segmented__item.is-selected,.el-segmented__item.is-selected.is-disabled{color:var(--el-segmented-item-selected-color)}.el-segmented__item.is-disabled{color:var(--el-segmented-item-disabled-color);cursor:not-allowed}.el-segmented__item-input{height:0;margin:0;opacity:0;pointer-events:none;position:absolute;width:0}.el-segmented__item-label{flex:1;line-height:normal;overflow:hidden;text-align:center;text-overflow:ellipsis;transition:color .3s;white-space:nowrap;z-index:1}.el-segmented.is-block{display:flex}.el-segmented.is-block .el-segmented__item{min-width:0}.el-segmented--large{border-radius:var(--el-border-radius-base);font-size:16px;min-height:40px}.el-segmented--large .el-segmented__item-selected{border-radius:calc(var(--el-border-radius-base) - 2px)}.el-segmented--large .el-segmented--vertical .el-segmented__item{padding:11px}.el-segmented--large .el-segmented__item{border-radius:calc(var(--el-border-radius-base) - 2px);padding:0 11px}.el-segmented--small{border-radius:calc(var(--el-border-radius-base) - 1px);font-size:14px;min-height:24px}.el-segmented--small .el-segmented__item-selected{border-radius:calc(var(--el-border-radius-base) - 3px)}.el-segmented--small .el-segmented--vertical .el-segmented__item{padding:7px}.el-segmented--small .el-segmented__item{border-radius:calc(var(--el-border-radius-base) - 3px);padding:0 7px}.el-mention{position:relative;width:100%}.el-mention__popper.el-popper{background:var(--el-bg-color-overlay);box-shadow:var(--el-box-shadow-light)}.el-mention__popper.el-popper,.el-mention__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-mention__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-left-color:transparent;border-top-color:transparent}.el-mention__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-mention__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-bottom-color:transparent;border-left-color:transparent}.el-mention__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-mention-dropdown{--el-mention-font-size:var(--el-font-size-base);--el-mention-bg-color:var(--el-bg-color-overlay);--el-mention-shadow:var(--el-box-shadow-light);--el-mention-border:1px solid var(--el-border-color-light);--el-mention-option-color:var(--el-text-color-regular);--el-mention-option-height:34px;--el-mention-option-min-width:100px;--el-mention-option-hover-background:var(--el-fill-color-light);--el-mention-option-selected-color:var(--el-color-primary);--el-mention-option-disabled-color:var(--el-text-color-placeholder);--el-mention-option-loading-color:var(--el-text-color-secondary);--el-mention-option-loading-padding:10px 0;--el-mention-max-height:174px;--el-mention-padding:6px 0;--el-mention-header-padding:10px;--el-mention-footer-padding:10px}.el-mention-dropdown__item{box-sizing:border-box;color:var(--el-mention-option-color);cursor:pointer;font-size:var(--el-mention-font-size);height:var(--el-mention-option-height);line-height:var(--el-mention-option-height);min-width:var(--el-mention-option-min-width);overflow:hidden;padding:0 20px;position:relative;text-overflow:ellipsis;white-space:nowrap}.el-mention-dropdown__item.is-hovering{background-color:var(--el-mention-option-hover-background)}.el-mention-dropdown__item.is-selected{color:var(--el-mention-option-selected-color);font-weight:bold}.el-mention-dropdown__item.is-disabled{background-color:unset;color:var(--el-mention-option-disabled-color);cursor:not-allowed}.el-mention-dropdown{border-radius:var(--el-border-radius-base);box-sizing:border-box;z-index:calc(var(--el-index-top) + 1)}.el-mention-dropdown__loading{color:var(--el-mention-option-loading-color);font-size:12px;margin:0;min-width:var(--el-mention-option-min-width);padding:10px 0;text-align:center}.el-mention-dropdown__wrap{max-height:var(--el-mention-max-height)}.el-mention-dropdown__list{box-sizing:border-box;list-style:none;margin:0;padding:var(--el-mention-padding)}.el-mention-dropdown__header{border-bottom:var(--el-mention-border);padding:var(--el-mention-header-padding)}.el-mention-dropdown__footer{border-top:var(--el-mention-border);padding:var(--el-mention-footer-padding)}.el-splitter{display:flex;height:100%;margin:0;padding:0;position:relative;width:100%}.el-splitter__mask{bottom:0;left:0;position:absolute;right:0;top:0;z-index:999}.el-splitter__mask-horizontal{cursor:col-resize}.el-splitter__mask-vertical{cursor:row-resize}.el-splitter__horizontal{flex-direction:row}.el-splitter__vertical{flex-direction:column}.el-splitter-bar{flex:none;position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none}.el-splitter-bar__disable{cursor:auto!important}.el-splitter-bar__disable:before{background-color:var(--el-border-color-light)!important}.el-splitter-bar__dragger{background:transparent;z-index:1}.el-splitter-bar__dragger,.el-splitter-bar__dragger:before{left:50%;position:absolute;top:50%;transform:translate(-50%,-50%)}.el-splitter-bar__dragger:before{background-color:var(--el-border-color-light);content:""}.el-splitter-bar__dragger:hover:before{background-color:var(--el-color-primary-light-5)}.el-splitter-bar__dragger-horizontal:before{height:100%;width:2px}.el-splitter-bar__dragger-vertical:before{height:2px;width:100%}.el-splitter-bar__dragger-active:before{background-color:var(--el-color-primary-light-3)}.el-splitter-bar:hover .el-splitter-bar__collapse-icon{opacity:1}.el-splitter-bar__collapse-icon{align-items:center;background:var(--el-border-color-light);border-radius:2px;cursor:pointer;display:flex;justify-content:center;opacity:0;position:absolute;z-index:9}.el-splitter-bar__collapse-icon:hover{background-color:var(--el-color-primary-light-5);opacity:1}.el-splitter-bar__horizontal-collapse-icon-start{height:24px;left:-12px;top:50%;transform:translate(-50%,-50%);width:16px}.el-splitter-bar__horizontal-collapse-icon-end{height:24px;left:12px;top:50%;transform:translate(-50%,-50%);width:16px}.el-splitter-bar__vertical-collapse-icon-start{height:16px;right:50%;top:-12px;transform:translate(50%,-50%);width:24px}.el-splitter-bar__vertical-collapse-icon-end{height:16px;right:50%;top:12px;transform:translate(50%,-50%);width:24px}.el-splitter-panel{box-sizing:border-box;flex-grow:0;overflow:auto;scrollbar-width:thin}`));
      document.head.appendChild(elementStyle);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
})();
System.register([], function(exports, module) {
  "use strict";
  return {
    execute: function() {
      exports({
        useCalcInputWidth,
        useComposition,
        useCursor,
        useFocusController,
        useGlobalComponentSettings,
        useGlobalConfig,
        useSpace,
        useTimeout
      });
      const index$1 = "";
      /*! Element Plus v2.10.7 */
      const unref = window["Vue"].unref;
      const readonly = window["Vue"].readonly;
      const shallowRef = window["Vue"].shallowRef;
      const watchEffect = window["Vue"].watchEffect;
      const getCurrentScope = window["Vue"].getCurrentScope;
      const onScopeDispose = window["Vue"].onScopeDispose;
      const isRef = window["Vue"].isRef;
      const ref = window["Vue"].ref;
      const watch = window["Vue"].watch;
      const getCurrentInstance = window["Vue"].getCurrentInstance;
      const onMounted = window["Vue"].onMounted;
      const nextTick = window["Vue"].nextTick;
      const computed = window["Vue"].computed;
      const defineComponent = window["Vue"].defineComponent;
      const openBlock = window["Vue"].openBlock;
      const createElementBlock = window["Vue"].createElementBlock;
      const createElementVNode = window["Vue"].createElementVNode;
      const warn = window["Vue"].warn;
      const isVNode = window["Vue"].isVNode;
      const Fragment = window["Vue"].Fragment;
      const Comment = window["Vue"].Comment;
      const onBeforeUnmount = window["Vue"].onBeforeUnmount;
      const inject = window["Vue"].inject;
      const onUnmounted = window["Vue"].onUnmounted;
      const h$1 = window["Vue"].h;
      const Teleport$1 = window["Vue"].Teleport;
      const onBeforeMount = window["Vue"].onBeforeMount;
      const provide = window["Vue"].provide;
      const triggerRef = window["Vue"].triggerRef;
      const renderSlot = window["Vue"].renderSlot;
      const normalizeClass = window["Vue"].normalizeClass;
      const normalizeStyle = window["Vue"].normalizeStyle;
      const mergeProps = window["Vue"].mergeProps;
      const useSlots = window["Vue"].useSlots;
      const toRef = window["Vue"].toRef;
      const createBlock = window["Vue"].createBlock;
      const Transition = window["Vue"].Transition;
      const withCtx = window["Vue"].withCtx;
      const withDirectives = window["Vue"].withDirectives;
      const resolveDynamicComponent = window["Vue"].resolveDynamicComponent;
      const createCommentVNode = window["Vue"].createCommentVNode;
      const createTextVNode = window["Vue"].createTextVNode;
      const toDisplayString = window["Vue"].toDisplayString;
      const createVNode = window["Vue"].createVNode;
      const vShow = window["Vue"].vShow;
      const reactive = window["Vue"].reactive;
      const toRefs = window["Vue"].toRefs;
      const onUpdated = window["Vue"].onUpdated;
      const TransitionGroup = window["Vue"].TransitionGroup;
      const useAttrs$1 = window["Vue"].useAttrs;
      const withModifiers = window["Vue"].withModifiers;
      const onActivated = window["Vue"].onActivated;
      const cloneVNode = window["Vue"].cloneVNode;
      const Text$1 = window["Vue"].Text;
      const onDeactivated = window["Vue"].onDeactivated;
      const renderList = window["Vue"].renderList;
      const withKeys = window["Vue"].withKeys;
      const createSlots = window["Vue"].createSlots;
      const normalizeProps = window["Vue"].normalizeProps;
      const guardReactiveProps = window["Vue"].guardReactiveProps;
      const toRaw = window["Vue"].toRaw;
      const vModelCheckbox = window["Vue"].vModelCheckbox;
      const vModelRadio = window["Vue"].vModelRadio;
      const onBeforeUpdate = window["Vue"].onBeforeUpdate;
      const vModelText = window["Vue"].vModelText;
      const toHandlers = window["Vue"].toHandlers;
      const resolveComponent = window["Vue"].resolveComponent;
      const markRaw = window["Vue"].markRaw;
      const effectScope = window["Vue"].effectScope;
      const resolveDirective = window["Vue"].resolveDirective;
      const toHandlerKey = window["Vue"].toHandlerKey;
      const render = window["Vue"].render;
      const createApp = window["Vue"].createApp;
      const shallowReactive = window["Vue"].shallowReactive;
      const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])`;
      const isVisible = (element) => {
        const computed2 = getComputedStyle(element);
        return computed2.position === "fixed" ? false : element.offsetParent !== null;
      };
      const obtainAllFocusableElements$1 = (element) => {
        return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS)).filter((item) => isFocusable(item) && isVisible(item));
      };
      const isFocusable = (element) => {
        if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
          return true;
        }
        if (element.tabIndex < 0 || element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true") {
          return false;
        }
        switch (element.nodeName) {
          case "A": {
            return !!element.href && element.rel !== "ignore";
          }
          case "INPUT": {
            return !(element.type === "hidden" || element.type === "file");
          }
          case "BUTTON":
          case "SELECT":
          case "TEXTAREA": {
            return true;
          }
          default: {
            return false;
          }
        }
      };
      const triggerEvent = function(elm, name, ...opts) {
        let eventName;
        if (name.includes("mouse") || name.includes("click")) {
          eventName = "MouseEvents";
        } else if (name.includes("key")) {
          eventName = "KeyboardEvent";
        } else {
          eventName = "HTMLEvents";
        }
        const evt = document.createEvent(eventName);
        evt.initEvent(name, ...opts);
        elm.dispatchEvent(evt);
        return elm;
      };
      const isLeaf = (el) => !el.getAttribute("aria-owns");
      const getSibling = (el, distance, elClass) => {
        const { parentNode } = el;
        if (!parentNode)
          return null;
        const siblings = parentNode.querySelectorAll(elClass);
        const index2 = Array.prototype.indexOf.call(siblings, el);
        return siblings[index2 + distance] || null;
      };
      const focusNode = (el) => {
        if (!el)
          return;
        el.focus();
        !isLeaf(el) && el.click();
      };
      const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
        const handleEvent = (event) => {
          const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
          if (checkForDefaultPrevented === false || !shouldPrevent) {
            return oursHandler == null ? void 0 : oursHandler(event);
          }
        };
        return handleEvent;
      };
      const whenMouse = (handler) => {
        return (e) => e.pointerType === "mouse" ? handler(e) : void 0;
      };
      function computedEager(fn2, options) {
        var _a;
        const result2 = shallowRef();
        watchEffect(() => {
          result2.value = fn2();
        }, {
          ...options,
          flush: (_a = options == null ? void 0 : options.flush) != null ? _a : "sync"
        });
        return readonly(result2);
      }
      function tryOnScopeDispose(fn2) {
        if (getCurrentScope()) {
          onScopeDispose(fn2);
          return true;
        }
        return false;
      }
      function toValue(r) {
        return typeof r === "function" ? r() : unref(r);
      }
      const isClient = typeof window !== "undefined" && typeof document !== "undefined";
      typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
      const isDef = (val) => typeof val !== "undefined";
      const notNullish = (val) => val != null;
      const toString$1 = Object.prototype.toString;
      const isObject$2 = (val) => toString$1.call(val) === "[object Object]";
      const noop$1 = () => {
      };
      const isIOS = /* @__PURE__ */ getIsIOS();
      function getIsIOS() {
        var _a, _b;
        return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
      }
      function createFilterWrapper(filter2, fn2) {
        function wrapper(...args) {
          return new Promise((resolve, reject2) => {
            Promise.resolve(filter2(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve).catch(reject2);
          });
        }
        return wrapper;
      }
      function debounceFilter(ms, options = {}) {
        let timer;
        let maxTimer;
        let lastRejector = noop$1;
        const _clearTimeout = (timer2) => {
          clearTimeout(timer2);
          lastRejector();
          lastRejector = noop$1;
        };
        const filter2 = (invoke2) => {
          const duration = toValue(ms);
          const maxDuration = toValue(options.maxWait);
          if (timer)
            _clearTimeout(timer);
          if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
            if (maxTimer) {
              _clearTimeout(maxTimer);
              maxTimer = null;
            }
            return Promise.resolve(invoke2());
          }
          return new Promise((resolve, reject2) => {
            lastRejector = options.rejectOnCancel ? reject2 : resolve;
            if (maxDuration && !maxTimer) {
              maxTimer = setTimeout(() => {
                if (timer)
                  _clearTimeout(timer);
                maxTimer = null;
                resolve(invoke2());
              }, maxDuration);
            }
            timer = setTimeout(() => {
              if (maxTimer)
                _clearTimeout(maxTimer);
              maxTimer = null;
              resolve(invoke2());
            }, duration);
          });
        };
        return filter2;
      }
      function throttleFilter(...args) {
        let lastExec = 0;
        let timer;
        let isLeading = true;
        let lastRejector = noop$1;
        let lastValue;
        let ms;
        let trailing;
        let leading;
        let rejectOnCancel;
        if (!isRef(args[0]) && typeof args[0] === "object")
          ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);
        else
          [ms, trailing = true, leading = true, rejectOnCancel = false] = args;
        const clear = () => {
          if (timer) {
            clearTimeout(timer);
            timer = void 0;
            lastRejector();
            lastRejector = noop$1;
          }
        };
        const filter2 = (_invoke) => {
          const duration = toValue(ms);
          const elapsed = Date.now() - lastExec;
          const invoke2 = () => {
            return lastValue = _invoke();
          };
          clear();
          if (duration <= 0) {
            lastExec = Date.now();
            return invoke2();
          }
          if (elapsed > duration && (leading || !isLeading)) {
            lastExec = Date.now();
            invoke2();
          } else if (trailing) {
            lastValue = new Promise((resolve, reject2) => {
              lastRejector = rejectOnCancel ? reject2 : resolve;
              timer = setTimeout(() => {
                lastExec = Date.now();
                isLeading = true;
                resolve(invoke2());
                clear();
              }, Math.max(0, duration - elapsed));
            });
          }
          if (!leading && !timer)
            timer = setTimeout(() => isLeading = true, duration);
          isLeading = false;
          return lastValue;
        };
        return filter2;
      }
      function getLifeCycleTarget(target2) {
        return target2 || getCurrentInstance();
      }
      function useDebounceFn(fn2, ms = 200, options = {}) {
        return createFilterWrapper(
          debounceFilter(ms, options),
          fn2
        );
      }
      function refDebounced(value, ms = 200, options = {}) {
        const debounced = ref(value.value);
        const updater = useDebounceFn(() => {
          debounced.value = value.value;
        }, ms, options);
        watch(value, () => updater());
        return debounced;
      }
      function useThrottleFn(fn2, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {
        return createFilterWrapper(
          throttleFilter(ms, trailing, leading, rejectOnCancel),
          fn2
        );
      }
      function tryOnMounted(fn2, sync = true, target2) {
        const instance = getLifeCycleTarget();
        if (instance)
          onMounted(fn2, target2);
        else if (sync)
          fn2();
        else
          nextTick(fn2);
      }
      function useTimeoutFn(cb, interval, options = {}) {
        const {
          immediate = true
        } = options;
        const isPending = ref(false);
        let timer = null;
        function clear() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
        }
        function stop() {
          isPending.value = false;
          clear();
        }
        function start(...args) {
          clear();
          isPending.value = true;
          timer = setTimeout(() => {
            isPending.value = false;
            timer = null;
            cb(...args);
          }, toValue(interval));
        }
        if (immediate) {
          isPending.value = true;
          if (isClient)
            start();
        }
        tryOnScopeDispose(stop);
        return {
          isPending: readonly(isPending),
          start,
          stop
        };
      }
      function unrefElement(elRef) {
        var _a;
        const plain = toValue(elRef);
        return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
      }
      const defaultWindow = isClient ? window : void 0;
      const defaultDocument = isClient ? window.document : void 0;
      function useEventListener(...args) {
        let target2;
        let events;
        let listeners;
        let options;
        if (typeof args[0] === "string" || Array.isArray(args[0])) {
          [events, listeners, options] = args;
          target2 = defaultWindow;
        } else {
          [target2, events, listeners, options] = args;
        }
        if (!target2)
          return noop$1;
        if (!Array.isArray(events))
          events = [events];
        if (!Array.isArray(listeners))
          listeners = [listeners];
        const cleanups = [];
        const cleanup = () => {
          cleanups.forEach((fn2) => fn2());
          cleanups.length = 0;
        };
        const register = (el, event, listener, options2) => {
          el.addEventListener(event, listener, options2);
          return () => el.removeEventListener(event, listener, options2);
        };
        const stopWatch = watch(
          () => [unrefElement(target2), toValue(options)],
          ([el, options2]) => {
            cleanup();
            if (!el)
              return;
            const optionsClone = isObject$2(options2) ? { ...options2 } : options2;
            cleanups.push(
              ...events.flatMap((event) => {
                return listeners.map((listener) => register(el, event, listener, optionsClone));
              })
            );
          },
          { immediate: true, flush: "post" }
        );
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose(stop);
        return stop;
      }
      let _iOSWorkaround = false;
      function onClickOutside(target2, handler, options = {}) {
        const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
        if (!window2)
          return noop$1;
        if (isIOS && !_iOSWorkaround) {
          _iOSWorkaround = true;
          Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop$1));
          window2.document.documentElement.addEventListener("click", noop$1);
        }
        let shouldListen = true;
        const shouldIgnore = (event) => {
          return ignore.some((target22) => {
            if (typeof target22 === "string") {
              return Array.from(window2.document.querySelectorAll(target22)).some((el) => el === event.target || event.composedPath().includes(el));
            } else {
              const el = unrefElement(target22);
              return el && (event.target === el || event.composedPath().includes(el));
            }
          });
        };
        const listener = (event) => {
          const el = unrefElement(target2);
          if (!el || el === event.target || event.composedPath().includes(el))
            return;
          if (event.detail === 0)
            shouldListen = !shouldIgnore(event);
          if (!shouldListen) {
            shouldListen = true;
            return;
          }
          handler(event);
        };
        const cleanup = [
          useEventListener(window2, "click", listener, { passive: true, capture }),
          useEventListener(window2, "pointerdown", (e) => {
            const el = unrefElement(target2);
            shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));
          }, { passive: true }),
          detectIframe && useEventListener(window2, "blur", (event) => {
            setTimeout(() => {
              var _a;
              const el = unrefElement(target2);
              if (((_a = window2.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement))) {
                handler(event);
              }
            }, 0);
          })
        ].filter(Boolean);
        const stop = () => cleanup.forEach((fn2) => fn2());
        return stop;
      }
      function useMounted() {
        const isMounted = ref(false);
        const instance = getCurrentInstance();
        if (instance) {
          onMounted(() => {
            isMounted.value = true;
          }, instance);
        }
        return isMounted;
      }
      function useSupported(callback) {
        const isMounted = useMounted();
        return computed(() => {
          isMounted.value;
          return Boolean(callback());
        });
      }
      function useMutationObserver(target2, callback, options = {}) {
        const { window: window2 = defaultWindow, ...mutationOptions } = options;
        let observer;
        const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const targets = computed(() => {
          const value = toValue(target2);
          const items = (Array.isArray(value) ? value : [value]).map(unrefElement).filter(notNullish);
          return new Set(items);
        });
        const stopWatch = watch(
          () => targets.value,
          (targets2) => {
            cleanup();
            if (isSupported.value && targets2.size) {
              observer = new MutationObserver(callback);
              targets2.forEach((el) => observer.observe(el, mutationOptions));
            }
          },
          { immediate: true, flush: "post" }
        );
        const takeRecords = () => {
          return observer == null ? void 0 : observer.takeRecords();
        };
        const stop = () => {
          cleanup();
          stopWatch();
        };
        tryOnScopeDispose(stop);
        return {
          isSupported,
          stop,
          takeRecords
        };
      }
      function useActiveElement(options = {}) {
        var _a;
        const {
          window: window2 = defaultWindow,
          deep = true,
          triggerOnRemoval = false
        } = options;
        const document2 = (_a = options.document) != null ? _a : window2 == null ? void 0 : window2.document;
        const getDeepActiveElement = () => {
          var _a2;
          let element = document2 == null ? void 0 : document2.activeElement;
          if (deep) {
            while (element == null ? void 0 : element.shadowRoot)
              element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;
          }
          return element;
        };
        const activeElement = ref();
        const trigger = () => {
          activeElement.value = getDeepActiveElement();
        };
        if (window2) {
          useEventListener(window2, "blur", (event) => {
            if (event.relatedTarget !== null)
              return;
            trigger();
          }, true);
          useEventListener(window2, "focus", trigger, true);
        }
        if (triggerOnRemoval) {
          useMutationObserver(document2, (mutations) => {
            mutations.filter((m2) => m2.removedNodes.length).map((n) => Array.from(n.removedNodes)).flat().forEach((node) => {
              if (node === activeElement.value)
                trigger();
            });
          }, {
            childList: true,
            subtree: true
          });
        }
        trigger();
        return activeElement;
      }
      function useMediaQuery(query, options = {}) {
        const { window: window2 = defaultWindow } = options;
        const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
        let mediaQuery;
        const matches2 = ref(false);
        const handler = (event) => {
          matches2.value = event.matches;
        };
        const cleanup = () => {
          if (!mediaQuery)
            return;
          if ("removeEventListener" in mediaQuery)
            mediaQuery.removeEventListener("change", handler);
          else
            mediaQuery.removeListener(handler);
        };
        const stopWatch = watchEffect(() => {
          if (!isSupported.value)
            return;
          cleanup();
          mediaQuery = window2.matchMedia(toValue(query));
          if ("addEventListener" in mediaQuery)
            mediaQuery.addEventListener("change", handler);
          else
            mediaQuery.addListener(handler);
          matches2.value = mediaQuery.matches;
        });
        tryOnScopeDispose(() => {
          stopWatch();
          cleanup();
          mediaQuery = void 0;
        });
        return matches2;
      }
      function cloneFnJSON(source) {
        return JSON.parse(JSON.stringify(source));
      }
      function useCssVar(prop, target2, options = {}) {
        const { window: window2 = defaultWindow, initialValue = "", observe = false } = options;
        const variable = ref(initialValue);
        const elRef = computed(() => {
          var _a;
          return unrefElement(target2) || ((_a = window2 == null ? void 0 : window2.document) == null ? void 0 : _a.documentElement);
        });
        function updateCssVar() {
          var _a;
          const key = toValue(prop);
          const el = toValue(elRef);
          if (el && window2) {
            const value = (_a = window2.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();
            variable.value = value || initialValue;
          }
        }
        if (observe) {
          useMutationObserver(elRef, updateCssVar, {
            attributeFilter: ["style", "class"],
            window: window2
          });
        }
        watch(
          [elRef, () => toValue(prop)],
          updateCssVar,
          { immediate: true }
        );
        watch(
          variable,
          (val) => {
            var _a;
            if ((_a = elRef.value) == null ? void 0 : _a.style)
              elRef.value.style.setProperty(toValue(prop), val);
          }
        );
        return variable;
      }
      function useDocumentVisibility(options = {}) {
        const { document: document2 = defaultDocument } = options;
        if (!document2)
          return ref("visible");
        const visibility = ref(document2.visibilityState);
        useEventListener(document2, "visibilitychange", () => {
          visibility.value = document2.visibilityState;
        });
        return visibility;
      }
      function useResizeObserver(target2, callback, options = {}) {
        const { window: window2 = defaultWindow, ...observerOptions } = options;
        let observer;
        const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
        const cleanup = () => {
          if (observer) {
            observer.disconnect();
            observer = void 0;
          }
        };
        const targets = computed(() => Array.isArray(target2) ? target2.map((el) => unrefElement(el)) : [unrefElement(target2)]);
        const stopWatch = watch(
          targets,
          (els) => {
            cleanup();
            if (isSupported.value && window2) {
              observer = new ResizeObserver(callback);
              for (const _el of els)
                _el && observer.observe(_el, observerOptions);
            }
          },
          { immediate: true, flush: "post" }
        );
        const stop = () => {
          cleanup();
          stopWatch();
        };
        tryOnScopeDispose(stop);
        return {
          isSupported,
          stop
        };
      }
      function useElementBounding(target2, options = {}) {
        const {
          reset = true,
          windowResize = true,
          windowScroll = true,
          immediate = true
        } = options;
        const height = ref(0);
        const bottom = ref(0);
        const left = ref(0);
        const right = ref(0);
        const top = ref(0);
        const width = ref(0);
        const x2 = ref(0);
        const y = ref(0);
        function update2() {
          const el = unrefElement(target2);
          if (!el) {
            if (reset) {
              height.value = 0;
              bottom.value = 0;
              left.value = 0;
              right.value = 0;
              top.value = 0;
              width.value = 0;
              x2.value = 0;
              y.value = 0;
            }
            return;
          }
          const rect = el.getBoundingClientRect();
          height.value = rect.height;
          bottom.value = rect.bottom;
          left.value = rect.left;
          right.value = rect.right;
          top.value = rect.top;
          width.value = rect.width;
          x2.value = rect.x;
          y.value = rect.y;
        }
        useResizeObserver(target2, update2);
        watch(() => unrefElement(target2), (ele) => !ele && update2());
        useMutationObserver(target2, update2, {
          attributeFilter: ["style", "class"]
        });
        if (windowScroll)
          useEventListener("scroll", update2, { capture: true, passive: true });
        if (windowResize)
          useEventListener("resize", update2, { passive: true });
        tryOnMounted(() => {
          if (immediate)
            update2();
        });
        return {
          height,
          bottom,
          left,
          right,
          top,
          width,
          x: x2,
          y,
          update: update2
        };
      }
      function useElementSize(target2, initialSize = { width: 0, height: 0 }, options = {}) {
        const { window: window2 = defaultWindow, box = "content-box" } = options;
        const isSVG = computed(() => {
          var _a, _b;
          return (_b = (_a = unrefElement(target2)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes("svg");
        });
        const width = ref(initialSize.width);
        const height = ref(initialSize.height);
        const { stop: stop1 } = useResizeObserver(
          target2,
          ([entry]) => {
            const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
            if (window2 && isSVG.value) {
              const $elem = unrefElement(target2);
              if ($elem) {
                const rect = $elem.getBoundingClientRect();
                width.value = rect.width;
                height.value = rect.height;
              }
            } else {
              if (boxSize) {
                const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];
                width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
                height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
              } else {
                width.value = entry.contentRect.width;
                height.value = entry.contentRect.height;
              }
            }
          },
          options
        );
        tryOnMounted(() => {
          const ele = unrefElement(target2);
          if (ele) {
            width.value = "offsetWidth" in ele ? ele.offsetWidth : initialSize.width;
            height.value = "offsetHeight" in ele ? ele.offsetHeight : initialSize.height;
          }
        });
        const stop2 = watch(
          () => unrefElement(target2),
          (ele) => {
            width.value = ele ? initialSize.width : 0;
            height.value = ele ? initialSize.height : 0;
          }
        );
        function stop() {
          stop1();
          stop2();
        }
        return {
          width,
          height,
          stop
        };
      }
      function useIntersectionObserver(target2, callback, options = {}) {
        const {
          root: root2,
          rootMargin = "0px",
          threshold = 0.1,
          window: window2 = defaultWindow,
          immediate = true
        } = options;
        const isSupported = useSupported(() => window2 && "IntersectionObserver" in window2);
        const targets = computed(() => {
          const _target = toValue(target2);
          return (Array.isArray(_target) ? _target : [_target]).map(unrefElement).filter(notNullish);
        });
        let cleanup = noop$1;
        const isActive = ref(immediate);
        const stopWatch = isSupported.value ? watch(
          () => [targets.value, unrefElement(root2), isActive.value],
          ([targets2, root22]) => {
            cleanup();
            if (!isActive.value)
              return;
            if (!targets2.length)
              return;
            const observer = new IntersectionObserver(
              callback,
              {
                root: unrefElement(root22),
                rootMargin,
                threshold
              }
            );
            targets2.forEach((el) => el && observer.observe(el));
            cleanup = () => {
              observer.disconnect();
              cleanup = noop$1;
            };
          },
          { immediate, flush: "post" }
        ) : noop$1;
        const stop = () => {
          cleanup();
          stopWatch();
          isActive.value = false;
        };
        tryOnScopeDispose(stop);
        return {
          isSupported,
          isActive,
          pause() {
            cleanup();
            isActive.value = false;
          },
          resume() {
            isActive.value = true;
          },
          stop
        };
      }
      function useVModel(props2, key, emit, options = {}) {
        var _a, _b, _c;
        const {
          clone: clone2 = false,
          passive = false,
          eventName,
          deep = false,
          defaultValue,
          shouldEmit
        } = options;
        const vm = getCurrentInstance();
        const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
        let event = eventName;
        if (!key) {
          {
            key = "modelValue";
          }
        }
        event = event || `update:${key.toString()}`;
        const cloneFn = (val) => !clone2 ? val : typeof clone2 === "function" ? clone2(val) : cloneFnJSON(val);
        const getValue2 = () => isDef(props2[key]) ? cloneFn(props2[key]) : defaultValue;
        const triggerEmit = (value) => {
          if (shouldEmit) {
            if (shouldEmit(value))
              _emit(event, value);
          } else {
            _emit(event, value);
          }
        };
        if (passive) {
          const initialValue = getValue2();
          const proxy = ref(initialValue);
          let isUpdating = false;
          watch(
            () => props2[key],
            (v2) => {
              if (!isUpdating) {
                isUpdating = true;
                proxy.value = cloneFn(v2);
                nextTick(() => isUpdating = false);
              }
            }
          );
          watch(
            proxy,
            (v2) => {
              if (!isUpdating && (v2 !== props2[key] || deep))
                triggerEmit(v2);
            },
            { deep }
          );
          return proxy;
        } else {
          return computed({
            get() {
              return getValue2();
            },
            set(value) {
              triggerEmit(value);
            }
          });
        }
      }
      function useWindowFocus(options = {}) {
        const { window: window2 = defaultWindow } = options;
        if (!window2)
          return ref(false);
        const focused = ref(window2.document.hasFocus());
        useEventListener(window2, "blur", () => {
          focused.value = false;
        });
        useEventListener(window2, "focus", () => {
          focused.value = true;
        });
        return focused;
      }
      function useWindowSize(options = {}) {
        const {
          window: window2 = defaultWindow,
          initialWidth = Number.POSITIVE_INFINITY,
          initialHeight = Number.POSITIVE_INFINITY,
          listenOrientation = true,
          includeScrollbar = true
        } = options;
        const width = ref(initialWidth);
        const height = ref(initialHeight);
        const update2 = () => {
          if (window2) {
            if (includeScrollbar) {
              width.value = window2.innerWidth;
              height.value = window2.innerHeight;
            } else {
              width.value = window2.document.documentElement.clientWidth;
              height.value = window2.document.documentElement.clientHeight;
            }
          }
        };
        update2();
        tryOnMounted(update2);
        useEventListener("resize", update2, { passive: true });
        if (listenOrientation) {
          const matches2 = useMediaQuery("(orientation: portrait)");
          watch(matches2, () => update2());
        }
        return { width, height };
      }
      const isFirefox = () => isClient && /firefox/i.test(window.navigator.userAgent);
      const getOffsetTop = (el) => {
        let offset2 = 0;
        let parent2 = el;
        while (parent2) {
          offset2 += parent2.offsetTop;
          parent2 = parent2.offsetParent;
        }
        return offset2;
      };
      const getOffsetTopDistance = (el, containerEl) => {
        return Math.abs(getOffsetTop(el) - getOffsetTop(containerEl));
      };
      const getClientXY = (event) => {
        let clientX;
        let clientY;
        if (event.type === "touchend") {
          clientY = event.changedTouches[0].clientY;
          clientX = event.changedTouches[0].clientX;
        } else if (event.type.startsWith("touch")) {
          clientY = event.touches[0].clientY;
          clientX = event.touches[0].clientX;
        } else {
          clientY = event.clientY;
          clientX = event.clientX;
        }
        return {
          clientX,
          clientY
        };
      };
      function easeInOutCubic(t, b2, c2, d2) {
        const cc = c2 - b2;
        t /= d2 / 2;
        if (t < 1) {
          return cc / 2 * t * t * t + b2;
        }
        return cc / 2 * ((t -= 2) * t * t + 2) + b2;
      }
      const NOOP = () => {
      };
      const hasOwnProperty$p = Object.prototype.hasOwnProperty;
      const hasOwn = (val, key) => hasOwnProperty$p.call(val, key);
      const isArray$1 = Array.isArray;
      const isDate$1 = (val) => toTypeString(val) === "[object Date]";
      const isFunction$1 = (val) => typeof val === "function";
      const isString$1 = (val) => typeof val === "string";
      const isObject$1 = (val) => val !== null && typeof val === "object";
      const isPromise = (val) => {
        return isObject$1(val) && isFunction$1(val.then) && isFunction$1(val.catch);
      };
      const objectToString$1 = Object.prototype.toString;
      const toTypeString = (value) => objectToString$1.call(value);
      const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
      const cacheStringFunction = (fn2) => {
        const cache2 = /* @__PURE__ */ Object.create(null);
        return (str) => {
          const hit = cache2[str];
          return hit || (cache2[str] = fn2(str));
        };
      };
      const camelizeRE = /-(\w)/g;
      const camelize = cacheStringFunction((str) => {
        return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
      });
      const hyphenateRE = /\B([A-Z])/g;
      const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
      const capitalize$2 = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var Symbol$1 = root.Symbol;
      var objectProto$s = Object.prototype;
      var hasOwnProperty$o = objectProto$s.hasOwnProperty;
      var nativeObjectToString$3 = objectProto$s.toString;
      var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty$o.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
          value[symToStringTag$1] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString$3.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag$1] = tag;
          } else {
            delete value[symToStringTag$1];
          }
        }
        return result2;
      }
      var objectProto$r = Object.prototype;
      var nativeObjectToString$2 = objectProto$r.toString;
      function objectToString(value) {
        return nativeObjectToString$2.call(value);
      }
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var symbolTag$3 = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
      }
      var NAN$2 = 0 / 0;
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN$2;
        }
        return +value;
      }
      function arrayMap(array3, iteratee2) {
        var index2 = -1, length = array3 == null ? 0 : array3.length, result2 = Array(length);
        while (++index2 < length) {
          result2[index2] = iteratee2(array3[index2], index2, array3);
        }
        return result2;
      }
      var isArray = Array.isArray;
      var INFINITY$5 = 1 / 0;
      var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0;
      var symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY$5 ? "-0" : result2;
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === void 0 && other === void 0) {
            return defaultValue;
          }
          if (value !== void 0) {
            result2 = value;
          }
          if (other !== void 0) {
            if (result2 === void 0) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var reWhitespace = /\s/;
      function trimmedEndIndex(string2) {
        var index2 = string2.length;
        while (index2-- && reWhitespace.test(string2.charAt(index2))) {
        }
        return index2;
      }
      var reTrimStart$2 = /^\s+/;
      function baseTrim(string2) {
        return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart$2, "") : string2;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      var NAN$1 = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN$1;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN$1 : +value;
      }
      var INFINITY$4 = 1 / 0;
      var MAX_INTEGER = 17976931348623157e292;
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY$4 || value === -INFINITY$4) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      var FUNC_ERROR_TEXT$b = "Expected a function";
      function after(n, func2) {
        if (typeof func2 != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$b);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func2.apply(this, arguments);
          }
        };
      }
      function identity(value) {
        return value;
      }
      var asyncTag = "[object AsyncFunction]";
      var funcTag$2 = "[object Function]";
      var genTag$1 = "[object GeneratorFunction]";
      var proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
      }
      var coreJsData = root["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      function isMasked(func2) {
        return !!maskSrcKey && maskSrcKey in func2;
      }
      var funcProto$2 = Function.prototype;
      var funcToString$2 = funcProto$2.toString;
      function toSource(func2) {
        if (func2 != null) {
          try {
            return funcToString$2.call(func2);
          } catch (e) {
          }
          try {
            return func2 + "";
          } catch (e) {
          }
        }
        return "";
      }
      var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto$1 = Function.prototype;
      var objectProto$q = Object.prototype;
      var funcToString$1 = funcProto$1.toString;
      var hasOwnProperty$n = objectProto$q.hasOwnProperty;
      var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$n).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function getValue$1(object3, key) {
        return object3 == null ? void 0 : object3[key];
      }
      function getNative(object3, key) {
        var value = getValue$1(object3, key);
        return baseIsNative(value) ? value : void 0;
      }
      var WeakMap$1 = getNative(root, "WeakMap");
      var metaMap = WeakMap$1 && new WeakMap$1();
      var baseSetData = !metaMap ? identity : function(func2, data) {
        metaMap.set(func2, data);
        return func2;
      };
      var objectCreate = Object.create;
      var baseCreate = function() {
        function object3() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object3.prototype = proto;
          var result2 = new object3();
          object3.prototype = void 0;
          return result2;
        };
      }();
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject(result2) ? result2 : thisBinding;
        };
      }
      var WRAP_BIND_FLAG$8 = 1;
      function createBind(func2, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG$8, Ctor = createCtor(func2);
        function wrapper() {
          var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func2;
          return fn2.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function apply(func2, thisArg, args) {
        switch (args.length) {
          case 0:
            return func2.call(thisArg);
          case 1:
            return func2.call(thisArg, args[0]);
          case 2:
            return func2.call(thisArg, args[0], args[1]);
          case 3:
            return func2.call(thisArg, args[0], args[1], args[2]);
        }
        return func2.apply(thisArg, args);
      }
      var nativeMax$g = Math.max;
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax$g(argsLength - holdersLength, 0), result2 = Array(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      var nativeMax$f = Math.max;
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax$f(argsLength - holdersLength, 0), result2 = Array(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset2 = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset2 + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function countHolders(array3, placeholder) {
        var length = array3.length, result2 = 0;
        while (length--) {
          if (array3[length] === placeholder) {
            ++result2;
          }
        }
        return result2;
      }
      function baseLodash() {
      }
      var MAX_ARRAY_LENGTH$6 = 4294967295;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH$6;
        this.__views__ = [];
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function noop() {
      }
      var getData = !metaMap ? noop : function(func2) {
        return metaMap.get(func2);
      };
      var realNames = {};
      var objectProto$p = Object.prototype;
      var hasOwnProperty$m = objectProto$p.hasOwnProperty;
      function getFuncName(func2) {
        var result2 = func2.name + "", array3 = realNames[result2], length = hasOwnProperty$m.call(realNames, result2) ? array3.length : 0;
        while (length--) {
          var data = array3[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func2) {
            return data.name;
          }
        }
        return result2;
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = void 0;
      }
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function copyArray(source, array3) {
        var index2 = -1, length = source.length;
        array3 || (array3 = Array(length));
        while (++index2 < length) {
          array3[index2] = source[index2];
        }
        return array3;
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      var objectProto$o = Object.prototype;
      var hasOwnProperty$l = objectProto$o.hasOwnProperty;
      function lodash(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty$l.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      function isLaziable(func2) {
        var funcName = getFuncName(func2), other = lodash[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func2 === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func2 === data[0];
      }
      var HOT_COUNT = 800;
      var HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func2) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func2.apply(void 0, arguments);
        };
      }
      var setData = shortOut(baseSetData);
      var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/;
      var reSplitDetails = /,? & /;
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      var defineProperty = function() {
        try {
          var func2 = getNative(Object, "defineProperty");
          func2({}, "", {});
          return func2;
        } catch (e) {
        }
      }();
      var baseSetToString = !defineProperty ? identity : function(func2, string2) {
        return defineProperty(func2, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string2),
          "writable": true
        });
      };
      var setToString = shortOut(baseSetToString);
      function arrayEach(array3, iteratee2) {
        var index2 = -1, length = array3 == null ? 0 : array3.length;
        while (++index2 < length) {
          if (iteratee2(array3[index2], index2, array3) === false) {
            break;
          }
        }
        return array3;
      }
      function baseFindIndex(array3, predicate, fromIndex, fromRight) {
        var length = array3.length, index2 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index2-- : ++index2 < length) {
          if (predicate(array3[index2], index2, array3)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function strictIndexOf(array3, value, fromIndex) {
        var index2 = fromIndex - 1, length = array3.length;
        while (++index2 < length) {
          if (array3[index2] === value) {
            return index2;
          }
        }
        return -1;
      }
      function baseIndexOf(array3, value, fromIndex) {
        return value === value ? strictIndexOf(array3, value, fromIndex) : baseFindIndex(array3, baseIsNaN, fromIndex);
      }
      function arrayIncludes(array3, value) {
        var length = array3 == null ? 0 : array3.length;
        return !!length && baseIndexOf(array3, value, 0) > -1;
      }
      var WRAP_BIND_FLAG$7 = 1;
      var WRAP_BIND_KEY_FLAG$6 = 2;
      var WRAP_CURRY_FLAG$6 = 8;
      var WRAP_CURRY_RIGHT_FLAG$3 = 16;
      var WRAP_PARTIAL_FLAG$6 = 32;
      var WRAP_PARTIAL_RIGHT_FLAG$3 = 64;
      var WRAP_ARY_FLAG$4 = 128;
      var WRAP_REARG_FLAG$3 = 256;
      var WRAP_FLIP_FLAG$2 = 512;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG$4],
        ["bind", WRAP_BIND_FLAG$7],
        ["bindKey", WRAP_BIND_KEY_FLAG$6],
        ["curry", WRAP_CURRY_FLAG$6],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG$3],
        ["flip", WRAP_FLIP_FLAG$2],
        ["partial", WRAP_PARTIAL_FLAG$6],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG$3],
        ["rearg", WRAP_REARG_FLAG$3]
      ];
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      var WRAP_BIND_FLAG$6 = 1;
      var WRAP_BIND_KEY_FLAG$5 = 2;
      var WRAP_CURRY_BOUND_FLAG$1 = 4;
      var WRAP_CURRY_FLAG$5 = 8;
      var WRAP_PARTIAL_FLAG$5 = 32;
      var WRAP_PARTIAL_RIGHT_FLAG$2 = 64;
      function createRecurry(func2, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG$5, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG$5 : WRAP_PARTIAL_RIGHT_FLAG$2;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG$2 : WRAP_PARTIAL_FLAG$5);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG$1)) {
          bitmask &= ~(WRAP_BIND_FLAG$6 | WRAP_BIND_KEY_FLAG$5);
        }
        var newData = [
          func2,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(void 0, newData);
        if (isLaziable(func2)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func2, bitmask);
      }
      function getHolder(func2) {
        var object3 = func2;
        return object3.placeholder;
      }
      var MAX_SAFE_INTEGER$5 = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER$5 : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      var nativeMin$e = Math.min;
      function reorder(array3, indexes) {
        var arrLength = array3.length, length = nativeMin$e(indexes.length, arrLength), oldArray = copyArray(array3);
        while (length--) {
          var index2 = indexes[length];
          array3[length] = isIndex(index2, arrLength) ? oldArray[index2] : void 0;
        }
        return array3;
      }
      var PLACEHOLDER$1 = "__lodash_placeholder__";
      function replaceHolders(array3, placeholder) {
        var index2 = -1, length = array3.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array3[index2];
          if (value === placeholder || value === PLACEHOLDER$1) {
            array3[index2] = PLACEHOLDER$1;
            result2[resIndex++] = index2;
          }
        }
        return result2;
      }
      var WRAP_BIND_FLAG$5 = 1;
      var WRAP_BIND_KEY_FLAG$4 = 2;
      var WRAP_CURRY_FLAG$4 = 8;
      var WRAP_CURRY_RIGHT_FLAG$2 = 16;
      var WRAP_ARY_FLAG$3 = 128;
      var WRAP_FLIP_FLAG$1 = 512;
      function createHybrid(func2, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG$3, isBind = bitmask & WRAP_BIND_FLAG$5, isBindKey = bitmask & WRAP_BIND_KEY_FLAG$4, isCurried = bitmask & (WRAP_CURRY_FLAG$4 | WRAP_CURRY_RIGHT_FLAG$2), isFlip = bitmask & WRAP_FLIP_FLAG$1, Ctor = isBindKey ? void 0 : createCtor(func2);
        function wrapper() {
          var length = arguments.length, args = Array(length), index2 = length;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func2, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func2] : func2;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn2 = Ctor || createCtor(fn2);
          }
          return fn2.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createCurry(func2, bitmask, arity) {
        var Ctor = createCtor(func2);
        function wrapper() {
          var length = arguments.length, args = Array(length), index2 = length, placeholder = getHolder(wrapper);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func2, bitmask, createHybrid, wrapper.placeholder, void 0, args, holders, void 0, void 0, arity - length);
          }
          var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func2;
          return apply(fn2, this, args);
        }
        return wrapper;
      }
      var WRAP_BIND_FLAG$4 = 1;
      function createPartial(func2, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG$4, Ctor = createCtor(func2);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn2 = this && this !== root && this instanceof wrapper ? Ctor : func2;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn2, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      var PLACEHOLDER = "__lodash_placeholder__";
      var WRAP_BIND_FLAG$3 = 1;
      var WRAP_BIND_KEY_FLAG$3 = 2;
      var WRAP_CURRY_BOUND_FLAG = 4;
      var WRAP_CURRY_FLAG$3 = 8;
      var WRAP_ARY_FLAG$2 = 128;
      var WRAP_REARG_FLAG$2 = 256;
      var nativeMin$d = Math.min;
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG$3 | WRAP_BIND_KEY_FLAG$3 | WRAP_ARY_FLAG$2);
        var isCombo = srcBitmask == WRAP_ARY_FLAG$2 && bitmask == WRAP_CURRY_FLAG$3 || srcBitmask == WRAP_ARY_FLAG$2 && bitmask == WRAP_REARG_FLAG$2 && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG$2 | WRAP_REARG_FLAG$2) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG$3;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG$3) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG$3 ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG$2) {
          data[8] = data[8] == null ? source[8] : nativeMin$d(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      var FUNC_ERROR_TEXT$a = "Expected a function";
      var WRAP_BIND_FLAG$2 = 1;
      var WRAP_BIND_KEY_FLAG$2 = 2;
      var WRAP_CURRY_FLAG$2 = 8;
      var WRAP_CURRY_RIGHT_FLAG$1 = 16;
      var WRAP_PARTIAL_FLAG$4 = 32;
      var WRAP_PARTIAL_RIGHT_FLAG$1 = 64;
      var nativeMax$e = Math.max;
      function createWrap(func2, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG$2;
        if (!isBindKey && typeof func2 != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$a);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG$4 | WRAP_PARTIAL_RIGHT_FLAG$1);
          partials = holders = void 0;
        }
        ary2 = ary2 === void 0 ? ary2 : nativeMax$e(toInteger(ary2), 0);
        arity = arity === void 0 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG$1) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = void 0;
        }
        var data = isBindKey ? void 0 : getData(func2);
        var newData = [
          func2,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func2 = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func2.length : nativeMax$e(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1)) {
          bitmask &= ~(WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG$2) {
          var result2 = createBind(func2, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG$2 || bitmask == WRAP_CURRY_RIGHT_FLAG$1) {
          result2 = createCurry(func2, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG$4 || bitmask == (WRAP_BIND_FLAG$2 | WRAP_PARTIAL_FLAG$4)) && !holders.length) {
          result2 = createPartial(func2, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(void 0, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func2, bitmask);
      }
      var WRAP_ARY_FLAG$1 = 128;
      function ary(func2, n, guard) {
        n = guard ? void 0 : n;
        n = func2 && n == null ? func2.length : n;
        return createWrap(func2, WRAP_ARY_FLAG$1, void 0, void 0, void 0, void 0, n);
      }
      function baseAssignValue(object3, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object3, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object3[key] = value;
        }
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var objectProto$n = Object.prototype;
      var hasOwnProperty$k = objectProto$n.hasOwnProperty;
      function assignValue(object3, key, value) {
        var objValue = object3[key];
        if (!(hasOwnProperty$k.call(object3, key) && eq(objValue, value)) || value === void 0 && !(key in object3)) {
          baseAssignValue(object3, key, value);
        }
      }
      function copyObject(source, props2, object3, customizer) {
        var isNew = !object3;
        object3 || (object3 = {});
        var index2 = -1, length = props2.length;
        while (++index2 < length) {
          var key = props2[index2];
          var newValue = customizer ? customizer(object3[key], source[key], key, object3, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object3, key, newValue);
          } else {
            assignValue(object3, key, newValue);
          }
        }
        return object3;
      }
      var nativeMax$d = Math.max;
      function overRest(func2, start, transform2) {
        start = nativeMax$d(start === void 0 ? func2.length - 1 : start, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax$d(args.length - start, 0), array3 = Array(length);
          while (++index2 < length) {
            array3[index2] = args[start + index2];
          }
          index2 = -1;
          var otherArgs = Array(start + 1);
          while (++index2 < start) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start] = transform2(array3);
          return apply(func2, this, otherArgs);
        };
      }
      function baseRest(func2, start) {
        return setToString(overRest(func2, start, identity), func2 + "");
      }
      var MAX_SAFE_INTEGER$4 = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$4;
      }
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isIterateeCall(value, index2, object3) {
        if (!isObject(object3)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike(object3) && isIndex(index2, object3.length) : type == "string" && index2 in object3) {
          return eq(object3[index2], value);
        }
        return false;
      }
      function createAssigner(assigner) {
        return baseRest(function(object3, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
          }
          object3 = Object(object3);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object3, source, index2, customizer);
            }
          }
          return object3;
        });
      }
      var objectProto$m = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$m;
        return value === proto;
      }
      function baseTimes(n, iteratee2) {
        var index2 = -1, result2 = Array(n);
        while (++index2 < n) {
          result2[index2] = iteratee2(index2);
        }
        return result2;
      }
      var argsTag$3 = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag$3;
      }
      var objectProto$l = Object.prototype;
      var hasOwnProperty$j = objectProto$l.hasOwnProperty;
      var propertyIsEnumerable$1 = objectProto$l.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty$j.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
      };
      function stubFalse() {
        return false;
      }
      var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
      var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      var argsTag$2 = "[object Arguments]";
      var arrayTag$2 = "[object Array]";
      var boolTag$4 = "[object Boolean]";
      var dateTag$4 = "[object Date]";
      var errorTag$3 = "[object Error]";
      var funcTag$1 = "[object Function]";
      var mapTag$9 = "[object Map]";
      var numberTag$4 = "[object Number]";
      var objectTag$4 = "[object Object]";
      var regexpTag$4 = "[object RegExp]";
      var setTag$9 = "[object Set]";
      var stringTag$4 = "[object String]";
      var weakMapTag$3 = "[object WeakMap]";
      var arrayBufferTag$4 = "[object ArrayBuffer]";
      var dataViewTag$4 = "[object DataView]";
      var float32Tag$2 = "[object Float32Array]";
      var float64Tag$2 = "[object Float64Array]";
      var int8Tag$2 = "[object Int8Array]";
      var int16Tag$2 = "[object Int16Array]";
      var int32Tag$2 = "[object Int32Array]";
      var uint8Tag$2 = "[object Uint8Array]";
      var uint8ClampedTag$2 = "[object Uint8ClampedArray]";
      var uint16Tag$2 = "[object Uint16Array]";
      var uint32Tag$2 = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
      typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$4] = typedArrayTags[boolTag$4] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$4] = typedArrayTags[errorTag$3] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$9] = typedArrayTags[numberTag$4] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$4] = typedArrayTags[setTag$9] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$3] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseUnary(func2) {
        return function(value) {
          return func2(value);
        };
      }
      var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
      var freeProcess = moduleExports$1 && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      var objectProto$k = Object.prototype;
      var hasOwnProperty$i = objectProto$k.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty$i.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function overArg(func2, transform2) {
        return function(arg) {
          return func2(transform2(arg));
        };
      }
      var nativeKeys = overArg(Object.keys, Object);
      var objectProto$j = Object.prototype;
      var hasOwnProperty$h = objectProto$j.hasOwnProperty;
      function baseKeys(object3) {
        if (!isPrototype(object3)) {
          return nativeKeys(object3);
        }
        var result2 = [];
        for (var key in Object(object3)) {
          if (hasOwnProperty$h.call(object3, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function keys(object3) {
        return isArrayLike(object3) ? arrayLikeKeys(object3) : baseKeys(object3);
      }
      var objectProto$i = Object.prototype;
      var hasOwnProperty$g = objectProto$i.hasOwnProperty;
      var assign = createAssigner(function(object3, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object3);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty$g.call(source, key)) {
            assignValue(object3, key, source[key]);
          }
        }
      });
      function nativeKeysIn(object3) {
        var result2 = [];
        if (object3 != null) {
          for (var key in Object(object3)) {
            result2.push(key);
          }
        }
        return result2;
      }
      var objectProto$h = Object.prototype;
      var hasOwnProperty$f = objectProto$h.hasOwnProperty;
      function baseKeysIn(object3) {
        if (!isObject(object3)) {
          return nativeKeysIn(object3);
        }
        var isProto = isPrototype(object3), result2 = [];
        for (var key in object3) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty$f.call(object3, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function keysIn(object3) {
        return isArrayLike(object3) ? arrayLikeKeys(object3, true) : baseKeysIn(object3);
      }
      var assignIn = createAssigner(function(object3, source) {
        copyObject(source, keysIn(source), object3);
      });
      var assignInWith = createAssigner(function(object3, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object3, customizer);
      });
      var assignWith = createAssigner(function(object3, source, srcIndex, customizer) {
        copyObject(source, keys(source), object3, customizer);
      });
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
      var reIsPlainProp = /^\w*$/;
      function isKey(value, object3) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object3 != null && value in Object(object3);
      }
      var nativeCreate = getNative(Object, "create");
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
      var objectProto$g = Object.prototype;
      var hasOwnProperty$e = objectProto$g.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED$2 ? void 0 : result2;
        }
        return hasOwnProperty$e.call(data, key) ? data[key] : void 0;
      }
      var objectProto$f = Object.prototype;
      var hasOwnProperty$d = objectProto$f.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty$d.call(data, key);
      }
      var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
        return this;
      }
      function Hash(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function assocIndexOf(array3, key) {
        var length = array3.length;
        while (length--) {
          if (eq(array3[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      var arrayProto$5 = Array.prototype;
      var splice$2 = arrayProto$5.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice$2.call(data, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        return index2 < 0 ? void 0 : data[index2][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      var Map$1 = getNative(root, "Map");
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map$1 || ListCache)(),
          "string": new Hash()
        };
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      var FUNC_ERROR_TEXT$9 = "Expected a function";
      function memoize(func2, resolver) {
        if (typeof func2 != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$9);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result2 = func2.apply(this, args);
          memoized.cache = cache2.set(key, result2) || cache2;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func2) {
        var result2 = memoize(func2, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result2.cache;
        return result2;
      }
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string2) {
        var result2 = [];
        if (string2.charCodeAt(0) === 46) {
          result2.push("");
        }
        string2.replace(rePropName, function(match, number3, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match);
        });
        return result2;
      });
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      function castPath(value, object3) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object3) ? [value] : stringToPath(toString(value));
      }
      var INFINITY$3 = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY$3 ? "-0" : result2;
      }
      function baseGet(object3, path) {
        path = castPath(path, object3);
        var index2 = 0, length = path.length;
        while (object3 != null && index2 < length) {
          object3 = object3[toKey(path[index2++])];
        }
        return index2 && index2 == length ? object3 : void 0;
      }
      function get(object3, path, defaultValue) {
        var result2 = object3 == null ? void 0 : baseGet(object3, path);
        return result2 === void 0 ? defaultValue : result2;
      }
      function baseAt(object3, paths) {
        var index2 = -1, length = paths.length, result2 = Array(length), skip = object3 == null;
        while (++index2 < length) {
          result2[index2] = skip ? void 0 : get(object3, paths[index2]);
        }
        return result2;
      }
      function arrayPush(array3, values2) {
        var index2 = -1, length = values2.length, offset2 = array3.length;
        while (++index2 < length) {
          array3[offset2 + index2] = values2[index2];
        }
        return array3;
      }
      var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function baseFlatten(array3, depth, predicate, isStrict, result2) {
        var index2 = -1, length = array3.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length) {
          var value = array3[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      function flatten(array3) {
        var length = array3 == null ? 0 : array3.length;
        return length ? baseFlatten(array3, 1) : [];
      }
      function flatRest(func2) {
        return setToString(overRest(func2, void 0, flatten), func2 + "");
      }
      var at$1 = flatRest(baseAt);
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      var objectTag$3 = "[object Object]";
      var funcProto = Function.prototype;
      var objectProto$e = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty$c = objectProto$e.hasOwnProperty;
      var objectCtorString = funcToString.call(Object);
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty$c.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var domExcTag = "[object DOMException]";
      var errorTag$2 = "[object Error]";
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag$2 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
      }
      var attempt = baseRest(function(func2, args) {
        try {
          return apply(func2, void 0, args);
        } catch (e) {
          return isError(e) ? e : new Error(e);
        }
      });
      var FUNC_ERROR_TEXT$8 = "Expected a function";
      function before(n, func2) {
        var result2;
        if (typeof func2 != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$8);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func2.apply(this, arguments);
          }
          if (n <= 1) {
            func2 = void 0;
          }
          return result2;
        };
      }
      var WRAP_BIND_FLAG$1 = 1;
      var WRAP_PARTIAL_FLAG$3 = 32;
      var bind = baseRest(function(func2, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG$1;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG$3;
        }
        return createWrap(func2, bitmask, thisArg, partials, holders);
      });
      bind.placeholder = {};
      var bindAll = flatRest(function(object3, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object3, key, bind(object3[key], object3));
        });
        return object3;
      });
      var WRAP_BIND_FLAG = 1;
      var WRAP_BIND_KEY_FLAG$1 = 2;
      var WRAP_PARTIAL_FLAG$2 = 32;
      var bindKey = baseRest(function(object3, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG$1;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG$2;
        }
        return createWrap(key, bitmask, object3, partials, holders);
      });
      bindKey.placeholder = {};
      function baseSlice(array3, start, end) {
        var index2 = -1, length = array3.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array(length);
        while (++index2 < length) {
          result2[index2] = array3[index2 + start];
        }
        return result2;
      }
      function castSlice(array3, start, end) {
        var length = array3.length;
        end = end === void 0 ? length : end;
        return !start && end >= length ? array3 : baseSlice(array3, start, end);
      }
      var rsAstralRange$3 = "\\ud800-\\udfff";
      var rsComboMarksRange$4 = "\\u0300-\\u036f";
      var reComboHalfMarksRange$4 = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange$4 = "\\u20d0-\\u20ff";
      var rsComboRange$4 = rsComboMarksRange$4 + reComboHalfMarksRange$4 + rsComboSymbolsRange$4;
      var rsVarRange$3 = "\\ufe0e\\ufe0f";
      var rsZWJ$3 = "\\u200d";
      var reHasUnicode = RegExp("[" + rsZWJ$3 + rsAstralRange$3 + rsComboRange$4 + rsVarRange$3 + "]");
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      function asciiToArray(string2) {
        return string2.split("");
      }
      var rsAstralRange$2 = "\\ud800-\\udfff";
      var rsComboMarksRange$3 = "\\u0300-\\u036f";
      var reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange$3 = "\\u20d0-\\u20ff";
      var rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3;
      var rsVarRange$2 = "\\ufe0e\\ufe0f";
      var rsAstral$1 = "[" + rsAstralRange$2 + "]";
      var rsCombo$3 = "[" + rsComboRange$3 + "]";
      var rsFitz$2 = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier$2 = "(?:" + rsCombo$3 + "|" + rsFitz$2 + ")";
      var rsNonAstral$2 = "[^" + rsAstralRange$2 + "]";
      var rsRegional$2 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair$2 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsZWJ$2 = "\\u200d";
      var reOptMod$2 = rsModifier$2 + "?";
      var rsOptVar$2 = "[" + rsVarRange$2 + "]?";
      var rsOptJoin$2 = "(?:" + rsZWJ$2 + "(?:" + [rsNonAstral$2, rsRegional$2, rsSurrPair$2].join("|") + ")" + rsOptVar$2 + reOptMod$2 + ")*";
      var rsSeq$2 = rsOptVar$2 + reOptMod$2 + rsOptJoin$2;
      var rsSymbol$1 = "(?:" + [rsNonAstral$2 + rsCombo$3 + "?", rsCombo$3, rsRegional$2, rsSurrPair$2, rsAstral$1].join("|") + ")";
      var reUnicode$1 = RegExp(rsFitz$2 + "(?=" + rsFitz$2 + ")|" + rsSymbol$1 + rsSeq$2, "g");
      function unicodeToArray(string2) {
        return string2.match(reUnicode$1) || [];
      }
      function stringToArray(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      function createCaseFirst(methodName) {
        return function(string2) {
          string2 = toString(string2);
          var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
          var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      var upperFirst = createCaseFirst("toUpperCase");
      function capitalize$1(string2) {
        return upperFirst(toString(string2).toLowerCase());
      }
      function arrayReduce(array3, iteratee2, accumulator, initAccum) {
        var index2 = -1, length = array3 == null ? 0 : array3.length;
        if (initAccum && length) {
          accumulator = array3[++index2];
        }
        while (++index2 < length) {
          accumulator = iteratee2(accumulator, array3[index2], index2, array3);
        }
        return accumulator;
      }
      function basePropertyOf(object3) {
        return function(key) {
          return object3 == null ? void 0 : object3[key];
        };
      }
      var deburredLetters = {
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var deburrLetter = basePropertyOf(deburredLetters);
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var rsComboMarksRange$2 = "\\u0300-\\u036f";
      var reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange$2 = "\\u20d0-\\u20ff";
      var rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;
      var rsCombo$2 = "[" + rsComboRange$2 + "]";
      var reComboMark = RegExp(rsCombo$2, "g");
      function deburr(string2) {
        string2 = toString(string2);
        return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      function asciiWords(string2) {
        return string2.match(reAsciiWord) || [];
      }
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      function hasUnicodeWord(string2) {
        return reHasUnicodeWord.test(string2);
      }
      var rsAstralRange$1 = "\\ud800-\\udfff";
      var rsComboMarksRange$1 = "\\u0300-\\u036f";
      var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
      var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
      var rsDingbatRange = "\\u2700-\\u27bf";
      var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
      var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
      var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
      var rsPunctuationRange = "\\u2000-\\u206f";
      var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
      var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
      var rsVarRange$1 = "\\ufe0e\\ufe0f";
      var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos$1 = "['’]";
      var rsBreak = "[" + rsBreakRange + "]";
      var rsCombo$1 = "[" + rsComboRange$1 + "]";
      var rsDigits = "\\d+";
      var rsDingbat = "[" + rsDingbatRange + "]";
      var rsLower = "[" + rsLowerRange + "]";
      var rsMisc = "[^" + rsAstralRange$1 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
      var rsFitz$1 = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier$1 = "(?:" + rsCombo$1 + "|" + rsFitz$1 + ")";
      var rsNonAstral$1 = "[^" + rsAstralRange$1 + "]";
      var rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsUpper = "[" + rsUpperRange + "]";
      var rsZWJ$1 = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
      var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
      var rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?";
      var rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?";
      var reOptMod$1 = rsModifier$1 + "?";
      var rsOptVar$1 = "[" + rsVarRange$1 + "]?";
      var rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*";
      var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
      var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
      var rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1;
      var rsEmoji = "(?:" + [rsDingbat, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsSeq$1;
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      function unicodeWords(string2) {
        return string2.match(reUnicodeWord) || [];
      }
      function words(string2, pattern, guard) {
        string2 = toString(string2);
        pattern = guard ? void 0 : pattern;
        if (pattern === void 0) {
          return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
        }
        return string2.match(pattern) || [];
      }
      var rsApos = "['’]";
      var reApos = RegExp(rsApos, "g");
      function createCompounder(callback) {
        return function(string2) {
          return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
        };
      }
      var camelCase = createCompounder(function(result2, word, index2) {
        word = word.toLowerCase();
        return result2 + (index2 ? capitalize$1(word) : word);
      });
      function castArray$1() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      var nativeIsFinite$1 = root.isFinite;
      var nativeMin$c = Math.min;
      function createRound(methodName) {
        var func2 = Math[methodName];
        return function(number3, precision) {
          number3 = toNumber(number3);
          precision = precision == null ? 0 : nativeMin$c(toInteger(precision), 292);
          if (precision && nativeIsFinite$1(number3)) {
            var pair = (toString(number3) + "e").split("e"), value = func2(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func2(number3);
        };
      }
      var ceil = createRound("ceil");
      function chain(value) {
        var result2 = lodash(value);
        result2.__chain__ = true;
        return result2;
      }
      var nativeCeil$3 = Math.ceil;
      var nativeMax$c = Math.max;
      function chunk(array3, size, guard) {
        if (guard ? isIterateeCall(array3, size, guard) : size === void 0) {
          size = 1;
        } else {
          size = nativeMax$c(toInteger(size), 0);
        }
        var length = array3 == null ? 0 : array3.length;
        if (!length || size < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array(nativeCeil$3(length / size));
        while (index2 < length) {
          result2[resIndex++] = baseSlice(array3, index2, index2 += size);
        }
        return result2;
      }
      function baseClamp(number3, lower, upper) {
        if (number3 === number3) {
          if (upper !== void 0) {
            number3 = number3 <= upper ? number3 : upper;
          }
          if (lower !== void 0) {
            number3 = number3 >= lower ? number3 : lower;
          }
        }
        return number3;
      }
      function clamp$1(number3, lower, upper) {
        if (upper === void 0) {
          upper = lower;
          lower = void 0;
        }
        if (upper !== void 0) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== void 0) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number3), lower, upper);
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      var LARGE_ARRAY_SIZE$2 = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE$2 - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function baseAssign(object3, source) {
        return object3 && copyObject(source, keys(source), object3);
      }
      function baseAssignIn(object3, source) {
        return object3 && copyObject(source, keysIn(source), object3);
      }
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer = moduleExports ? root.Buffer : void 0;
      var allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function arrayFilter(array3, predicate) {
        var index2 = -1, length = array3 == null ? 0 : array3.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array3[index2];
          if (predicate(value, index2, array3)) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function stubArray() {
        return [];
      }
      var objectProto$d = Object.prototype;
      var propertyIsEnumerable = objectProto$d.propertyIsEnumerable;
      var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object3) {
        if (object3 == null) {
          return [];
        }
        object3 = Object(object3);
        return arrayFilter(nativeGetSymbols$1(object3), function(symbol) {
          return propertyIsEnumerable.call(object3, symbol);
        });
      };
      function copySymbols(source, object3) {
        return copyObject(source, getSymbols(source), object3);
      }
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object3) {
        var result2 = [];
        while (object3) {
          arrayPush(result2, getSymbols(object3));
          object3 = getPrototype(object3);
        }
        return result2;
      };
      function copySymbolsIn(source, object3) {
        return copyObject(source, getSymbolsIn(source), object3);
      }
      function baseGetAllKeys(object3, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object3);
        return isArray(object3) ? result2 : arrayPush(result2, symbolsFunc(object3));
      }
      function getAllKeys(object3) {
        return baseGetAllKeys(object3, keys, getSymbols);
      }
      function getAllKeysIn(object3) {
        return baseGetAllKeys(object3, keysIn, getSymbolsIn);
      }
      var DataView = getNative(root, "DataView");
      var Promise$1 = getNative(root, "Promise");
      var Set$1 = getNative(root, "Set");
      var mapTag$8 = "[object Map]";
      var objectTag$2 = "[object Object]";
      var promiseTag = "[object Promise]";
      var setTag$8 = "[object Set]";
      var weakMapTag$2 = "[object WeakMap]";
      var dataViewTag$3 = "[object DataView]";
      var dataViewCtorString = toSource(DataView);
      var mapCtorString = toSource(Map$1);
      var promiseCtorString = toSource(Promise$1);
      var setCtorString = toSource(Set$1);
      var weakMapCtorString = toSource(WeakMap$1);
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$8 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$8 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$2) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag$3;
              case mapCtorString:
                return mapTag$8;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag$8;
              case weakMapCtorString:
                return weakMapTag$2;
            }
          }
          return result2;
        };
      }
      var getTag$1 = getTag;
      var objectProto$c = Object.prototype;
      var hasOwnProperty$b = objectProto$c.hasOwnProperty;
      function initCloneArray(array3) {
        var length = array3.length, result2 = new array3.constructor(length);
        if (length && typeof array3[0] == "string" && hasOwnProperty$b.call(array3, "index")) {
          result2.index = array3.index;
          result2.input = array3.input;
        }
        return result2;
      }
      var Uint8Array = root.Uint8Array;
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array(result2).set(new Uint8Array(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      var reFlags$1 = /\w*$/;
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags$1.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0;
      var symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      var boolTag$3 = "[object Boolean]";
      var dateTag$3 = "[object Date]";
      var mapTag$7 = "[object Map]";
      var numberTag$3 = "[object Number]";
      var regexpTag$3 = "[object RegExp]";
      var setTag$7 = "[object Set]";
      var stringTag$3 = "[object String]";
      var symbolTag$2 = "[object Symbol]";
      var arrayBufferTag$3 = "[object ArrayBuffer]";
      var dataViewTag$2 = "[object DataView]";
      var float32Tag$1 = "[object Float32Array]";
      var float64Tag$1 = "[object Float64Array]";
      var int8Tag$1 = "[object Int8Array]";
      var int16Tag$1 = "[object Int16Array]";
      var int32Tag$1 = "[object Int32Array]";
      var uint8Tag$1 = "[object Uint8Array]";
      var uint8ClampedTag$1 = "[object Uint8ClampedArray]";
      var uint16Tag$1 = "[object Uint16Array]";
      var uint32Tag$1 = "[object Uint32Array]";
      function initCloneByTag(object3, tag, isDeep) {
        var Ctor = object3.constructor;
        switch (tag) {
          case arrayBufferTag$3:
            return cloneArrayBuffer(object3);
          case boolTag$3:
          case dateTag$3:
            return new Ctor(+object3);
          case dataViewTag$2:
            return cloneDataView(object3, isDeep);
          case float32Tag$1:
          case float64Tag$1:
          case int8Tag$1:
          case int16Tag$1:
          case int32Tag$1:
          case uint8Tag$1:
          case uint8ClampedTag$1:
          case uint16Tag$1:
          case uint32Tag$1:
            return cloneTypedArray(object3, isDeep);
          case mapTag$7:
            return new Ctor();
          case numberTag$3:
          case stringTag$3:
            return new Ctor(object3);
          case regexpTag$3:
            return cloneRegExp(object3);
          case setTag$7:
            return new Ctor();
          case symbolTag$2:
            return cloneSymbol(object3);
        }
      }
      function initCloneObject(object3) {
        return typeof object3.constructor == "function" && !isPrototype(object3) ? baseCreate(getPrototype(object3)) : {};
      }
      var mapTag$6 = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike(value) && getTag$1(value) == mapTag$6;
      }
      var nodeIsMap = nodeUtil && nodeUtil.isMap;
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      var setTag$6 = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike(value) && getTag$1(value) == setTag$6;
      }
      var nodeIsSet = nodeUtil && nodeUtil.isSet;
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      var CLONE_DEEP_FLAG$7 = 1;
      var CLONE_FLAT_FLAG$1 = 2;
      var CLONE_SYMBOLS_FLAG$5 = 4;
      var argsTag$1 = "[object Arguments]";
      var arrayTag$1 = "[object Array]";
      var boolTag$2 = "[object Boolean]";
      var dateTag$2 = "[object Date]";
      var errorTag$1 = "[object Error]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var mapTag$5 = "[object Map]";
      var numberTag$2 = "[object Number]";
      var objectTag$1 = "[object Object]";
      var regexpTag$2 = "[object RegExp]";
      var setTag$5 = "[object Set]";
      var stringTag$2 = "[object String]";
      var symbolTag$1 = "[object Symbol]";
      var weakMapTag$1 = "[object WeakMap]";
      var arrayBufferTag$2 = "[object ArrayBuffer]";
      var dataViewTag$1 = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$2] = cloneableTags[dateTag$2] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$5] = cloneableTags[numberTag$2] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$2] = cloneableTags[setTag$5] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag$1] = false;
      function baseClone(value, bitmask, customizer, key, object3, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG$7, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$5;
        if (customizer) {
          result2 = object3 ? customizer(value, key, object3, stack) : customizer(value);
        }
        if (result2 !== void 0) {
          return result2;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object3) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object3 ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props2 = isArr ? void 0 : keysFunc(value);
        arrayEach(props2 || value, function(subValue, key2) {
          if (props2) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      var CLONE_SYMBOLS_FLAG$4 = 4;
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG$4);
      }
      var CLONE_DEEP_FLAG$6 = 1;
      var CLONE_SYMBOLS_FLAG$3 = 4;
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG$6 | CLONE_SYMBOLS_FLAG$3);
      }
      var CLONE_DEEP_FLAG$5 = 1;
      var CLONE_SYMBOLS_FLAG$2 = 4;
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : void 0;
        return baseClone(value, CLONE_DEEP_FLAG$5 | CLONE_SYMBOLS_FLAG$2, customizer);
      }
      var CLONE_SYMBOLS_FLAG$1 = 4;
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : void 0;
        return baseClone(value, CLONE_SYMBOLS_FLAG$1, customizer);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function compact(array3) {
        var index2 = -1, length = array3 == null ? 0 : array3.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array3[index2];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array(length - 1), array3 = arguments[0], index2 = length;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush(isArray(array3) ? copyArray(array3) : [array3], baseFlatten(args, 1));
      }
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      function SetCache(values2) {
        var index2 = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values2[index2]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function arraySome(array3, predicate) {
        var index2 = -1, length = array3 == null ? 0 : array3.length;
        while (++index2 < length) {
          if (predicate(array3[index2], index2, array3)) {
            return true;
          }
        }
        return false;
      }
      function cacheHas(cache2, key) {
        return cache2.has(key);
      }
      var COMPARE_PARTIAL_FLAG$5 = 1;
      var COMPARE_UNORDERED_FLAG$3 = 2;
      function equalArrays(array3, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array3.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array3);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array3;
        }
        var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
        stack.set(array3, other);
        stack.set(other, array3);
        while (++index2 < arrLength) {
          var arrValue = array3[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array3, stack) : customizer(arrValue, othValue, index2, array3, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array3);
        stack["delete"](other);
        return result2;
      }
      function mapToArray(map2) {
        var index2 = -1, result2 = Array(map2.size);
        map2.forEach(function(value, key) {
          result2[++index2] = [key, value];
        });
        return result2;
      }
      function setToArray(set2) {
        var index2 = -1, result2 = Array(set2.size);
        set2.forEach(function(value) {
          result2[++index2] = value;
        });
        return result2;
      }
      var COMPARE_PARTIAL_FLAG$4 = 1;
      var COMPARE_UNORDERED_FLAG$2 = 2;
      var boolTag$1 = "[object Boolean]";
      var dateTag$1 = "[object Date]";
      var errorTag = "[object Error]";
      var mapTag$4 = "[object Map]";
      var numberTag$1 = "[object Number]";
      var regexpTag$1 = "[object RegExp]";
      var setTag$4 = "[object Set]";
      var stringTag$1 = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag$1 = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object3, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object3.byteLength != other.byteLength || object3.byteOffset != other.byteOffset) {
              return false;
            }
            object3 = object3.buffer;
            other = other.buffer;
          case arrayBufferTag$1:
            if (object3.byteLength != other.byteLength || !equalFunc(new Uint8Array(object3), new Uint8Array(other))) {
              return false;
            }
            return true;
          case boolTag$1:
          case dateTag$1:
          case numberTag$1:
            return eq(+object3, +other);
          case errorTag:
            return object3.name == other.name && object3.message == other.message;
          case regexpTag$1:
          case stringTag$1:
            return object3 == other + "";
          case mapTag$4:
            var convert = mapToArray;
          case setTag$4:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
            convert || (convert = setToArray);
            if (object3.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object3);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG$2;
            stack.set(object3, other);
            var result2 = equalArrays(convert(object3), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object3);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object3) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      var COMPARE_PARTIAL_FLAG$3 = 1;
      var objectProto$b = Object.prototype;
      var hasOwnProperty$a = objectProto$b.hasOwnProperty;
      function equalObjects(object3, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object3), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty$a.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object3);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object3;
        }
        var result2 = true;
        stack.set(object3, other);
        stack.set(other, object3);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object3[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object3, stack) : customizer(objValue, othValue, key, object3, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object3.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object3 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object3);
        stack["delete"](other);
        return result2;
      }
      var COMPARE_PARTIAL_FLAG$2 = 1;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var objectTag = "[object Object]";
      var objectProto$a = Object.prototype;
      var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
      function baseIsEqualDeep(object3, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object3), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag$1(object3), othTag = othIsArr ? arrayTag : getTag$1(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object3)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object3) ? equalArrays(object3, other, bitmask, customizer, equalFunc, stack) : equalByTag(object3, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
          var objIsWrapped = objIsObj && hasOwnProperty$9.call(object3, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$9.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object3.value() : object3, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object3, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      var COMPARE_PARTIAL_FLAG$1 = 1;
      var COMPARE_UNORDERED_FLAG$1 = 2;
      function baseIsMatch(object3, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object3 == null) {
          return !length;
        }
        object3 = Object(object3);
        while (index2--) {
          var data = matchData[index2];
          if (noCustomizer && data[2] ? data[1] !== object3[data[0]] : !(data[0] in object3)) {
            return false;
          }
        }
        while (++index2 < length) {
          data = matchData[index2];
          var key = data[0], objValue = object3[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object3)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object3, source, stack);
            }
            if (!(result2 === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function getMatchData(object3) {
        var result2 = keys(object3), length = result2.length;
        while (length--) {
          var key = result2[length], value = object3[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object3) {
          if (object3 == null) {
            return false;
          }
          return object3[key] === srcValue && (srcValue !== void 0 || key in Object(object3));
        };
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object3) {
          return object3 === source || baseIsMatch(object3, source, matchData);
        };
      }
      function baseHasIn(object3, key) {
        return object3 != null && key in Object(object3);
      }
      function hasPath(object3, path, hasFunc) {
        path = castPath(path, object3);
        var index2 = -1, length = path.length, result2 = false;
        while (++index2 < length) {
          var key = toKey(path[index2]);
          if (!(result2 = object3 != null && hasFunc(object3, key))) {
            break;
          }
          object3 = object3[key];
        }
        if (result2 || ++index2 != length) {
          return result2;
        }
        length = object3 == null ? 0 : object3.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object3) || isArguments(object3));
      }
      function hasIn(object3, path) {
        return object3 != null && hasPath(object3, path, baseHasIn);
      }
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object3) {
          var objValue = get(object3, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object3, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseProperty(key) {
        return function(object3) {
          return object3 == null ? void 0 : object3[key];
        };
      }
      function basePropertyDeep(path) {
        return function(object3) {
          return baseGet(object3, path);
        };
      }
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      var FUNC_ERROR_TEXT$7 = "Expected a function";
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = baseIteratee;
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError(FUNC_ERROR_TEXT$7);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index2 = -1;
          while (++index2 < length) {
            var pair = pairs[index2];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function baseConformsTo(object3, source, props2) {
        var length = props2.length;
        if (object3 == null) {
          return !length;
        }
        object3 = Object(object3);
        while (length--) {
          var key = props2[length], predicate = source[key], value = object3[key];
          if (value === void 0 && !(key in object3) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseConforms(source) {
        var props2 = keys(source);
        return function(object3) {
          return baseConformsTo(object3, source, props2);
        };
      }
      var CLONE_DEEP_FLAG$4 = 1;
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG$4));
      }
      function conformsTo(object3, source) {
        return source == null || baseConformsTo(object3, source, keys(source));
      }
      function arrayAggregator(array3, setter, iteratee2, accumulator) {
        var index2 = -1, length = array3 == null ? 0 : array3.length;
        while (++index2 < length) {
          var value = array3[index2];
          setter(accumulator, value, iteratee2(value), array3);
        }
        return accumulator;
      }
      function createBaseFor(fromRight) {
        return function(object3, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object(object3), props2 = keysFunc(object3), length = props2.length;
          while (length--) {
            var key = props2[fromRight ? length : ++index2];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object3;
        };
      }
      var baseFor = createBaseFor();
      function baseForOwn(object3, iteratee2) {
        return object3 && baseFor(object3, iteratee2, keys);
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection2, iteratee2) {
          if (collection2 == null) {
            return collection2;
          }
          if (!isArrayLike(collection2)) {
            return eachFunc(collection2, iteratee2);
          }
          var length = collection2.length, index2 = fromRight ? length : -1, iterable = Object(collection2);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection2;
        };
      }
      var baseEach = createBaseEach(baseForOwn);
      function baseAggregator(collection2, setter, iteratee2, accumulator) {
        baseEach(collection2, function(value, key, collection22) {
          setter(accumulator, value, iteratee2(value), collection22);
        });
        return accumulator;
      }
      function createAggregator(setter, initializer) {
        return function(collection2, iteratee2) {
          var func2 = isArray(collection2) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func2(collection2, setter, baseIteratee(iteratee2), accumulator);
        };
      }
      var objectProto$9 = Object.prototype;
      var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty$8.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var WRAP_CURRY_FLAG$1 = 8;
      function curry(func2, arity, guard) {
        arity = guard ? void 0 : arity;
        var result2 = createWrap(func2, WRAP_CURRY_FLAG$1, void 0, void 0, void 0, void 0, void 0, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      curry.placeholder = {};
      var WRAP_CURRY_RIGHT_FLAG = 16;
      function curryRight(func2, arity, guard) {
        arity = guard ? void 0 : arity;
        var result2 = createWrap(func2, WRAP_CURRY_RIGHT_FLAG, void 0, void 0, void 0, void 0, void 0, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      curryRight.placeholder = {};
      var now = function() {
        return root.Date.now();
      };
      var FUNC_ERROR_TEXT$6 = "Expected a function";
      var nativeMax$b = Math.max;
      var nativeMin$b = Math.min;
      function debounce(func2, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func2 != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$6);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax$b(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result2 = func2.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin$b(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result2;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var objectProto$8 = Object.prototype;
      var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
      var defaults = baseRest(function(object3, sources) {
        object3 = Object(object3);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source = sources[index2];
          var props2 = keysIn(source);
          var propsIndex = -1;
          var propsLength = props2.length;
          while (++propsIndex < propsLength) {
            var key = props2[propsIndex];
            var value = object3[key];
            if (value === void 0 || eq(value, objectProto$8[key]) && !hasOwnProperty$7.call(object3, key)) {
              object3[key] = source[key];
            }
          }
        }
        return object3;
      });
      function assignMergeValue(object3, key, value) {
        if (value !== void 0 && !eq(object3[key], value) || value === void 0 && !(key in object3)) {
          baseAssignValue(object3, key, value);
        }
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function safeGet(object3, key) {
        if (key === "constructor" && typeof object3[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object3[key];
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function baseMergeDeep(object3, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object3, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object3, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object3, source, stack) : void 0;
        var isCommon = newValue === void 0;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object3, key, newValue);
      }
      function baseMerge(object3, source, srcIndex, customizer, stack) {
        if (object3 === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject(srcValue)) {
            baseMergeDeep(object3, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object3, key), srcValue, key + "", object3, source, stack) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            assignMergeValue(object3, key, newValue);
          }
        }, keysIn);
      }
      function customDefaultsMerge(objValue, srcValue, key, object3, source, stack) {
        if (isObject(objValue) && isObject(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, void 0, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      var mergeWith = createAssigner(function(object3, source, srcIndex, customizer) {
        baseMerge(object3, source, srcIndex, customizer);
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(void 0, customDefaultsMerge);
        return apply(mergeWith, void 0, args);
      });
      var FUNC_ERROR_TEXT$5 = "Expected a function";
      function baseDelay(func2, wait, args) {
        if (typeof func2 != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$5);
        }
        return setTimeout(function() {
          func2.apply(void 0, args);
        }, wait);
      }
      var defer = baseRest(function(func2, args) {
        return baseDelay(func2, 1, args);
      });
      var delay = baseRest(function(func2, wait, args) {
        return baseDelay(func2, toNumber(wait) || 0, args);
      });
      function arrayIncludesWith(array3, value, comparator) {
        var index2 = -1, length = array3 == null ? 0 : array3.length;
        while (++index2 < length) {
          if (comparator(value, array3[index2])) {
            return true;
          }
        }
        return false;
      }
      var LARGE_ARRAY_SIZE$1 = 200;
      function baseDifference(array3, values2, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array3.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE$1) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index2 < length) {
            var value = array3[index2], computed2 = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed2) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed2, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var difference = baseRest(function(array3, values2) {
        return isArrayLikeObject(array3) ? baseDifference(array3, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      function last(array3) {
        var length = array3 == null ? 0 : array3.length;
        return length ? array3[length - 1] : void 0;
      }
      var differenceBy = baseRest(function(array3, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = void 0;
        }
        return isArrayLikeObject(array3) ? baseDifference(array3, baseFlatten(values2, 1, isArrayLikeObject, true), baseIteratee(iteratee2)) : [];
      });
      var differenceWith = baseRest(function(array3, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = void 0;
        }
        return isArrayLikeObject(array3) ? baseDifference(array3, baseFlatten(values2, 1, isArrayLikeObject, true), void 0, comparator) : [];
      });
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      function drop(array3, n, guard) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return [];
        }
        n = guard || n === void 0 ? 1 : toInteger(n);
        return baseSlice(array3, n < 0 ? 0 : n, length);
      }
      function dropRight(array3, n, guard) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return [];
        }
        n = guard || n === void 0 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array3, 0, n < 0 ? 0 : n);
      }
      function baseWhile(array3, predicate, isDrop, fromRight) {
        var length = array3.length, index2 = fromRight ? length : -1;
        while ((fromRight ? index2-- : ++index2 < length) && predicate(array3[index2], index2, array3)) {
        }
        return isDrop ? baseSlice(array3, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array3, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
      }
      function dropRightWhile(array3, predicate) {
        return array3 && array3.length ? baseWhile(array3, baseIteratee(predicate), true, true) : [];
      }
      function dropWhile(array3, predicate) {
        return array3 && array3.length ? baseWhile(array3, baseIteratee(predicate), true) : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function forEach(collection2, iteratee2) {
        var func2 = isArray(collection2) ? arrayEach : baseEach;
        return func2(collection2, castFunction(iteratee2));
      }
      function arrayEachRight(array3, iteratee2) {
        var length = array3 == null ? 0 : array3.length;
        while (length--) {
          if (iteratee2(array3[length], length, array3) === false) {
            break;
          }
        }
        return array3;
      }
      var baseForRight = createBaseFor(true);
      function baseForOwnRight(object3, iteratee2) {
        return object3 && baseForRight(object3, iteratee2, keys);
      }
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function forEachRight(collection2, iteratee2) {
        var func2 = isArray(collection2) ? arrayEachRight : baseEachRight;
        return func2(collection2, castFunction(iteratee2));
      }
      function endsWith(string2, target2, position) {
        string2 = toString(string2);
        target2 = baseToString(target2);
        var length = string2.length;
        position = position === void 0 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target2.length;
        return position >= 0 && string2.slice(position, end) == target2;
      }
      function baseToPairs(object3, props2) {
        return arrayMap(props2, function(key) {
          return [key, object3[key]];
        });
      }
      function setToPairs(set2) {
        var index2 = -1, result2 = Array(set2.size);
        set2.forEach(function(value) {
          result2[++index2] = [value, value];
        });
        return result2;
      }
      var mapTag$3 = "[object Map]";
      var setTag$3 = "[object Set]";
      function createToPairs(keysFunc) {
        return function(object3) {
          var tag = getTag$1(object3);
          if (tag == mapTag$3) {
            return mapToArray(object3);
          }
          if (tag == setTag$3) {
            return setToPairs(object3);
          }
          return baseToPairs(object3, keysFunc(object3));
        };
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      var reUnescapedHtml = /[&<>"']/g;
      var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      function escape(string2) {
        string2 = toString(string2);
        return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
      }
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reHasRegExpChar = RegExp(reRegExpChar.source);
      function escapeRegExp(string2) {
        string2 = toString(string2);
        return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
      }
      function arrayEvery(array3, predicate) {
        var index2 = -1, length = array3 == null ? 0 : array3.length;
        while (++index2 < length) {
          if (!predicate(array3[index2], index2, array3)) {
            return false;
          }
        }
        return true;
      }
      function baseEvery(collection2, predicate) {
        var result2 = true;
        baseEach(collection2, function(value, index2, collection22) {
          result2 = !!predicate(value, index2, collection22);
          return result2;
        });
        return result2;
      }
      function every(collection2, predicate, guard) {
        var func2 = isArray(collection2) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection2, predicate, guard)) {
          predicate = void 0;
        }
        return func2(collection2, baseIteratee(predicate));
      }
      var MAX_ARRAY_LENGTH$5 = 4294967295;
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH$5) : 0;
      }
      function baseFill(array3, value, start, end) {
        var length = array3.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === void 0 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array3[start++] = value;
        }
        return array3;
      }
      function fill(array3, value, start, end) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array3, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array3, value, start, end);
      }
      function baseFilter(collection2, predicate) {
        var result2 = [];
        baseEach(collection2, function(value, index2, collection22) {
          if (predicate(value, index2, collection22)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function filter(collection2, predicate) {
        var func2 = isArray(collection2) ? arrayFilter : baseFilter;
        return func2(collection2, baseIteratee(predicate));
      }
      function createFind(findIndexFunc) {
        return function(collection2, predicate, fromIndex) {
          var iterable = Object(collection2);
          if (!isArrayLike(collection2)) {
            var iteratee2 = baseIteratee(predicate);
            collection2 = keys(collection2);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index2 = findIndexFunc(collection2, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection2[index2] : index2] : void 0;
        };
      }
      var nativeMax$a = Math.max;
      function findIndex(array3, predicate, fromIndex) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax$a(length + index2, 0);
        }
        return baseFindIndex(array3, baseIteratee(predicate), index2);
      }
      var find = createFind(findIndex);
      function baseFindKey(collection2, predicate, eachFunc) {
        var result2;
        eachFunc(collection2, function(value, key, collection22) {
          if (predicate(value, key, collection22)) {
            result2 = key;
            return false;
          }
        });
        return result2;
      }
      function findKey(object3, predicate) {
        return baseFindKey(object3, baseIteratee(predicate), baseForOwn);
      }
      var nativeMax$9 = Math.max;
      var nativeMin$a = Math.min;
      function findLastIndex(array3, predicate, fromIndex) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return -1;
        }
        var index2 = length - 1;
        if (fromIndex !== void 0) {
          index2 = toInteger(fromIndex);
          index2 = fromIndex < 0 ? nativeMax$9(length + index2, 0) : nativeMin$a(index2, length - 1);
        }
        return baseFindIndex(array3, baseIteratee(predicate), index2, true);
      }
      var findLast = createFind(findLastIndex);
      function findLastKey(object3, predicate) {
        return baseFindKey(object3, baseIteratee(predicate), baseForOwnRight);
      }
      function head(array3) {
        return array3 && array3.length ? array3[0] : void 0;
      }
      function baseMap(collection2, iteratee2) {
        var index2 = -1, result2 = isArrayLike(collection2) ? Array(collection2.length) : [];
        baseEach(collection2, function(value, key, collection22) {
          result2[++index2] = iteratee2(value, key, collection22);
        });
        return result2;
      }
      function map(collection2, iteratee2) {
        var func2 = isArray(collection2) ? arrayMap : baseMap;
        return func2(collection2, baseIteratee(iteratee2));
      }
      function flatMap(collection2, iteratee2) {
        return baseFlatten(map(collection2, iteratee2), 1);
      }
      var INFINITY$2 = 1 / 0;
      function flatMapDeep(collection2, iteratee2) {
        return baseFlatten(map(collection2, iteratee2), INFINITY$2);
      }
      function flatMapDepth(collection2, iteratee2, depth) {
        depth = depth === void 0 ? 1 : toInteger(depth);
        return baseFlatten(map(collection2, iteratee2), depth);
      }
      var INFINITY$1 = 1 / 0;
      function flattenDeep(array3) {
        var length = array3 == null ? 0 : array3.length;
        return length ? baseFlatten(array3, INFINITY$1) : [];
      }
      function flattenDepth(array3, depth) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return [];
        }
        depth = depth === void 0 ? 1 : toInteger(depth);
        return baseFlatten(array3, depth);
      }
      var WRAP_FLIP_FLAG = 512;
      function flip$2(func2) {
        return createWrap(func2, WRAP_FLIP_FLAG);
      }
      var floor$1 = createRound("floor");
      var FUNC_ERROR_TEXT$4 = "Expected a function";
      var WRAP_CURRY_FLAG = 8;
      var WRAP_PARTIAL_FLAG$1 = 32;
      var WRAP_ARY_FLAG = 128;
      var WRAP_REARG_FLAG$1 = 256;
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func2 = funcs[index2];
            if (typeof func2 != "function") {
              throw new TypeError(FUNC_ERROR_TEXT$4);
            }
            if (prereq && !wrapper && getFuncName(func2) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index2 = wrapper ? index2 : length;
          while (++index2 < length) {
            func2 = funcs[index2];
            var funcName = getFuncName(func2), data = funcName == "wrapper" ? getData(func2) : void 0;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG$1 | WRAP_REARG_FLAG$1) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func2.length == 1 && isLaziable(func2) ? wrapper[funcName]() : wrapper.thru(func2);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray(value)) {
              return wrapper.plant(value).value();
            }
            var index22 = 0, result2 = length ? funcs[index22].apply(this, args) : value;
            while (++index22 < length) {
              result2 = funcs[index22].call(this, result2);
            }
            return result2;
          };
        });
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function forIn(object3, iteratee2) {
        return object3 == null ? object3 : baseFor(object3, castFunction(iteratee2), keysIn);
      }
      function forInRight(object3, iteratee2) {
        return object3 == null ? object3 : baseForRight(object3, castFunction(iteratee2), keysIn);
      }
      function forOwn(object3, iteratee2) {
        return object3 && baseForOwn(object3, castFunction(iteratee2));
      }
      function forOwnRight(object3, iteratee2) {
        return object3 && baseForOwnRight(object3, castFunction(iteratee2));
      }
      function fromPairs(pairs) {
        var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index2 < length) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function baseFunctions(object3, props2) {
        return arrayFilter(props2, function(key) {
          return isFunction(object3[key]);
        });
      }
      function functions(object3) {
        return object3 == null ? [] : baseFunctions(object3, keys(object3));
      }
      function functionsIn(object3) {
        return object3 == null ? [] : baseFunctions(object3, keysIn(object3));
      }
      var objectProto$7 = Object.prototype;
      var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty$6.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function baseGt(value, other) {
        return value > other;
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      var gt$1 = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var objectProto$6 = Object.prototype;
      var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
      function baseHas(object3, key) {
        return object3 != null && hasOwnProperty$5.call(object3, key);
      }
      function has(object3, path) {
        return object3 != null && hasPath(object3, path, baseHas);
      }
      var nativeMax$8 = Math.max;
      var nativeMin$9 = Math.min;
      function baseInRange(number3, start, end) {
        return number3 >= nativeMin$9(start, end) && number3 < nativeMax$8(start, end);
      }
      function inRange(number3, start, end) {
        start = toFinite(start);
        if (end === void 0) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number3 = toNumber(number3);
        return baseInRange(number3, start, end);
      }
      var stringTag = "[object String]";
      function isString(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function baseValues(object3, props2) {
        return arrayMap(props2, function(key) {
          return object3[key];
        });
      }
      function values(object3) {
        return object3 == null ? [] : baseValues(object3, keys(object3));
      }
      var nativeMax$7 = Math.max;
      function includes(collection2, value, fromIndex, guard) {
        collection2 = isArrayLike(collection2) ? collection2 : values(collection2);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection2.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax$7(length + fromIndex, 0);
        }
        return isString(collection2) ? fromIndex <= length && collection2.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection2, value, fromIndex) > -1;
      }
      var nativeMax$6 = Math.max;
      function indexOf(array3, value, fromIndex) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax$6(length + index2, 0);
        }
        return baseIndexOf(array3, value, index2);
      }
      function initial$1(array3) {
        var length = array3 == null ? 0 : array3.length;
        return length ? baseSlice(array3, 0, -1) : [];
      }
      var nativeMin$8 = Math.min;
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array3 = arrays[othIndex];
          if (othIndex && iteratee2) {
            array3 = arrayMap(array3, baseUnary(iteratee2));
          }
          maxLength = nativeMin$8(array3.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array3.length >= 120) ? new SetCache(othIndex && array3) : void 0;
        }
        array3 = arrays[0];
        var index2 = -1, seen = caches[0];
        outer:
          while (++index2 < length && result2.length < maxLength) {
            var value = array3[index2], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed2) : includes2(result2, computed2, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache2 = caches[othIndex];
                if (!(cache2 ? cacheHas(cache2, computed2) : includes2(arrays[othIndex], computed2, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = void 0;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, baseIteratee(iteratee2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : void 0;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, void 0, comparator) : [];
      });
      function baseInverter(object3, setter, iteratee2, accumulator) {
        baseForOwn(object3, function(value, key, object22) {
          setter(accumulator, iteratee2(value), key, object22);
        });
        return accumulator;
      }
      function createInverter(setter, toIteratee) {
        return function(object3, iteratee2) {
          return baseInverter(object3, setter, toIteratee(iteratee2), {});
        };
      }
      var objectProto$5 = Object.prototype;
      var nativeObjectToString$1 = objectProto$5.toString;
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString$1.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var objectProto$4 = Object.prototype;
      var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
      var nativeObjectToString = objectProto$4.toString;
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty$4.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, baseIteratee);
      function parent(object3, path) {
        return path.length < 2 ? object3 : baseGet(object3, baseSlice(path, 0, -1));
      }
      function baseInvoke(object3, path, args) {
        path = castPath(path, object3);
        object3 = parent(object3, path);
        var func2 = object3 == null ? object3 : object3[toKey(last(path))];
        return func2 == null ? void 0 : apply(func2, object3, args);
      }
      var invoke = baseRest(baseInvoke);
      var invokeMap = baseRest(function(collection2, path, args) {
        var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection2) ? Array(collection2.length) : [];
        baseEach(collection2, function(value) {
          result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var arrayBufferTag = "[object ArrayBuffer]";
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      var boolTag = "[object Boolean]";
      function isBoolean$1(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var dateTag = "[object Date]";
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      var nodeIsDate = nodeUtil && nodeUtil.isDate;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement$3(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
      }
      var mapTag$2 = "[object Map]";
      var setTag$2 = "[object Set]";
      var objectProto$3 = Object.prototype;
      var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
      function isEmpty$1(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag$1(value);
        if (tag == mapTag$2 || tag == setTag$2) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty$3.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual$1(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : void 0;
        var result2 = customizer ? customizer(value, other) : void 0;
        return result2 === void 0 ? baseIsEqual(value, other, void 0, customizer) : !!result2;
      }
      var nativeIsFinite = root.isFinite;
      function isFinite(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isMatch(object3, source) {
        return object3 === source || baseIsMatch(object3, source, getMatchData(source));
      }
      function isMatchWith(object3, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : void 0;
        return baseIsMatch(object3, source, getMatchData(source), customizer);
      }
      var numberTag = "[object Number]";
      function isNumber$1(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isNaN$1(value) {
        return isNumber$1(value) && value != +value;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.";
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNil(value) {
        return value == null;
      }
      function isNull(value) {
        return value === null;
      }
      var regexpTag = "[object RegExp]";
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      var MAX_SAFE_INTEGER$3 = 9007199254740991;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER$3 && value <= MAX_SAFE_INTEGER$3;
      }
      function isUndefined$1(value) {
        return value === void 0;
      }
      var weakMapTag = "[object WeakMap]";
      function isWeakMap(value) {
        return isObjectLike(value) && getTag$1(value) == weakMapTag;
      }
      var weakSetTag = "[object WeakSet]";
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var CLONE_DEEP_FLAG$3 = 1;
      function iteratee(func2) {
        return baseIteratee(typeof func2 == "function" ? func2 : baseClone(func2, CLONE_DEEP_FLAG$3));
      }
      var arrayProto$4 = Array.prototype;
      var nativeJoin = arrayProto$4.join;
      function join(array3, separator) {
        return array3 == null ? "" : nativeJoin.call(array3, separator);
      }
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function strictLastIndexOf(array3, value, fromIndex) {
        var index2 = fromIndex + 1;
        while (index2--) {
          if (array3[index2] === value) {
            return index2;
          }
        }
        return index2;
      }
      var nativeMax$5 = Math.max;
      var nativeMin$7 = Math.min;
      function lastIndexOf(array3, value, fromIndex) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return -1;
        }
        var index2 = length;
        if (fromIndex !== void 0) {
          index2 = toInteger(fromIndex);
          index2 = index2 < 0 ? nativeMax$5(length + index2, 0) : nativeMin$7(index2, length - 1);
        }
        return value === value ? strictLastIndexOf(array3, value, index2) : baseFindIndex(array3, baseIsNaN, index2, true);
      }
      var lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function baseLt(value, other) {
        return value < other;
      }
      var lt$1 = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function mapKeys(object3, iteratee2) {
        var result2 = {};
        iteratee2 = baseIteratee(iteratee2);
        baseForOwn(object3, function(value, key, object22) {
          baseAssignValue(result2, iteratee2(value, key, object22), value);
        });
        return result2;
      }
      function mapValues(object3, iteratee2) {
        var result2 = {};
        iteratee2 = baseIteratee(iteratee2);
        baseForOwn(object3, function(value, key, object22) {
          baseAssignValue(result2, key, iteratee2(value, key, object22));
        });
        return result2;
      }
      var CLONE_DEEP_FLAG$2 = 1;
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG$2));
      }
      var CLONE_DEEP_FLAG$1 = 1;
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG$1));
      }
      function baseExtremum(array3, iteratee2, comparator) {
        var index2 = -1, length = array3.length;
        while (++index2 < length) {
          var value = array3[index2], current = iteratee2(value);
          if (current != null && (computed2 === void 0 ? current === current && !isSymbol(current) : comparator(current, computed2))) {
            var computed2 = current, result2 = value;
          }
        }
        return result2;
      }
      function max$4(array3) {
        return array3 && array3.length ? baseExtremum(array3, identity, baseGt) : void 0;
      }
      function maxBy(array3, iteratee2) {
        return array3 && array3.length ? baseExtremum(array3, baseIteratee(iteratee2), baseGt) : void 0;
      }
      function baseSum(array3, iteratee2) {
        var result2, index2 = -1, length = array3.length;
        while (++index2 < length) {
          var current = iteratee2(array3[index2]);
          if (current !== void 0) {
            result2 = result2 === void 0 ? current : result2 + current;
          }
        }
        return result2;
      }
      var NAN = 0 / 0;
      function baseMean(array3, iteratee2) {
        var length = array3 == null ? 0 : array3.length;
        return length ? baseSum(array3, iteratee2) / length : NAN;
      }
      function mean(array3) {
        return baseMean(array3, identity);
      }
      function meanBy(array3, iteratee2) {
        return baseMean(array3, baseIteratee(iteratee2));
      }
      var merge = createAssigner(function(object3, source, srcIndex) {
        baseMerge(object3, source, srcIndex);
      });
      var method = baseRest(function(path, args) {
        return function(object3) {
          return baseInvoke(object3, path, args);
        };
      });
      var methodOf = baseRest(function(object3, args) {
        return function(path) {
          return baseInvoke(object3, path, args);
        };
      });
      function min$4(array3) {
        return array3 && array3.length ? baseExtremum(array3, identity, baseLt) : void 0;
      }
      function minBy(array3, iteratee2) {
        return array3 && array3.length ? baseExtremum(array3, baseIteratee(iteratee2), baseLt) : void 0;
      }
      function mixin$1(object3, source, options) {
        var props2 = keys(source), methodNames = baseFunctions(source, props2);
        var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object3);
        arrayEach(methodNames, function(methodName) {
          var func2 = source[methodName];
          object3[methodName] = func2;
          if (isFunc) {
            object3.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object3(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ "func": func2, "args": arguments, "thisArg": object3 });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func2.apply(object3, arrayPush([this.value()], arguments));
            };
          }
        });
        return object3;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var FUNC_ERROR_TEXT$3 = "Expected a function";
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$3);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function iteratorToArray(iterator) {
        var data, result2 = [];
        while (!(data = iterator.next()).done) {
          result2.push(data.value);
        }
        return result2;
      }
      var mapTag$1 = "[object Map]";
      var setTag$1 = "[object Set]";
      var symIterator$1 = Symbol$1 ? Symbol$1.iterator : void 0;
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator$1 && value[symIterator$1]) {
          return iteratorToArray(value[symIterator$1]());
        }
        var tag = getTag$1(value), func2 = tag == mapTag$1 ? mapToArray : tag == setTag$1 ? setToArray : values;
        return func2(value);
      }
      function wrapperNext() {
        if (this.__values__ === void 0) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? void 0 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function baseNth(array3, n) {
        var length = array3.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array3[n] : void 0;
      }
      function nth(array3, n) {
        return array3 && array3.length ? baseNth(array3, toInteger(n)) : void 0;
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      function baseUnset(object3, path) {
        path = castPath(path, object3);
        object3 = parent(object3, path);
        return object3 == null || delete object3[toKey(last(path))];
      }
      function customOmitClone(value) {
        return isPlainObject(value) ? void 0 : value;
      }
      var CLONE_DEEP_FLAG = 1;
      var CLONE_FLAT_FLAG = 2;
      var CLONE_SYMBOLS_FLAG = 4;
      var omit = flatRest(function(object3, paths) {
        var result2 = {};
        if (object3 == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object3);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object3, getAllKeysIn(object3), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function baseSet(object3, path, value, customizer) {
        if (!isObject(object3)) {
          return object3;
        }
        path = castPath(path, object3);
        var index2 = -1, length = path.length, lastIndex = length - 1, nested = object3;
        while (nested != null && ++index2 < length) {
          var key = toKey(path[index2]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object3;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : void 0;
            if (newValue === void 0) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object3;
      }
      function basePickBy(object3, paths, predicate) {
        var index2 = -1, length = paths.length, result2 = {};
        while (++index2 < length) {
          var path = paths[index2], value = baseGet(object3, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object3), value);
          }
        }
        return result2;
      }
      function pickBy(object3, predicate) {
        if (object3 == null) {
          return {};
        }
        var props2 = arrayMap(getAllKeysIn(object3), function(prop) {
          return [prop];
        });
        predicate = baseIteratee(predicate);
        return basePickBy(object3, props2, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function omitBy(object3, predicate) {
        return pickBy(object3, negate(baseIteratee(predicate)));
      }
      function once(func2) {
        return before(2, func2);
      }
      function baseSortBy(array3, comparer) {
        var length = array3.length;
        array3.sort(comparer);
        while (length--) {
          array3[length] = array3[length].value;
        }
        return array3;
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object3, other, orders) {
        var index2 = -1, objCriteria = object3.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order = orders[index2];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object3.index - other.index;
      }
      function baseOrderBy(collection2, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
        var result2 = baseMap(collection2, function(value, key, collection22) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index2, "value": value };
        });
        return baseSortBy(result2, function(object3, other) {
          return compareMultiple(object3, other, orders);
        });
      }
      function orderBy$1(collection2, iteratees, orders, guard) {
        if (collection2 == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? void 0 : orders;
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection2, iteratees, orders);
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      var over = createOver(arrayMap);
      var castRest = baseRest;
      var nativeMin$6 = Math.min;
      var overArgs = castRest(function(func2, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(baseIteratee)) : arrayMap(baseFlatten(transforms, 1), baseUnary(baseIteratee));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index2 = -1, length = nativeMin$6(args.length, funcsLength);
          while (++index2 < length) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply(func2, this, args);
        });
      });
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      var MAX_SAFE_INTEGER$2 = 9007199254740991;
      var nativeFloor$3 = Math.floor;
      function baseRepeat(string2, n) {
        var result2 = "";
        if (!string2 || n < 1 || n > MAX_SAFE_INTEGER$2) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string2;
          }
          n = nativeFloor$3(n / 2);
          if (n) {
            string2 += string2;
          }
        } while (n);
        return result2;
      }
      var asciiSize = baseProperty("length");
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsAstral = "[" + rsAstralRange + "]";
      var rsCombo = "[" + rsComboRange + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsZWJ = "\\u200d";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange + "]?";
      var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      function unicodeSize(string2) {
        var result2 = reUnicode.lastIndex = 0;
        while (reUnicode.test(string2)) {
          ++result2;
        }
        return result2;
      }
      function stringSize(string2) {
        return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
      }
      var nativeCeil$2 = Math.ceil;
      function createPadding(length, chars) {
        chars = chars === void 0 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil$2(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      var nativeCeil$1 = Math.ceil;
      var nativeFloor$2 = Math.floor;
      function pad(string2, length, chars) {
        string2 = toString(string2);
        length = toInteger(length);
        var strLength = length ? stringSize(string2) : 0;
        if (!length || strLength >= length) {
          return string2;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor$2(mid), chars) + string2 + createPadding(nativeCeil$1(mid), chars);
      }
      function padEnd(string2, length, chars) {
        string2 = toString(string2);
        length = toInteger(length);
        var strLength = length ? stringSize(string2) : 0;
        return length && strLength < length ? string2 + createPadding(length - strLength, chars) : string2;
      }
      function padStart(string2, length, chars) {
        string2 = toString(string2);
        length = toInteger(length);
        var strLength = length ? stringSize(string2) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string2 : string2;
      }
      var reTrimStart$1 = /^\s+/;
      var nativeParseInt = root.parseInt;
      function parseInt$1(string2, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString(string2).replace(reTrimStart$1, ""), radix || 0);
      }
      var WRAP_PARTIAL_FLAG = 32;
      var partial = baseRest(function(func2, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func2, WRAP_PARTIAL_FLAG, void 0, partials, holders);
      });
      partial.placeholder = {};
      var WRAP_PARTIAL_RIGHT_FLAG = 64;
      var partialRight = baseRest(function(func2, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func2, WRAP_PARTIAL_RIGHT_FLAG, void 0, partials, holders);
      });
      partialRight.placeholder = {};
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function basePick(object3, paths) {
        return basePickBy(object3, paths, function(value, path) {
          return hasIn(object3, path);
        });
      }
      var pick = flatRest(function(object3, paths) {
        return object3 == null ? {} : basePick(object3, paths);
      });
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0;
          clone2.__values__ = void 0;
          if (result2) {
            previous.__wrapped__ = clone2;
          } else {
            result2 = clone2;
          }
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function propertyOf(object3) {
        return function(path) {
          return object3 == null ? void 0 : baseGet(object3, path);
        };
      }
      function baseIndexOfWith(array3, value, fromIndex, comparator) {
        var index2 = fromIndex - 1, length = array3.length;
        while (++index2 < length) {
          if (comparator(array3[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      var arrayProto$3 = Array.prototype;
      var splice$1 = arrayProto$3.splice;
      function basePullAll(array3, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array3;
        if (array3 === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array3, baseUnary(iteratee2));
        }
        while (++index2 < length) {
          var fromIndex = 0, value = values2[index2], computed2 = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed2, fromIndex, comparator)) > -1) {
            if (seen !== array3) {
              splice$1.call(seen, fromIndex, 1);
            }
            splice$1.call(array3, fromIndex, 1);
          }
        }
        return array3;
      }
      function pullAll(array3, values2) {
        return array3 && array3.length && values2 && values2.length ? basePullAll(array3, values2) : array3;
      }
      var pull = baseRest(pullAll);
      function pullAllBy(array3, values2, iteratee2) {
        return array3 && array3.length && values2 && values2.length ? basePullAll(array3, values2, baseIteratee(iteratee2)) : array3;
      }
      function pullAllWith(array3, values2, comparator) {
        return array3 && array3.length && values2 && values2.length ? basePullAll(array3, values2, void 0, comparator) : array3;
      }
      var arrayProto$2 = Array.prototype;
      var splice = arrayProto$2.splice;
      function basePullAt(array3, indexes) {
        var length = array3 ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index2 = indexes[length];
          if (length == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex(index2)) {
              splice.call(array3, index2, 1);
            } else {
              baseUnset(array3, index2);
            }
          }
        }
        return array3;
      }
      var pullAt = flatRest(function(array3, indexes) {
        var length = array3 == null ? 0 : array3.length, result2 = baseAt(array3, indexes);
        basePullAt(array3, arrayMap(indexes, function(index2) {
          return isIndex(index2, length) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      var nativeFloor$1 = Math.floor;
      var nativeRandom$1 = Math.random;
      function baseRandom(lower, upper) {
        return lower + nativeFloor$1(nativeRandom$1() * (upper - lower + 1));
      }
      var freeParseFloat = parseFloat;
      var nativeMin$5 = Math.min;
      var nativeRandom = Math.random;
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = void 0;
        }
        if (floating === void 0) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = void 0;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = void 0;
          }
        }
        if (lower === void 0 && upper === void 0) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === void 0) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin$5(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var nativeCeil = Math.ceil;
      var nativeMax$4 = Math.max;
      function baseRange(start, end, step2, fromRight) {
        var index2 = -1, length = nativeMax$4(nativeCeil((end - start) / (step2 || 1)), 0), result2 = Array(length);
        while (length--) {
          result2[fromRight ? length : ++index2] = start;
          start += step2;
        }
        return result2;
      }
      function createRange(fromRight) {
        return function(start, end, step2) {
          if (step2 && typeof step2 != "number" && isIterateeCall(start, end, step2)) {
            end = step2 = void 0;
          }
          start = toFinite(start);
          if (end === void 0) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step2 = step2 === void 0 ? start < end ? 1 : -1 : toFinite(step2);
          return baseRange(start, end, step2, fromRight);
        };
      }
      var range$1 = createRange();
      var rangeRight = createRange(true);
      var WRAP_REARG_FLAG = 256;
      var rearg = flatRest(function(func2, indexes) {
        return createWrap(func2, WRAP_REARG_FLAG, void 0, void 0, void 0, indexes);
      });
      function baseReduce(collection2, iteratee2, accumulator, initAccum, eachFunc) {
        eachFunc(collection2, function(value, index2, collection22) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee2(accumulator, value, index2, collection22);
        });
        return accumulator;
      }
      function reduce(collection2, iteratee2, accumulator) {
        var func2 = isArray(collection2) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func2(collection2, baseIteratee(iteratee2), accumulator, initAccum, baseEach);
      }
      function arrayReduceRight(array3, iteratee2, accumulator, initAccum) {
        var length = array3 == null ? 0 : array3.length;
        if (initAccum && length) {
          accumulator = array3[--length];
        }
        while (length--) {
          accumulator = iteratee2(accumulator, array3[length], length, array3);
        }
        return accumulator;
      }
      function reduceRight(collection2, iteratee2, accumulator) {
        var func2 = isArray(collection2) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func2(collection2, baseIteratee(iteratee2), accumulator, initAccum, baseEachRight);
      }
      function reject(collection2, predicate) {
        var func2 = isArray(collection2) ? arrayFilter : baseFilter;
        return func2(collection2, negate(baseIteratee(predicate)));
      }
      function remove(array3, predicate) {
        var result2 = [];
        if (!(array3 && array3.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length = array3.length;
        predicate = baseIteratee(predicate);
        while (++index2 < length) {
          var value = array3[index2];
          if (predicate(value, index2, array3)) {
            result2.push(value);
            indexes.push(index2);
          }
        }
        basePullAt(array3, indexes);
        return result2;
      }
      function repeat(string2, n, guard) {
        if (guard ? isIterateeCall(string2, n, guard) : n === void 0) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString(string2), n);
      }
      function replace() {
        var args = arguments, string2 = toString(args[0]);
        return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
      }
      var FUNC_ERROR_TEXT$2 = "Expected a function";
      function rest(func2, start) {
        if (typeof func2 != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$2);
        }
        start = start === void 0 ? start : toInteger(start);
        return baseRest(func2, start);
      }
      function result(object3, path, defaultValue) {
        path = castPath(path, object3);
        var index2 = -1, length = path.length;
        if (!length) {
          length = 1;
          object3 = void 0;
        }
        while (++index2 < length) {
          var value = object3 == null ? void 0 : object3[toKey(path[index2])];
          if (value === void 0) {
            index2 = length;
            value = defaultValue;
          }
          object3 = isFunction(value) ? value.call(object3) : value;
        }
        return object3;
      }
      var arrayProto$1 = Array.prototype;
      var nativeReverse = arrayProto$1.reverse;
      function reverse(array3) {
        return array3 == null ? array3 : nativeReverse.call(array3);
      }
      var round$2 = createRound("round");
      function arraySample(array3) {
        var length = array3.length;
        return length ? array3[baseRandom(0, length - 1)] : void 0;
      }
      function baseSample(collection2) {
        return arraySample(values(collection2));
      }
      function sample(collection2) {
        var func2 = isArray(collection2) ? arraySample : baseSample;
        return func2(collection2);
      }
      function shuffleSelf(array3, size) {
        var index2 = -1, length = array3.length, lastIndex = length - 1;
        size = size === void 0 ? length : size;
        while (++index2 < size) {
          var rand = baseRandom(index2, lastIndex), value = array3[rand];
          array3[rand] = array3[index2];
          array3[index2] = value;
        }
        array3.length = size;
        return array3;
      }
      function arraySampleSize(array3, n) {
        return shuffleSelf(copyArray(array3), baseClamp(n, 0, array3.length));
      }
      function baseSampleSize(collection2, n) {
        var array3 = values(collection2);
        return shuffleSelf(array3, baseClamp(n, 0, array3.length));
      }
      function sampleSize(collection2, n, guard) {
        if (guard ? isIterateeCall(collection2, n, guard) : n === void 0) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func2 = isArray(collection2) ? arraySampleSize : baseSampleSize;
        return func2(collection2, n);
      }
      function set(object3, path, value) {
        return object3 == null ? object3 : baseSet(object3, path, value);
      }
      function setWith(object3, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : void 0;
        return object3 == null ? object3 : baseSet(object3, path, value, customizer);
      }
      function arrayShuffle(array3) {
        return shuffleSelf(copyArray(array3));
      }
      function baseShuffle(collection2) {
        return shuffleSelf(values(collection2));
      }
      function shuffle(collection2) {
        var func2 = isArray(collection2) ? arrayShuffle : baseShuffle;
        return func2(collection2);
      }
      var mapTag = "[object Map]";
      var setTag = "[object Set]";
      function size$1(collection2) {
        if (collection2 == null) {
          return 0;
        }
        if (isArrayLike(collection2)) {
          return isString(collection2) ? stringSize(collection2) : collection2.length;
        }
        var tag = getTag$1(collection2);
        if (tag == mapTag || tag == setTag) {
          return collection2.size;
        }
        return baseKeys(collection2).length;
      }
      function slice(array3, start, end) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array3, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === void 0 ? length : toInteger(end);
        }
        return baseSlice(array3, start, end);
      }
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function baseSome(collection2, predicate) {
        var result2;
        baseEach(collection2, function(value, index2, collection22) {
          result2 = predicate(value, index2, collection22);
          return !result2;
        });
        return !!result2;
      }
      function some(collection2, predicate, guard) {
        var func2 = isArray(collection2) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection2, predicate, guard)) {
          predicate = void 0;
        }
        return func2(collection2, baseIteratee(predicate));
      }
      var sortBy = baseRest(function(collection2, iteratees) {
        if (collection2 == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection2, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection2, baseFlatten(iteratees, 1), []);
      });
      var MAX_ARRAY_LENGTH$4 = 4294967295;
      var MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH$4 - 1;
      var nativeFloor = Math.floor;
      var nativeMin$4 = Math.min;
      function baseSortedIndexBy(array3, value, iteratee2, retHighest) {
        var low = 0, high = array3 == null ? 0 : array3.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === void 0;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed2 = iteratee2(array3[mid]), othIsDefined = computed2 !== void 0, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol(computed2);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed2 <= value : computed2 < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin$4(high, MAX_ARRAY_INDEX);
      }
      var MAX_ARRAY_LENGTH$3 = 4294967295;
      var HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH$3 >>> 1;
      function baseSortedIndex(array3, value, retHighest) {
        var low = 0, high = array3 == null ? low : array3.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed2 = array3[mid];
            if (computed2 !== null && !isSymbol(computed2) && (retHighest ? computed2 <= value : computed2 < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array3, value, identity, retHighest);
      }
      function sortedIndex(array3, value) {
        return baseSortedIndex(array3, value);
      }
      function sortedIndexBy(array3, value, iteratee2) {
        return baseSortedIndexBy(array3, value, baseIteratee(iteratee2));
      }
      function sortedIndexOf(array3, value) {
        var length = array3 == null ? 0 : array3.length;
        if (length) {
          var index2 = baseSortedIndex(array3, value);
          if (index2 < length && eq(array3[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array3, value) {
        return baseSortedIndex(array3, value, true);
      }
      function sortedLastIndexBy(array3, value, iteratee2) {
        return baseSortedIndexBy(array3, value, baseIteratee(iteratee2), true);
      }
      function sortedLastIndexOf(array3, value) {
        var length = array3 == null ? 0 : array3.length;
        if (length) {
          var index2 = baseSortedIndex(array3, value, true) - 1;
          if (eq(array3[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function baseSortedUniq(array3, iteratee2) {
        var index2 = -1, length = array3.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array3[index2], computed2 = iteratee2 ? iteratee2(value) : value;
          if (!index2 || !eq(computed2, seen)) {
            var seen = computed2;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function sortedUniq(array3) {
        return array3 && array3.length ? baseSortedUniq(array3) : [];
      }
      function sortedUniqBy(array3, iteratee2) {
        return array3 && array3.length ? baseSortedUniq(array3, baseIteratee(iteratee2)) : [];
      }
      var MAX_ARRAY_LENGTH$2 = 4294967295;
      function split(string2, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string2, separator, limit)) {
          separator = limit = void 0;
        }
        limit = limit === void 0 ? MAX_ARRAY_LENGTH$2 : limit >>> 0;
        if (!limit) {
          return [];
        }
        string2 = toString(string2);
        if (string2 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string2)) {
            return castSlice(stringToArray(string2), 0, limit);
          }
        }
        return string2.split(separator, limit);
      }
      var FUNC_ERROR_TEXT$1 = "Expected a function";
      var nativeMax$3 = Math.max;
      function spread(func2, start) {
        if (typeof func2 != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$1);
        }
        start = start == null ? 0 : nativeMax$3(toInteger(start), 0);
        return baseRest(function(args) {
          var array3 = args[start], otherArgs = castSlice(args, 0, start);
          if (array3) {
            arrayPush(otherArgs, array3);
          }
          return apply(func2, this, otherArgs);
        });
      }
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith(string2, target2, position) {
        string2 = toString(string2);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string2.length);
        target2 = baseToString(target2);
        return string2.slice(position, position + target2.length) == target2;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum$1(array3) {
        return array3 && array3.length ? baseSum(array3, identity) : 0;
      }
      function sumBy(array3, iteratee2) {
        return array3 && array3.length ? baseSum(array3, baseIteratee(iteratee2)) : 0;
      }
      function tail(array3) {
        var length = array3 == null ? 0 : array3.length;
        return length ? baseSlice(array3, 1, length) : [];
      }
      function take(array3, n, guard) {
        if (!(array3 && array3.length)) {
          return [];
        }
        n = guard || n === void 0 ? 1 : toInteger(n);
        return baseSlice(array3, 0, n < 0 ? 0 : n);
      }
      function takeRight(array3, n, guard) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return [];
        }
        n = guard || n === void 0 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array3, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array3, predicate) {
        return array3 && array3.length ? baseWhile(array3, baseIteratee(predicate), false, true) : [];
      }
      function takeWhile(array3, predicate) {
        return array3 && array3.length ? baseWhile(array3, baseIteratee(predicate)) : [];
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      var objectProto$2 = Object.prototype;
      var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
      function customDefaultsAssignIn(objValue, srcValue, key, object3) {
        if (objValue === void 0 || eq(objValue, objectProto$2[key]) && !hasOwnProperty$2.call(object3, key)) {
          return srcValue;
        }
        return objValue;
      }
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      var reInterpolate = /<%=([\s\S]+?)%>/g;
      var reEscape = /<%-([\s\S]+?)%>/g;
      var reEvaluate = /<%([\s\S]+?)%>/g;
      var templateSettings = {
        "escape": reEscape,
        "evaluate": reEvaluate,
        "interpolate": reInterpolate,
        "variable": "",
        "imports": {
          "_": { "escape": escape }
        }
      };
      var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var reEmptyStringLeading = /\b__p \+= '';/g;
      var reEmptyStringMiddle = /\b(__p \+=) '' \+/g;
      var reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var objectProto$1 = Object.prototype;
      var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
      function template(string2, options, guard) {
        var settings = templateSettings.imports._.templateSettings || templateSettings;
        if (guard && isIterateeCall(string2, options, guard)) {
          options = void 0;
        }
        string2 = toString(string2);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = hasOwnProperty$1.call(options, "sourceURL") ? "//# sourceURL=" + (options.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
        string2.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string2.slice(index2, offset2).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset2 + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty$1.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      var FUNC_ERROR_TEXT = "Expected a function";
      function throttle(func2, wait, options) {
        var leading = true, trailing = true;
        if (typeof func2 != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func2, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var MAX_SAFE_INTEGER$1 = 9007199254740991;
      var MAX_ARRAY_LENGTH$1 = 4294967295;
      var nativeMin$3 = Math.min;
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER$1) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH$1, length = nativeMin$3(n, MAX_ARRAY_LENGTH$1);
        iteratee2 = castFunction(iteratee2);
        n -= MAX_ARRAY_LENGTH$1;
        var result2 = baseTimes(length, iteratee2);
        while (++index2 < n) {
          iteratee2(index2);
        }
        return result2;
      }
      function wrapperToIterator() {
        return this;
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result22, action) {
          return action.func.apply(action.thisArg, arrayPush([result22], action.args));
        }, result2);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      function toLower(value) {
        return toString(value).toLowerCase();
      }
      function toPath(value) {
        if (isArray(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toUpper(value) {
        return toString(value).toUpperCase();
      }
      function transform(object3, iteratee2, accumulator) {
        var isArr = isArray(object3), isArrLike = isArr || isBuffer(object3) || isTypedArray(object3);
        iteratee2 = baseIteratee(iteratee2);
        if (accumulator == null) {
          var Ctor = object3 && object3.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject(object3)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object3)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object3, function(value, index2, object22) {
          return iteratee2(accumulator, value, index2, object22);
        });
        return accumulator;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index2 = strSymbols.length;
        while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index2 = -1, length = strSymbols.length;
        while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function trim(string2, chars, guard) {
        string2 = toString(string2);
        if (string2 && (guard || chars === void 0)) {
          return baseTrim(string2);
        }
        if (!string2 || !(chars = baseToString(chars))) {
          return string2;
        }
        var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string2, chars, guard) {
        string2 = toString(string2);
        if (string2 && (guard || chars === void 0)) {
          return string2.slice(0, trimmedEndIndex(string2) + 1);
        }
        if (!string2 || !(chars = baseToString(chars))) {
          return string2;
        }
        var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      var reTrimStart = /^\s+/;
      function trimStart(string2, chars, guard) {
        string2 = toString(string2);
        if (string2 && (guard || chars === void 0)) {
          return string2.replace(reTrimStart, "");
        }
        if (!string2 || !(chars = baseToString(chars))) {
          return string2;
        }
        var strSymbols = stringToArray(string2), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      var DEFAULT_TRUNC_LENGTH = 30;
      var DEFAULT_TRUNC_OMISSION = "...";
      var reFlags = /\w*$/;
      function truncate(string2, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string2 = toString(string2);
        var strLength = string2.length;
        if (hasUnicode(string2)) {
          var strSymbols = stringToArray(string2);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string2;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
        if (separator === void 0) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string2.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === void 0 ? end : newEnd);
          }
        } else if (string2.indexOf(baseToString(separator), end) != end) {
          var index2 = result2.lastIndexOf(separator);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      function unary(func2) {
        return ary(func2, 1);
      }
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;
      var reHasEscapedHtml = RegExp(reEscapedHtml.source);
      function unescape(string2) {
        string2 = toString(string2);
        return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
      }
      var INFINITY = 1 / 0;
      var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY) ? noop : function(values2) {
        return new Set$1(values2);
      };
      var LARGE_ARRAY_SIZE = 200;
      function baseUniq(array3, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, length = array3.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array3);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length) {
            var value = array3[index2], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed2);
              }
              result2.push(value);
            } else if (!includes2(seen, computed2, comparator)) {
              if (seen !== result2) {
                seen.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = void 0;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), baseIteratee(iteratee2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : void 0;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), void 0, comparator);
      });
      function uniq(array3) {
        return array3 && array3.length ? baseUniq(array3) : [];
      }
      function uniqBy(array3, iteratee2) {
        return array3 && array3.length ? baseUniq(array3, baseIteratee(iteratee2)) : [];
      }
      function uniqWith(array3, comparator) {
        comparator = typeof comparator == "function" ? comparator : void 0;
        return array3 && array3.length ? baseUniq(array3, void 0, comparator) : [];
      }
      var idCounter = 0;
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      function unset(object3, path) {
        return object3 == null ? true : baseUnset(object3, path);
      }
      var nativeMax$2 = Math.max;
      function unzip(array3) {
        if (!(array3 && array3.length)) {
          return [];
        }
        var length = 0;
        array3 = arrayFilter(array3, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax$2(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index2) {
          return arrayMap(array3, baseProperty(index2));
        });
      }
      function unzipWith(array3, iteratee2) {
        if (!(array3 && array3.length)) {
          return [];
        }
        var result2 = unzip(array3);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, void 0, group);
        });
      }
      function baseUpdate(object3, path, updater, customizer) {
        return baseSet(object3, path, updater(baseGet(object3, path)), customizer);
      }
      function update(object3, path, updater) {
        return object3 == null ? object3 : baseUpdate(object3, path, castFunction(updater));
      }
      function updateWith(object3, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : void 0;
        return object3 == null ? object3 : baseUpdate(object3, path, castFunction(updater), customizer);
      }
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      });
      function valuesIn(object3) {
        return object3 == null ? [] : baseValues(object3, keysIn(object3));
      }
      var without = baseRest(function(array3, values2) {
        return isArrayLikeObject(array3) ? baseDifference(array3, values2) : [];
      });
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object3) {
          return baseAt(object3, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": void 0
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array3) {
          if (length && !array3.length) {
            array3.push(void 0);
          }
          return array3;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": void 0
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array(length);
        while (++index2 < length) {
          var array3 = arrays[index2], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array3, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = void 0;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), baseIteratee(iteratee2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : void 0;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), void 0, comparator);
      });
      var zip = baseRest(unzip);
      function baseZipObject(props2, values2, assignFunc) {
        var index2 = -1, length = props2.length, valsLength = values2.length, result2 = {};
        while (++index2 < length) {
          var value = index2 < valsLength ? values2[index2] : void 0;
          assignFunc(result2, props2[index2], value);
        }
        return result2;
      }
      function zipObject(props2, values2) {
        return baseZipObject(props2 || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props2, values2) {
        return baseZipObject(props2 || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : void 0;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : void 0;
        return unzipWith(arrays, iteratee2);
      });
      var array = {
        chunk,
        compact,
        concat,
        difference,
        differenceBy,
        differenceWith,
        drop,
        dropRight,
        dropRightWhile,
        dropWhile,
        fill,
        findIndex,
        findLastIndex,
        first: head,
        flatten,
        flattenDeep,
        flattenDepth,
        fromPairs,
        head,
        indexOf,
        initial: initial$1,
        intersection,
        intersectionBy,
        intersectionWith,
        join,
        last,
        lastIndexOf,
        nth,
        pull,
        pullAll,
        pullAllBy,
        pullAllWith,
        pullAt,
        remove,
        reverse,
        slice,
        sortedIndex,
        sortedIndexBy,
        sortedIndexOf,
        sortedLastIndex,
        sortedLastIndexBy,
        sortedLastIndexOf,
        sortedUniq,
        sortedUniqBy,
        tail,
        take,
        takeRight,
        takeRightWhile,
        takeWhile,
        union,
        unionBy,
        unionWith,
        uniq,
        uniqBy,
        uniqWith,
        unzip,
        unzipWith,
        without,
        xor,
        xorBy,
        xorWith,
        zip,
        zipObject,
        zipObjectDeep,
        zipWith
      };
      var collection = {
        countBy,
        each: forEach,
        eachRight: forEachRight,
        every,
        filter,
        find,
        findLast,
        flatMap,
        flatMapDeep,
        flatMapDepth,
        forEach,
        forEachRight,
        groupBy,
        includes,
        invokeMap,
        keyBy,
        map,
        orderBy: orderBy$1,
        partition,
        reduce,
        reduceRight,
        reject,
        sample,
        sampleSize,
        shuffle,
        size: size$1,
        some,
        sortBy
      };
      var date = {
        now
      };
      var func = {
        after,
        ary,
        before,
        bind,
        bindKey,
        curry,
        curryRight,
        debounce,
        defer,
        delay,
        flip: flip$2,
        memoize,
        negate,
        once,
        overArgs,
        partial,
        partialRight,
        rearg,
        rest,
        spread,
        throttle,
        unary,
        wrap
      };
      var lang = {
        castArray: castArray$1,
        clone,
        cloneDeep,
        cloneDeepWith,
        cloneWith,
        conformsTo,
        eq,
        gt: gt$1,
        gte,
        isArguments,
        isArray,
        isArrayBuffer,
        isArrayLike,
        isArrayLikeObject,
        isBoolean: isBoolean$1,
        isBuffer,
        isDate,
        isElement: isElement$3,
        isEmpty: isEmpty$1,
        isEqual: isEqual$1,
        isEqualWith,
        isError,
        isFinite,
        isFunction,
        isInteger,
        isLength,
        isMap,
        isMatch,
        isMatchWith,
        isNaN: isNaN$1,
        isNative,
        isNil,
        isNull,
        isNumber: isNumber$1,
        isObject,
        isObjectLike,
        isPlainObject,
        isRegExp,
        isSafeInteger,
        isSet,
        isString,
        isSymbol,
        isTypedArray,
        isUndefined: isUndefined$1,
        isWeakMap,
        isWeakSet,
        lt: lt$1,
        lte,
        toArray,
        toFinite,
        toInteger,
        toLength,
        toNumber,
        toPlainObject,
        toSafeInteger,
        toString
      };
      var math = {
        add,
        ceil,
        divide,
        floor: floor$1,
        max: max$4,
        maxBy,
        mean,
        meanBy,
        min: min$4,
        minBy,
        multiply,
        round: round$2,
        subtract,
        sum: sum$1,
        sumBy
      };
      var number = {
        clamp: clamp$1,
        inRange,
        random
      };
      var object = {
        assign,
        assignIn,
        assignInWith,
        assignWith,
        at: at$1,
        create,
        defaults,
        defaultsDeep,
        entries: toPairs,
        entriesIn: toPairsIn,
        extend: assignIn,
        extendWith: assignInWith,
        findKey,
        findLastKey,
        forIn,
        forInRight,
        forOwn,
        forOwnRight,
        functions,
        functionsIn,
        get,
        has,
        hasIn,
        invert,
        invertBy,
        invoke,
        keys,
        keysIn,
        mapKeys,
        mapValues,
        merge,
        mergeWith,
        omit,
        omitBy,
        pick,
        pickBy,
        result,
        set,
        setWith,
        toPairs,
        toPairsIn,
        transform,
        unset,
        update,
        updateWith,
        values,
        valuesIn
      };
      var seq = {
        at: wrapperAt,
        chain,
        commit: wrapperCommit,
        lodash,
        next: wrapperNext,
        plant: wrapperPlant,
        reverse: wrapperReverse,
        tap,
        thru,
        toIterator: wrapperToIterator,
        toJSON: wrapperValue,
        value: wrapperValue,
        valueOf: wrapperValue,
        wrapperChain
      };
      var string$1 = {
        camelCase,
        capitalize: capitalize$1,
        deburr,
        endsWith,
        escape,
        escapeRegExp,
        kebabCase,
        lowerCase,
        lowerFirst,
        pad,
        padEnd,
        padStart,
        parseInt: parseInt$1,
        repeat,
        replace,
        snakeCase,
        split,
        startCase,
        startsWith,
        template,
        templateSettings,
        toLower,
        toUpper,
        trim,
        trimEnd,
        trimStart,
        truncate,
        unescape,
        upperCase,
        upperFirst,
        words
      };
      var util = {
        attempt,
        bindAll,
        cond,
        conforms,
        constant,
        defaultTo,
        flow,
        flowRight,
        identity,
        iteratee,
        matches,
        matchesProperty,
        method,
        methodOf,
        mixin: mixin$1,
        noop,
        nthArg,
        over,
        overEvery,
        overSome,
        property,
        propertyOf,
        range: range$1,
        rangeRight,
        stubArray,
        stubFalse,
        stubObject,
        stubString,
        stubTrue,
        times,
        toPath,
        uniqueId
      };
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      var nativeMax$1 = Math.max;
      var nativeMin$2 = Math.min;
      function getView(start, end, transforms) {
        var index2 = -1, length = transforms.length;
        while (++index2 < length) {
          var data = transforms[index2], size = data.size;
          switch (data.type) {
            case "drop":
              start += size;
              break;
            case "dropRight":
              end -= size;
              break;
            case "take":
              end = nativeMin$2(end, start + size);
              break;
            case "takeRight":
              start = nativeMax$1(start, end - size);
              break;
          }
        }
        return { "start": start, "end": end };
      }
      var LAZY_FILTER_FLAG$1 = 1;
      var LAZY_MAP_FLAG = 2;
      var nativeMin$1 = Math.min;
      function lazyValue() {
        var array3 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array3), isRight = dir < 0, arrLength = isArr ? array3.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin$1(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array3, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value = array3[index2];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed2 = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed2;
              } else if (!computed2) {
                if (type == LAZY_FILTER_FLAG$1) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      var VERSION = "4.17.21";
      var WRAP_BIND_KEY_FLAG = 2;
      var LAZY_FILTER_FLAG = 1;
      var LAZY_WHILE_FLAG = 3;
      var MAX_ARRAY_LENGTH = 4294967295;
      var arrayProto = Array.prototype;
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var symIterator = Symbol$1 ? Symbol$1.iterator : void 0;
      var nativeMax = Math.max;
      var nativeMin = Math.min;
      var mixin = function(func2) {
        return function(object22, source, options) {
          if (options == null) {
            var isObj = isObject(source), props2 = isObj && keys(source), methodNames = props2 && props2.length && baseFunctions(source, props2);
            if (!(methodNames ? methodNames.length : isObj)) {
              options = source;
              source = object22;
              object22 = this;
            }
          }
          return func2(object22, source, options);
        };
      }(mixin$1);
      lodash.after = func.after;
      lodash.ary = func.ary;
      lodash.assign = object.assign;
      lodash.assignIn = object.assignIn;
      lodash.assignInWith = object.assignInWith;
      lodash.assignWith = object.assignWith;
      lodash.at = object.at;
      lodash.before = func.before;
      lodash.bind = func.bind;
      lodash.bindAll = util.bindAll;
      lodash.bindKey = func.bindKey;
      lodash.castArray = lang.castArray;
      lodash.chain = seq.chain;
      lodash.chunk = array.chunk;
      lodash.compact = array.compact;
      lodash.concat = array.concat;
      lodash.cond = util.cond;
      lodash.conforms = util.conforms;
      lodash.constant = util.constant;
      lodash.countBy = collection.countBy;
      lodash.create = object.create;
      lodash.curry = func.curry;
      lodash.curryRight = func.curryRight;
      lodash.debounce = func.debounce;
      lodash.defaults = object.defaults;
      lodash.defaultsDeep = object.defaultsDeep;
      lodash.defer = func.defer;
      lodash.delay = func.delay;
      lodash.difference = array.difference;
      lodash.differenceBy = array.differenceBy;
      lodash.differenceWith = array.differenceWith;
      lodash.drop = array.drop;
      lodash.dropRight = array.dropRight;
      lodash.dropRightWhile = array.dropRightWhile;
      lodash.dropWhile = array.dropWhile;
      lodash.fill = array.fill;
      lodash.filter = collection.filter;
      lodash.flatMap = collection.flatMap;
      lodash.flatMapDeep = collection.flatMapDeep;
      lodash.flatMapDepth = collection.flatMapDepth;
      lodash.flatten = array.flatten;
      lodash.flattenDeep = array.flattenDeep;
      lodash.flattenDepth = array.flattenDepth;
      lodash.flip = func.flip;
      lodash.flow = util.flow;
      lodash.flowRight = util.flowRight;
      lodash.fromPairs = array.fromPairs;
      lodash.functions = object.functions;
      lodash.functionsIn = object.functionsIn;
      lodash.groupBy = collection.groupBy;
      lodash.initial = array.initial;
      lodash.intersection = array.intersection;
      lodash.intersectionBy = array.intersectionBy;
      lodash.intersectionWith = array.intersectionWith;
      lodash.invert = object.invert;
      lodash.invertBy = object.invertBy;
      lodash.invokeMap = collection.invokeMap;
      lodash.iteratee = util.iteratee;
      lodash.keyBy = collection.keyBy;
      lodash.keys = keys;
      lodash.keysIn = object.keysIn;
      lodash.map = collection.map;
      lodash.mapKeys = object.mapKeys;
      lodash.mapValues = object.mapValues;
      lodash.matches = util.matches;
      lodash.matchesProperty = util.matchesProperty;
      lodash.memoize = func.memoize;
      lodash.merge = object.merge;
      lodash.mergeWith = object.mergeWith;
      lodash.method = util.method;
      lodash.methodOf = util.methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = util.nthArg;
      lodash.omit = object.omit;
      lodash.omitBy = object.omitBy;
      lodash.once = func.once;
      lodash.orderBy = collection.orderBy;
      lodash.over = util.over;
      lodash.overArgs = func.overArgs;
      lodash.overEvery = util.overEvery;
      lodash.overSome = util.overSome;
      lodash.partial = func.partial;
      lodash.partialRight = func.partialRight;
      lodash.partition = collection.partition;
      lodash.pick = object.pick;
      lodash.pickBy = object.pickBy;
      lodash.property = util.property;
      lodash.propertyOf = util.propertyOf;
      lodash.pull = array.pull;
      lodash.pullAll = array.pullAll;
      lodash.pullAllBy = array.pullAllBy;
      lodash.pullAllWith = array.pullAllWith;
      lodash.pullAt = array.pullAt;
      lodash.range = util.range;
      lodash.rangeRight = util.rangeRight;
      lodash.rearg = func.rearg;
      lodash.reject = collection.reject;
      lodash.remove = array.remove;
      lodash.rest = func.rest;
      lodash.reverse = array.reverse;
      lodash.sampleSize = collection.sampleSize;
      lodash.set = object.set;
      lodash.setWith = object.setWith;
      lodash.shuffle = collection.shuffle;
      lodash.slice = array.slice;
      lodash.sortBy = collection.sortBy;
      lodash.sortedUniq = array.sortedUniq;
      lodash.sortedUniqBy = array.sortedUniqBy;
      lodash.split = string$1.split;
      lodash.spread = func.spread;
      lodash.tail = array.tail;
      lodash.take = array.take;
      lodash.takeRight = array.takeRight;
      lodash.takeRightWhile = array.takeRightWhile;
      lodash.takeWhile = array.takeWhile;
      lodash.tap = seq.tap;
      lodash.throttle = func.throttle;
      lodash.thru = thru;
      lodash.toArray = lang.toArray;
      lodash.toPairs = object.toPairs;
      lodash.toPairsIn = object.toPairsIn;
      lodash.toPath = util.toPath;
      lodash.toPlainObject = lang.toPlainObject;
      lodash.transform = object.transform;
      lodash.unary = func.unary;
      lodash.union = array.union;
      lodash.unionBy = array.unionBy;
      lodash.unionWith = array.unionWith;
      lodash.uniq = array.uniq;
      lodash.uniqBy = array.uniqBy;
      lodash.uniqWith = array.uniqWith;
      lodash.unset = object.unset;
      lodash.unzip = array.unzip;
      lodash.unzipWith = array.unzipWith;
      lodash.update = object.update;
      lodash.updateWith = object.updateWith;
      lodash.values = object.values;
      lodash.valuesIn = object.valuesIn;
      lodash.without = array.without;
      lodash.words = string$1.words;
      lodash.wrap = func.wrap;
      lodash.xor = array.xor;
      lodash.xorBy = array.xorBy;
      lodash.xorWith = array.xorWith;
      lodash.zip = array.zip;
      lodash.zipObject = array.zipObject;
      lodash.zipObjectDeep = array.zipObjectDeep;
      lodash.zipWith = array.zipWith;
      lodash.entries = object.toPairs;
      lodash.entriesIn = object.toPairsIn;
      lodash.extend = object.assignIn;
      lodash.extendWith = object.assignInWith;
      mixin(lodash, lodash);
      lodash.add = math.add;
      lodash.attempt = util.attempt;
      lodash.camelCase = string$1.camelCase;
      lodash.capitalize = string$1.capitalize;
      lodash.ceil = math.ceil;
      lodash.clamp = number.clamp;
      lodash.clone = lang.clone;
      lodash.cloneDeep = lang.cloneDeep;
      lodash.cloneDeepWith = lang.cloneDeepWith;
      lodash.cloneWith = lang.cloneWith;
      lodash.conformsTo = lang.conformsTo;
      lodash.deburr = string$1.deburr;
      lodash.defaultTo = util.defaultTo;
      lodash.divide = math.divide;
      lodash.endsWith = string$1.endsWith;
      lodash.eq = lang.eq;
      lodash.escape = string$1.escape;
      lodash.escapeRegExp = string$1.escapeRegExp;
      lodash.every = collection.every;
      lodash.find = collection.find;
      lodash.findIndex = array.findIndex;
      lodash.findKey = object.findKey;
      lodash.findLast = collection.findLast;
      lodash.findLastIndex = array.findLastIndex;
      lodash.findLastKey = object.findLastKey;
      lodash.floor = math.floor;
      lodash.forEach = collection.forEach;
      lodash.forEachRight = collection.forEachRight;
      lodash.forIn = object.forIn;
      lodash.forInRight = object.forInRight;
      lodash.forOwn = object.forOwn;
      lodash.forOwnRight = object.forOwnRight;
      lodash.get = object.get;
      lodash.gt = lang.gt;
      lodash.gte = lang.gte;
      lodash.has = object.has;
      lodash.hasIn = object.hasIn;
      lodash.head = array.head;
      lodash.identity = identity;
      lodash.includes = collection.includes;
      lodash.indexOf = array.indexOf;
      lodash.inRange = number.inRange;
      lodash.invoke = object.invoke;
      lodash.isArguments = lang.isArguments;
      lodash.isArray = isArray;
      lodash.isArrayBuffer = lang.isArrayBuffer;
      lodash.isArrayLike = lang.isArrayLike;
      lodash.isArrayLikeObject = lang.isArrayLikeObject;
      lodash.isBoolean = lang.isBoolean;
      lodash.isBuffer = lang.isBuffer;
      lodash.isDate = lang.isDate;
      lodash.isElement = lang.isElement;
      lodash.isEmpty = lang.isEmpty;
      lodash.isEqual = lang.isEqual;
      lodash.isEqualWith = lang.isEqualWith;
      lodash.isError = lang.isError;
      lodash.isFinite = lang.isFinite;
      lodash.isFunction = lang.isFunction;
      lodash.isInteger = lang.isInteger;
      lodash.isLength = lang.isLength;
      lodash.isMap = lang.isMap;
      lodash.isMatch = lang.isMatch;
      lodash.isMatchWith = lang.isMatchWith;
      lodash.isNaN = lang.isNaN;
      lodash.isNative = lang.isNative;
      lodash.isNil = lang.isNil;
      lodash.isNull = lang.isNull;
      lodash.isNumber = lang.isNumber;
      lodash.isObject = isObject;
      lodash.isObjectLike = lang.isObjectLike;
      lodash.isPlainObject = lang.isPlainObject;
      lodash.isRegExp = lang.isRegExp;
      lodash.isSafeInteger = lang.isSafeInteger;
      lodash.isSet = lang.isSet;
      lodash.isString = lang.isString;
      lodash.isSymbol = lang.isSymbol;
      lodash.isTypedArray = lang.isTypedArray;
      lodash.isUndefined = lang.isUndefined;
      lodash.isWeakMap = lang.isWeakMap;
      lodash.isWeakSet = lang.isWeakSet;
      lodash.join = array.join;
      lodash.kebabCase = string$1.kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = array.lastIndexOf;
      lodash.lowerCase = string$1.lowerCase;
      lodash.lowerFirst = string$1.lowerFirst;
      lodash.lt = lang.lt;
      lodash.lte = lang.lte;
      lodash.max = math.max;
      lodash.maxBy = math.maxBy;
      lodash.mean = math.mean;
      lodash.meanBy = math.meanBy;
      lodash.min = math.min;
      lodash.minBy = math.minBy;
      lodash.stubArray = util.stubArray;
      lodash.stubFalse = util.stubFalse;
      lodash.stubObject = util.stubObject;
      lodash.stubString = util.stubString;
      lodash.stubTrue = util.stubTrue;
      lodash.multiply = math.multiply;
      lodash.nth = array.nth;
      lodash.noop = util.noop;
      lodash.now = date.now;
      lodash.pad = string$1.pad;
      lodash.padEnd = string$1.padEnd;
      lodash.padStart = string$1.padStart;
      lodash.parseInt = string$1.parseInt;
      lodash.random = number.random;
      lodash.reduce = collection.reduce;
      lodash.reduceRight = collection.reduceRight;
      lodash.repeat = string$1.repeat;
      lodash.replace = string$1.replace;
      lodash.result = object.result;
      lodash.round = math.round;
      lodash.sample = collection.sample;
      lodash.size = collection.size;
      lodash.snakeCase = string$1.snakeCase;
      lodash.some = collection.some;
      lodash.sortedIndex = array.sortedIndex;
      lodash.sortedIndexBy = array.sortedIndexBy;
      lodash.sortedIndexOf = array.sortedIndexOf;
      lodash.sortedLastIndex = array.sortedLastIndex;
      lodash.sortedLastIndexBy = array.sortedLastIndexBy;
      lodash.sortedLastIndexOf = array.sortedLastIndexOf;
      lodash.startCase = string$1.startCase;
      lodash.startsWith = string$1.startsWith;
      lodash.subtract = math.subtract;
      lodash.sum = math.sum;
      lodash.sumBy = math.sumBy;
      lodash.template = string$1.template;
      lodash.times = util.times;
      lodash.toFinite = lang.toFinite;
      lodash.toInteger = toInteger;
      lodash.toLength = lang.toLength;
      lodash.toLower = string$1.toLower;
      lodash.toNumber = lang.toNumber;
      lodash.toSafeInteger = lang.toSafeInteger;
      lodash.toString = lang.toString;
      lodash.toUpper = string$1.toUpper;
      lodash.trim = string$1.trim;
      lodash.trimEnd = string$1.trimEnd;
      lodash.trimStart = string$1.trimStart;
      lodash.truncate = string$1.truncate;
      lodash.unescape = string$1.unescape;
      lodash.uniqueId = util.uniqueId;
      lodash.upperCase = string$1.upperCase;
      lodash.upperFirst = string$1.upperFirst;
      lodash.each = collection.forEach;
      lodash.eachRight = collection.forEachRight;
      lodash.first = array.head;
      mixin(lodash, function() {
        var source = {};
        baseForOwn(lodash, function(func2, methodName) {
          if (!hasOwnProperty.call(lodash.prototype, methodName)) {
            source[methodName] = func2;
          }
        });
        return source;
      }(), { "chain": false });
      lodash.VERSION = VERSION;
      (lodash.templateSettings = string$1.templateSettings).imports._ = lodash;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === void 0 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin(n, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": baseIteratee(iteratee2),
            "type": type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(baseIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== void 0) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func2, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
          var interceptor = function(value2) {
            var result22 = lodashFunc.apply(lodash, arrayPush([value2], args));
            return isTaker && chainAll ? result22[0] : result22;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func2.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": void 0 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func2.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func2 = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func2.apply(isArray(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func2.apply(isArray(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func2, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(void 0, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": void 0
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = seq.at;
      lodash.prototype.chain = seq.wrapperChain;
      lodash.prototype.commit = seq.commit;
      lodash.prototype.next = seq.next;
      lodash.prototype.plant = seq.plant;
      lodash.prototype.reverse = seq.reverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = seq.value;
      lodash.prototype.first = lodash.prototype.head;
      if (symIterator) {
        lodash.prototype[symIterator] = seq.toIterator;
      }
      /**
       * @license
       * Lodash (Custom Build) <https://lodash.com/>
       * Build: `lodash modularize exports="es" -o ./`
       * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
       * Released under MIT license <https://lodash.com/license>
       * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
       * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
       */
      const isUndefined = (val) => val === void 0;
      const isBoolean = (val) => typeof val === "boolean";
      const isNumber = (val) => typeof val === "number";
      const isEmpty = (val) => !val && val !== 0 || isArray$1(val) && val.length === 0 || isObject$1(val) && !Object.keys(val).length;
      const isElement$2 = (e) => {
        if (typeof Element === "undefined")
          return false;
        return e instanceof Element;
      };
      const isPropAbsent = (prop) => isNil(prop);
      const isStringNumber = (val) => {
        if (!isString$1(val)) {
          return false;
        }
        return !Number.isNaN(Number(val));
      };
      const isWindow$1 = (val) => val === window;
      const rAF = (fn2) => isClient ? window.requestAnimationFrame(fn2) : setTimeout(fn2, 16);
      const cAF = (handle) => isClient ? window.cancelAnimationFrame(handle) : clearTimeout(handle);
      const escapeStringRegexp = (string2 = "") => string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      const capitalize = (str) => capitalize$2(str);
      const keysOf = (arr) => Object.keys(arr);
      const entriesOf = (arr) => Object.entries(arr);
      const getProp = (obj, path, defaultValue) => {
        return {
          get value() {
            return get(obj, path, defaultValue);
          },
          set value(val) {
            set(obj, path, val);
          }
        };
      };
      class ElementPlusError extends Error {
        constructor(m2) {
          super(m2);
          this.name = "ElementPlusError";
        }
      }
      function throwError(scope, m2) {
        throw new ElementPlusError(`[${scope}] ${m2}`);
      }
      function debugWarn(scope, message2) {
      }
      const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
      const hasClass = (el, cls) => {
        if (!el || !cls)
          return false;
        if (cls.includes(" "))
          throw new Error("className should not contain space.");
        return el.classList.contains(cls);
      };
      const addClass = (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.add(...classNameToArray(cls));
      };
      const removeClass = (el, cls) => {
        if (!el || !cls.trim())
          return;
        el.classList.remove(...classNameToArray(cls));
      };
      const getStyle = (element, styleName) => {
        var _a;
        if (!isClient || !element || !styleName)
          return "";
        let key = camelize(styleName);
        if (key === "float")
          key = "cssFloat";
        try {
          const style = element.style[key];
          if (style)
            return style;
          const computed2 = (_a = document.defaultView) == null ? void 0 : _a.getComputedStyle(element, "");
          return computed2 ? computed2[key] : "";
        } catch (e) {
          return element.style[key];
        }
      };
      const setStyle = (element, styleName, value) => {
        if (!element || !styleName)
          return;
        if (isObject$1(styleName)) {
          entriesOf(styleName).forEach(([prop, value2]) => setStyle(element, prop, value2));
        } else {
          const key = camelize(styleName);
          element.style[key] = value;
        }
      };
      function addUnit(value, defaultUnit = "px") {
        if (!value)
          return "";
        if (isNumber(value) || isStringNumber(value)) {
          return `${value}${defaultUnit}`;
        } else if (isString$1(value)) {
          return value;
        }
      }
      const isScroll = (el, isVertical) => {
        if (!isClient)
          return false;
        const key = {
          undefined: "overflow",
          true: "overflow-y",
          false: "overflow-x"
        }[String(isVertical)];
        const overflow = getStyle(el, key);
        return ["scroll", "auto", "overlay"].some((s2) => overflow.includes(s2));
      };
      const getScrollContainer = (el, isVertical) => {
        if (!isClient)
          return;
        let parent2 = el;
        while (parent2) {
          if ([window, document, document.documentElement].includes(parent2))
            return window;
          if (isScroll(parent2, isVertical))
            return parent2;
          parent2 = parent2.parentNode;
        }
        return parent2;
      };
      let scrollBarWidth;
      const getScrollBarWidth = (namespace) => {
        var _a;
        if (!isClient)
          return 0;
        if (scrollBarWidth !== void 0)
          return scrollBarWidth;
        const outer = document.createElement("div");
        outer.className = `${namespace}-scrollbar__wrap`;
        outer.style.visibility = "hidden";
        outer.style.width = "100px";
        outer.style.position = "absolute";
        outer.style.top = "-9999px";
        document.body.appendChild(outer);
        const widthNoScroll = outer.offsetWidth;
        outer.style.overflow = "scroll";
        const inner = document.createElement("div");
        inner.style.width = "100%";
        outer.appendChild(inner);
        const widthWithScroll = inner.offsetWidth;
        (_a = outer.parentNode) == null ? void 0 : _a.removeChild(outer);
        scrollBarWidth = widthNoScroll - widthWithScroll;
        return scrollBarWidth;
      };
      function scrollIntoView(container, selected) {
        if (!isClient)
          return;
        if (!selected) {
          container.scrollTop = 0;
          return;
        }
        const offsetParents = [];
        let pointer = selected.offsetParent;
        while (pointer !== null && container !== pointer && container.contains(pointer)) {
          offsetParents.push(pointer);
          pointer = pointer.offsetParent;
        }
        const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
        const bottom = top + selected.offsetHeight;
        const viewRectTop = container.scrollTop;
        const viewRectBottom = viewRectTop + container.clientHeight;
        if (top < viewRectTop) {
          container.scrollTop = top;
        } else if (bottom > viewRectBottom) {
          container.scrollTop = bottom - container.clientHeight;
        }
      }
      function animateScrollTo(container, from, to, duration, callback) {
        const startTime = Date.now();
        let handle;
        const scroll = () => {
          const timestamp = Date.now();
          const time = timestamp - startTime;
          const nextScrollTop = easeInOutCubic(time > duration ? duration : time, from, to, duration);
          if (isWindow$1(container)) {
            container.scrollTo(window.pageXOffset, nextScrollTop);
          } else {
            container.scrollTop = nextScrollTop;
          }
          if (time < duration) {
            handle = rAF(scroll);
          } else if (isFunction$1(callback)) {
            callback();
          }
        };
        scroll();
        return () => {
          handle && cAF(handle);
        };
      }
      const getScrollElement = (target2, container) => {
        if (isWindow$1(container)) {
          return target2.ownerDocument.documentElement;
        }
        return container;
      };
      const getScrollTop = (container) => {
        if (isWindow$1(container)) {
          return window.scrollY;
        }
        return container.scrollTop;
      };
      const getElement = (target2) => {
        if (!isClient || target2 === "")
          return null;
        if (isString$1(target2)) {
          try {
            return document.querySelector(target2);
          } catch (e) {
            return null;
          }
        }
        return target2;
      };
      let target = !isClient ? void 0 : document.body;
      function createGlobalNode(id) {
        const el = document.createElement("div");
        if (id !== void 0) {
          el.setAttribute("id", id);
        }
        if (target) {
          target.appendChild(el);
        }
        return el;
      }
      function removeGlobalNode(el) {
        el.remove();
      }
      var arrow_down_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowDown",
        __name: "arrow-down",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
            })
          ]));
        }
      });
      var arrow_down_default$1 = arrow_down_vue_vue_type_script_setup_true_lang_default;
      var arrow_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowLeft",
        __name: "arrow-left",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
            })
          ]));
        }
      });
      var arrow_left_default$1 = arrow_left_vue_vue_type_script_setup_true_lang_default;
      var arrow_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowRight",
        __name: "arrow-right",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
            })
          ]));
        }
      });
      var arrow_right_default$1 = arrow_right_vue_vue_type_script_setup_true_lang_default;
      var arrow_up_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ArrowUp",
        __name: "arrow-up",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
            })
          ]));
        }
      });
      var arrow_up_default$1 = arrow_up_vue_vue_type_script_setup_true_lang_default;
      var back_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Back",
        __name: "back",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M224 480h640a32 32 0 1 1 0 64H224a32 32 0 0 1 0-64"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "m237.248 512 265.408 265.344a32 32 0 0 1-45.312 45.312l-288-288a32 32 0 0 1 0-45.312l288-288a32 32 0 1 1 45.312 45.312z"
            })
          ]));
        }
      });
      var back_default$1 = back_vue_vue_type_script_setup_true_lang_default;
      var calendar_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Calendar",
        __name: "calendar",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64"
            })
          ]));
        }
      });
      var calendar_default$1 = calendar_vue_vue_type_script_setup_true_lang_default;
      var caret_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CaretRight",
        __name: "caret-right",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M384 192v640l384-320.064z"
            })
          ]));
        }
      });
      var caret_right_default$1 = caret_right_vue_vue_type_script_setup_true_lang_default;
      var caret_top_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CaretTop",
        __name: "caret-top",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 320 192 704h639.936z"
            })
          ]));
        }
      });
      var caret_top_default$1 = caret_top_vue_vue_type_script_setup_true_lang_default;
      var check_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Check",
        __name: "check",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
            })
          ]));
        }
      });
      var check_default$1 = check_vue_vue_type_script_setup_true_lang_default;
      var circle_check_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleCheckFilled",
        __name: "circle-check-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
            })
          ]));
        }
      });
      var circle_check_filled_default$1 = circle_check_filled_vue_vue_type_script_setup_true_lang_default;
      var circle_check_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleCheck",
        __name: "circle-check",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
            })
          ]));
        }
      });
      var circle_check_default$1 = circle_check_vue_vue_type_script_setup_true_lang_default;
      var circle_close_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleCloseFilled",
        __name: "circle-close-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
            })
          ]));
        }
      });
      var circle_close_filled_default$1 = circle_close_filled_vue_vue_type_script_setup_true_lang_default;
      var circle_close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "CircleClose",
        __name: "circle-close",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            })
          ]));
        }
      });
      var circle_close_default$1 = circle_close_vue_vue_type_script_setup_true_lang_default;
      var clock_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Clock",
        __name: "clock",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32"
            })
          ]));
        }
      });
      var clock_default$1 = clock_vue_vue_type_script_setup_true_lang_default;
      var close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Close",
        __name: "close",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
            })
          ]));
        }
      });
      var close_default$1 = close_vue_vue_type_script_setup_true_lang_default;
      var d_arrow_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "DArrowLeft",
        __name: "d-arrow-left",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
            })
          ]));
        }
      });
      var d_arrow_left_default$1 = d_arrow_left_vue_vue_type_script_setup_true_lang_default;
      var d_arrow_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "DArrowRight",
        __name: "d-arrow-right",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688m-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
            })
          ]));
        }
      });
      var d_arrow_right_default$1 = d_arrow_right_vue_vue_type_script_setup_true_lang_default;
      var delete_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Delete",
        __name: "delete",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32zm448-64v-64H416v64zM224 896h576V256H224zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32m192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32"
            })
          ]));
        }
      });
      var delete_default$1 = delete_vue_vue_type_script_setup_true_lang_default;
      var document_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Document",
        __name: "document",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M832 384H576V128H192v768h640zm-26.496-64L640 154.496V320zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m160 448h384v64H320zm0-192h160v64H320zm0 384h384v64H320z"
            })
          ]));
        }
      });
      var document_default$1 = document_vue_vue_type_script_setup_true_lang_default;
      var full_screen_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "FullScreen",
        __name: "full-screen",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64z"
            })
          ]));
        }
      });
      var full_screen_default$1 = full_screen_vue_vue_type_script_setup_true_lang_default;
      var hide_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Hide",
        __name: "hide",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
            }),
            createElementVNode("path", {
              fill: "currentColor",
              d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
            })
          ]));
        }
      });
      var hide_default$1 = hide_vue_vue_type_script_setup_true_lang_default;
      var info_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "InfoFilled",
        __name: "info-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
            })
          ]));
        }
      });
      var info_filled_default$1 = info_filled_vue_vue_type_script_setup_true_lang_default;
      var loading_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Loading",
        __name: "loading",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
            })
          ]));
        }
      });
      var loading_default$1 = loading_vue_vue_type_script_setup_true_lang_default;
      var minus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Minus",
        __name: "minus",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
            })
          ]));
        }
      });
      var minus_default$1 = minus_vue_vue_type_script_setup_true_lang_default;
      var more_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "MoreFilled",
        __name: "more-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224"
            })
          ]));
        }
      });
      var more_filled_default$1 = more_filled_vue_vue_type_script_setup_true_lang_default;
      var more_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "More",
        __name: "more",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M176 416a112 112 0 1 0 0 224 112 112 0 0 0 0-224m0 64a48 48 0 1 1 0 96 48 48 0 0 1 0-96m336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224m0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96m336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224m0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96"
            })
          ]));
        }
      });
      var more_default$1 = more_vue_vue_type_script_setup_true_lang_default;
      var picture_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "PictureFilled",
        __name: "picture-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M96 896a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h832a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32zm315.52-228.48-68.928-68.928a32 32 0 0 0-45.248 0L128 768.064h778.688l-242.112-290.56a32 32 0 0 0-49.216 0L458.752 665.408a32 32 0 0 1-47.232 2.112M256 384a96 96 0 1 0 192.064-.064A96 96 0 0 0 256 384"
            })
          ]));
        }
      });
      var picture_filled_default$1 = picture_filled_vue_vue_type_script_setup_true_lang_default;
      var plus_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Plus",
        __name: "plus",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
            })
          ]));
        }
      });
      var plus_default$1 = plus_vue_vue_type_script_setup_true_lang_default;
      var question_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "QuestionFilled",
        __name: "question-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"
            })
          ]));
        }
      });
      var question_filled_default$1 = question_filled_vue_vue_type_script_setup_true_lang_default;
      var refresh_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "RefreshLeft",
        __name: "refresh-left",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
            })
          ]));
        }
      });
      var refresh_left_default$1 = refresh_left_vue_vue_type_script_setup_true_lang_default;
      var refresh_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "RefreshRight",
        __name: "refresh-right",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
            })
          ]));
        }
      });
      var refresh_right_default$1 = refresh_right_vue_vue_type_script_setup_true_lang_default;
      var scale_to_original_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ScaleToOriginal",
        __name: "scale-to-original",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118M512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412M512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512"
            })
          ]));
        }
      });
      var scale_to_original_default$1 = scale_to_original_vue_vue_type_script_setup_true_lang_default;
      var search_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Search",
        __name: "search",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704"
            })
          ]));
        }
      });
      var search_default$1 = search_vue_vue_type_script_setup_true_lang_default;
      var sort_down_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "SortDown",
        __name: "sort-down",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M576 96v709.568L333.312 562.816A32 32 0 1 0 288 608l297.408 297.344A32 32 0 0 0 640 882.688V96a32 32 0 0 0-64 0"
            })
          ]));
        }
      });
      var sort_down_default$1 = sort_down_vue_vue_type_script_setup_true_lang_default;
      var sort_up_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "SortUp",
        __name: "sort-up",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M384 141.248V928a32 32 0 1 0 64 0V218.56l242.688 242.688A32 32 0 1 0 736 416L438.592 118.656A32 32 0 0 0 384 141.248"
            })
          ]));
        }
      });
      var sort_up_default$1 = sort_up_vue_vue_type_script_setup_true_lang_default;
      var star_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "StarFilled",
        __name: "star-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M283.84 867.84 512 747.776l228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72z"
            })
          ]));
        }
      });
      var star_filled_default$1 = star_filled_vue_vue_type_script_setup_true_lang_default;
      var star_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "Star",
        __name: "star",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m512 747.84 228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72zM313.6 924.48a70.4 70.4 0 0 1-102.144-74.24l37.888-220.928L88.96 472.96A70.4 70.4 0 0 1 128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 0 1 126.208 0l99.2 200.96 221.824 32.256a70.4 70.4 0 0 1 39.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 0 1-102.144 74.24L512 820.096l-198.4 104.32z"
            })
          ]));
        }
      });
      var star_default$1 = star_vue_vue_type_script_setup_true_lang_default;
      var success_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "SuccessFilled",
        __name: "success-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
            })
          ]));
        }
      });
      var success_filled_default$1 = success_filled_vue_vue_type_script_setup_true_lang_default;
      var view_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "View",
        __name: "view",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
            })
          ]));
        }
      });
      var view_default$1 = view_vue_vue_type_script_setup_true_lang_default;
      var warning_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "WarningFilled",
        __name: "warning-filled",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
            })
          ]));
        }
      });
      var warning_filled_default$1 = warning_filled_vue_vue_type_script_setup_true_lang_default;
      var zoom_in_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ZoomIn",
        __name: "zoom-in",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704m-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64z"
            })
          ]));
        }
      });
      var zoom_in_default$1 = zoom_in_vue_vue_type_script_setup_true_lang_default;
      var zoom_out_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
        name: "ZoomOut",
        __name: "zoom-out",
        setup(__props) {
          return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            createElementVNode("path", {
              fill: "currentColor",
              d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704M352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64"
            })
          ]));
        }
      });
      var zoom_out_default$1 = zoom_out_vue_vue_type_script_setup_true_lang_default;
      /*! Element Plus Icons Vue v2.3.1 */
      const epPropKey = "__epPropKey";
      const definePropType = (val) => val;
      const isEpProp = (val) => isObject$1(val) && !!val[epPropKey];
      const buildProp = (prop, key) => {
        if (!isObject$1(prop) || isEpProp(prop))
          return prop;
        const { values: values2, required, default: defaultValue, type, validator } = prop;
        const _validator = values2 || validator ? (val) => {
          let valid = false;
          let allowedValues = [];
          if (values2) {
            allowedValues = Array.from(values2);
            if (hasOwn(prop, "default")) {
              allowedValues.push(defaultValue);
            }
            valid || (valid = allowedValues.includes(val));
          }
          if (validator)
            valid || (valid = validator(val));
          if (!valid && allowedValues.length > 0) {
            const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
            warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
          }
          return valid;
        } : void 0;
        const epProp = {
          type,
          required: !!required,
          validator: _validator,
          [epPropKey]: true
        };
        if (hasOwn(prop, "default"))
          epProp.default = defaultValue;
        return epProp;
      };
      const buildProps = (props2) => fromPairs(Object.entries(props2).map(([key, option]) => [
        key,
        buildProp(option, key)
      ]));
      const iconPropType = definePropType([
        String,
        Object,
        Function
      ]);
      const CloseComponents = {
        Close: close_default$1
      };
      const TypeComponents = {
        Close: close_default$1,
        SuccessFilled: success_filled_default$1,
        InfoFilled: info_filled_default$1,
        WarningFilled: warning_filled_default$1,
        CircleCloseFilled: circle_close_filled_default$1
      };
      const TypeComponentsMap = {
        primary: info_filled_default$1,
        success: success_filled_default$1,
        warning: warning_filled_default$1,
        error: circle_close_filled_default$1,
        info: info_filled_default$1
      };
      const ValidateComponentsMap = {
        validating: loading_default$1,
        success: circle_check_default$1,
        error: circle_close_default$1
      };
      const withInstall = (main, extra) => {
        main.install = (app) => {
          for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
            app.component(comp.name, comp);
          }
        };
        if (extra) {
          for (const [key, comp] of Object.entries(extra)) {
            main[key] = comp;
          }
        }
        return main;
      };
      const withInstallFunction = (fn2, name) => {
        fn2.install = (app) => {
          fn2._context = app._context;
          app.config.globalProperties[name] = fn2;
        };
        return fn2;
      };
      const withInstallDirective = (directive, name) => {
        directive.install = (app) => {
          app.directive(name, directive);
        };
        return directive;
      };
      const withNoopInstall = (component2) => {
        component2.install = NOOP;
        return component2;
      };
      const composeRefs = (...refs) => {
        return (el) => {
          refs.forEach((ref2) => {
            if (isFunction$1(ref2)) {
              ref2(el);
            } else {
              ref2.value = el;
            }
          });
        };
      };
      const EVENT_CODE = exports("EVENT_CODE", {
        tab: "Tab",
        enter: "Enter",
        space: "Space",
        left: "ArrowLeft",
        up: "ArrowUp",
        right: "ArrowRight",
        down: "ArrowDown",
        esc: "Escape",
        delete: "Delete",
        backspace: "Backspace",
        numpadEnter: "NumpadEnter",
        pageUp: "PageUp",
        pageDown: "PageDown",
        home: "Home",
        end: "End"
      });
      const datePickTypes = exports("datePickTypes", [
        "year",
        "years",
        "month",
        "months",
        "date",
        "dates",
        "week",
        "datetime",
        "datetimerange",
        "daterange",
        "monthrange",
        "yearrange"
      ]);
      const WEEK_DAYS = exports("WEEK_DAYS", [
        "sun",
        "mon",
        "tue",
        "wed",
        "thu",
        "fri",
        "sat"
      ]);
      const UPDATE_MODEL_EVENT = exports("UPDATE_MODEL_EVENT", "update:modelValue");
      const CHANGE_EVENT = exports("CHANGE_EVENT", "change");
      const INPUT_EVENT = exports("INPUT_EVENT", "input");
      const INSTALLED_KEY = exports("INSTALLED_KEY", Symbol("INSTALLED_KEY"));
      const componentSizes = exports("componentSizes", ["", "default", "small", "large"]);
      const componentSizeMap = exports("componentSizeMap", {
        large: 40,
        default: 32,
        small: 24
      });
      const columnAlignment = exports("columnAlignment", ["left", "center", "right"]);
      const isValidComponentSize = (val) => ["", ...componentSizes].includes(val);
      var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
        PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
        PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
        PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
        PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
        PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
        PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
        PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
        PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
        PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
        PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
        PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
        PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
        return PatchFlags2;
      })(PatchFlags || {});
      function isFragment(node) {
        return isVNode(node) && node.type === Fragment;
      }
      function isComment(node) {
        return isVNode(node) && node.type === Comment;
      }
      function isValidElementNode(node) {
        return isVNode(node) && !isFragment(node) && !isComment(node);
      }
      const getNormalizedProps = (node) => {
        if (!isVNode(node)) {
          return {};
        }
        const raw = node.props || {};
        const type = (isVNode(node.type) ? node.type.props : void 0) || {};
        const props2 = {};
        Object.keys(type).forEach((key) => {
          if (hasOwn(type[key], "default")) {
            props2[key] = type[key].default;
          }
        });
        Object.keys(raw).forEach((key) => {
          props2[camelize(key)] = raw[key];
        });
        return props2;
      };
      const ensureOnlyChild = (children) => {
        if (!isArray$1(children) || children.length > 1) {
          throw new Error("expect to receive a single Vue element child");
        }
        return children[0];
      };
      const flattedChildren = (children) => {
        const vNodes = isArray$1(children) ? children : [children];
        const result2 = [];
        vNodes.forEach((child) => {
          var _a;
          if (isArray$1(child)) {
            result2.push(...flattedChildren(child));
          } else if (isVNode(child) && ((_a = child.component) == null ? void 0 : _a.subTree)) {
            result2.push(child, ...flattedChildren(child.component.subTree));
          } else if (isVNode(child) && isArray$1(child.children)) {
            result2.push(...flattedChildren(child.children));
          } else if (isVNode(child) && child.shapeFlag === 2) {
            result2.push(...flattedChildren(child.type()));
          } else {
            result2.push(child);
          }
        });
        return result2;
      };
      function ensureValidVNode(vnodes) {
        return vnodes.some((child) => {
          if (!isVNode(child))
            return true;
          if (child.type === Comment)
            return false;
          if (child.type === Fragment && !ensureValidVNode(child.children))
            return false;
          return true;
        }) ? vnodes : null;
      }
      const unique = (arr) => [...new Set(arr)];
      const castArray = (arr) => {
        if (!arr && arr !== 0)
          return [];
        return isArray$1(arr) ? arr : [arr];
      };
      const isKorean = (text) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(text);
      const mutable = (val) => val;
      function throttleByRaf(cb) {
        let timer = 0;
        const throttle2 = (...args) => {
          if (timer) {
            cAF(timer);
          }
          timer = rAF(() => {
            cb(...args);
            timer = 0;
          });
        };
        throttle2.cancel = () => {
          cAF(timer);
          timer = 0;
        };
        return throttle2;
      }
      const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
      const LISTENER_PREFIX = /^on[A-Z]/;
      const useAttrs = exports("useAttrs", (params = {}) => {
        const { excludeListeners = false, excludeKeys } = params;
        const allExcludeKeys = computed(() => {
          return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
        });
        const instance = getCurrentInstance();
        if (!instance) {
          return computed(() => ({}));
        }
        return computed(() => {
          var _a;
          return fromPairs(Object.entries((_a = instance.proxy) == null ? void 0 : _a.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
        });
      });
      function useCalcInputWidth() {
        const calculatorRef = shallowRef();
        const calculatorWidth = ref(0);
        const MINIMUM_INPUT_WIDTH = 11;
        const inputStyle = computed(() => ({
          minWidth: `${Math.max(calculatorWidth.value, MINIMUM_INPUT_WIDTH)}px`
        }));
        const resetCalculatorWidth = () => {
          var _a, _b;
          calculatorWidth.value = (_b = (_a = calculatorRef.value) == null ? void 0 : _a.getBoundingClientRect().width) != null ? _b : 0;
        };
        useResizeObserver(calculatorRef, resetCalculatorWidth);
        return {
          calculatorRef,
          calculatorWidth,
          inputStyle
        };
      }
      const useDeprecated = exports("useDeprecated", ({ from, replacement, scope, version: version2, ref: ref2, type = "API" }, condition) => {
        watch(() => unref(condition), (val) => {
        }, {
          immediate: true
        });
      });
      const useDraggable = exports("useDraggable", (targetRef, dragRef, draggable2, overflow) => {
        const transform2 = {
          offsetX: 0,
          offsetY: 0
        };
        const adjustPosition = (moveX, moveY) => {
          if (targetRef.value) {
            const { offsetX, offsetY } = transform2;
            const targetRect = targetRef.value.getBoundingClientRect();
            const targetLeft = targetRect.left;
            const targetTop = targetRect.top;
            const targetWidth = targetRect.width;
            const targetHeight = targetRect.height;
            const clientWidth = document.documentElement.clientWidth;
            const clientHeight = document.documentElement.clientHeight;
            const minLeft = -targetLeft + offsetX;
            const minTop = -targetTop + offsetY;
            const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
            const maxTop = clientHeight - targetTop - (targetHeight < clientHeight ? targetHeight : 0) + offsetY;
            if (!(overflow == null ? void 0 : overflow.value)) {
              moveX = Math.min(Math.max(moveX, minLeft), maxLeft);
              moveY = Math.min(Math.max(moveY, minTop), maxTop);
            }
            transform2.offsetX = moveX;
            transform2.offsetY = moveY;
            targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
          }
        };
        const onMousedown = (e) => {
          const downX = e.clientX;
          const downY = e.clientY;
          const { offsetX, offsetY } = transform2;
          const onMousemove = (e2) => {
            const moveX = offsetX + e2.clientX - downX;
            const moveY = offsetY + e2.clientY - downY;
            adjustPosition(moveX, moveY);
          };
          const onMouseup = () => {
            document.removeEventListener("mousemove", onMousemove);
            document.removeEventListener("mouseup", onMouseup);
          };
          document.addEventListener("mousemove", onMousemove);
          document.addEventListener("mouseup", onMouseup);
        };
        const onDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.addEventListener("mousedown", onMousedown);
            window.addEventListener("resize", updatePosition);
          }
        };
        const offDraggable = () => {
          if (dragRef.value && targetRef.value) {
            dragRef.value.removeEventListener("mousedown", onMousedown);
            window.removeEventListener("resize", updatePosition);
          }
        };
        const resetPosition = () => {
          transform2.offsetX = 0;
          transform2.offsetY = 0;
          if (targetRef.value) {
            targetRef.value.style.transform = "";
          }
        };
        const updatePosition = () => {
          const { offsetX, offsetY } = transform2;
          adjustPosition(offsetX, offsetY);
        };
        onMounted(() => {
          watchEffect(() => {
            if (draggable2.value) {
              onDraggable();
            } else {
              offDraggable();
            }
          });
        });
        onBeforeUnmount(() => {
          offDraggable();
        });
        return {
          resetPosition,
          updatePosition
        };
      });
      const useFocus = exports("useFocus", (el) => {
        return {
          focus: () => {
            var _a, _b;
            (_b = (_a = el.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
          }
        };
      });
      var English = {
        name: "en",
        el: {
          breadcrumb: {
            label: "Breadcrumb"
          },
          colorpicker: {
            confirm: "OK",
            clear: "Clear",
            defaultLabel: "color picker",
            description: "current color is {color}. press enter to select a new color.",
            alphaLabel: "pick alpha value"
          },
          datepicker: {
            now: "Now",
            today: "Today",
            cancel: "Cancel",
            clear: "Clear",
            confirm: "OK",
            dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
            monthTablePrompt: "Use the arrow keys and enter to select the month",
            yearTablePrompt: "Use the arrow keys and enter to select the year",
            selectedDate: "Selected date",
            selectDate: "Select date",
            selectTime: "Select time",
            startDate: "Start Date",
            startTime: "Start Time",
            endDate: "End Date",
            endTime: "End Time",
            prevYear: "Previous Year",
            nextYear: "Next Year",
            prevMonth: "Previous Month",
            nextMonth: "Next Month",
            year: "",
            month1: "January",
            month2: "February",
            month3: "March",
            month4: "April",
            month5: "May",
            month6: "June",
            month7: "July",
            month8: "August",
            month9: "September",
            month10: "October",
            month11: "November",
            month12: "December",
            week: "week",
            weeks: {
              sun: "Sun",
              mon: "Mon",
              tue: "Tue",
              wed: "Wed",
              thu: "Thu",
              fri: "Fri",
              sat: "Sat"
            },
            weeksFull: {
              sun: "Sunday",
              mon: "Monday",
              tue: "Tuesday",
              wed: "Wednesday",
              thu: "Thursday",
              fri: "Friday",
              sat: "Saturday"
            },
            months: {
              jan: "Jan",
              feb: "Feb",
              mar: "Mar",
              apr: "Apr",
              may: "May",
              jun: "Jun",
              jul: "Jul",
              aug: "Aug",
              sep: "Sep",
              oct: "Oct",
              nov: "Nov",
              dec: "Dec"
            }
          },
          inputNumber: {
            decrease: "decrease number",
            increase: "increase number"
          },
          select: {
            loading: "Loading",
            noMatch: "No matching data",
            noData: "No data",
            placeholder: "Select"
          },
          mention: {
            loading: "Loading"
          },
          dropdown: {
            toggleDropdown: "Toggle Dropdown"
          },
          cascader: {
            noMatch: "No matching data",
            loading: "Loading",
            placeholder: "Select",
            noData: "No data"
          },
          pagination: {
            goto: "Go to",
            pagesize: "/page",
            total: "Total {total}",
            pageClassifier: "",
            page: "Page",
            prev: "Go to previous page",
            next: "Go to next page",
            currentPage: "page {pager}",
            prevPages: "Previous {pager} pages",
            nextPages: "Next {pager} pages",
            deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
          },
          dialog: {
            close: "Close this dialog"
          },
          drawer: {
            close: "Close this dialog"
          },
          messagebox: {
            title: "Message",
            confirm: "OK",
            cancel: "Cancel",
            error: "Illegal input",
            close: "Close this dialog"
          },
          upload: {
            deleteTip: "press delete to remove",
            delete: "Delete",
            preview: "Preview",
            continue: "Continue"
          },
          slider: {
            defaultLabel: "slider between {min} and {max}",
            defaultRangeStartLabel: "pick start value",
            defaultRangeEndLabel: "pick end value"
          },
          table: {
            emptyText: "No Data",
            confirmFilter: "Confirm",
            resetFilter: "Reset",
            clearFilter: "All",
            sumText: "Sum"
          },
          tour: {
            next: "Next",
            previous: "Previous",
            finish: "Finish"
          },
          tree: {
            emptyText: "No Data"
          },
          transfer: {
            noMatch: "No matching data",
            noData: "No data",
            titles: ["List 1", "List 2"],
            filterPlaceholder: "Enter keyword",
            noCheckedFormat: "{total} items",
            hasCheckedFormat: "{checked}/{total} checked"
          },
          image: {
            error: "FAILED"
          },
          pageHeader: {
            title: "Back"
          },
          popconfirm: {
            confirmButtonText: "Yes",
            cancelButtonText: "No"
          },
          carousel: {
            leftArrow: "Carousel arrow left",
            rightArrow: "Carousel arrow right",
            indicator: "Carousel switch to index {index}"
          }
        }
      };
      const buildTranslator = exports("buildTranslator", (locale) => (path, option) => translate(path, option, unref(locale)));
      const translate = exports("translate", (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_2, key) => {
        var _a;
        return `${(_a = option == null ? void 0 : option[key]) != null ? _a : `{${key}}`}`;
      }));
      const buildLocaleContext = exports("buildLocaleContext", (locale) => {
        const lang2 = computed(() => unref(locale).name);
        const localeRef = isRef(locale) ? locale : ref(locale);
        return {
          lang: lang2,
          locale: localeRef,
          t: buildTranslator(locale)
        };
      });
      const localeContextKey = exports("localeContextKey", Symbol("localeContextKey"));
      const useLocale = exports("useLocale", (localeOverrides) => {
        const locale = localeOverrides || inject(localeContextKey, ref());
        return buildLocaleContext(computed(() => locale.value || English));
      });
      const defaultNamespace = exports("defaultNamespace", "el");
      const statePrefix = "is-";
      const _bem = (namespace, block, blockSuffix, element, modifier) => {
        let cls = `${namespace}-${block}`;
        if (blockSuffix) {
          cls += `-${blockSuffix}`;
        }
        if (element) {
          cls += `__${element}`;
        }
        if (modifier) {
          cls += `--${modifier}`;
        }
        return cls;
      };
      const namespaceContextKey = exports("namespaceContextKey", Symbol("namespaceContextKey"));
      const useGetDerivedNamespace = exports("useGetDerivedNamespace", (namespaceOverrides) => {
        const derivedNamespace = namespaceOverrides || (getCurrentInstance() ? inject(namespaceContextKey, ref(defaultNamespace)) : ref(defaultNamespace));
        const namespace = computed(() => {
          return unref(derivedNamespace) || defaultNamespace;
        });
        return namespace;
      });
      const useNamespace = exports("useNamespace", (block, namespaceOverrides) => {
        const namespace = useGetDerivedNamespace(namespaceOverrides);
        const b2 = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
        const e = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
        const m2 = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
        const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
        const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
        const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
        const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
        const is = (name, ...args) => {
          const state = args.length >= 1 ? args[0] : true;
          return name && state ? `${statePrefix}${name}` : "";
        };
        const cssVar = (object3) => {
          const styles = {};
          for (const key in object3) {
            if (object3[key]) {
              styles[`--${namespace.value}-${key}`] = object3[key];
            }
          }
          return styles;
        };
        const cssVarBlock = (object3) => {
          const styles = {};
          for (const key in object3) {
            if (object3[key]) {
              styles[`--${namespace.value}-${block}-${key}`] = object3[key];
            }
          }
          return styles;
        };
        const cssVarName = (name) => `--${namespace.value}-${name}`;
        const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
        return {
          namespace,
          b: b2,
          e,
          m: m2,
          be: be2,
          em,
          bm,
          bem,
          is,
          cssVar,
          cssVarName,
          cssVarBlock,
          cssVarBlockName
        };
      });
      const useLockscreen = exports("useLockscreen", (trigger, options = {}) => {
        if (!isRef(trigger)) {
          throwError("[useLockscreen]", "You need to pass a ref param to this function");
        }
        const ns = options.ns || useNamespace("popup");
        const hiddenCls = computed(() => ns.bm("parent", "hidden"));
        if (!isClient || hasClass(document.body, hiddenCls.value)) {
          return;
        }
        let scrollBarWidth2 = 0;
        let withoutHiddenClass = false;
        let bodyWidth = "0";
        const cleanup = () => {
          setTimeout(() => {
            if (typeof document === "undefined")
              return;
            if (withoutHiddenClass && document) {
              document.body.style.width = bodyWidth;
              removeClass(document.body, hiddenCls.value);
            }
          }, 200);
        };
        watch(trigger, (val) => {
          if (!val) {
            cleanup();
            return;
          }
          withoutHiddenClass = !hasClass(document.body, hiddenCls.value);
          if (withoutHiddenClass) {
            bodyWidth = document.body.style.width;
            addClass(document.body, hiddenCls.value);
          }
          scrollBarWidth2 = getScrollBarWidth(ns.namespace.value);
          const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
          const bodyOverflowY = getStyle(document.body, "overflowY");
          if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
            document.body.style.width = `calc(100% - ${scrollBarWidth2}px)`;
          }
        });
        onScopeDispose(() => cleanup());
      });
      const modalStack = [];
      const closeModal = (e) => {
        if (modalStack.length === 0)
          return;
        if (e.code === EVENT_CODE.esc) {
          e.stopPropagation();
          const topModal = modalStack[modalStack.length - 1];
          topModal.handleClose();
        }
      };
      const useModal = exports("useModal", (instance, visibleRef) => {
        watch(visibleRef, (val) => {
          if (val) {
            modalStack.push(instance);
          } else {
            modalStack.splice(modalStack.indexOf(instance), 1);
          }
        });
      });
      if (isClient)
        useEventListener(document, "keydown", closeModal);
      const _prop = buildProp({
        type: definePropType(Boolean),
        default: null
      });
      const _event = buildProp({
        type: definePropType(Function)
      });
      const createModelToggleComposable = exports("createModelToggleComposable", (name) => {
        const updateEventKey = `update:${name}`;
        const updateEventKeyRaw2 = `onUpdate:${name}`;
        const useModelToggleEmits2 = [updateEventKey];
        const useModelToggleProps2 = {
          [name]: _prop,
          [updateEventKeyRaw2]: _event
        };
        const useModelToggle2 = ({
          indicator,
          toggleReason,
          shouldHideWhenRouteChanges,
          shouldProceed,
          onShow,
          onHide
        }) => {
          const instance = getCurrentInstance();
          const { emit } = instance;
          const props2 = instance.props;
          const hasUpdateHandler = computed(() => isFunction$1(props2[updateEventKeyRaw2]));
          const isModelBindingAbsent = computed(() => props2[name] === null);
          const doShow = (event) => {
            if (indicator.value === true) {
              return;
            }
            indicator.value = true;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$1(onShow)) {
              onShow(event);
            }
          };
          const doHide = (event) => {
            if (indicator.value === false) {
              return;
            }
            indicator.value = false;
            if (toggleReason) {
              toggleReason.value = event;
            }
            if (isFunction$1(onHide)) {
              onHide(event);
            }
          };
          const show = (event) => {
            if (props2.disabled === true || isFunction$1(shouldProceed) && !shouldProceed())
              return;
            const shouldEmit = hasUpdateHandler.value && isClient;
            if (shouldEmit) {
              emit(updateEventKey, true);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doShow(event);
            }
          };
          const hide = (event) => {
            if (props2.disabled === true || !isClient)
              return;
            const shouldEmit = hasUpdateHandler.value && isClient;
            if (shouldEmit) {
              emit(updateEventKey, false);
            }
            if (isModelBindingAbsent.value || !shouldEmit) {
              doHide(event);
            }
          };
          const onChange = (val) => {
            if (!isBoolean(val))
              return;
            if (props2.disabled && val) {
              if (hasUpdateHandler.value) {
                emit(updateEventKey, false);
              }
            } else if (indicator.value !== val) {
              if (val) {
                doShow();
              } else {
                doHide();
              }
            }
          };
          const toggle = () => {
            if (indicator.value) {
              hide();
            } else {
              show();
            }
          };
          watch(() => props2[name], onChange);
          if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
            watch(() => ({
              ...instance.proxy.$route
            }), () => {
              if (shouldHideWhenRouteChanges.value && indicator.value) {
                hide();
              }
            });
          }
          onMounted(() => {
            onChange(props2[name]);
          });
          return {
            hide,
            show,
            toggle,
            hasUpdateHandler
          };
        };
        return {
          useModelToggle: useModelToggle2,
          useModelToggleProps: useModelToggleProps2,
          useModelToggleEmits: useModelToggleEmits2
        };
      });
      const { useModelToggle, useModelToggleProps, useModelToggleEmits } = createModelToggleComposable("modelValue");
      exports({ useModelToggle, useModelToggleProps, useModelToggleEmits });
      const usePreventGlobal = exports("usePreventGlobal", (indicator, evt, cb) => {
        const prevent = (e) => {
          if (cb(e))
            e.stopImmediatePropagation();
        };
        let stop = void 0;
        watch(() => indicator.value, (val) => {
          if (val) {
            stop = useEventListener(document, evt, prevent, true);
          } else {
            stop == null ? void 0 : stop();
          }
        }, { immediate: true });
      });
      const useProp = exports("useProp", (name) => {
        const vm = getCurrentInstance();
        return computed(() => {
          var _a, _b;
          return (_b = (_a = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a.$props) == null ? void 0 : _b[name];
        });
      });
      var E$1 = "top", R = "bottom", W = "right", P$1 = "left", me = "auto", G = [E$1, R, W, P$1], U$1 = "start", J = "end", Xe = "clippingParents", je = "viewport", K = "popper", Ye = "reference", De = G.reduce(function(t, e) {
        return t.concat([e + "-" + U$1, e + "-" + J]);
      }, []), Ee = [].concat(G, [me]).reduce(function(t, e) {
        return t.concat([e, e + "-" + U$1, e + "-" + J]);
      }, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et = "afterMain", tt = "beforeWrite", nt = "write", rt = "afterWrite", ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
      function C(t) {
        return t ? (t.nodeName || "").toLowerCase() : null;
      }
      function H(t) {
        if (t == null)
          return window;
        if (t.toString() !== "[object Window]") {
          var e = t.ownerDocument;
          return e && e.defaultView || window;
        }
        return t;
      }
      function Q(t) {
        var e = H(t).Element;
        return t instanceof e || t instanceof Element;
      }
      function B(t) {
        var e = H(t).HTMLElement;
        return t instanceof e || t instanceof HTMLElement;
      }
      function Pe(t) {
        if (typeof ShadowRoot == "undefined")
          return false;
        var e = H(t).ShadowRoot;
        return t instanceof e || t instanceof ShadowRoot;
      }
      function Mt(t) {
        var e = t.state;
        Object.keys(e.elements).forEach(function(n) {
          var r = e.styles[n] || {}, o2 = e.attributes[n] || {}, i = e.elements[n];
          !B(i) || !C(i) || (Object.assign(i.style, r), Object.keys(o2).forEach(function(a2) {
            var s2 = o2[a2];
            s2 === false ? i.removeAttribute(a2) : i.setAttribute(a2, s2 === true ? "" : s2);
          }));
        });
      }
      function Rt(t) {
        var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
        return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
          Object.keys(e.elements).forEach(function(r) {
            var o2 = e.elements[r], i = e.attributes[r] || {}, a2 = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), s2 = a2.reduce(function(f2, c2) {
              return f2[c2] = "", f2;
            }, {});
            !B(o2) || !C(o2) || (Object.assign(o2.style, s2), Object.keys(i).forEach(function(f2) {
              o2.removeAttribute(f2);
            }));
          });
        };
      }
      var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
      function q(t) {
        return t.split("-")[0];
      }
      var X$1 = Math.max, ve = Math.min, Z = Math.round;
      function ee(t, e) {
        e === void 0 && (e = false);
        var n = t.getBoundingClientRect(), r = 1, o2 = 1;
        if (B(t) && e) {
          var i = t.offsetHeight, a2 = t.offsetWidth;
          a2 > 0 && (r = Z(n.width) / a2 || 1), i > 0 && (o2 = Z(n.height) / i || 1);
        }
        return { width: n.width / r, height: n.height / o2, top: n.top / o2, right: n.right / r, bottom: n.bottom / o2, left: n.left / r, x: n.left / r, y: n.top / o2 };
      }
      function ke(t) {
        var e = ee(t), n = t.offsetWidth, r = t.offsetHeight;
        return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
      }
      function it(t, e) {
        var n = e.getRootNode && e.getRootNode();
        if (t.contains(e))
          return true;
        if (n && Pe(n)) {
          var r = e;
          do {
            if (r && t.isSameNode(r))
              return true;
            r = r.parentNode || r.host;
          } while (r);
        }
        return false;
      }
      function N$1(t) {
        return H(t).getComputedStyle(t);
      }
      function Wt(t) {
        return ["table", "td", "th"].indexOf(C(t)) >= 0;
      }
      function I$1(t) {
        return ((Q(t) ? t.ownerDocument : t.document) || window.document).documentElement;
      }
      function ge(t) {
        return C(t) === "html" ? t : t.assignedSlot || t.parentNode || (Pe(t) ? t.host : null) || I$1(t);
      }
      function at(t) {
        return !B(t) || N$1(t).position === "fixed" ? null : t.offsetParent;
      }
      function Bt(t) {
        var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
        if (n && B(t)) {
          var r = N$1(t);
          if (r.position === "fixed")
            return null;
        }
        var o2 = ge(t);
        for (Pe(o2) && (o2 = o2.host); B(o2) && ["html", "body"].indexOf(C(o2)) < 0; ) {
          var i = N$1(o2);
          if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none")
            return o2;
          o2 = o2.parentNode;
        }
        return null;
      }
      function se(t) {
        for (var e = H(t), n = at(t); n && Wt(n) && N$1(n).position === "static"; )
          n = at(n);
        return n && (C(n) === "html" || C(n) === "body" && N$1(n).position === "static") ? e : n || Bt(t) || e;
      }
      function Le(t) {
        return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
      }
      function fe(t, e, n) {
        return X$1(t, ve(e, n));
      }
      function St(t, e, n) {
        var r = fe(t, e, n);
        return r > n ? n : r;
      }
      function st() {
        return { top: 0, right: 0, bottom: 0, left: 0 };
      }
      function ft(t) {
        return Object.assign({}, st(), t);
      }
      function ct(t, e) {
        return e.reduce(function(n, r) {
          return n[r] = t, n;
        }, {});
      }
      var Tt = function(t, e) {
        return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, ft(typeof t != "number" ? t : ct(t, G));
      };
      function Ht(t) {
        var e, n = t.state, r = t.name, o2 = t.options, i = n.elements.arrow, a2 = n.modifiersData.popperOffsets, s2 = q(n.placement), f2 = Le(s2), c2 = [P$1, W].indexOf(s2) >= 0, u2 = c2 ? "height" : "width";
        if (!(!i || !a2)) {
          var m2 = Tt(o2.padding, n), v2 = ke(i), l2 = f2 === "y" ? E$1 : P$1, h2 = f2 === "y" ? R : W, p2 = n.rects.reference[u2] + n.rects.reference[f2] - a2[f2] - n.rects.popper[u2], g = a2[f2] - n.rects.reference[f2], x2 = se(i), y = x2 ? f2 === "y" ? x2.clientHeight || 0 : x2.clientWidth || 0 : 0, $ = p2 / 2 - g / 2, d2 = m2[l2], b2 = y - v2[u2] - m2[h2], w2 = y / 2 - v2[u2] / 2 + $, O2 = fe(d2, w2, b2), j = f2;
          n.modifiersData[r] = (e = {}, e[j] = O2, e.centerOffset = O2 - w2, e);
        }
      }
      function Ct(t) {
        var e = t.state, n = t.options, r = n.element, o2 = r === void 0 ? "[data-popper-arrow]" : r;
        o2 != null && (typeof o2 == "string" && (o2 = e.elements.popper.querySelector(o2), !o2) || !it(e.elements.popper, o2) || (e.elements.arrow = o2));
      }
      var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
      function te(t) {
        return t.split("-")[1];
      }
      var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
      function Vt(t) {
        var e = t.x, n = t.y, r = window, o2 = r.devicePixelRatio || 1;
        return { x: Z(e * o2) / o2 || 0, y: Z(n * o2) / o2 || 0 };
      }
      function ut(t) {
        var e, n = t.popper, r = t.popperRect, o2 = t.placement, i = t.variation, a2 = t.offsets, s2 = t.position, f2 = t.gpuAcceleration, c2 = t.adaptive, u2 = t.roundOffsets, m2 = t.isFixed, v2 = a2.x, l2 = v2 === void 0 ? 0 : v2, h2 = a2.y, p2 = h2 === void 0 ? 0 : h2, g = typeof u2 == "function" ? u2({ x: l2, y: p2 }) : { x: l2, y: p2 };
        l2 = g.x, p2 = g.y;
        var x2 = a2.hasOwnProperty("x"), y = a2.hasOwnProperty("y"), $ = P$1, d2 = E$1, b2 = window;
        if (c2) {
          var w2 = se(n), O2 = "clientHeight", j = "clientWidth";
          if (w2 === H(n) && (w2 = I$1(n), N$1(w2).position !== "static" && s2 === "absolute" && (O2 = "scrollHeight", j = "scrollWidth")), w2 = w2, o2 === E$1 || (o2 === P$1 || o2 === W) && i === J) {
            d2 = R;
            var A2 = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.height : w2[O2];
            p2 -= A2 - r.height, p2 *= f2 ? 1 : -1;
          }
          if (o2 === P$1 || (o2 === E$1 || o2 === R) && i === J) {
            $ = W;
            var k = m2 && w2 === b2 && b2.visualViewport ? b2.visualViewport.width : w2[j];
            l2 -= k - r.width, l2 *= f2 ? 1 : -1;
          }
        }
        var D2 = Object.assign({ position: s2 }, c2 && qt), S2 = u2 === true ? Vt({ x: l2, y: p2 }) : { x: l2, y: p2 };
        if (l2 = S2.x, p2 = S2.y, f2) {
          var L;
          return Object.assign({}, D2, (L = {}, L[d2] = y ? "0" : "", L[$] = x2 ? "0" : "", L.transform = (b2.devicePixelRatio || 1) <= 1 ? "translate(" + l2 + "px, " + p2 + "px)" : "translate3d(" + l2 + "px, " + p2 + "px, 0)", L));
        }
        return Object.assign({}, D2, (e = {}, e[d2] = y ? p2 + "px" : "", e[$] = x2 ? l2 + "px" : "", e.transform = "", e));
      }
      function Nt(t) {
        var e = t.state, n = t.options, r = n.gpuAcceleration, o2 = r === void 0 ? true : r, i = n.adaptive, a2 = i === void 0 ? true : i, s2 = n.roundOffsets, f2 = s2 === void 0 ? true : s2, c2 = { placement: q(e.placement), variation: te(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: o2, isFixed: e.options.strategy === "fixed" };
        e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ut(Object.assign({}, c2, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a2, roundOffsets: f2 })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ut(Object.assign({}, c2, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f2 })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
      }
      var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} }, ye = { passive: true };
      function It(t) {
        var e = t.state, n = t.instance, r = t.options, o2 = r.scroll, i = o2 === void 0 ? true : o2, a2 = r.resize, s2 = a2 === void 0 ? true : a2, f2 = H(e.elements.popper), c2 = [].concat(e.scrollParents.reference, e.scrollParents.popper);
        return i && c2.forEach(function(u2) {
          u2.addEventListener("scroll", n.update, ye);
        }), s2 && f2.addEventListener("resize", n.update, ye), function() {
          i && c2.forEach(function(u2) {
            u2.removeEventListener("scroll", n.update, ye);
          }), s2 && f2.removeEventListener("resize", n.update, ye);
        };
      }
      var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
      }, effect: It, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
      function be(t) {
        return t.replace(/left|right|bottom|top/g, function(e) {
          return _t[e];
        });
      }
      var zt = { start: "end", end: "start" };
      function lt(t) {
        return t.replace(/start|end/g, function(e) {
          return zt[e];
        });
      }
      function We(t) {
        var e = H(t), n = e.pageXOffset, r = e.pageYOffset;
        return { scrollLeft: n, scrollTop: r };
      }
      function Be(t) {
        return ee(I$1(t)).left + We(t).scrollLeft;
      }
      function Ft(t) {
        var e = H(t), n = I$1(t), r = e.visualViewport, o2 = n.clientWidth, i = n.clientHeight, a2 = 0, s2 = 0;
        return r && (o2 = r.width, i = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a2 = r.offsetLeft, s2 = r.offsetTop)), { width: o2, height: i, x: a2 + Be(t), y: s2 };
      }
      function Ut(t) {
        var e, n = I$1(t), r = We(t), o2 = (e = t.ownerDocument) == null ? void 0 : e.body, i = X$1(n.scrollWidth, n.clientWidth, o2 ? o2.scrollWidth : 0, o2 ? o2.clientWidth : 0), a2 = X$1(n.scrollHeight, n.clientHeight, o2 ? o2.scrollHeight : 0, o2 ? o2.clientHeight : 0), s2 = -r.scrollLeft + Be(t), f2 = -r.scrollTop;
        return N$1(o2 || n).direction === "rtl" && (s2 += X$1(n.clientWidth, o2 ? o2.clientWidth : 0) - i), { width: i, height: a2, x: s2, y: f2 };
      }
      function Se(t) {
        var e = N$1(t), n = e.overflow, r = e.overflowX, o2 = e.overflowY;
        return /auto|scroll|overlay|hidden/.test(n + o2 + r);
      }
      function dt(t) {
        return ["html", "body", "#document"].indexOf(C(t)) >= 0 ? t.ownerDocument.body : B(t) && Se(t) ? t : dt(ge(t));
      }
      function ce(t, e) {
        var n;
        e === void 0 && (e = []);
        var r = dt(t), o2 = r === ((n = t.ownerDocument) == null ? void 0 : n.body), i = H(r), a2 = o2 ? [i].concat(i.visualViewport || [], Se(r) ? r : []) : r, s2 = e.concat(a2);
        return o2 ? s2 : s2.concat(ce(ge(a2)));
      }
      function Te(t) {
        return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
      }
      function Xt(t) {
        var e = ee(t);
        return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
      }
      function ht(t, e) {
        return e === je ? Te(Ft(t)) : Q(e) ? Xt(e) : Te(Ut(I$1(t)));
      }
      function Yt(t) {
        var e = ce(ge(t)), n = ["absolute", "fixed"].indexOf(N$1(t).position) >= 0, r = n && B(t) ? se(t) : t;
        return Q(r) ? e.filter(function(o2) {
          return Q(o2) && it(o2, r) && C(o2) !== "body";
        }) : [];
      }
      function Gt(t, e, n) {
        var r = e === "clippingParents" ? Yt(t) : [].concat(e), o2 = [].concat(r, [n]), i = o2[0], a2 = o2.reduce(function(s2, f2) {
          var c2 = ht(t, f2);
          return s2.top = X$1(c2.top, s2.top), s2.right = ve(c2.right, s2.right), s2.bottom = ve(c2.bottom, s2.bottom), s2.left = X$1(c2.left, s2.left), s2;
        }, ht(t, i));
        return a2.width = a2.right - a2.left, a2.height = a2.bottom - a2.top, a2.x = a2.left, a2.y = a2.top, a2;
      }
      function mt(t) {
        var e = t.reference, n = t.element, r = t.placement, o2 = r ? q(r) : null, i = r ? te(r) : null, a2 = e.x + e.width / 2 - n.width / 2, s2 = e.y + e.height / 2 - n.height / 2, f2;
        switch (o2) {
          case E$1:
            f2 = { x: a2, y: e.y - n.height };
            break;
          case R:
            f2 = { x: a2, y: e.y + e.height };
            break;
          case W:
            f2 = { x: e.x + e.width, y: s2 };
            break;
          case P$1:
            f2 = { x: e.x - n.width, y: s2 };
            break;
          default:
            f2 = { x: e.x, y: e.y };
        }
        var c2 = o2 ? Le(o2) : null;
        if (c2 != null) {
          var u2 = c2 === "y" ? "height" : "width";
          switch (i) {
            case U$1:
              f2[c2] = f2[c2] - (e[u2] / 2 - n[u2] / 2);
              break;
            case J:
              f2[c2] = f2[c2] + (e[u2] / 2 - n[u2] / 2);
              break;
          }
        }
        return f2;
      }
      function ne(t, e) {
        e === void 0 && (e = {});
        var n = e, r = n.placement, o2 = r === void 0 ? t.placement : r, i = n.boundary, a2 = i === void 0 ? Xe : i, s2 = n.rootBoundary, f2 = s2 === void 0 ? je : s2, c2 = n.elementContext, u2 = c2 === void 0 ? K : c2, m2 = n.altBoundary, v2 = m2 === void 0 ? false : m2, l2 = n.padding, h2 = l2 === void 0 ? 0 : l2, p2 = ft(typeof h2 != "number" ? h2 : ct(h2, G)), g = u2 === K ? Ye : K, x2 = t.rects.popper, y = t.elements[v2 ? g : u2], $ = Gt(Q(y) ? y : y.contextElement || I$1(t.elements.popper), a2, f2), d2 = ee(t.elements.reference), b2 = mt({ reference: d2, element: x2, strategy: "absolute", placement: o2 }), w2 = Te(Object.assign({}, x2, b2)), O2 = u2 === K ? w2 : d2, j = { top: $.top - O2.top + p2.top, bottom: O2.bottom - $.bottom + p2.bottom, left: $.left - O2.left + p2.left, right: O2.right - $.right + p2.right }, A2 = t.modifiersData.offset;
        if (u2 === K && A2) {
          var k = A2[o2];
          Object.keys(j).forEach(function(D2) {
            var S2 = [W, R].indexOf(D2) >= 0 ? 1 : -1, L = [E$1, R].indexOf(D2) >= 0 ? "y" : "x";
            j[D2] += k[L] * S2;
          });
        }
        return j;
      }
      function Jt(t, e) {
        e === void 0 && (e = {});
        var n = e, r = n.placement, o2 = n.boundary, i = n.rootBoundary, a2 = n.padding, s2 = n.flipVariations, f2 = n.allowedAutoPlacements, c2 = f2 === void 0 ? Ee : f2, u2 = te(r), m2 = u2 ? s2 ? De : De.filter(function(h2) {
          return te(h2) === u2;
        }) : G, v2 = m2.filter(function(h2) {
          return c2.indexOf(h2) >= 0;
        });
        v2.length === 0 && (v2 = m2);
        var l2 = v2.reduce(function(h2, p2) {
          return h2[p2] = ne(t, { placement: p2, boundary: o2, rootBoundary: i, padding: a2 })[q(p2)], h2;
        }, {});
        return Object.keys(l2).sort(function(h2, p2) {
          return l2[h2] - l2[p2];
        });
      }
      function Kt(t) {
        if (q(t) === me)
          return [];
        var e = be(t);
        return [lt(t), e, lt(e)];
      }
      function Qt(t) {
        var e = t.state, n = t.options, r = t.name;
        if (!e.modifiersData[r]._skip) {
          for (var o2 = n.mainAxis, i = o2 === void 0 ? true : o2, a2 = n.altAxis, s2 = a2 === void 0 ? true : a2, f2 = n.fallbackPlacements, c2 = n.padding, u2 = n.boundary, m2 = n.rootBoundary, v2 = n.altBoundary, l2 = n.flipVariations, h2 = l2 === void 0 ? true : l2, p2 = n.allowedAutoPlacements, g = e.options.placement, x2 = q(g), y = x2 === g, $ = f2 || (y || !h2 ? [be(g)] : Kt(g)), d2 = [g].concat($).reduce(function(z, V) {
            return z.concat(q(V) === me ? Jt(e, { placement: V, boundary: u2, rootBoundary: m2, padding: c2, flipVariations: h2, allowedAutoPlacements: p2 }) : V);
          }, []), b2 = e.rects.reference, w2 = e.rects.popper, O2 = /* @__PURE__ */ new Map(), j = true, A2 = d2[0], k = 0; k < d2.length; k++) {
            var D2 = d2[k], S2 = q(D2), L = te(D2) === U$1, re = [E$1, R].indexOf(S2) >= 0, oe = re ? "width" : "height", M2 = ne(e, { placement: D2, boundary: u2, rootBoundary: m2, altBoundary: v2, padding: c2 }), T2 = re ? L ? W : P$1 : L ? R : E$1;
            b2[oe] > w2[oe] && (T2 = be(T2));
            var pe = be(T2), _2 = [];
            if (i && _2.push(M2[S2] <= 0), s2 && _2.push(M2[T2] <= 0, M2[pe] <= 0), _2.every(function(z) {
              return z;
            })) {
              A2 = D2, j = false;
              break;
            }
            O2.set(D2, _2);
          }
          if (j)
            for (var ue = h2 ? 3 : 1, xe = function(z) {
              var V = d2.find(function(de) {
                var ae = O2.get(de);
                if (ae)
                  return ae.slice(0, z).every(function(Y2) {
                    return Y2;
                  });
              });
              if (V)
                return A2 = V, "break";
            }, ie = ue; ie > 0; ie--) {
              var le = xe(ie);
              if (le === "break")
                break;
            }
          e.placement !== A2 && (e.modifiersData[r]._skip = true, e.placement = A2, e.reset = true);
        }
      }
      var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
      function gt(t, e, n) {
        return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x };
      }
      function yt(t) {
        return [E$1, W, R, P$1].some(function(e) {
          return t[e] >= 0;
        });
      }
      function Zt(t) {
        var e = t.state, n = t.name, r = e.rects.reference, o2 = e.rects.popper, i = e.modifiersData.preventOverflow, a2 = ne(e, { elementContext: "reference" }), s2 = ne(e, { altBoundary: true }), f2 = gt(a2, r), c2 = gt(s2, o2, i), u2 = yt(f2), m2 = yt(c2);
        e.modifiersData[n] = { referenceClippingOffsets: f2, popperEscapeOffsets: c2, isReferenceHidden: u2, hasPopperEscaped: m2 }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u2, "data-popper-escaped": m2 });
      }
      var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
      function en(t, e, n) {
        var r = q(t), o2 = [P$1, E$1].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, a2 = i[0], s2 = i[1];
        return a2 = a2 || 0, s2 = (s2 || 0) * o2, [P$1, W].indexOf(r) >= 0 ? { x: s2, y: a2 } : { x: a2, y: s2 };
      }
      function tn(t) {
        var e = t.state, n = t.options, r = t.name, o2 = n.offset, i = o2 === void 0 ? [0, 0] : o2, a2 = Ee.reduce(function(u2, m2) {
          return u2[m2] = en(m2, e.rects, i), u2;
        }, {}), s2 = a2[e.placement], f2 = s2.x, c2 = s2.y;
        e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += f2, e.modifiersData.popperOffsets.y += c2), e.modifiersData[r] = a2;
      }
      var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
      function nn(t) {
        var e = t.state, n = t.name;
        e.modifiersData[n] = mt({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
      }
      var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
      function rn(t) {
        return t === "x" ? "y" : "x";
      }
      function on(t) {
        var e = t.state, n = t.options, r = t.name, o2 = n.mainAxis, i = o2 === void 0 ? true : o2, a2 = n.altAxis, s2 = a2 === void 0 ? false : a2, f2 = n.boundary, c2 = n.rootBoundary, u2 = n.altBoundary, m2 = n.padding, v2 = n.tether, l2 = v2 === void 0 ? true : v2, h2 = n.tetherOffset, p2 = h2 === void 0 ? 0 : h2, g = ne(e, { boundary: f2, rootBoundary: c2, padding: m2, altBoundary: u2 }), x2 = q(e.placement), y = te(e.placement), $ = !y, d2 = Le(x2), b2 = rn(d2), w2 = e.modifiersData.popperOffsets, O2 = e.rects.reference, j = e.rects.popper, A2 = typeof p2 == "function" ? p2(Object.assign({}, e.rects, { placement: e.placement })) : p2, k = typeof A2 == "number" ? { mainAxis: A2, altAxis: A2 } : Object.assign({ mainAxis: 0, altAxis: 0 }, A2), D2 = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, S2 = { x: 0, y: 0 };
        if (w2) {
          if (i) {
            var L, re = d2 === "y" ? E$1 : P$1, oe = d2 === "y" ? R : W, M2 = d2 === "y" ? "height" : "width", T2 = w2[d2], pe = T2 + g[re], _2 = T2 - g[oe], ue = l2 ? -j[M2] / 2 : 0, xe = y === U$1 ? O2[M2] : j[M2], ie = y === U$1 ? -j[M2] : -O2[M2], le = e.elements.arrow, z = l2 && le ? ke(le) : { width: 0, height: 0 }, V = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : st(), de = V[re], ae = V[oe], Y2 = fe(0, O2[M2], z[M2]), jt = $ ? O2[M2] / 2 - ue - Y2 - de - k.mainAxis : xe - Y2 - de - k.mainAxis, Dt = $ ? -O2[M2] / 2 + ue + Y2 + ae + k.mainAxis : ie + Y2 + ae + k.mainAxis, Oe = e.elements.arrow && se(e.elements.arrow), Et = Oe ? d2 === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L = D2 == null ? void 0 : D2[d2]) != null ? L : 0, Pt = T2 + jt - Ce - Et, At = T2 + Dt - Ce, qe = fe(l2 ? ve(pe, Pt) : pe, T2, l2 ? X$1(_2, At) : _2);
            w2[d2] = qe, S2[d2] = qe - T2;
          }
          if (s2) {
            var Ve, kt = d2 === "x" ? E$1 : P$1, Lt = d2 === "x" ? R : W, F2 = w2[b2], he = b2 === "y" ? "height" : "width", Ne = F2 + g[kt], Ie = F2 - g[Lt], $e = [E$1, P$1].indexOf(x2) !== -1, _e = (Ve = D2 == null ? void 0 : D2[b2]) != null ? Ve : 0, ze = $e ? Ne : F2 - O2[he] - j[he] - _e + k.altAxis, Fe = $e ? F2 + O2[he] + j[he] - _e - k.altAxis : Ie, Ue = l2 && $e ? St(ze, F2, Fe) : fe(l2 ? ze : Ne, F2, l2 ? Fe : Ie);
            w2[b2] = Ue, S2[b2] = Ue - F2;
          }
          e.modifiersData[r] = S2;
        }
      }
      var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
      function an(t) {
        return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
      }
      function sn(t) {
        return t === H(t) || !B(t) ? We(t) : an(t);
      }
      function fn(t) {
        var e = t.getBoundingClientRect(), n = Z(e.width) / t.offsetWidth || 1, r = Z(e.height) / t.offsetHeight || 1;
        return n !== 1 || r !== 1;
      }
      function cn(t, e, n) {
        n === void 0 && (n = false);
        var r = B(e), o2 = B(e) && fn(e), i = I$1(e), a2 = ee(t, o2), s2 = { scrollLeft: 0, scrollTop: 0 }, f2 = { x: 0, y: 0 };
        return (r || !r && !n) && ((C(e) !== "body" || Se(i)) && (s2 = sn(e)), B(e) ? (f2 = ee(e, true), f2.x += e.clientLeft, f2.y += e.clientTop) : i && (f2.x = Be(i))), { x: a2.left + s2.scrollLeft - f2.x, y: a2.top + s2.scrollTop - f2.y, width: a2.width, height: a2.height };
      }
      function pn(t) {
        var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
        t.forEach(function(i) {
          e.set(i.name, i);
        });
        function o2(i) {
          n.add(i.name);
          var a2 = [].concat(i.requires || [], i.requiresIfExists || []);
          a2.forEach(function(s2) {
            if (!n.has(s2)) {
              var f2 = e.get(s2);
              f2 && o2(f2);
            }
          }), r.push(i);
        }
        return t.forEach(function(i) {
          n.has(i.name) || o2(i);
        }), r;
      }
      function un(t) {
        var e = pn(t);
        return ot.reduce(function(n, r) {
          return n.concat(e.filter(function(o2) {
            return o2.phase === r;
          }));
        }, []);
      }
      function ln(t) {
        var e;
        return function() {
          return e || (e = new Promise(function(n) {
            Promise.resolve().then(function() {
              e = void 0, n(t());
            });
          })), e;
        };
      }
      function dn(t) {
        var e = t.reduce(function(n, r) {
          var o2 = n[r.name];
          return n[r.name] = o2 ? Object.assign({}, o2, r, { options: Object.assign({}, o2.options, r.options), data: Object.assign({}, o2.data, r.data) }) : r, n;
        }, {});
        return Object.keys(e).map(function(n) {
          return e[n];
        });
      }
      var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
      function $t() {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        return !e.some(function(r) {
          return !(r && typeof r.getBoundingClientRect == "function");
        });
      }
      function we(t) {
        t === void 0 && (t = {});
        var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, o2 = e.defaultOptions, i = o2 === void 0 ? Ot : o2;
        return function(a2, s2, f2) {
          f2 === void 0 && (f2 = i);
          var c2 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i), modifiersData: {}, elements: { reference: a2, popper: s2 }, attributes: {}, styles: {} }, u2 = [], m2 = false, v2 = { state: c2, setOptions: function(p2) {
            var g = typeof p2 == "function" ? p2(c2.options) : p2;
            h2(), c2.options = Object.assign({}, i, c2.options, g), c2.scrollParents = { reference: Q(a2) ? ce(a2) : a2.contextElement ? ce(a2.contextElement) : [], popper: ce(s2) };
            var x2 = un(dn([].concat(r, c2.options.modifiers)));
            return c2.orderedModifiers = x2.filter(function(y) {
              return y.enabled;
            }), l2(), v2.update();
          }, forceUpdate: function() {
            if (!m2) {
              var p2 = c2.elements, g = p2.reference, x2 = p2.popper;
              if ($t(g, x2)) {
                c2.rects = { reference: cn(g, se(x2), c2.options.strategy === "fixed"), popper: ke(x2) }, c2.reset = false, c2.placement = c2.options.placement, c2.orderedModifiers.forEach(function(j) {
                  return c2.modifiersData[j.name] = Object.assign({}, j.data);
                });
                for (var y = 0; y < c2.orderedModifiers.length; y++) {
                  if (c2.reset === true) {
                    c2.reset = false, y = -1;
                    continue;
                  }
                  var $ = c2.orderedModifiers[y], d2 = $.fn, b2 = $.options, w2 = b2 === void 0 ? {} : b2, O2 = $.name;
                  typeof d2 == "function" && (c2 = d2({ state: c2, options: w2, name: O2, instance: v2 }) || c2);
                }
              }
            }
          }, update: ln(function() {
            return new Promise(function(p2) {
              v2.forceUpdate(), p2(c2);
            });
          }), destroy: function() {
            h2(), m2 = true;
          } };
          if (!$t(a2, s2))
            return v2;
          v2.setOptions(f2).then(function(p2) {
            !m2 && f2.onFirstUpdate && f2.onFirstUpdate(p2);
          });
          function l2() {
            c2.orderedModifiers.forEach(function(p2) {
              var g = p2.name, x2 = p2.options, y = x2 === void 0 ? {} : x2, $ = p2.effect;
              if (typeof $ == "function") {
                var d2 = $({ state: c2, name: g, instance: v2, options: y }), b2 = function() {
                };
                u2.push(d2 || b2);
              }
            });
          }
          function h2() {
            u2.forEach(function(p2) {
              return p2();
            }), u2 = [];
          }
          return v2;
        };
      }
      we();
      var mn = [Re, He, Me, Ae];
      we({ defaultModifiers: mn });
      var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt], yn = we({ defaultModifiers: gn });
      const usePopper = exports("usePopper", (referenceElementRef, popperElementRef, opts = {}) => {
        const stateUpdater = {
          name: "updateState",
          enabled: true,
          phase: "write",
          fn: ({ state }) => {
            const derivedState = deriveState(state);
            Object.assign(states.value, derivedState);
          },
          requires: ["computeStyles"]
        };
        const options = computed(() => {
          const { onFirstUpdate, placement, strategy, modifiers } = unref(opts);
          return {
            onFirstUpdate,
            placement: placement || "bottom",
            strategy: strategy || "absolute",
            modifiers: [
              ...modifiers || [],
              stateUpdater,
              { name: "applyStyles", enabled: false }
            ]
          };
        });
        const instanceRef = shallowRef();
        const states = ref({
          styles: {
            popper: {
              position: unref(options).strategy,
              left: "0",
              top: "0"
            },
            arrow: {
              position: "absolute"
            }
          },
          attributes: {}
        });
        const destroy = () => {
          if (!instanceRef.value)
            return;
          instanceRef.value.destroy();
          instanceRef.value = void 0;
        };
        watch(options, (newOptions) => {
          const instance = unref(instanceRef);
          if (instance) {
            instance.setOptions(newOptions);
          }
        }, {
          deep: true
        });
        watch([referenceElementRef, popperElementRef], ([referenceElement, popperElement]) => {
          destroy();
          if (!referenceElement || !popperElement)
            return;
          instanceRef.value = yn(referenceElement, popperElement, unref(options));
        });
        onBeforeUnmount(() => {
          destroy();
        });
        return {
          state: computed(() => {
            var _a;
            return { ...((_a = unref(instanceRef)) == null ? void 0 : _a.state) || {} };
          }),
          styles: computed(() => unref(states).styles),
          attributes: computed(() => unref(states).attributes),
          update: () => {
            var _a;
            return (_a = unref(instanceRef)) == null ? void 0 : _a.update();
          },
          forceUpdate: () => {
            var _a;
            return (_a = unref(instanceRef)) == null ? void 0 : _a.forceUpdate();
          },
          instanceRef: computed(() => unref(instanceRef))
        };
      });
      function deriveState(state) {
        const elements = Object.keys(state.elements);
        const styles = fromPairs(elements.map((element) => [element, state.styles[element] || {}]));
        const attributes2 = fromPairs(elements.map((element) => [element, state.attributes[element]]));
        return {
          styles,
          attributes: attributes2
        };
      }
      const useSameTarget = exports("useSameTarget", (handleClick) => {
        if (!handleClick) {
          return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
        }
        let mousedownTarget = false;
        let mouseupTarget = false;
        const onClick = (e) => {
          if (mousedownTarget && mouseupTarget) {
            handleClick(e);
          }
          mousedownTarget = mouseupTarget = false;
        };
        const onMousedown = (e) => {
          mousedownTarget = e.target === e.currentTarget;
        };
        const onMouseup = (e) => {
          mouseupTarget = e.target === e.currentTarget;
        };
        return { onClick, onMousedown, onMouseup };
      });
      const useTeleport = exports("useTeleport", (contentRenderer, appendToBody) => {
        const isTeleportVisible = ref(false);
        if (!isClient) {
          return {
            isTeleportVisible,
            showTeleport: NOOP,
            hideTeleport: NOOP,
            renderTeleport: NOOP
          };
        }
        let $el = null;
        const showTeleport = () => {
          isTeleportVisible.value = true;
          if ($el !== null)
            return;
          $el = createGlobalNode();
        };
        const hideTeleport = () => {
          isTeleportVisible.value = false;
          if ($el !== null) {
            removeGlobalNode($el);
            $el = null;
          }
        };
        const renderTeleport = () => {
          return appendToBody.value !== true ? contentRenderer() : isTeleportVisible.value ? [h$1(Teleport$1, { to: $el }, contentRenderer())] : void 0;
        };
        onUnmounted(hideTeleport);
        return {
          isTeleportVisible,
          showTeleport,
          hideTeleport,
          renderTeleport
        };
      });
      const useThrottleRender = exports("useThrottleRender", (loading, throttle2 = 0) => {
        if (throttle2 === 0)
          return loading;
        const initVal = isObject$1(throttle2) && Boolean(throttle2.initVal);
        const throttled = ref(initVal);
        let timeoutHandle = null;
        const dispatchThrottling = (timer) => {
          if (isUndefined(timer)) {
            throttled.value = loading.value;
            return;
          }
          if (timeoutHandle) {
            clearTimeout(timeoutHandle);
          }
          timeoutHandle = setTimeout(() => {
            throttled.value = loading.value;
          }, timer);
        };
        const dispatcher = (type) => {
          if (type === "leading") {
            if (isNumber(throttle2)) {
              dispatchThrottling(throttle2);
            } else {
              dispatchThrottling(throttle2.leading);
            }
          } else {
            if (isObject$1(throttle2)) {
              dispatchThrottling(throttle2.trailing);
            } else {
              throttled.value = false;
            }
          }
        };
        onMounted(() => dispatcher("leading"));
        watch(() => loading.value, (val) => {
          dispatcher(val ? "leading" : "trailing");
        });
        return throttled;
      });
      function useTimeout() {
        let timeoutHandle;
        const registerTimeout = (fn2, delay2) => {
          cancelTimeout();
          timeoutHandle = window.setTimeout(fn2, delay2);
        };
        const cancelTimeout = () => window.clearTimeout(timeoutHandle);
        tryOnScopeDispose(() => cancelTimeout());
        return {
          registerTimeout,
          cancelTimeout
        };
      }
      const AFTER_APPEAR = "after-appear";
      const AFTER_ENTER = "after-enter";
      const AFTER_LEAVE = "after-leave";
      const APPEAR = "appear";
      const APPEAR_CANCELLED = "appear-cancelled";
      const BEFORE_ENTER = "before-enter";
      const BEFORE_LEAVE = "before-leave";
      const ENTER = "enter";
      const ENTER_CANCELLED = "enter-cancelled";
      const LEAVE = "leave";
      const LEAVE_CANCELLED = "leave-cancelled";
      const useTransitionFallthroughEmits = exports("useTransitionFallthroughEmits", [
        AFTER_APPEAR,
        AFTER_ENTER,
        AFTER_LEAVE,
        APPEAR,
        APPEAR_CANCELLED,
        BEFORE_ENTER,
        BEFORE_LEAVE,
        ENTER,
        ENTER_CANCELLED,
        LEAVE,
        LEAVE_CANCELLED
      ]);
      const useTransitionFallthrough = exports("useTransitionFallthrough", () => {
        const { emit } = getCurrentInstance();
        return {
          onAfterAppear: () => {
            emit(AFTER_APPEAR);
          },
          onAfterEnter: () => {
            emit(AFTER_ENTER);
          },
          onAfterLeave: () => {
            emit(AFTER_LEAVE);
          },
          onAppearCancelled: () => {
            emit(APPEAR_CANCELLED);
          },
          onBeforeEnter: () => {
            emit(BEFORE_ENTER);
          },
          onBeforeLeave: () => {
            emit(BEFORE_LEAVE);
          },
          onEnter: () => {
            emit(ENTER);
          },
          onEnterCancelled: () => {
            emit(ENTER_CANCELLED);
          },
          onLeave: () => {
            emit(LEAVE);
          },
          onLeaveCancelled: () => {
            emit(LEAVE_CANCELLED);
          }
        };
      });
      const defaultIdInjection = {
        prefix: Math.floor(Math.random() * 1e4),
        current: 0
      };
      const ID_INJECTION_KEY = exports("ID_INJECTION_KEY", Symbol("elIdInjection"));
      const useIdInjection = exports("useIdInjection", () => {
        return getCurrentInstance() ? inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
      });
      const useId = exports("useId", (deterministicId) => {
        const idInjection = useIdInjection();
        const namespace = useGetDerivedNamespace();
        const idRef = computedEager(() => unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
        return idRef;
      });
      let registeredEscapeHandlers = [];
      const cachedHandler = (event) => {
        if (event.code === EVENT_CODE.esc) {
          registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
        }
      };
      const useEscapeKeydown = exports("useEscapeKeydown", (handler) => {
        onMounted(() => {
          if (registeredEscapeHandlers.length === 0) {
            document.addEventListener("keydown", cachedHandler);
          }
          if (isClient)
            registeredEscapeHandlers.push(handler);
        });
        onBeforeUnmount(() => {
          registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
          if (registeredEscapeHandlers.length === 0) {
            if (isClient)
              document.removeEventListener("keydown", cachedHandler);
          }
        });
      });
      const usePopperContainerId = exports("usePopperContainerId", () => {
        const namespace = useGetDerivedNamespace();
        const idInjection = useIdInjection();
        const id = computed(() => {
          return `${namespace.value}-popper-container-${idInjection.prefix}`;
        });
        const selector = computed(() => `#${id.value}`);
        return {
          id,
          selector
        };
      });
      const createContainer = (id) => {
        const container = document.createElement("div");
        container.id = id;
        document.body.appendChild(container);
        return container;
      };
      const usePopperContainer = exports("usePopperContainer", () => {
        const { id, selector } = usePopperContainerId();
        onBeforeMount(() => {
          if (!isClient)
            return;
          if (!document.body.querySelector(selector.value)) {
            createContainer(id.value);
          }
        });
        return {
          id,
          selector
        };
      });
      const useDelayedRender = exports("useDelayedRender", ({
        indicator,
        intermediateIndicator,
        shouldSetIntermediate = () => true,
        beforeShow,
        afterShow,
        afterHide,
        beforeHide
      }) => {
        watch(() => unref(indicator), (val) => {
          if (val) {
            beforeShow == null ? void 0 : beforeShow();
            nextTick(() => {
              if (!unref(indicator))
                return;
              if (shouldSetIntermediate("show")) {
                intermediateIndicator.value = true;
              }
            });
          } else {
            beforeHide == null ? void 0 : beforeHide();
            nextTick(() => {
              if (unref(indicator))
                return;
              if (shouldSetIntermediate("hide")) {
                intermediateIndicator.value = false;
              }
            });
          }
        });
        watch(() => intermediateIndicator.value, (val) => {
          if (val) {
            afterShow == null ? void 0 : afterShow();
          } else {
            afterHide == null ? void 0 : afterHide();
          }
        });
      });
      const useDelayedToggleProps = exports("useDelayedToggleProps", buildProps({
        showAfter: {
          type: Number,
          default: 0
        },
        hideAfter: {
          type: Number,
          default: 200
        },
        autoClose: {
          type: Number,
          default: 0
        }
      }));
      const useDelayedToggle = exports("useDelayedToggle", ({
        showAfter,
        hideAfter,
        autoClose,
        open,
        close: close2
      }) => {
        const { registerTimeout } = useTimeout();
        const {
          registerTimeout: registerTimeoutForAutoClose,
          cancelTimeout: cancelTimeoutForAutoClose
        } = useTimeout();
        const onOpen = (event) => {
          registerTimeout(() => {
            open(event);
            const _autoClose = unref(autoClose);
            if (isNumber(_autoClose) && _autoClose > 0) {
              registerTimeoutForAutoClose(() => {
                close2(event);
              }, _autoClose);
            }
          }, unref(showAfter));
        };
        const onClose = (event) => {
          cancelTimeoutForAutoClose();
          registerTimeout(() => {
            close2(event);
          }, unref(hideAfter));
        };
        return {
          onOpen,
          onClose
        };
      });
      const FORWARD_REF_INJECTION_KEY = exports("FORWARD_REF_INJECTION_KEY", Symbol("elForwardRef"));
      const useForwardRef = exports("useForwardRef", (forwardRef) => {
        const setForwardRef = (el) => {
          forwardRef.value = el;
        };
        provide(FORWARD_REF_INJECTION_KEY, {
          setForwardRef
        });
      });
      const useForwardRefDirective = exports("useForwardRefDirective", (setForwardRef) => {
        return {
          mounted(el) {
            setForwardRef(el);
          },
          updated(el) {
            setForwardRef(el);
          },
          unmounted() {
            setForwardRef(null);
          }
        };
      });
      const initial = {
        current: 0
      };
      const zIndex = ref(0);
      const defaultInitialZIndex = exports("defaultInitialZIndex", 2e3);
      const ZINDEX_INJECTION_KEY = exports("ZINDEX_INJECTION_KEY", Symbol("elZIndexContextKey"));
      const zIndexContextKey = exports("zIndexContextKey", Symbol("zIndexContextKey"));
      const useZIndex = exports("useZIndex", (zIndexOverrides) => {
        const increasingInjection = getCurrentInstance() ? inject(ZINDEX_INJECTION_KEY, initial) : initial;
        const zIndexInjection = zIndexOverrides || (getCurrentInstance() ? inject(zIndexContextKey, void 0) : void 0);
        const initialZIndex = computed(() => {
          const zIndexFromInjection = unref(zIndexInjection);
          return isNumber(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
        });
        const currentZIndex = computed(() => initialZIndex.value + zIndex.value);
        const nextZIndex = () => {
          increasingInjection.current++;
          zIndex.value = increasingInjection.current;
          return currentZIndex.value;
        };
        if (!isClient && !inject(ZINDEX_INJECTION_KEY))
          ;
        return {
          initialZIndex,
          currentZIndex,
          nextZIndex
        };
      });
      const min$3 = Math.min;
      const max$3 = Math.max;
      const round$1 = Math.round;
      const createCoords = (v2) => ({
        x: v2,
        y: v2
      });
      function clamp(start, value, end) {
        return max$3(start, min$3(value, end));
      }
      function evaluate(value, param) {
        return typeof value === "function" ? value(param) : value;
      }
      function getSide$1(placement) {
        return placement.split("-")[0];
      }
      function getAlignment$1(placement) {
        return placement.split("-")[1];
      }
      function getOppositeAxis(axis) {
        return axis === "x" ? "y" : "x";
      }
      function getAxisLength(axis) {
        return axis === "y" ? "height" : "width";
      }
      function getSideAxis(placement) {
        return ["top", "bottom"].includes(getSide$1(placement)) ? "y" : "x";
      }
      function getAlignmentAxis(placement) {
        return getOppositeAxis(getSideAxis(placement));
      }
      function expandPaddingObject$1(padding) {
        return {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0,
          ...padding
        };
      }
      function getPaddingObject(padding) {
        return typeof padding !== "number" ? expandPaddingObject$1(padding) : {
          top: padding,
          right: padding,
          bottom: padding,
          left: padding
        };
      }
      function rectToClientRect$1(rect) {
        const {
          x: x2,
          y,
          width,
          height
        } = rect;
        return {
          width,
          height,
          top: y,
          left: x2,
          right: x2 + width,
          bottom: y + height,
          x: x2,
          y
        };
      }
      function computeCoordsFromPlacement$1(_ref, placement, rtl) {
        let {
          reference,
          floating
        } = _ref;
        const sideAxis = getSideAxis(placement);
        const alignmentAxis = getAlignmentAxis(placement);
        const alignLength = getAxisLength(alignmentAxis);
        const side = getSide$1(placement);
        const isVertical = sideAxis === "y";
        const commonX = reference.x + reference.width / 2 - floating.width / 2;
        const commonY = reference.y + reference.height / 2 - floating.height / 2;
        const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
        let coords;
        switch (side) {
          case "top":
            coords = {
              x: commonX,
              y: reference.y - floating.height
            };
            break;
          case "bottom":
            coords = {
              x: commonX,
              y: reference.y + reference.height
            };
            break;
          case "right":
            coords = {
              x: reference.x + reference.width,
              y: commonY
            };
            break;
          case "left":
            coords = {
              x: reference.x - floating.width,
              y: commonY
            };
            break;
          default:
            coords = {
              x: reference.x,
              y: reference.y
            };
        }
        switch (getAlignment$1(placement)) {
          case "start":
            coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
            break;
          case "end":
            coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
            break;
        }
        return coords;
      }
      const computePosition$3 = async (reference, floating, config) => {
        const {
          placement = "bottom",
          strategy = "absolute",
          middleware = [],
          platform: platform2
        } = config;
        const validMiddleware = middleware.filter(Boolean);
        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
        let rects = await platform2.getElementRects({
          reference,
          floating,
          strategy
        });
        let {
          x: x2,
          y
        } = computeCoordsFromPlacement$1(rects, placement, rtl);
        let statefulPlacement = placement;
        let middlewareData = {};
        let resetCount = 0;
        for (let i = 0; i < validMiddleware.length; i++) {
          const {
            name,
            fn: fn2
          } = validMiddleware[i];
          const {
            x: nextX,
            y: nextY,
            data,
            reset
          } = await fn2({
            x: x2,
            y,
            initialPlacement: placement,
            placement: statefulPlacement,
            strategy,
            middlewareData,
            rects,
            platform: platform2,
            elements: {
              reference,
              floating
            }
          });
          x2 = nextX != null ? nextX : x2;
          y = nextY != null ? nextY : y;
          middlewareData = {
            ...middlewareData,
            [name]: {
              ...middlewareData[name],
              ...data
            }
          };
          if (reset && resetCount <= 50) {
            resetCount++;
            if (typeof reset === "object") {
              if (reset.placement) {
                statefulPlacement = reset.placement;
              }
              if (reset.rects) {
                rects = reset.rects === true ? await platform2.getElementRects({
                  reference,
                  floating,
                  strategy
                }) : reset.rects;
              }
              ({
                x: x2,
                y
              } = computeCoordsFromPlacement$1(rects, statefulPlacement, rtl));
            }
            i = -1;
          }
        }
        return {
          x: x2,
          y,
          placement: statefulPlacement,
          strategy,
          middlewareData
        };
      };
      const arrow$2 = (options) => ({
        name: "arrow",
        options,
        async fn(state) {
          const {
            x: x2,
            y,
            placement,
            rects,
            platform: platform2,
            elements,
            middlewareData
          } = state;
          const {
            element,
            padding = 0
          } = evaluate(options, state) || {};
          if (element == null) {
            return {};
          }
          const paddingObject = getPaddingObject(padding);
          const coords = {
            x: x2,
            y
          };
          const axis = getAlignmentAxis(placement);
          const length = getAxisLength(axis);
          const arrowDimensions = await platform2.getDimensions(element);
          const isYAxis = axis === "y";
          const minProp = isYAxis ? "top" : "left";
          const maxProp = isYAxis ? "bottom" : "right";
          const clientProp = isYAxis ? "clientHeight" : "clientWidth";
          const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
          const startDiff = coords[axis] - rects.reference[axis];
          const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
          let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
          if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
            clientSize = elements.floating[clientProp] || rects.floating[length];
          }
          const centerToReference = endDiff / 2 - startDiff / 2;
          const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
          const minPadding = min$3(paddingObject[minProp], largestPossiblePadding);
          const maxPadding = min$3(paddingObject[maxProp], largestPossiblePadding);
          const min$12 = minPadding;
          const max2 = clientSize - arrowDimensions[length] - maxPadding;
          const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
          const offset2 = clamp(min$12, center, max2);
          const shouldAddOffset = !middlewareData.arrow && getAlignment$1(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$12 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
          const alignmentOffset = shouldAddOffset ? center < min$12 ? center - min$12 : center - max2 : 0;
          return {
            [axis]: coords[axis] + alignmentOffset,
            data: {
              [axis]: offset2,
              centerOffset: center - offset2 - alignmentOffset,
              ...shouldAddOffset && {
                alignmentOffset
              }
            },
            reset: shouldAddOffset
          };
        }
      });
      function getNodeName$1(node) {
        if (isNode$1(node)) {
          return (node.nodeName || "").toLowerCase();
        }
        return "#document";
      }
      function getWindow$1(node) {
        var _node$ownerDocument;
        return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
      }
      function getDocumentElement$1(node) {
        var _ref;
        return (_ref = (isNode$1(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
      }
      function isNode$1(value) {
        return value instanceof Node || value instanceof getWindow$1(value).Node;
      }
      function isElement$1(value) {
        return value instanceof Element || value instanceof getWindow$1(value).Element;
      }
      function isHTMLElement$1(value) {
        return value instanceof HTMLElement || value instanceof getWindow$1(value).HTMLElement;
      }
      function isShadowRoot$1(value) {
        if (typeof ShadowRoot === "undefined") {
          return false;
        }
        return value instanceof ShadowRoot || value instanceof getWindow$1(value).ShadowRoot;
      }
      function isOverflowElement$1(element) {
        const {
          overflow,
          overflowX,
          overflowY,
          display
        } = getComputedStyle$2(element);
        return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
      }
      function isTableElement$1(element) {
        return ["table", "td", "th"].includes(getNodeName$1(element));
      }
      function isTopLayer(element) {
        return [":popover-open", ":modal"].some((selector) => {
          try {
            return element.matches(selector);
          } catch (e) {
            return false;
          }
        });
      }
      function isContainingBlock$1(elementOrCss) {
        const webkit = isWebKit();
        const css = isElement$1(elementOrCss) ? getComputedStyle$2(elementOrCss) : elementOrCss;
        return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
      }
      function getContainingBlock$1(element) {
        let currentNode = getParentNode$1(element);
        while (isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
          if (isContainingBlock$1(currentNode)) {
            return currentNode;
          } else if (isTopLayer(currentNode)) {
            return null;
          }
          currentNode = getParentNode$1(currentNode);
        }
        return null;
      }
      function isWebKit() {
        if (typeof CSS === "undefined" || !CSS.supports)
          return false;
        return CSS.supports("-webkit-backdrop-filter", "none");
      }
      function isLastTraversableNode(node) {
        return ["html", "body", "#document"].includes(getNodeName$1(node));
      }
      function getComputedStyle$2(element) {
        return getWindow$1(element).getComputedStyle(element);
      }
      function getNodeScroll$1(element) {
        if (isElement$1(element)) {
          return {
            scrollLeft: element.scrollLeft,
            scrollTop: element.scrollTop
          };
        }
        return {
          scrollLeft: element.scrollX,
          scrollTop: element.scrollY
        };
      }
      function getParentNode$1(node) {
        if (getNodeName$1(node) === "html") {
          return node;
        }
        const result2 = (
          // Step into the shadow DOM of the parent of a slotted node.
          node.assignedSlot || // DOM Element detected.
          node.parentNode || // ShadowRoot detected.
          isShadowRoot$1(node) && node.host || // Fallback.
          getDocumentElement$1(node)
        );
        return isShadowRoot$1(result2) ? result2.host : result2;
      }
      function getNearestOverflowAncestor$1(node) {
        const parentNode = getParentNode$1(node);
        if (isLastTraversableNode(parentNode)) {
          return node.ownerDocument ? node.ownerDocument.body : node.body;
        }
        if (isHTMLElement$1(parentNode) && isOverflowElement$1(parentNode)) {
          return parentNode;
        }
        return getNearestOverflowAncestor$1(parentNode);
      }
      function getOverflowAncestors$1(node, list, traverseIframes) {
        var _node$ownerDocument2;
        if (list === void 0) {
          list = [];
        }
        if (traverseIframes === void 0) {
          traverseIframes = true;
        }
        const scrollableAncestor = getNearestOverflowAncestor$1(node);
        const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
        const win = getWindow$1(scrollableAncestor);
        if (isBody) {
          return list.concat(win, win.visualViewport || [], isOverflowElement$1(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors$1(win.frameElement) : []);
        }
        return list.concat(scrollableAncestor, getOverflowAncestors$1(scrollableAncestor, [], traverseIframes));
      }
      function getCssDimensions(element) {
        const css = getComputedStyle$2(element);
        let width = parseFloat(css.width) || 0;
        let height = parseFloat(css.height) || 0;
        const hasOffset = isHTMLElement$1(element);
        const offsetWidth = hasOffset ? element.offsetWidth : width;
        const offsetHeight = hasOffset ? element.offsetHeight : height;
        const shouldFallback = round$1(width) !== offsetWidth || round$1(height) !== offsetHeight;
        if (shouldFallback) {
          width = offsetWidth;
          height = offsetHeight;
        }
        return {
          width,
          height,
          $: shouldFallback
        };
      }
      function unwrapElement(element) {
        return !isElement$1(element) ? element.contextElement : element;
      }
      function getScale(element) {
        const domElement = unwrapElement(element);
        if (!isHTMLElement$1(domElement)) {
          return createCoords(1);
        }
        const rect = domElement.getBoundingClientRect();
        const {
          width,
          height,
          $
        } = getCssDimensions(domElement);
        let x2 = ($ ? round$1(rect.width) : rect.width) / width;
        let y = ($ ? round$1(rect.height) : rect.height) / height;
        if (!x2 || !Number.isFinite(x2)) {
          x2 = 1;
        }
        if (!y || !Number.isFinite(y)) {
          y = 1;
        }
        return {
          x: x2,
          y
        };
      }
      const noOffsets = /* @__PURE__ */ createCoords(0);
      function getVisualOffsets(element) {
        const win = getWindow$1(element);
        if (!isWebKit() || !win.visualViewport) {
          return noOffsets;
        }
        return {
          x: win.visualViewport.offsetLeft,
          y: win.visualViewport.offsetTop
        };
      }
      function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
        if (isFixed === void 0) {
          isFixed = false;
        }
        if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow$1(element)) {
          return false;
        }
        return isFixed;
      }
      function getBoundingClientRect$1(element, includeScale, isFixedStrategy, offsetParent) {
        if (includeScale === void 0) {
          includeScale = false;
        }
        if (isFixedStrategy === void 0) {
          isFixedStrategy = false;
        }
        const clientRect = element.getBoundingClientRect();
        const domElement = unwrapElement(element);
        let scale = createCoords(1);
        if (includeScale) {
          if (offsetParent) {
            if (isElement$1(offsetParent)) {
              scale = getScale(offsetParent);
            }
          } else {
            scale = getScale(element);
          }
        }
        const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
        let x2 = (clientRect.left + visualOffsets.x) / scale.x;
        let y = (clientRect.top + visualOffsets.y) / scale.y;
        let width = clientRect.width / scale.x;
        let height = clientRect.height / scale.y;
        if (domElement) {
          const win = getWindow$1(domElement);
          const offsetWin = offsetParent && isElement$1(offsetParent) ? getWindow$1(offsetParent) : offsetParent;
          let currentWin = win;
          let currentIFrame = currentWin.frameElement;
          while (currentIFrame && offsetParent && offsetWin !== currentWin) {
            const iframeScale = getScale(currentIFrame);
            const iframeRect = currentIFrame.getBoundingClientRect();
            const css = getComputedStyle$2(currentIFrame);
            const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
            const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
            x2 *= iframeScale.x;
            y *= iframeScale.y;
            width *= iframeScale.x;
            height *= iframeScale.y;
            x2 += left;
            y += top;
            currentWin = getWindow$1(currentIFrame);
            currentIFrame = currentWin.frameElement;
          }
        }
        return rectToClientRect$1({
          width,
          height,
          x: x2,
          y
        });
      }
      function convertOffsetParentRelativeRectToViewportRelativeRect$1(_ref) {
        let {
          elements,
          rect,
          offsetParent,
          strategy
        } = _ref;
        const isFixed = strategy === "fixed";
        const documentElement = getDocumentElement$1(offsetParent);
        const topLayer = elements ? isTopLayer(elements.floating) : false;
        if (offsetParent === documentElement || topLayer && isFixed) {
          return rect;
        }
        let scroll = {
          scrollLeft: 0,
          scrollTop: 0
        };
        let scale = createCoords(1);
        const offsets = createCoords(0);
        const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
        if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
          if (getNodeName$1(offsetParent) !== "body" || isOverflowElement$1(documentElement)) {
            scroll = getNodeScroll$1(offsetParent);
          }
          if (isHTMLElement$1(offsetParent)) {
            const offsetRect = getBoundingClientRect$1(offsetParent);
            scale = getScale(offsetParent);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
          }
        }
        return {
          width: rect.width * scale.x,
          height: rect.height * scale.y,
          x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
          y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
        };
      }
      function getClientRects(element) {
        return Array.from(element.getClientRects());
      }
      function getWindowScrollBarX$1(element) {
        return getBoundingClientRect$1(getDocumentElement$1(element)).left + getNodeScroll$1(element).scrollLeft;
      }
      function getDocumentRect$1(element) {
        const html = getDocumentElement$1(element);
        const scroll = getNodeScroll$1(element);
        const body = element.ownerDocument.body;
        const width = max$3(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
        const height = max$3(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
        let x2 = -scroll.scrollLeft + getWindowScrollBarX$1(element);
        const y = -scroll.scrollTop;
        if (getComputedStyle$2(body).direction === "rtl") {
          x2 += max$3(html.clientWidth, body.clientWidth) - width;
        }
        return {
          width,
          height,
          x: x2,
          y
        };
      }
      function getViewportRect$1(element, strategy) {
        const win = getWindow$1(element);
        const html = getDocumentElement$1(element);
        const visualViewport = win.visualViewport;
        let width = html.clientWidth;
        let height = html.clientHeight;
        let x2 = 0;
        let y = 0;
        if (visualViewport) {
          width = visualViewport.width;
          height = visualViewport.height;
          const visualViewportBased = isWebKit();
          if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
            x2 = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
          }
        }
        return {
          width,
          height,
          x: x2,
          y
        };
      }
      function getInnerBoundingClientRect$1(element, strategy) {
        const clientRect = getBoundingClientRect$1(element, true, strategy === "fixed");
        const top = clientRect.top + element.clientTop;
        const left = clientRect.left + element.clientLeft;
        const scale = isHTMLElement$1(element) ? getScale(element) : createCoords(1);
        const width = element.clientWidth * scale.x;
        const height = element.clientHeight * scale.y;
        const x2 = left * scale.x;
        const y = top * scale.y;
        return {
          width,
          height,
          x: x2,
          y
        };
      }
      function getClientRectFromClippingAncestor$1(element, clippingAncestor, strategy) {
        let rect;
        if (clippingAncestor === "viewport") {
          rect = getViewportRect$1(element, strategy);
        } else if (clippingAncestor === "document") {
          rect = getDocumentRect$1(getDocumentElement$1(element));
        } else if (isElement$1(clippingAncestor)) {
          rect = getInnerBoundingClientRect$1(clippingAncestor, strategy);
        } else {
          const visualOffsets = getVisualOffsets(element);
          rect = {
            ...clippingAncestor,
            x: clippingAncestor.x - visualOffsets.x,
            y: clippingAncestor.y - visualOffsets.y
          };
        }
        return rectToClientRect$1(rect);
      }
      function hasFixedPositionAncestor(element, stopNode) {
        const parentNode = getParentNode$1(element);
        if (parentNode === stopNode || !isElement$1(parentNode) || isLastTraversableNode(parentNode)) {
          return false;
        }
        return getComputedStyle$2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
      }
      function getClippingElementAncestors(element, cache2) {
        const cachedResult = cache2.get(element);
        if (cachedResult) {
          return cachedResult;
        }
        let result2 = getOverflowAncestors$1(element, [], false).filter((el) => isElement$1(el) && getNodeName$1(el) !== "body");
        let currentContainingBlockComputedStyle = null;
        const elementIsFixed = getComputedStyle$2(element).position === "fixed";
        let currentNode = elementIsFixed ? getParentNode$1(element) : element;
        while (isElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
          const computedStyle = getComputedStyle$2(currentNode);
          const currentNodeIsContaining = isContainingBlock$1(currentNode);
          if (!currentNodeIsContaining && computedStyle.position === "fixed") {
            currentContainingBlockComputedStyle = null;
          }
          const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement$1(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
          if (shouldDropCurrentNode) {
            result2 = result2.filter((ancestor) => ancestor !== currentNode);
          } else {
            currentContainingBlockComputedStyle = computedStyle;
          }
          currentNode = getParentNode$1(currentNode);
        }
        cache2.set(element, result2);
        return result2;
      }
      function getClippingRect$1(_ref) {
        let {
          element,
          boundary,
          rootBoundary,
          strategy
        } = _ref;
        const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
        const clippingAncestors = [...elementClippingAncestors, rootBoundary];
        const firstClippingAncestor = clippingAncestors[0];
        const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
          const rect = getClientRectFromClippingAncestor$1(element, clippingAncestor, strategy);
          accRect.top = max$3(rect.top, accRect.top);
          accRect.right = min$3(rect.right, accRect.right);
          accRect.bottom = min$3(rect.bottom, accRect.bottom);
          accRect.left = max$3(rect.left, accRect.left);
          return accRect;
        }, getClientRectFromClippingAncestor$1(element, firstClippingAncestor, strategy));
        return {
          width: clippingRect.right - clippingRect.left,
          height: clippingRect.bottom - clippingRect.top,
          x: clippingRect.left,
          y: clippingRect.top
        };
      }
      function getDimensions$1(element) {
        const {
          width,
          height
        } = getCssDimensions(element);
        return {
          width,
          height
        };
      }
      function getRectRelativeToOffsetParent$1(element, offsetParent, strategy) {
        const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
        const documentElement = getDocumentElement$1(offsetParent);
        const isFixed = strategy === "fixed";
        const rect = getBoundingClientRect$1(element, true, isFixed, offsetParent);
        let scroll = {
          scrollLeft: 0,
          scrollTop: 0
        };
        const offsets = createCoords(0);
        if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
          if (getNodeName$1(offsetParent) !== "body" || isOverflowElement$1(documentElement)) {
            scroll = getNodeScroll$1(offsetParent);
          }
          if (isOffsetParentAnElement) {
            const offsetRect = getBoundingClientRect$1(offsetParent, true, isFixed, offsetParent);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
          } else if (documentElement) {
            offsets.x = getWindowScrollBarX$1(documentElement);
          }
        }
        const x2 = rect.left + scroll.scrollLeft - offsets.x;
        const y = rect.top + scroll.scrollTop - offsets.y;
        return {
          x: x2,
          y,
          width: rect.width,
          height: rect.height
        };
      }
      function isStaticPositioned(element) {
        return getComputedStyle$2(element).position === "static";
      }
      function getTrueOffsetParent$1(element, polyfill) {
        if (!isHTMLElement$1(element) || getComputedStyle$2(element).position === "fixed") {
          return null;
        }
        if (polyfill) {
          return polyfill(element);
        }
        return element.offsetParent;
      }
      function getOffsetParent$1(element, polyfill) {
        const win = getWindow$1(element);
        if (isTopLayer(element)) {
          return win;
        }
        if (!isHTMLElement$1(element)) {
          let svgOffsetParent = getParentNode$1(element);
          while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
            if (isElement$1(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
              return svgOffsetParent;
            }
            svgOffsetParent = getParentNode$1(svgOffsetParent);
          }
          return win;
        }
        let offsetParent = getTrueOffsetParent$1(element, polyfill);
        while (offsetParent && isTableElement$1(offsetParent) && isStaticPositioned(offsetParent)) {
          offsetParent = getTrueOffsetParent$1(offsetParent, polyfill);
        }
        if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock$1(offsetParent)) {
          return win;
        }
        return offsetParent || getContainingBlock$1(element) || win;
      }
      const getElementRects = async function(data) {
        const getOffsetParentFn = this.getOffsetParent || getOffsetParent$1;
        const getDimensionsFn = this.getDimensions;
        const floatingDimensions = await getDimensionsFn(data.floating);
        return {
          reference: getRectRelativeToOffsetParent$1(data.reference, await getOffsetParentFn(data.floating), data.strategy),
          floating: {
            x: 0,
            y: 0,
            width: floatingDimensions.width,
            height: floatingDimensions.height
          }
        };
      };
      function isRTL$1(element) {
        return getComputedStyle$2(element).direction === "rtl";
      }
      const platform$1 = {
        convertOffsetParentRelativeRectToViewportRelativeRect: convertOffsetParentRelativeRectToViewportRelativeRect$1,
        getDocumentElement: getDocumentElement$1,
        getClippingRect: getClippingRect$1,
        getOffsetParent: getOffsetParent$1,
        getElementRects,
        getClientRects,
        getDimensions: getDimensions$1,
        getScale,
        isElement: isElement$1,
        isRTL: isRTL$1
      };
      const arrow$1 = arrow$2;
      const computePosition$2 = (reference, floating, options) => {
        const cache2 = /* @__PURE__ */ new Map();
        const mergedOptions = {
          platform: platform$1,
          ...options
        };
        const platformWithCache = {
          ...mergedOptions.platform,
          _c: cache2
        };
        return computePosition$3(reference, floating, {
          ...mergedOptions,
          platform: platformWithCache
        });
      };
      const useFloatingProps = exports("useFloatingProps", buildProps({}));
      const unrefReference = (elRef) => {
        if (!isClient)
          return;
        if (!elRef)
          return elRef;
        const unrefEl = unrefElement(elRef);
        if (unrefEl)
          return unrefEl;
        return isRef(elRef) ? unrefEl : elRef;
      };
      const getPositionDataWithUnit = exports("getPositionDataWithUnit", (record, key) => {
        const value = record == null ? void 0 : record[key];
        return isNil(value) ? "" : `${value}px`;
      });
      const useFloating$1 = exports("useFloating", ({
        middleware,
        placement,
        strategy
      }) => {
        const referenceRef = ref();
        const contentRef = ref();
        const x2 = ref();
        const y = ref();
        const middlewareData = ref({});
        const states = {
          x: x2,
          y,
          placement,
          strategy,
          middlewareData
        };
        const update2 = async () => {
          if (!isClient)
            return;
          const referenceEl = unrefReference(referenceRef);
          const contentEl = unrefElement(contentRef);
          if (!referenceEl || !contentEl)
            return;
          const data = await computePosition$2(referenceEl, contentEl, {
            placement: unref(placement),
            strategy: unref(strategy),
            middleware: unref(middleware)
          });
          keysOf(states).forEach((key) => {
            states[key].value = data[key];
          });
        };
        onMounted(() => {
          watchEffect(() => {
            update2();
          });
        });
        return {
          ...states,
          update: update2,
          referenceRef,
          contentRef
        };
      });
      const arrowMiddleware = exports("arrowMiddleware", ({
        arrowRef,
        padding
      }) => {
        return {
          name: "arrow",
          options: {
            element: arrowRef,
            padding
          },
          fn(args) {
            const arrowEl = unref(arrowRef);
            if (!arrowEl)
              return {};
            return arrow$1({
              element: arrowEl,
              padding
            }).fn(args);
          }
        };
      });
      function useCursor(input) {
        let selectionInfo;
        function recordCursor() {
          if (input.value == void 0)
            return;
          const { selectionStart, selectionEnd, value } = input.value;
          if (selectionStart == null || selectionEnd == null)
            return;
          const beforeTxt = value.slice(0, Math.max(0, selectionStart));
          const afterTxt = value.slice(Math.max(0, selectionEnd));
          selectionInfo = {
            selectionStart,
            selectionEnd,
            value,
            beforeTxt,
            afterTxt
          };
        }
        function setCursor() {
          if (input.value == void 0 || selectionInfo == void 0)
            return;
          const { value } = input.value;
          const { beforeTxt, afterTxt, selectionStart } = selectionInfo;
          if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
            return;
          let startPos = value.length;
          if (value.endsWith(afterTxt)) {
            startPos = value.length - afterTxt.length;
          } else if (value.startsWith(beforeTxt)) {
            startPos = beforeTxt.length;
          } else {
            const beforeLastChar = beforeTxt[selectionStart - 1];
            const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
            if (newIndex !== -1) {
              startPos = newIndex + 1;
            }
          }
          input.value.setSelectionRange(startPos, startPos);
        }
        return [recordCursor, setCursor];
      }
      const getOrderedChildren = (vm, childComponentName, children) => {
        const nodes = flattedChildren(vm.subTree).filter((n) => {
          var _a;
          return isVNode(n) && ((_a = n.type) == null ? void 0 : _a.name) === childComponentName && !!n.component;
        });
        const uids = nodes.map((n) => n.component.uid);
        return uids.map((uid2) => children[uid2]).filter((p2) => !!p2);
      };
      const useOrderedChildren = exports("useOrderedChildren", (vm, childComponentName) => {
        const children = shallowRef({});
        const orderedChildren = shallowRef([]);
        const nodesMap = /* @__PURE__ */ new WeakMap();
        const addChild = (child) => {
          children.value[child.uid] = child;
          triggerRef(children);
          onMounted(() => {
            const childNode = child.getVnode().el;
            const parentNode = childNode.parentNode;
            if (!nodesMap.has(parentNode)) {
              nodesMap.set(parentNode, []);
              const originalFn = parentNode.insertBefore.bind(parentNode);
              parentNode.insertBefore = (node, anchor) => {
                const shouldSortChildren = nodesMap.get(parentNode).some((el) => node === el || anchor === el);
                if (shouldSortChildren)
                  triggerRef(children);
                return originalFn(node, anchor);
              };
            }
            nodesMap.get(parentNode).push(childNode);
          });
        };
        const removeChild = (child) => {
          delete children.value[child.uid];
          triggerRef(children);
          const childNode = child.getVnode().el;
          const parentNode = childNode.parentNode;
          const childNodes = nodesMap.get(parentNode);
          const index2 = childNodes.indexOf(childNode);
          childNodes.splice(index2, 1);
        };
        const sortChildren = () => {
          orderedChildren.value = getOrderedChildren(vm, childComponentName, children.value);
        };
        const IsolatedRenderer = (props2) => {
          return props2.render();
        };
        const ChildrenSorter = defineComponent({
          setup(_2, { slots }) {
            return () => {
              sortChildren();
              return slots.default ? h$1(IsolatedRenderer, {
                render: slots.default
              }) : null;
            };
          }
        });
        return {
          children: orderedChildren,
          addChild,
          removeChild,
          ChildrenSorter
        };
      });
      const useSizeProp = exports("useSizeProp", buildProp({
        type: String,
        values: componentSizes,
        required: false
      }));
      const useSizeProps = exports("useSizeProps", {
        size: useSizeProp
      });
      const SIZE_INJECTION_KEY = exports("SIZE_INJECTION_KEY", Symbol("size"));
      const useGlobalSize = exports("useGlobalSize", () => {
        const injectedSize = inject(SIZE_INJECTION_KEY, {});
        return computed(() => {
          return unref(injectedSize.size) || "";
        });
      });
      function useFocusController(target2, {
        disabled,
        beforeFocus,
        afterFocus,
        beforeBlur,
        afterBlur
      } = {}) {
        const instance = getCurrentInstance();
        const { emit } = instance;
        const wrapperRef = shallowRef();
        const isFocused = ref(false);
        const handleFocus = (event) => {
          const cancelFocus = isFunction$1(beforeFocus) ? beforeFocus(event) : false;
          if (unref(disabled) || isFocused.value || cancelFocus)
            return;
          isFocused.value = true;
          emit("focus", event);
          afterFocus == null ? void 0 : afterFocus();
        };
        const handleBlur = (event) => {
          var _a;
          const cancelBlur = isFunction$1(beforeBlur) ? beforeBlur(event) : false;
          if (unref(disabled) || event.relatedTarget && ((_a = wrapperRef.value) == null ? void 0 : _a.contains(event.relatedTarget)) || cancelBlur)
            return;
          isFocused.value = false;
          emit("blur", event);
          afterBlur == null ? void 0 : afterBlur();
        };
        const handleClick = (event) => {
          var _a, _b;
          if (unref(disabled) || isFocusable(event.target) || ((_a = wrapperRef.value) == null ? void 0 : _a.contains(document.activeElement)) && wrapperRef.value !== document.activeElement)
            return;
          (_b = target2.value) == null ? void 0 : _b.focus();
        };
        watch([wrapperRef, () => unref(disabled)], ([el, disabled2]) => {
          if (!el)
            return;
          if (disabled2) {
            el.removeAttribute("tabindex");
          } else {
            el.setAttribute("tabindex", "-1");
          }
        });
        useEventListener(wrapperRef, "focus", handleFocus, true);
        useEventListener(wrapperRef, "blur", handleBlur, true);
        useEventListener(wrapperRef, "click", handleClick, true);
        return {
          isFocused,
          wrapperRef,
          handleFocus,
          handleBlur
        };
      }
      function useComposition({
        afterComposition,
        emit
      }) {
        const isComposing = ref(false);
        const handleCompositionStart = (event) => {
          emit == null ? void 0 : emit("compositionstart", event);
          isComposing.value = true;
        };
        const handleCompositionUpdate = (event) => {
          var _a;
          emit == null ? void 0 : emit("compositionupdate", event);
          const text = (_a = event.target) == null ? void 0 : _a.value;
          const lastCharacter = text[text.length - 1] || "";
          isComposing.value = !isKorean(lastCharacter);
        };
        const handleCompositionEnd = (event) => {
          emit == null ? void 0 : emit("compositionend", event);
          if (isComposing.value) {
            isComposing.value = false;
            nextTick(() => afterComposition(event));
          }
        };
        const handleComposition = (event) => {
          event.type === "compositionend" ? handleCompositionEnd(event) : handleCompositionUpdate(event);
        };
        return {
          isComposing,
          handleComposition,
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        };
      }
      const emptyValuesContextKey = exports("emptyValuesContextKey", Symbol("emptyValuesContextKey"));
      const SCOPE$4 = exports("SCOPE", "use-empty-values");
      const DEFAULT_EMPTY_VALUES = exports("DEFAULT_EMPTY_VALUES", ["", void 0, null]);
      const DEFAULT_VALUE_ON_CLEAR = exports("DEFAULT_VALUE_ON_CLEAR", void 0);
      const useEmptyValuesProps = exports("useEmptyValuesProps", buildProps({
        emptyValues: Array,
        valueOnClear: {
          type: definePropType([
            String,
            Number,
            Boolean,
            Function
          ]),
          default: void 0,
          validator: (val) => isFunction$1(val) ? !val() : !val
        }
      }));
      const useEmptyValues = exports("useEmptyValues", (props2, defaultValue) => {
        const config = getCurrentInstance() ? inject(emptyValuesContextKey, ref({})) : ref({});
        const emptyValues = computed(() => props2.emptyValues || config.value.emptyValues || DEFAULT_EMPTY_VALUES);
        const valueOnClear = computed(() => {
          if (isFunction$1(props2.valueOnClear)) {
            return props2.valueOnClear();
          } else if (props2.valueOnClear !== void 0) {
            return props2.valueOnClear;
          } else if (isFunction$1(config.value.valueOnClear)) {
            return config.value.valueOnClear();
          } else if (config.value.valueOnClear !== void 0) {
            return config.value.valueOnClear;
          }
          return defaultValue !== void 0 ? defaultValue : DEFAULT_VALUE_ON_CLEAR;
        });
        const isEmptyValue2 = (value) => {
          return emptyValues.value.includes(value);
        };
        if (!emptyValues.value.includes(valueOnClear.value))
          ;
        return {
          emptyValues,
          valueOnClear,
          isEmptyValue: isEmptyValue2
        };
      });
      const ariaProps = exports("ariaProps", buildProps({
        ariaLabel: String,
        ariaOrientation: {
          type: String,
          values: ["horizontal", "vertical", "undefined"]
        },
        ariaControls: String
      }));
      const useAriaProps = exports("useAriaProps", (arias) => {
        return pick(ariaProps, arias);
      });
      const configProviderContextKey = exports("configProviderContextKey", Symbol());
      const globalConfig = ref();
      function useGlobalConfig(key, defaultValue = void 0) {
        const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
        if (key) {
          return computed(() => {
            var _a, _b;
            return (_b = (_a = config.value) == null ? void 0 : _a[key]) != null ? _b : defaultValue;
          });
        } else {
          return config;
        }
      }
      function useGlobalComponentSettings(block, sizeFallback) {
        const config = useGlobalConfig();
        const ns = useNamespace(block, computed(() => {
          var _a;
          return ((_a = config.value) == null ? void 0 : _a.namespace) || defaultNamespace;
        }));
        const locale = useLocale(computed(() => {
          var _a;
          return (_a = config.value) == null ? void 0 : _a.locale;
        }));
        const zIndex2 = useZIndex(computed(() => {
          var _a;
          return ((_a = config.value) == null ? void 0 : _a.zIndex) || defaultInitialZIndex;
        }));
        const size = computed(() => {
          var _a;
          return unref(sizeFallback) || ((_a = config.value) == null ? void 0 : _a.size) || "";
        });
        provideGlobalConfig(computed(() => unref(config) || {}));
        return {
          ns,
          locale,
          zIndex: zIndex2,
          size
        };
      }
      const provideGlobalConfig = exports("provideGlobalConfig", (config, app, global2 = false) => {
        var _a;
        const inSetup = !!getCurrentInstance();
        const oldConfig = inSetup ? useGlobalConfig() : void 0;
        const provideFn = (_a = app == null ? void 0 : app.provide) != null ? _a : inSetup ? provide : void 0;
        if (!provideFn) {
          return;
        }
        const context = computed(() => {
          const cfg = unref(config);
          if (!(oldConfig == null ? void 0 : oldConfig.value))
            return cfg;
          return mergeConfig(oldConfig.value, cfg);
        });
        provideFn(configProviderContextKey, context);
        provideFn(localeContextKey, computed(() => context.value.locale));
        provideFn(namespaceContextKey, computed(() => context.value.namespace));
        provideFn(zIndexContextKey, computed(() => context.value.zIndex));
        provideFn(SIZE_INJECTION_KEY, {
          size: computed(() => context.value.size || "")
        });
        provideFn(emptyValuesContextKey, computed(() => ({
          emptyValues: context.value.emptyValues,
          valueOnClear: context.value.valueOnClear
        })));
        if (global2 || !globalConfig.value) {
          globalConfig.value = context.value;
        }
        return context;
      });
      const mergeConfig = (a2, b2) => {
        const keys2 = [.../* @__PURE__ */ new Set([...keysOf(a2), ...keysOf(b2)])];
        const obj = {};
        for (const key of keys2) {
          obj[key] = b2[key] !== void 0 ? b2[key] : a2[key];
        }
        return obj;
      };
      const configProviderProps = exports("configProviderProps", buildProps({
        a11y: {
          type: Boolean,
          default: true
        },
        locale: {
          type: definePropType(Object)
        },
        size: useSizeProp,
        button: {
          type: definePropType(Object)
        },
        card: {
          type: definePropType(Object)
        },
        dialog: {
          type: definePropType(Object)
        },
        link: {
          type: definePropType(Object)
        },
        experimentalFeatures: {
          type: definePropType(Object)
        },
        keyboardNavigation: {
          type: Boolean,
          default: true
        },
        message: {
          type: definePropType(Object)
        },
        zIndex: Number,
        namespace: {
          type: String,
          default: "el"
        },
        ...useEmptyValuesProps
      }));
      const messageConfig = exports("messageConfig", {});
      const ConfigProvider = defineComponent({
        name: "ElConfigProvider",
        props: configProviderProps,
        setup(props2, { slots }) {
          const config = provideGlobalConfig(props2);
          watch(() => props2.message, (val) => {
            var _a, _b;
            Object.assign(messageConfig, (_b = (_a = config == null ? void 0 : config.value) == null ? void 0 : _a.message) != null ? _b : {}, val != null ? val : {});
          }, { immediate: true, deep: true });
          return () => renderSlot(slots, "default", { config: config == null ? void 0 : config.value });
        }
      });
      const ElConfigProvider = exports("ElConfigProvider", withInstall(ConfigProvider));
      const version$1 = "2.10.7";
      const makeInstaller = exports("makeInstaller", (components = []) => {
        const install2 = (app, options) => {
          if (app[INSTALLED_KEY])
            return;
          app[INSTALLED_KEY] = true;
          components.forEach((c2) => app.use(c2));
          if (options)
            provideGlobalConfig(options, app, true);
        };
        return {
          version: version$1,
          install: install2
        };
      });
      const affixProps = exports("affixProps", buildProps({
        zIndex: {
          type: definePropType([Number, String]),
          default: 100
        },
        target: {
          type: String,
          default: ""
        },
        offset: {
          type: Number,
          default: 0
        },
        position: {
          type: String,
          values: ["top", "bottom"],
          default: "top"
        }
      }));
      const affixEmits = exports("affixEmits", {
        scroll: ({ scrollTop, fixed }) => isNumber(scrollTop) && isBoolean(fixed),
        [CHANGE_EVENT]: (fixed) => isBoolean(fixed)
      });
      var _export_sfc = (sfc, props2) => {
        const target2 = sfc.__vccOpts || sfc;
        for (const [key, val] of props2) {
          target2[key] = val;
        }
        return target2;
      };
      const COMPONENT_NAME$q = "ElAffix";
      const __default__$1_ = defineComponent({
        name: COMPONENT_NAME$q
      });
      const _sfc_main$2A = /* @__PURE__ */ defineComponent({
        ...__default__$1_,
        props: affixProps,
        emits: affixEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const ns = useNamespace("affix");
          const target2 = shallowRef();
          const root2 = shallowRef();
          const scrollContainer = shallowRef();
          const { height: windowHeight } = useWindowSize();
          const {
            height: rootHeight,
            width: rootWidth,
            top: rootTop,
            bottom: rootBottom,
            update: updateRoot
          } = useElementBounding(root2, { windowScroll: false });
          const targetRect = useElementBounding(target2);
          const fixed = ref(false);
          const scrollTop = ref(0);
          const transform2 = ref(0);
          const rootStyle = computed(() => {
            return {
              height: fixed.value ? `${rootHeight.value}px` : "",
              width: fixed.value ? `${rootWidth.value}px` : ""
            };
          });
          const affixStyle = computed(() => {
            if (!fixed.value)
              return {};
            const offset2 = props2.offset ? addUnit(props2.offset) : 0;
            return {
              height: `${rootHeight.value}px`,
              width: `${rootWidth.value}px`,
              top: props2.position === "top" ? offset2 : "",
              bottom: props2.position === "bottom" ? offset2 : "",
              transform: transform2.value ? `translateY(${transform2.value}px)` : "",
              zIndex: props2.zIndex
            };
          });
          const update2 = () => {
            if (!scrollContainer.value)
              return;
            scrollTop.value = scrollContainer.value instanceof Window ? document.documentElement.scrollTop : scrollContainer.value.scrollTop || 0;
            const { position, target: target22, offset: offset2 } = props2;
            const rootHeightOffset = offset2 + rootHeight.value;
            if (position === "top") {
              if (target22) {
                const difference2 = targetRect.bottom.value - rootHeightOffset;
                fixed.value = offset2 > rootTop.value && targetRect.bottom.value > 0;
                transform2.value = difference2 < 0 ? difference2 : 0;
              } else {
                fixed.value = offset2 > rootTop.value;
              }
            } else if (target22) {
              const difference2 = windowHeight.value - targetRect.top.value - rootHeightOffset;
              fixed.value = windowHeight.value - offset2 < rootBottom.value && windowHeight.value > targetRect.top.value;
              transform2.value = difference2 < 0 ? -difference2 : 0;
            } else {
              fixed.value = windowHeight.value - offset2 < rootBottom.value;
            }
          };
          const updateRootRect = async () => {
            if (!fixed.value) {
              updateRoot();
              return;
            }
            fixed.value = false;
            await nextTick();
            updateRoot();
            fixed.value = true;
          };
          const handleScroll2 = async () => {
            updateRoot();
            await nextTick();
            emit("scroll", {
              scrollTop: scrollTop.value,
              fixed: fixed.value
            });
          };
          watch(fixed, (val) => emit(CHANGE_EVENT, val));
          onMounted(() => {
            var _a;
            if (props2.target) {
              target2.value = (_a = document.querySelector(props2.target)) != null ? _a : void 0;
              if (!target2.value)
                throwError(COMPONENT_NAME$q, `Target does not exist: ${props2.target}`);
            } else {
              target2.value = document.documentElement;
            }
            scrollContainer.value = getScrollContainer(root2.value, true);
            updateRoot();
          });
          useEventListener(scrollContainer, "scroll", handleScroll2);
          watchEffect(update2);
          expose({
            update: update2,
            updateRoot: updateRootRect
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "root",
              ref: root2,
              class: normalizeClass(unref(ns).b()),
              style: normalizeStyle(unref(rootStyle))
            }, [
              createElementVNode("div", {
                class: normalizeClass({ [unref(ns).m("fixed")]: fixed.value }),
                style: normalizeStyle(unref(affixStyle))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 6)
            ], 6);
          };
        }
      });
      var Affix = /* @__PURE__ */ _export_sfc(_sfc_main$2A, [["__file", "affix.vue"]]);
      const ElAffix = exports("ElAffix", withInstall(Affix));
      const iconProps = exports("iconProps", buildProps({
        size: {
          type: definePropType([Number, String])
        },
        color: {
          type: String
        }
      }));
      const __default__$1Z = defineComponent({
        name: "ElIcon",
        inheritAttrs: false
      });
      const _sfc_main$2z = /* @__PURE__ */ defineComponent({
        ...__default__$1Z,
        props: iconProps,
        setup(__props) {
          const props2 = __props;
          const ns = useNamespace("icon");
          const style = computed(() => {
            const { size, color } = props2;
            if (!size && !color)
              return {};
            return {
              fontSize: isUndefined(size) ? void 0 : addUnit(size),
              "--color": color
            };
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("i", mergeProps({
              class: unref(ns).b(),
              style: unref(style)
            }, _ctx.$attrs), [
              renderSlot(_ctx.$slots, "default")
            ], 16);
          };
        }
      });
      var Icon = /* @__PURE__ */ _export_sfc(_sfc_main$2z, [["__file", "icon.vue"]]);
      const ElIcon = exports("ElIcon", withInstall(Icon));
      const alertEffects = exports("alertEffects", ["light", "dark"]);
      const alertProps = exports("alertProps", buildProps({
        title: {
          type: String,
          default: ""
        },
        description: {
          type: String,
          default: ""
        },
        type: {
          type: String,
          values: keysOf(TypeComponentsMap),
          default: "info"
        },
        closable: {
          type: Boolean,
          default: true
        },
        closeText: {
          type: String,
          default: ""
        },
        showIcon: Boolean,
        center: Boolean,
        effect: {
          type: String,
          values: alertEffects,
          default: "light"
        },
        ...useDelayedToggleProps
      }));
      const alertEmits = exports("alertEmits", {
        open: () => true,
        close: (evt) => isUndefined(evt) || evt instanceof Event
      });
      const __default__$1Y = defineComponent({
        name: "ElAlert"
      });
      const _sfc_main$2y = /* @__PURE__ */ defineComponent({
        ...__default__$1Y,
        props: alertProps,
        emits: alertEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const { Close } = TypeComponents;
          const slots = useSlots();
          const ns = useNamespace("alert");
          const visible = ref(false);
          const iconComponent = computed(() => TypeComponentsMap[props2.type]);
          const hasDesc = computed(() => !!(props2.description || slots.default));
          const open = () => {
            visible.value = true;
            emit("open");
          };
          const close2 = (event) => {
            visible.value = false;
            emit("close", event);
          };
          const { onOpen, onClose } = useDelayedToggle({
            showAfter: toRef(props2, "showAfter"),
            hideAfter: toRef(props2, "hideAfter"),
            autoClose: toRef(props2, "autoClose"),
            open,
            close: close2
          });
          if (isClient) {
            onOpen();
          }
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createElementVNode("div", {
                  class: normalizeClass([unref(ns).b(), unref(ns).m(_ctx.type), unref(ns).is("center", _ctx.center), unref(ns).is(_ctx.effect)]),
                  role: "alert"
                }, [
                  _ctx.showIcon && (_ctx.$slots.icon || unref(iconComponent)) ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass([unref(ns).e("icon"), { [unref(ns).is("big")]: unref(hasDesc) }])
                  }, {
                    default: withCtx(() => [
                      renderSlot(_ctx.$slots, "icon", {}, () => [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                      ])
                    ]),
                    _: 3
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).e("content"))
                  }, [
                    _ctx.title || _ctx.$slots.title ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      class: normalizeClass([unref(ns).e("title"), { "with-description": unref(hasDesc) }])
                    }, [
                      renderSlot(_ctx.$slots, "title", {}, () => [
                        createTextVNode(toDisplayString(_ctx.title), 1)
                      ])
                    ], 2)) : createCommentVNode("v-if", true),
                    unref(hasDesc) ? (openBlock(), createElementBlock("p", {
                      key: 1,
                      class: normalizeClass(unref(ns).e("description"))
                    }, [
                      renderSlot(_ctx.$slots, "default", {}, () => [
                        createTextVNode(toDisplayString(_ctx.description), 1)
                      ])
                    ], 2)) : createCommentVNode("v-if", true),
                    _ctx.closable ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                      _ctx.closeText ? (openBlock(), createElementBlock("div", {
                        key: 0,
                        class: normalizeClass([unref(ns).e("close-btn"), unref(ns).is("customed")]),
                        onClick: close2
                      }, toDisplayString(_ctx.closeText), 3)) : (openBlock(), createBlock(unref(ElIcon), {
                        key: 1,
                        class: normalizeClass(unref(ns).e("close-btn")),
                        onClick: unref(onClose)
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(Close))
                        ]),
                        _: 1
                      }, 8, ["class", "onClick"]))
                    ], 64)) : createCommentVNode("v-if", true)
                  ], 2)
                ], 2), [
                  [vShow, visible.value]
                ])
              ]),
              _: 3
            }, 8, ["name"]);
          };
        }
      });
      var Alert = /* @__PURE__ */ _export_sfc(_sfc_main$2y, [["__file", "alert.vue"]]);
      const ElAlert = exports("ElAlert", withInstall(Alert));
      const formContextKey = exports("formContextKey", Symbol("formContextKey"));
      const formItemContextKey = exports("formItemContextKey", Symbol("formItemContextKey"));
      const useFormSize = exports("useFormSize", (fallback, ignore = {}) => {
        const emptyRef = ref(void 0);
        const size = ignore.prop ? emptyRef : useProp("size");
        const globalConfig2 = ignore.global ? emptyRef : useGlobalSize();
        const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
        const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
        return computed(() => size.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
      });
      const useFormDisabled = exports("useFormDisabled", (fallback) => {
        const disabled = useProp("disabled");
        const form = inject(formContextKey, void 0);
        return computed(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
      });
      const useSize$1 = exports("useSize", useFormSize);
      const useDisabled = exports("useDisabled", useFormDisabled);
      const useFormItem = exports("useFormItem", () => {
        const form = inject(formContextKey, void 0);
        const formItem = inject(formItemContextKey, void 0);
        return {
          form,
          formItem
        };
      });
      const useFormItemInputId = exports("useFormItemInputId", (props2, {
        formItemContext,
        disableIdGeneration,
        disableIdManagement
      }) => {
        if (!disableIdGeneration) {
          disableIdGeneration = ref(false);
        }
        if (!disableIdManagement) {
          disableIdManagement = ref(false);
        }
        const instance = getCurrentInstance();
        const inLabel = () => {
          let parent2 = instance == null ? void 0 : instance.parent;
          while (parent2) {
            if (parent2.type.name === "ElFormItem") {
              return false;
            }
            if (parent2.type.name === "ElLabelWrap") {
              return true;
            }
            parent2 = parent2.parent;
          }
          return false;
        };
        const inputId = ref();
        let idUnwatch = void 0;
        const isLabeledByFormItem = computed(() => {
          var _a;
          return !!(!(props2.label || props2.ariaLabel) && formItemContext && formItemContext.inputIds && ((_a = formItemContext.inputIds) == null ? void 0 : _a.length) <= 1);
        });
        onMounted(() => {
          idUnwatch = watch([toRef(props2, "id"), disableIdGeneration], ([id, disableIdGeneration2]) => {
            const newId = id != null ? id : !disableIdGeneration2 ? useId().value : void 0;
            if (newId !== inputId.value) {
              if ((formItemContext == null ? void 0 : formItemContext.removeInputId) && !inLabel()) {
                inputId.value && formItemContext.removeInputId(inputId.value);
                if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
                  formItemContext.addInputId(newId);
                }
              }
              inputId.value = newId;
            }
          }, { immediate: true });
        });
        onUnmounted(() => {
          idUnwatch && idUnwatch();
          if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
            inputId.value && formItemContext.removeInputId(inputId.value);
          }
        });
        return {
          isLabeledByFormItem,
          inputId
        };
      });
      const formMetaProps = exports("formMetaProps", buildProps({
        size: {
          type: String,
          values: componentSizes
        },
        disabled: Boolean
      }));
      const formProps = exports("formProps", buildProps({
        ...formMetaProps,
        model: Object,
        rules: {
          type: definePropType(Object)
        },
        labelPosition: {
          type: String,
          values: ["left", "right", "top"],
          default: "right"
        },
        requireAsteriskPosition: {
          type: String,
          values: ["left", "right"],
          default: "left"
        },
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        labelSuffix: {
          type: String,
          default: ""
        },
        inline: Boolean,
        inlineMessage: Boolean,
        statusIcon: Boolean,
        showMessage: {
          type: Boolean,
          default: true
        },
        validateOnRuleChange: {
          type: Boolean,
          default: true
        },
        hideRequiredAsterisk: Boolean,
        scrollToError: Boolean,
        scrollIntoViewOptions: {
          type: definePropType([Object, Boolean]),
          default: true
        }
      }));
      const formEmits = exports("formEmits", {
        validate: (prop, isValid, message2) => (isArray$1(prop) || isString$1(prop)) && isBoolean(isValid) && isString$1(message2)
      });
      function useFormLabelWidth() {
        const potentialLabelWidthArr = ref([]);
        const autoLabelWidth = computed(() => {
          if (!potentialLabelWidthArr.value.length)
            return "0";
          const max2 = Math.max(...potentialLabelWidthArr.value);
          return max2 ? `${max2}px` : "";
        });
        function getLabelWidthIndex(width) {
          const index2 = potentialLabelWidthArr.value.indexOf(width);
          if (index2 === -1 && autoLabelWidth.value === "0")
            ;
          return index2;
        }
        function registerLabelWidth(val, oldVal) {
          if (val && oldVal) {
            const index2 = getLabelWidthIndex(oldVal);
            potentialLabelWidthArr.value.splice(index2, 1, val);
          } else if (val) {
            potentialLabelWidthArr.value.push(val);
          }
        }
        function deregisterLabelWidth(val) {
          const index2 = getLabelWidthIndex(val);
          if (index2 > -1) {
            potentialLabelWidthArr.value.splice(index2, 1);
          }
        }
        return {
          autoLabelWidth,
          registerLabelWidth,
          deregisterLabelWidth
        };
      }
      const filterFields = (fields, props2) => {
        const normalized = castArray$1(props2).map((prop) => isArray$1(prop) ? prop.join(".") : prop);
        return normalized.length > 0 ? fields.filter((field) => field.propString && normalized.includes(field.propString)) : fields;
      };
      const COMPONENT_NAME$p = "ElForm";
      const __default__$1X = defineComponent({
        name: COMPONENT_NAME$p
      });
      const _sfc_main$2x = /* @__PURE__ */ defineComponent({
        ...__default__$1X,
        props: formProps,
        emits: formEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const formRef = ref();
          const fields = reactive([]);
          const formSize = useFormSize();
          const ns = useNamespace("form");
          const formClasses = computed(() => {
            const { labelPosition, inline } = props2;
            return [
              ns.b(),
              ns.m(formSize.value || "default"),
              {
                [ns.m(`label-${labelPosition}`)]: labelPosition,
                [ns.m("inline")]: inline
              }
            ];
          });
          const getField = (prop) => {
            return filterFields(fields, [prop])[0];
          };
          const addField = (field) => {
            fields.push(field);
          };
          const removeField = (field) => {
            if (field.prop) {
              fields.splice(fields.indexOf(field), 1);
            }
          };
          const resetFields = (properties = []) => {
            if (!props2.model) {
              return;
            }
            filterFields(fields, properties).forEach((field) => field.resetField());
          };
          const clearValidate = (props22 = []) => {
            filterFields(fields, props22).forEach((field) => field.clearValidate());
          };
          const isValidatable = computed(() => {
            const hasModel = !!props2.model;
            return hasModel;
          });
          const obtainValidateFields = (props22) => {
            if (fields.length === 0)
              return [];
            const filteredFields = filterFields(fields, props22);
            if (!filteredFields.length) {
              return [];
            }
            return filteredFields;
          };
          const validate = async (callback) => validateField(void 0, callback);
          const doValidateField = async (props22 = []) => {
            if (!isValidatable.value)
              return false;
            const fields2 = obtainValidateFields(props22);
            if (fields2.length === 0)
              return true;
            let validationErrors = {};
            for (const field of fields2) {
              try {
                await field.validate("");
                if (field.validateState === "error" && !field.error)
                  field.resetField();
              } catch (fields3) {
                validationErrors = {
                  ...validationErrors,
                  ...fields3
                };
              }
            }
            if (Object.keys(validationErrors).length === 0)
              return true;
            return Promise.reject(validationErrors);
          };
          const validateField = async (modelProps = [], callback) => {
            let result2 = false;
            const shouldThrow = !isFunction$1(callback);
            try {
              result2 = await doValidateField(modelProps);
              if (result2 === true) {
                await (callback == null ? void 0 : callback(result2));
              }
              return result2;
            } catch (e) {
              if (e instanceof Error)
                throw e;
              const invalidFields = e;
              if (props2.scrollToError) {
                if (formRef.value) {
                  const formItem = formRef.value.querySelector(`.${ns.b()}-item.is-error`);
                  formItem == null ? void 0 : formItem.scrollIntoView(props2.scrollIntoViewOptions);
                }
              }
              !result2 && await (callback == null ? void 0 : callback(false, invalidFields));
              return shouldThrow && Promise.reject(invalidFields);
            }
          };
          const scrollToField = (prop) => {
            var _a;
            const field = getField(prop);
            if (field) {
              (_a = field.$el) == null ? void 0 : _a.scrollIntoView(props2.scrollIntoViewOptions);
            }
          };
          watch(() => props2.rules, () => {
            if (props2.validateOnRuleChange) {
              validate().catch((err) => debugWarn());
            }
          }, { deep: true, flush: "post" });
          provide(formContextKey, reactive({
            ...toRefs(props2),
            emit,
            resetFields,
            clearValidate,
            validateField,
            getField,
            addField,
            removeField,
            ...useFormLabelWidth()
          }));
          expose({
            validate,
            validateField,
            resetFields,
            clearValidate,
            scrollToField,
            getField,
            fields
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("form", {
              ref_key: "formRef",
              ref: formRef,
              class: normalizeClass(unref(formClasses))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Form = /* @__PURE__ */ _export_sfc(_sfc_main$2x, [["__file", "form.vue"]]);
      function _extends() {
        _extends = Object.assign ? Object.assign.bind() : function(target2) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target2[key] = source[key];
              }
            }
          }
          return target2;
        };
        return _extends.apply(this, arguments);
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _getPrototypeOf(o2) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o22) {
          return o22.__proto__ || Object.getPrototypeOf(o22);
        };
        return _getPrototypeOf(o2);
      }
      function _setPrototypeOf(o2, p2) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o22, p22) {
          o22.__proto__ = p22;
          return o22;
        };
        return _setPrototypeOf(o2, p2);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct.bind();
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a2 = [null];
            a2.push.apply(a2, args2);
            var Constructor = Function.bind.apply(Parent2, a2);
            var instance = new Constructor();
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeFunction(fn2) {
        return Function.toString.call(fn2).indexOf("[native code]") !== -1;
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2))
            return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2))
              return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
          }
          function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class2.prototype, {
            constructor: {
              value: Wrapper,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          return _setPrototypeOf(Wrapper, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      var formatRegExp = /%[sdj%]/g;
      var warning = function warning2() {
      };
      if (typeof process !== "undefined" && process.env && false) {
        warning = function warning3(type4, errors) {
          if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
            if (errors.every(function(e) {
              return typeof e === "string";
            })) {
              console.warn(type4, errors);
            }
          }
        };
      }
      function convertFieldsError(errors) {
        if (!errors || !errors.length)
          return null;
        var fields = {};
        errors.forEach(function(error) {
          var field = error.field;
          fields[field] = fields[field] || [];
          fields[field].push(error);
        });
        return fields;
      }
      function format(template2) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var i = 0;
        var len = args.length;
        if (typeof template2 === "function") {
          return template2.apply(null, args);
        }
        if (typeof template2 === "string") {
          var str = template2.replace(formatRegExp, function(x2) {
            if (x2 === "%%") {
              return "%";
            }
            if (i >= len) {
              return x2;
            }
            switch (x2) {
              case "%s":
                return String(args[i++]);
              case "%d":
                return Number(args[i++]);
              case "%j":
                try {
                  return JSON.stringify(args[i++]);
                } catch (_2) {
                  return "[Circular]";
                }
                break;
              default:
                return x2;
            }
          });
          return str;
        }
        return template2;
      }
      function isNativeStringType(type4) {
        return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
      }
      function isEmptyValue(value, type4) {
        if (value === void 0 || value === null) {
          return true;
        }
        if (type4 === "array" && Array.isArray(value) && !value.length) {
          return true;
        }
        if (isNativeStringType(type4) && typeof value === "string" && !value) {
          return true;
        }
        return false;
      }
      function asyncParallelArray(arr, func2, callback) {
        var results = [];
        var total2 = 0;
        var arrLength = arr.length;
        function count(errors) {
          results.push.apply(results, errors || []);
          total2++;
          if (total2 === arrLength) {
            callback(results);
          }
        }
        arr.forEach(function(a2) {
          func2(a2, count);
        });
      }
      function asyncSerialArray(arr, func2, callback) {
        var index2 = 0;
        var arrLength = arr.length;
        function next(errors) {
          if (errors && errors.length) {
            callback(errors);
            return;
          }
          var original = index2;
          index2 = index2 + 1;
          if (original < arrLength) {
            func2(arr[original], next);
          } else {
            callback([]);
          }
        }
        next([]);
      }
      function flattenObjArr(objArr) {
        var ret = [];
        Object.keys(objArr).forEach(function(k) {
          ret.push.apply(ret, objArr[k] || []);
        });
        return ret;
      }
      var AsyncValidationError = /* @__PURE__ */ function(_Error) {
        _inheritsLoose(AsyncValidationError2, _Error);
        function AsyncValidationError2(errors, fields) {
          var _this;
          _this = _Error.call(this, "Async Validation Error") || this;
          _this.errors = errors;
          _this.fields = fields;
          return _this;
        }
        return AsyncValidationError2;
      }(/* @__PURE__ */ _wrapNativeSuper(Error));
      function asyncMap(objArr, option, func2, callback, source) {
        if (option.first) {
          var _pending = new Promise(function(resolve, reject2) {
            var next = function next2(errors) {
              callback(errors);
              return errors.length ? reject2(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
            };
            var flattenArr = flattenObjArr(objArr);
            asyncSerialArray(flattenArr, func2, next);
          });
          _pending["catch"](function(e) {
            return e;
          });
          return _pending;
        }
        var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
        var objArrKeys = Object.keys(objArr);
        var objArrLength = objArrKeys.length;
        var total2 = 0;
        var results = [];
        var pending = new Promise(function(resolve, reject2) {
          var next = function next2(errors) {
            results.push.apply(results, errors);
            total2++;
            if (total2 === objArrLength) {
              callback(results);
              return results.length ? reject2(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
            }
          };
          if (!objArrKeys.length) {
            callback(results);
            resolve(source);
          }
          objArrKeys.forEach(function(key) {
            var arr = objArr[key];
            if (firstFields.indexOf(key) !== -1) {
              asyncSerialArray(arr, func2, next);
            } else {
              asyncParallelArray(arr, func2, next);
            }
          });
        });
        pending["catch"](function(e) {
          return e;
        });
        return pending;
      }
      function isErrorObj(obj) {
        return !!(obj && obj.message !== void 0);
      }
      function getValue(value, path) {
        var v2 = value;
        for (var i = 0; i < path.length; i++) {
          if (v2 == void 0) {
            return v2;
          }
          v2 = v2[path[i]];
        }
        return v2;
      }
      function complementError(rule, source) {
        return function(oe) {
          var fieldValue;
          if (rule.fullFields) {
            fieldValue = getValue(source, rule.fullFields);
          } else {
            fieldValue = source[oe.field || rule.fullField];
          }
          if (isErrorObj(oe)) {
            oe.field = oe.field || rule.fullField;
            oe.fieldValue = fieldValue;
            return oe;
          }
          return {
            message: typeof oe === "function" ? oe() : oe,
            fieldValue,
            field: oe.field || rule.fullField
          };
        };
      }
      function deepMerge(target2, source) {
        if (source) {
          for (var s2 in source) {
            if (source.hasOwnProperty(s2)) {
              var value = source[s2];
              if (typeof value === "object" && typeof target2[s2] === "object") {
                target2[s2] = _extends({}, target2[s2], value);
              } else {
                target2[s2] = value;
              }
            }
          }
        }
        return target2;
      }
      var required$1 = function required(rule, value, source, errors, options, type4) {
        if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
          errors.push(format(options.messages.required, rule.fullField));
        }
      };
      var whitespace = function whitespace2(rule, value, source, errors, options) {
        if (/^\s+$/.test(value) || value === "") {
          errors.push(format(options.messages.whitespace, rule.fullField));
        }
      };
      var urlReg;
      var getUrlRegex = function() {
        if (urlReg) {
          return urlReg;
        }
        var word = "[a-fA-F\\d:]";
        var b2 = function b22(options) {
          return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
        };
        var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
        var v6seg = "[a-fA-F\\d]{1,4}";
        var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
        var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
        var v4exact = new RegExp("^" + v4 + "$");
        var v6exact = new RegExp("^" + v6 + "$");
        var ip = function ip2(options) {
          return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
        };
        ip.v4 = function(options) {
          return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
        };
        ip.v6 = function(options) {
          return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
        };
        var protocol = "(?:(?:[a-z]+:)?//)";
        var auth = "(?:\\S+(?::\\S*)?@)?";
        var ipv4 = ip.v4().source;
        var ipv6 = ip.v6().source;
        var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
        var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
        var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
        var port = "(?::\\d{2,5})?";
        var path = '(?:[/?#][^\\s"]*)?';
        var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
        urlReg = new RegExp("(?:^" + regex + "$)", "i");
        return urlReg;
      };
      var pattern$2 = {
        email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
        hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
      };
      var types = {
        integer: function integer(value) {
          return types.number(value) && parseInt(value, 10) === value;
        },
        "float": function float(value) {
          return types.number(value) && !types.integer(value);
        },
        array: function array3(value) {
          return Array.isArray(value);
        },
        regexp: function regexp(value) {
          if (value instanceof RegExp) {
            return true;
          }
          try {
            return !!new RegExp(value);
          } catch (e) {
            return false;
          }
        },
        date: function date3(value) {
          return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
        },
        number: function number3(value) {
          if (isNaN(value)) {
            return false;
          }
          return typeof value === "number";
        },
        object: function object3(value) {
          return typeof value === "object" && !types.array(value);
        },
        method: function method3(value) {
          return typeof value === "function";
        },
        email: function email(value) {
          return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
        },
        url: function url(value) {
          return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
        },
        hex: function hex(value) {
          return typeof value === "string" && !!value.match(pattern$2.hex);
        }
      };
      var type$1 = function type(rule, value, source, errors, options) {
        if (rule.required && value === void 0) {
          required$1(rule, value, source, errors, options);
          return;
        }
        var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
        var ruleType = rule.type;
        if (custom.indexOf(ruleType) > -1) {
          if (!types[ruleType](value)) {
            errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
          }
        } else if (ruleType && typeof value !== rule.type) {
          errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      };
      var range = function range2(rule, value, source, errors, options) {
        var len = typeof rule.len === "number";
        var min2 = typeof rule.min === "number";
        var max2 = typeof rule.max === "number";
        var val = value;
        var key = null;
        var num = typeof value === "number";
        var str = typeof value === "string";
        var arr = Array.isArray(value);
        if (num) {
          key = "number";
        } else if (str) {
          key = "string";
        } else if (arr) {
          key = "array";
        }
        if (!key) {
          return false;
        }
        if (arr) {
          val = value.length;
        }
        if (str) {
          val = value.length;
        }
        if (len) {
          if (val !== rule.len) {
            errors.push(format(options.messages[key].len, rule.fullField, rule.len));
          }
        } else if (min2 && !max2 && val < rule.min) {
          errors.push(format(options.messages[key].min, rule.fullField, rule.min));
        } else if (max2 && !min2 && val > rule.max) {
          errors.push(format(options.messages[key].max, rule.fullField, rule.max));
        } else if (min2 && max2 && (val < rule.min || val > rule.max)) {
          errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
        }
      };
      var ENUM$1 = "enum";
      var enumerable$1 = function enumerable(rule, value, source, errors, options) {
        rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
        if (rule[ENUM$1].indexOf(value) === -1) {
          errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
        }
      };
      var pattern$1 = function pattern(rule, value, source, errors, options) {
        if (rule.pattern) {
          if (rule.pattern instanceof RegExp) {
            rule.pattern.lastIndex = 0;
            if (!rule.pattern.test(value)) {
              errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          } else if (typeof rule.pattern === "string") {
            var _pattern = new RegExp(rule.pattern);
            if (!_pattern.test(value)) {
              errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          }
        }
      };
      var rules = {
        required: required$1,
        whitespace,
        type: type$1,
        range,
        "enum": enumerable$1,
        pattern: pattern$1
      };
      var string = function string2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "string");
          if (!isEmptyValue(value, "string")) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
            rules.pattern(rule, value, source, errors, options);
            if (rule.whitespace === true) {
              rules.whitespace(rule, value, source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var method2 = function method3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var number2 = function number3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (value === "") {
            value = void 0;
          }
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var _boolean = function _boolean2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var regexp2 = function regexp3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var integer2 = function integer3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var floatFn = function floatFn2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var array2 = function array3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if ((value === void 0 || value === null) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "array");
          if (value !== void 0 && value !== null) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var object2 = function object3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var ENUM = "enum";
      var enumerable2 = function enumerable3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules[ENUM](rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var pattern2 = function pattern3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "string")) {
            rules.pattern(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var date2 = function date3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "date") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "date")) {
            var dateObject;
            if (value instanceof Date) {
              dateObject = value;
            } else {
              dateObject = new Date(value);
            }
            rules.type(rule, dateObject, source, errors, options);
            if (dateObject) {
              rules.range(rule, dateObject.getTime(), source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var required2 = function required3(rule, value, callback, source, options) {
        var errors = [];
        var type4 = Array.isArray(value) ? "array" : typeof value;
        rules.required(rule, value, source, errors, options, type4);
        callback(errors);
      };
      var type2 = function type3(rule, value, callback, source, options) {
        var ruleType = rule.type;
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, ruleType) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, ruleType);
          if (!isEmptyValue(value, ruleType)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var any = function any2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
        }
        callback(errors);
      };
      var validators = {
        string,
        method: method2,
        number: number2,
        "boolean": _boolean,
        regexp: regexp2,
        integer: integer2,
        "float": floatFn,
        array: array2,
        object: object2,
        "enum": enumerable2,
        pattern: pattern2,
        date: date2,
        url: type2,
        hex: type2,
        email: type2,
        required: required2,
        any
      };
      function newMessages() {
        return {
          "default": "Validation error on field %s",
          required: "%s is required",
          "enum": "%s must be one of %s",
          whitespace: "%s cannot be empty",
          date: {
            format: "%s date %s is invalid for format %s",
            parse: "%s date could not be parsed, %s is invalid ",
            invalid: "%s date %s is invalid"
          },
          types: {
            string: "%s is not a %s",
            method: "%s is not a %s (function)",
            array: "%s is not an %s",
            object: "%s is not an %s",
            number: "%s is not a %s",
            date: "%s is not a %s",
            "boolean": "%s is not a %s",
            integer: "%s is not an %s",
            "float": "%s is not a %s",
            regexp: "%s is not a valid %s",
            email: "%s is not a valid %s",
            url: "%s is not a valid %s",
            hex: "%s is not a valid %s"
          },
          string: {
            len: "%s must be exactly %s characters",
            min: "%s must be at least %s characters",
            max: "%s cannot be longer than %s characters",
            range: "%s must be between %s and %s characters"
          },
          number: {
            len: "%s must equal %s",
            min: "%s cannot be less than %s",
            max: "%s cannot be greater than %s",
            range: "%s must be between %s and %s"
          },
          array: {
            len: "%s must be exactly %s in length",
            min: "%s cannot be less than %s in length",
            max: "%s cannot be greater than %s in length",
            range: "%s must be between %s and %s in length"
          },
          pattern: {
            mismatch: "%s value %s does not match pattern %s"
          },
          clone: function clone2() {
            var cloned = JSON.parse(JSON.stringify(this));
            cloned.clone = this.clone;
            return cloned;
          }
        };
      }
      var messages = newMessages();
      var Schema = /* @__PURE__ */ function() {
        function Schema2(descriptor) {
          this.rules = null;
          this._messages = messages;
          this.define(descriptor);
        }
        var _proto = Schema2.prototype;
        _proto.define = function define(rules2) {
          var _this = this;
          if (!rules2) {
            throw new Error("Cannot configure a schema with no rules");
          }
          if (typeof rules2 !== "object" || Array.isArray(rules2)) {
            throw new Error("Rules must be an object");
          }
          this.rules = {};
          Object.keys(rules2).forEach(function(name) {
            var item = rules2[name];
            _this.rules[name] = Array.isArray(item) ? item : [item];
          });
        };
        _proto.messages = function messages2(_messages) {
          if (_messages) {
            this._messages = deepMerge(newMessages(), _messages);
          }
          return this._messages;
        };
        _proto.validate = function validate(source_, o2, oc) {
          var _this2 = this;
          if (o2 === void 0) {
            o2 = {};
          }
          if (oc === void 0) {
            oc = function oc2() {
            };
          }
          var source = source_;
          var options = o2;
          var callback = oc;
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          if (!this.rules || Object.keys(this.rules).length === 0) {
            if (callback) {
              callback(null, source);
            }
            return Promise.resolve(source);
          }
          function complete(results) {
            var errors = [];
            var fields = {};
            function add2(e) {
              if (Array.isArray(e)) {
                var _errors;
                errors = (_errors = errors).concat.apply(_errors, e);
              } else {
                errors.push(e);
              }
            }
            for (var i = 0; i < results.length; i++) {
              add2(results[i]);
            }
            if (!errors.length) {
              callback(null, source);
            } else {
              fields = convertFieldsError(errors);
              callback(errors, fields);
            }
          }
          if (options.messages) {
            var messages$1 = this.messages();
            if (messages$1 === messages) {
              messages$1 = newMessages();
            }
            deepMerge(messages$1, options.messages);
            options.messages = messages$1;
          } else {
            options.messages = this.messages();
          }
          var series = {};
          var keys2 = options.keys || Object.keys(this.rules);
          keys2.forEach(function(z) {
            var arr = _this2.rules[z];
            var value = source[z];
            arr.forEach(function(r) {
              var rule = r;
              if (typeof rule.transform === "function") {
                if (source === source_) {
                  source = _extends({}, source);
                }
                value = source[z] = rule.transform(value);
              }
              if (typeof rule === "function") {
                rule = {
                  validator: rule
                };
              } else {
                rule = _extends({}, rule);
              }
              rule.validator = _this2.getValidationMethod(rule);
              if (!rule.validator) {
                return;
              }
              rule.field = z;
              rule.fullField = rule.fullField || z;
              rule.type = _this2.getType(rule);
              series[z] = series[z] || [];
              series[z].push({
                rule,
                value,
                source,
                field: z
              });
            });
          });
          var errorFields = {};
          return asyncMap(series, options, function(data, doIt) {
            var rule = data.rule;
            var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
            deep = deep && (rule.required || !rule.required && data.value);
            rule.field = data.field;
            function addFullField(key, schema) {
              return _extends({}, schema, {
                fullField: rule.fullField + "." + key,
                fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
              });
            }
            function cb(e) {
              if (e === void 0) {
                e = [];
              }
              var errorList = Array.isArray(e) ? e : [e];
              if (!options.suppressWarning && errorList.length) {
                Schema2.warning("async-validator:", errorList);
              }
              if (errorList.length && rule.message !== void 0) {
                errorList = [].concat(rule.message);
              }
              var filledErrors = errorList.map(complementError(rule, source));
              if (options.first && filledErrors.length) {
                errorFields[rule.field] = 1;
                return doIt(filledErrors);
              }
              if (!deep) {
                doIt(filledErrors);
              } else {
                if (rule.required && !data.value) {
                  if (rule.message !== void 0) {
                    filledErrors = [].concat(rule.message).map(complementError(rule, source));
                  } else if (options.error) {
                    filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                  }
                  return doIt(filledErrors);
                }
                var fieldsSchema = {};
                if (rule.defaultField) {
                  Object.keys(data.value).map(function(key) {
                    fieldsSchema[key] = rule.defaultField;
                  });
                }
                fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
                var paredFieldsSchema = {};
                Object.keys(fieldsSchema).forEach(function(field) {
                  var fieldSchema = fieldsSchema[field];
                  var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                  paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
                });
                var schema = new Schema2(paredFieldsSchema);
                schema.messages(options.messages);
                if (data.rule.options) {
                  data.rule.options.messages = options.messages;
                  data.rule.options.error = options.error;
                }
                schema.validate(data.value, data.rule.options || options, function(errs) {
                  var finalErrors = [];
                  if (filledErrors && filledErrors.length) {
                    finalErrors.push.apply(finalErrors, filledErrors);
                  }
                  if (errs && errs.length) {
                    finalErrors.push.apply(finalErrors, errs);
                  }
                  doIt(finalErrors.length ? finalErrors : null);
                });
              }
            }
            var res;
            if (rule.asyncValidator) {
              res = rule.asyncValidator(rule, data.value, cb, data.source, options);
            } else if (rule.validator) {
              try {
                res = rule.validator(rule, data.value, cb, data.source, options);
              } catch (error) {
                console.error == null ? void 0 : console.error(error);
                if (!options.suppressValidatorError) {
                  setTimeout(function() {
                    throw error;
                  }, 0);
                }
                cb(error.message);
              }
              if (res === true) {
                cb();
              } else if (res === false) {
                cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
              } else if (res instanceof Array) {
                cb(res);
              } else if (res instanceof Error) {
                cb(res.message);
              }
            }
            if (res && res.then) {
              res.then(function() {
                return cb();
              }, function(e) {
                return cb(e);
              });
            }
          }, function(results) {
            complete(results);
          }, source);
        };
        _proto.getType = function getType(rule) {
          if (rule.type === void 0 && rule.pattern instanceof RegExp) {
            rule.type = "pattern";
          }
          if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
            throw new Error(format("Unknown rule type %s", rule.type));
          }
          return rule.type || "string";
        };
        _proto.getValidationMethod = function getValidationMethod(rule) {
          if (typeof rule.validator === "function") {
            return rule.validator;
          }
          var keys2 = Object.keys(rule);
          var messageIndex = keys2.indexOf("message");
          if (messageIndex !== -1) {
            keys2.splice(messageIndex, 1);
          }
          if (keys2.length === 1 && keys2[0] === "required") {
            return validators.required;
          }
          return validators[this.getType(rule)] || void 0;
        };
        return Schema2;
      }();
      Schema.register = function register(type4, validator) {
        if (typeof validator !== "function") {
          throw new Error("Cannot register a validator by type, validator is not a function");
        }
        validators[type4] = validator;
      };
      Schema.warning = warning;
      Schema.messages = messages;
      Schema.validators = validators;
      const formItemValidateStates = exports("formItemValidateStates", [
        "",
        "error",
        "validating",
        "success"
      ]);
      const formItemProps = exports("formItemProps", buildProps({
        label: String,
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        labelPosition: {
          type: String,
          values: ["left", "right", "top", ""],
          default: ""
        },
        prop: {
          type: definePropType([String, Array])
        },
        required: {
          type: Boolean,
          default: void 0
        },
        rules: {
          type: definePropType([Object, Array])
        },
        error: String,
        validateStatus: {
          type: String,
          values: formItemValidateStates
        },
        for: String,
        inlineMessage: {
          type: [String, Boolean],
          default: ""
        },
        showMessage: {
          type: Boolean,
          default: true
        },
        size: {
          type: String,
          values: componentSizes
        }
      }));
      const COMPONENT_NAME$o = "ElLabelWrap";
      var FormLabelWrap = defineComponent({
        name: COMPONENT_NAME$o,
        props: {
          isAutoWidth: Boolean,
          updateAll: Boolean
        },
        setup(props2, {
          slots
        }) {
          const formContext = inject(formContextKey, void 0);
          const formItemContext = inject(formItemContextKey);
          if (!formItemContext)
            throwError(COMPONENT_NAME$o, "usage: <el-form-item><label-wrap /></el-form-item>");
          const ns = useNamespace("form");
          const el = ref();
          const computedWidth = ref(0);
          const getLabelWidth = () => {
            var _a;
            if ((_a = el.value) == null ? void 0 : _a.firstElementChild) {
              const width = window.getComputedStyle(el.value.firstElementChild).width;
              return Math.ceil(Number.parseFloat(width));
            } else {
              return 0;
            }
          };
          const updateLabelWidth = (action = "update") => {
            nextTick(() => {
              if (slots.default && props2.isAutoWidth) {
                if (action === "update") {
                  computedWidth.value = getLabelWidth();
                } else if (action === "remove") {
                  formContext == null ? void 0 : formContext.deregisterLabelWidth(computedWidth.value);
                }
              }
            });
          };
          const updateLabelWidthFn = () => updateLabelWidth("update");
          onMounted(() => {
            updateLabelWidthFn();
          });
          onBeforeUnmount(() => {
            updateLabelWidth("remove");
          });
          onUpdated(() => updateLabelWidthFn());
          watch(computedWidth, (val, oldVal) => {
            if (props2.updateAll) {
              formContext == null ? void 0 : formContext.registerLabelWidth(val, oldVal);
            }
          });
          useResizeObserver(computed(() => {
            var _a, _b;
            return (_b = (_a = el.value) == null ? void 0 : _a.firstElementChild) != null ? _b : null;
          }), updateLabelWidthFn);
          return () => {
            var _a, _b;
            if (!slots)
              return null;
            const {
              isAutoWidth
            } = props2;
            if (isAutoWidth) {
              const autoLabelWidth = formContext == null ? void 0 : formContext.autoLabelWidth;
              const hasLabel = formItemContext == null ? void 0 : formItemContext.hasLabel;
              const style = {};
              if (hasLabel && autoLabelWidth && autoLabelWidth !== "auto") {
                const marginWidth = Math.max(0, Number.parseInt(autoLabelWidth, 10) - computedWidth.value);
                const labelPosition = formItemContext.labelPosition || formContext.labelPosition;
                const marginPosition = labelPosition === "left" ? "marginRight" : "marginLeft";
                if (marginWidth) {
                  style[marginPosition] = `${marginWidth}px`;
                }
              }
              return createVNode("div", {
                "ref": el,
                "class": [ns.be("item", "label-wrap")],
                "style": style
              }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
            } else {
              return createVNode(Fragment, {
                "ref": el
              }, [(_b = slots.default) == null ? void 0 : _b.call(slots)]);
            }
          };
        }
      });
      const __default__$1W = defineComponent({
        name: "ElFormItem"
      });
      const _sfc_main$2w = /* @__PURE__ */ defineComponent({
        ...__default__$1W,
        props: formItemProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const slots = useSlots();
          const formContext = inject(formContextKey, void 0);
          const parentFormItemContext = inject(formItemContextKey, void 0);
          const _size = useFormSize(void 0, { formItem: false });
          const ns = useNamespace("form-item");
          const labelId = useId().value;
          const inputIds = ref([]);
          const validateState = ref("");
          const validateStateDebounced = refDebounced(validateState, 100);
          const validateMessage = ref("");
          const formItemRef = ref();
          let initialValue = void 0;
          let isResettingField = false;
          const labelPosition = computed(() => props2.labelPosition || (formContext == null ? void 0 : formContext.labelPosition));
          const labelStyle = computed(() => {
            if (labelPosition.value === "top") {
              return {};
            }
            const labelWidth = addUnit(props2.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
            if (labelWidth)
              return { width: labelWidth };
            return {};
          });
          const contentStyle = computed(() => {
            if (labelPosition.value === "top" || (formContext == null ? void 0 : formContext.inline)) {
              return {};
            }
            if (!props2.label && !props2.labelWidth && isNested) {
              return {};
            }
            const labelWidth = addUnit(props2.labelWidth || (formContext == null ? void 0 : formContext.labelWidth) || "");
            if (!props2.label && !slots.label) {
              return { marginLeft: labelWidth };
            }
            return {};
          });
          const formItemClasses = computed(() => [
            ns.b(),
            ns.m(_size.value),
            ns.is("error", validateState.value === "error"),
            ns.is("validating", validateState.value === "validating"),
            ns.is("success", validateState.value === "success"),
            ns.is("required", isRequired.value || props2.required),
            ns.is("no-asterisk", formContext == null ? void 0 : formContext.hideRequiredAsterisk),
            (formContext == null ? void 0 : formContext.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
            {
              [ns.m("feedback")]: formContext == null ? void 0 : formContext.statusIcon,
              [ns.m(`label-${labelPosition.value}`)]: labelPosition.value
            }
          ]);
          const _inlineMessage = computed(() => isBoolean(props2.inlineMessage) ? props2.inlineMessage : (formContext == null ? void 0 : formContext.inlineMessage) || false);
          const validateClasses = computed(() => [
            ns.e("error"),
            { [ns.em("error", "inline")]: _inlineMessage.value }
          ]);
          const propString = computed(() => {
            if (!props2.prop)
              return "";
            return isArray$1(props2.prop) ? props2.prop.join(".") : props2.prop;
          });
          const hasLabel = computed(() => {
            return !!(props2.label || slots.label);
          });
          const labelFor = computed(() => {
            var _a;
            return (_a = props2.for) != null ? _a : inputIds.value.length === 1 ? inputIds.value[0] : void 0;
          });
          const isGroup = computed(() => {
            return !labelFor.value && hasLabel.value;
          });
          const isNested = !!parentFormItemContext;
          const fieldValue = computed(() => {
            const model = formContext == null ? void 0 : formContext.model;
            if (!model || !props2.prop) {
              return;
            }
            return getProp(model, props2.prop).value;
          });
          const normalizedRules = computed(() => {
            const { required } = props2;
            const rules2 = [];
            if (props2.rules) {
              rules2.push(...castArray$1(props2.rules));
            }
            const formRules = formContext == null ? void 0 : formContext.rules;
            if (formRules && props2.prop) {
              const _rules = getProp(formRules, props2.prop).value;
              if (_rules) {
                rules2.push(...castArray$1(_rules));
              }
            }
            if (required !== void 0) {
              const requiredRules = rules2.map((rule, i) => [rule, i]).filter(([rule]) => Object.keys(rule).includes("required"));
              if (requiredRules.length > 0) {
                for (const [rule, i] of requiredRules) {
                  if (rule.required === required)
                    continue;
                  rules2[i] = { ...rule, required };
                }
              } else {
                rules2.push({ required });
              }
            }
            return rules2;
          });
          const validateEnabled = computed(() => normalizedRules.value.length > 0);
          const getFilteredRule = (trigger) => {
            const rules2 = normalizedRules.value;
            return rules2.filter((rule) => {
              if (!rule.trigger || !trigger)
                return true;
              if (isArray$1(rule.trigger)) {
                return rule.trigger.includes(trigger);
              } else {
                return rule.trigger === trigger;
              }
            }).map(({ trigger: trigger2, ...rule }) => rule);
          };
          const isRequired = computed(() => normalizedRules.value.some((rule) => rule.required));
          const shouldShowError = computed(() => {
            var _a;
            return validateStateDebounced.value === "error" && props2.showMessage && ((_a = formContext == null ? void 0 : formContext.showMessage) != null ? _a : true);
          });
          const currentLabel = computed(() => `${props2.label || ""}${(formContext == null ? void 0 : formContext.labelSuffix) || ""}`);
          const setValidationState = (state) => {
            validateState.value = state;
          };
          const onValidationFailed = (error) => {
            var _a, _b;
            const { errors, fields } = error;
            if (!errors || !fields) {
              console.error(error);
            }
            setValidationState("error");
            validateMessage.value = errors ? (_b = (_a = errors == null ? void 0 : errors[0]) == null ? void 0 : _a.message) != null ? _b : `${props2.prop} is required` : "";
            formContext == null ? void 0 : formContext.emit("validate", props2.prop, false, validateMessage.value);
          };
          const onValidationSucceeded = () => {
            setValidationState("success");
            formContext == null ? void 0 : formContext.emit("validate", props2.prop, true, "");
          };
          const doValidate = async (rules2) => {
            const modelName = propString.value;
            const validator = new Schema({
              [modelName]: rules2
            });
            return validator.validate({ [modelName]: fieldValue.value }, { firstFields: true }).then(() => {
              onValidationSucceeded();
              return true;
            }).catch((err) => {
              onValidationFailed(err);
              return Promise.reject(err);
            });
          };
          const validate = async (trigger, callback) => {
            if (isResettingField || !props2.prop) {
              return false;
            }
            const hasCallback = isFunction$1(callback);
            if (!validateEnabled.value) {
              callback == null ? void 0 : callback(false);
              return false;
            }
            const rules2 = getFilteredRule(trigger);
            if (rules2.length === 0) {
              callback == null ? void 0 : callback(true);
              return true;
            }
            setValidationState("validating");
            return doValidate(rules2).then(() => {
              callback == null ? void 0 : callback(true);
              return true;
            }).catch((err) => {
              const { fields } = err;
              callback == null ? void 0 : callback(false, fields);
              return hasCallback ? false : Promise.reject(fields);
            });
          };
          const clearValidate = () => {
            setValidationState("");
            validateMessage.value = "";
            isResettingField = false;
          };
          const resetField = async () => {
            const model = formContext == null ? void 0 : formContext.model;
            if (!model || !props2.prop)
              return;
            const computedValue = getProp(model, props2.prop);
            isResettingField = true;
            computedValue.value = clone(initialValue);
            await nextTick();
            clearValidate();
            isResettingField = false;
          };
          const addInputId = (id) => {
            if (!inputIds.value.includes(id)) {
              inputIds.value.push(id);
            }
          };
          const removeInputId = (id) => {
            inputIds.value = inputIds.value.filter((listId) => listId !== id);
          };
          watch(() => props2.error, (val) => {
            validateMessage.value = val || "";
            setValidationState(val ? "error" : "");
          }, { immediate: true });
          watch(() => props2.validateStatus, (val) => setValidationState(val || ""));
          const context = reactive({
            ...toRefs(props2),
            $el: formItemRef,
            size: _size,
            validateMessage,
            validateState,
            labelId,
            inputIds,
            isGroup,
            hasLabel,
            fieldValue,
            addInputId,
            removeInputId,
            resetField,
            clearValidate,
            validate,
            propString
          });
          provide(formItemContextKey, context);
          onMounted(() => {
            if (props2.prop) {
              formContext == null ? void 0 : formContext.addField(context);
              initialValue = clone(fieldValue.value);
            }
          });
          onBeforeUnmount(() => {
            formContext == null ? void 0 : formContext.removeField(context);
          });
          expose({
            size: _size,
            validateMessage,
            validateState,
            validate,
            clearValidate,
            resetField
          });
          return (_ctx, _cache) => {
            var _a;
            return openBlock(), createElementBlock("div", {
              ref_key: "formItemRef",
              ref: formItemRef,
              class: normalizeClass(unref(formItemClasses)),
              role: unref(isGroup) ? "group" : void 0,
              "aria-labelledby": unref(isGroup) ? unref(labelId) : void 0
            }, [
              createVNode(unref(FormLabelWrap), {
                "is-auto-width": unref(labelStyle).width === "auto",
                "update-all": ((_a = unref(formContext)) == null ? void 0 : _a.labelWidth) === "auto"
              }, {
                default: withCtx(() => [
                  unref(hasLabel) ? (openBlock(), createBlock(resolveDynamicComponent(unref(labelFor) ? "label" : "div"), {
                    key: 0,
                    id: unref(labelId),
                    for: unref(labelFor),
                    class: normalizeClass(unref(ns).e("label")),
                    style: normalizeStyle(unref(labelStyle))
                  }, {
                    default: withCtx(() => [
                      renderSlot(_ctx.$slots, "label", { label: unref(currentLabel) }, () => [
                        createTextVNode(toDisplayString(unref(currentLabel)), 1)
                      ])
                    ]),
                    _: 3
                  }, 8, ["id", "for", "class", "style"])) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["is-auto-width", "update-all"]),
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("content")),
                style: normalizeStyle(unref(contentStyle))
              }, [
                renderSlot(_ctx.$slots, "default"),
                createVNode(TransitionGroup, {
                  name: `${unref(ns).namespace.value}-zoom-in-top`
                }, {
                  default: withCtx(() => [
                    unref(shouldShowError) ? renderSlot(_ctx.$slots, "error", {
                      key: 0,
                      error: validateMessage.value
                    }, () => [
                      createElementVNode("div", {
                        class: normalizeClass(unref(validateClasses))
                      }, toDisplayString(validateMessage.value), 3)
                    ]) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["name"])
              ], 6)
            ], 10, ["role", "aria-labelledby"]);
          };
        }
      });
      var FormItem = /* @__PURE__ */ _export_sfc(_sfc_main$2w, [["__file", "form-item.vue"]]);
      const ElForm = exports("ElForm", withInstall(Form, {
        FormItem
      }));
      const ElFormItem = exports("ElFormItem", withNoopInstall(FormItem));
      let hiddenTextarea = void 0;
      const HIDDEN_STYLE = {
        height: "0",
        visibility: "hidden",
        overflow: isFirefox() ? "" : "hidden",
        position: "absolute",
        "z-index": "-1000",
        top: "0",
        right: "0"
      };
      const CONTEXT_STYLE = [
        "letter-spacing",
        "line-height",
        "padding-top",
        "padding-bottom",
        "font-family",
        "font-weight",
        "font-size",
        "text-rendering",
        "text-transform",
        "width",
        "text-indent",
        "padding-left",
        "padding-right",
        "border-width",
        "box-sizing"
      ];
      function calculateNodeStyling(targetElement) {
        const style = window.getComputedStyle(targetElement);
        const boxSizing = style.getPropertyValue("box-sizing");
        const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
        const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
        const contextStyle = CONTEXT_STYLE.map((name) => [
          name,
          style.getPropertyValue(name)
        ]);
        return { contextStyle, paddingSize, borderSize, boxSizing };
      }
      function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
        var _a, _b;
        if (!hiddenTextarea) {
          hiddenTextarea = document.createElement("textarea");
          ((_a = targetElement.parentNode) != null ? _a : document.body).appendChild(hiddenTextarea);
        }
        const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
        contextStyle.forEach(([key, value]) => hiddenTextarea == null ? void 0 : hiddenTextarea.style.setProperty(key, value));
        Object.entries(HIDDEN_STYLE).forEach(([key, value]) => hiddenTextarea == null ? void 0 : hiddenTextarea.style.setProperty(key, value, "important"));
        hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
        let height = hiddenTextarea.scrollHeight;
        const result2 = {};
        if (boxSizing === "border-box") {
          height = height + borderSize;
        } else if (boxSizing === "content-box") {
          height = height - paddingSize;
        }
        hiddenTextarea.value = "";
        const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
        if (isNumber(minRows)) {
          let minHeight = singleRowHeight * minRows;
          if (boxSizing === "border-box") {
            minHeight = minHeight + paddingSize + borderSize;
          }
          height = Math.max(minHeight, height);
          result2.minHeight = `${minHeight}px`;
        }
        if (isNumber(maxRows)) {
          let maxHeight = singleRowHeight * maxRows;
          if (boxSizing === "border-box") {
            maxHeight = maxHeight + paddingSize + borderSize;
          }
          height = Math.min(maxHeight, height);
        }
        result2.height = `${height}px`;
        (_b = hiddenTextarea.parentNode) == null ? void 0 : _b.removeChild(hiddenTextarea);
        hiddenTextarea = void 0;
        return result2;
      }
      const inputProps = exports("inputProps", buildProps({
        id: {
          type: String,
          default: void 0
        },
        size: useSizeProp,
        disabled: Boolean,
        modelValue: {
          type: definePropType([
            String,
            Number,
            Object
          ]),
          default: ""
        },
        maxlength: {
          type: [String, Number]
        },
        minlength: {
          type: [String, Number]
        },
        type: {
          type: String,
          default: "text"
        },
        resize: {
          type: String,
          values: ["none", "both", "horizontal", "vertical"]
        },
        autosize: {
          type: definePropType([Boolean, Object]),
          default: false
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        formatter: {
          type: Function
        },
        parser: {
          type: Function
        },
        placeholder: {
          type: String
        },
        form: {
          type: String
        },
        readonly: Boolean,
        clearable: Boolean,
        showPassword: Boolean,
        showWordLimit: Boolean,
        suffixIcon: {
          type: iconPropType
        },
        prefixIcon: {
          type: iconPropType
        },
        containerRole: {
          type: String,
          default: void 0
        },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        inputStyle: {
          type: definePropType([Object, Array, String]),
          default: () => mutable({})
        },
        autofocus: Boolean,
        rows: {
          type: Number,
          default: 2
        },
        ...useAriaProps(["ariaLabel"]),
        inputmode: {
          type: definePropType(String),
          default: void 0
        },
        name: String
      }));
      const inputEmits = exports("inputEmits", {
        [UPDATE_MODEL_EVENT]: (value) => isString$1(value),
        input: (value) => isString$1(value),
        change: (value) => isString$1(value),
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent,
        clear: () => true,
        mouseleave: (evt) => evt instanceof MouseEvent,
        mouseenter: (evt) => evt instanceof MouseEvent,
        keydown: (evt) => evt instanceof Event,
        compositionstart: (evt) => evt instanceof CompositionEvent,
        compositionupdate: (evt) => evt instanceof CompositionEvent,
        compositionend: (evt) => evt instanceof CompositionEvent
      });
      const COMPONENT_NAME$n = "ElInput";
      const __default__$1V = defineComponent({
        name: COMPONENT_NAME$n,
        inheritAttrs: false
      });
      const _sfc_main$2v = /* @__PURE__ */ defineComponent({
        ...__default__$1V,
        props: inputProps,
        emits: inputEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const rawAttrs = useAttrs$1();
          const attrs = useAttrs();
          const slots = useSlots();
          const containerKls = computed(() => [
            props2.type === "textarea" ? nsTextarea.b() : nsInput.b(),
            nsInput.m(inputSize.value),
            nsInput.is("disabled", inputDisabled.value),
            nsInput.is("exceed", inputExceed.value),
            {
              [nsInput.b("group")]: slots.prepend || slots.append,
              [nsInput.m("prefix")]: slots.prefix || props2.prefixIcon,
              [nsInput.m("suffix")]: slots.suffix || props2.suffixIcon || props2.clearable || props2.showPassword,
              [nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value,
              [nsInput.b("hidden")]: props2.type === "hidden"
            },
            rawAttrs.class
          ]);
          const wrapperKls = computed(() => [
            nsInput.e("wrapper"),
            nsInput.is("focus", isFocused.value)
          ]);
          const { form: elForm, formItem: elFormItem } = useFormItem();
          const { inputId } = useFormItemInputId(props2, {
            formItemContext: elFormItem
          });
          const inputSize = useFormSize();
          const inputDisabled = useFormDisabled();
          const nsInput = useNamespace("input");
          const nsTextarea = useNamespace("textarea");
          const input = shallowRef();
          const textarea = shallowRef();
          const hovering = ref(false);
          const passwordVisible = ref(false);
          const countStyle = ref();
          const textareaCalcStyle = shallowRef(props2.inputStyle);
          const _ref = computed(() => input.value || textarea.value);
          const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(_ref, {
            disabled: inputDisabled,
            afterBlur() {
              var _a;
              if (props2.validateEvent) {
                (_a = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "blur").catch((err) => debugWarn());
              }
            }
          });
          const needStatusIcon = computed(() => {
            var _a;
            return (_a = elForm == null ? void 0 : elForm.statusIcon) != null ? _a : false;
          });
          const validateState = computed(() => (elFormItem == null ? void 0 : elFormItem.validateState) || "");
          const validateIcon = computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
          const passwordIcon = computed(() => passwordVisible.value ? view_default$1 : hide_default$1);
          const containerStyle = computed(() => [
            rawAttrs.style
          ]);
          const textareaStyle = computed(() => [
            props2.inputStyle,
            textareaCalcStyle.value,
            { resize: props2.resize }
          ]);
          const nativeInputValue = computed(() => isNil(props2.modelValue) ? "" : String(props2.modelValue));
          const showClear = computed(() => props2.clearable && !inputDisabled.value && !props2.readonly && !!nativeInputValue.value && (isFocused.value || hovering.value));
          const showPwdVisible = computed(() => props2.showPassword && !inputDisabled.value && !!nativeInputValue.value);
          const isWordLimitVisible = computed(() => props2.showWordLimit && !!props2.maxlength && (props2.type === "text" || props2.type === "textarea") && !inputDisabled.value && !props2.readonly && !props2.showPassword);
          const textLength = computed(() => nativeInputValue.value.length);
          const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(props2.maxlength));
          const suffixVisible = computed(() => !!slots.suffix || !!props2.suffixIcon || showClear.value || props2.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
          const [recordCursor, setCursor] = useCursor(input);
          useResizeObserver(textarea, (entries) => {
            onceInitSizeTextarea();
            if (!isWordLimitVisible.value || props2.resize !== "both")
              return;
            const entry = entries[0];
            const { width } = entry.contentRect;
            countStyle.value = {
              right: `calc(100% - ${width + 15 + 6}px)`
            };
          });
          const resizeTextarea = () => {
            const { type, autosize } = props2;
            if (!isClient || type !== "textarea" || !textarea.value)
              return;
            if (autosize) {
              const minRows = isObject$1(autosize) ? autosize.minRows : void 0;
              const maxRows = isObject$1(autosize) ? autosize.maxRows : void 0;
              const textareaStyle2 = calcTextareaHeight(textarea.value, minRows, maxRows);
              textareaCalcStyle.value = {
                overflowY: "hidden",
                ...textareaStyle2
              };
              nextTick(() => {
                textarea.value.offsetHeight;
                textareaCalcStyle.value = textareaStyle2;
              });
            } else {
              textareaCalcStyle.value = {
                minHeight: calcTextareaHeight(textarea.value).minHeight
              };
            }
          };
          const createOnceInitResize = (resizeTextarea2) => {
            let isInit = false;
            return () => {
              var _a;
              if (isInit || !props2.autosize)
                return;
              const isElHidden = ((_a = textarea.value) == null ? void 0 : _a.offsetParent) === null;
              if (!isElHidden) {
                resizeTextarea2();
                isInit = true;
              }
            };
          };
          const onceInitSizeTextarea = createOnceInitResize(resizeTextarea);
          const setNativeInputValue = () => {
            const input2 = _ref.value;
            const formatterValue = props2.formatter ? props2.formatter(nativeInputValue.value) : nativeInputValue.value;
            if (!input2 || input2.value === formatterValue)
              return;
            input2.value = formatterValue;
          };
          const handleInput = async (event) => {
            recordCursor();
            let { value } = event.target;
            if (props2.formatter && props2.parser) {
              value = props2.parser(value);
            }
            if (isComposing.value)
              return;
            if (value === nativeInputValue.value) {
              setNativeInputValue();
              return;
            }
            emit(UPDATE_MODEL_EVENT, value);
            emit(INPUT_EVENT, value);
            await nextTick();
            setNativeInputValue();
            setCursor();
          };
          const handleChange = (event) => {
            let { value } = event.target;
            if (props2.formatter && props2.parser) {
              value = props2.parser(value);
            }
            emit(CHANGE_EVENT, value);
          };
          const {
            isComposing,
            handleCompositionStart,
            handleCompositionUpdate,
            handleCompositionEnd
          } = useComposition({ emit, afterComposition: handleInput });
          const handlePasswordVisible = () => {
            recordCursor();
            passwordVisible.value = !passwordVisible.value;
            setTimeout(setCursor);
          };
          const focus = () => {
            var _a;
            return (_a = _ref.value) == null ? void 0 : _a.focus();
          };
          const blur = () => {
            var _a;
            return (_a = _ref.value) == null ? void 0 : _a.blur();
          };
          const handleMouseLeave = (evt) => {
            hovering.value = false;
            emit("mouseleave", evt);
          };
          const handleMouseEnter = (evt) => {
            hovering.value = true;
            emit("mouseenter", evt);
          };
          const handleKeydown = (evt) => {
            emit("keydown", evt);
          };
          const select = () => {
            var _a;
            (_a = _ref.value) == null ? void 0 : _a.select();
          };
          const clear = () => {
            emit(UPDATE_MODEL_EVENT, "");
            emit(CHANGE_EVENT, "");
            emit("clear");
            emit(INPUT_EVENT, "");
          };
          watch(() => props2.modelValue, () => {
            var _a;
            nextTick(() => resizeTextarea());
            if (props2.validateEvent) {
              (_a = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "change").catch((err) => debugWarn());
            }
          });
          watch(nativeInputValue, () => setNativeInputValue());
          watch(() => props2.type, async () => {
            await nextTick();
            setNativeInputValue();
            resizeTextarea();
          });
          onMounted(() => {
            if (!props2.formatter && props2.parser)
              ;
            setNativeInputValue();
            nextTick(resizeTextarea);
          });
          expose({
            input,
            textarea,
            ref: _ref,
            textareaStyle,
            autosize: toRef(props2, "autosize"),
            isComposing,
            focus,
            blur,
            select,
            clear,
            resizeTextarea
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(containerKls),
                {
                  [unref(nsInput).bm("group", "append")]: _ctx.$slots.append,
                  [unref(nsInput).bm("group", "prepend")]: _ctx.$slots.prepend
                }
              ]),
              style: normalizeStyle(unref(containerStyle)),
              onMouseenter: handleMouseEnter,
              onMouseleave: handleMouseLeave
            }, [
              createCommentVNode(" input "),
              _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createCommentVNode(" prepend slot "),
                _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(nsInput).be("group", "prepend"))
                }, [
                  renderSlot(_ctx.$slots, "prepend")
                ], 2)) : createCommentVNode("v-if", true),
                createElementVNode("div", {
                  ref_key: "wrapperRef",
                  ref: wrapperRef,
                  class: normalizeClass(unref(wrapperKls))
                }, [
                  createCommentVNode(" prefix slot "),
                  _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(nsInput).e("prefix"))
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass(unref(nsInput).e("prefix-inner"))
                    }, [
                      renderSlot(_ctx.$slots, "prefix"),
                      _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass(unref(nsInput).e("icon"))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true),
                  createElementVNode("input", mergeProps({
                    id: unref(inputId),
                    ref_key: "input",
                    ref: input,
                    class: unref(nsInput).e("inner")
                  }, unref(attrs), {
                    name: _ctx.name,
                    minlength: _ctx.minlength,
                    maxlength: _ctx.maxlength,
                    type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
                    disabled: unref(inputDisabled),
                    readonly: _ctx.readonly,
                    autocomplete: _ctx.autocomplete,
                    tabindex: _ctx.tabindex,
                    "aria-label": _ctx.ariaLabel,
                    placeholder: _ctx.placeholder,
                    style: _ctx.inputStyle,
                    form: _ctx.form,
                    autofocus: _ctx.autofocus,
                    role: _ctx.containerRole,
                    inputmode: _ctx.inputmode,
                    onCompositionstart: unref(handleCompositionStart),
                    onCompositionupdate: unref(handleCompositionUpdate),
                    onCompositionend: unref(handleCompositionEnd),
                    onInput: handleInput,
                    onChange: handleChange,
                    onKeydown: handleKeydown
                  }), null, 16, ["id", "name", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus", "role", "inputmode", "onCompositionstart", "onCompositionupdate", "onCompositionend"]),
                  createCommentVNode(" suffix slot "),
                  unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass(unref(nsInput).e("suffix"))
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass(unref(nsInput).e("suffix-inner"))
                    }, [
                      !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        renderSlot(_ctx.$slots, "suffix"),
                        _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                          key: 0,
                          class: normalizeClass(unref(nsInput).e("icon"))
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                          ]),
                          _: 1
                        }, 8, ["class"])) : createCommentVNode("v-if", true)
                      ], 64)) : createCommentVNode("v-if", true),
                      unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 1,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                        onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                        onClick: clear
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(circle_close_default$1))
                        ]),
                        _: 1
                      }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                      unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 2,
                        class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
                        onClick: handlePasswordVisible
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true),
                      unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                        key: 3,
                        class: normalizeClass(unref(nsInput).e("count"))
                      }, [
                        createElementVNode("span", {
                          class: normalizeClass(unref(nsInput).e("count-inner"))
                        }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 3)
                      ], 2)) : createCommentVNode("v-if", true),
                      unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 4,
                        class: normalizeClass([
                          unref(nsInput).e("icon"),
                          unref(nsInput).e("validateIcon"),
                          unref(nsInput).is("loading", unref(validateState) === "validating")
                        ])
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true)
                ], 2),
                createCommentVNode(" append slot "),
                _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(nsInput).be("group", "append"))
                }, [
                  renderSlot(_ctx.$slots, "append")
                ], 2)) : createCommentVNode("v-if", true)
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createCommentVNode(" textarea "),
                createElementVNode("textarea", mergeProps({
                  id: unref(inputId),
                  ref_key: "textarea",
                  ref: textarea,
                  class: [unref(nsTextarea).e("inner"), unref(nsInput).is("focus", unref(isFocused))]
                }, unref(attrs), {
                  minlength: _ctx.minlength,
                  maxlength: _ctx.maxlength,
                  tabindex: _ctx.tabindex,
                  disabled: unref(inputDisabled),
                  readonly: _ctx.readonly,
                  autocomplete: _ctx.autocomplete,
                  style: unref(textareaStyle),
                  "aria-label": _ctx.ariaLabel,
                  placeholder: _ctx.placeholder,
                  form: _ctx.form,
                  autofocus: _ctx.autofocus,
                  rows: _ctx.rows,
                  role: _ctx.containerRole,
                  onCompositionstart: unref(handleCompositionStart),
                  onCompositionupdate: unref(handleCompositionUpdate),
                  onCompositionend: unref(handleCompositionEnd),
                  onInput: handleInput,
                  onFocus: unref(handleFocus),
                  onBlur: unref(handleBlur),
                  onChange: handleChange,
                  onKeydown: handleKeydown
                }), null, 16, ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus", "rows", "role", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onFocus", "onBlur"]),
                unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  style: normalizeStyle(countStyle.value),
                  class: normalizeClass(unref(nsInput).e("count"))
                }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 7)) : createCommentVNode("v-if", true)
              ], 64))
            ], 38);
          };
        }
      });
      var Input = /* @__PURE__ */ _export_sfc(_sfc_main$2v, [["__file", "input.vue"]]);
      const ElInput = exports("ElInput", withInstall(Input));
      const GAP = exports("GAP", 4);
      const BAR_MAP = exports("BAR_MAP", {
        vertical: {
          offset: "offsetHeight",
          scroll: "scrollTop",
          scrollSize: "scrollHeight",
          size: "height",
          key: "vertical",
          axis: "Y",
          client: "clientY",
          direction: "top"
        },
        horizontal: {
          offset: "offsetWidth",
          scroll: "scrollLeft",
          scrollSize: "scrollWidth",
          size: "width",
          key: "horizontal",
          axis: "X",
          client: "clientX",
          direction: "left"
        }
      });
      const renderThumbStyle$1 = exports("renderThumbStyle", ({
        move,
        size,
        bar
      }) => ({
        [bar.size]: size,
        transform: `translate${bar.axis}(${move}%)`
      }));
      const scrollbarContextKey = exports("scrollbarContextKey", Symbol("scrollbarContextKey"));
      const thumbProps = exports("thumbProps", buildProps({
        vertical: Boolean,
        size: String,
        move: Number,
        ratio: {
          type: Number,
          required: true
        },
        always: Boolean
      }));
      const COMPONENT_NAME$m = "Thumb";
      const _sfc_main$2u = /* @__PURE__ */ defineComponent({
        __name: "thumb",
        props: thumbProps,
        setup(__props) {
          const props2 = __props;
          const scrollbar = inject(scrollbarContextKey);
          const ns = useNamespace("scrollbar");
          if (!scrollbar)
            throwError(COMPONENT_NAME$m, "can not inject scrollbar context");
          const instance = ref();
          const thumb = ref();
          const thumbState = ref({});
          const visible = ref(false);
          let cursorDown = false;
          let cursorLeave = false;
          let baseScrollHeight = 0;
          let baseScrollWidth = 0;
          let originalOnSelectStart = isClient ? document.onselectstart : null;
          const bar = computed(() => BAR_MAP[props2.vertical ? "vertical" : "horizontal"]);
          const thumbStyle = computed(() => renderThumbStyle$1({
            size: props2.size,
            move: props2.move,
            bar: bar.value
          }));
          const offsetRatio = computed(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props2.ratio / thumb.value[bar.value.offset]);
          const clickThumbHandler = (e) => {
            var _a;
            e.stopPropagation();
            if (e.ctrlKey || [1, 2].includes(e.button))
              return;
            (_a = window.getSelection()) == null ? void 0 : _a.removeAllRanges();
            startDrag(e);
            const el = e.currentTarget;
            if (!el)
              return;
            thumbState.value[bar.value.axis] = el[bar.value.offset] - (e[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
          };
          const clickTrackHandler = (e) => {
            if (!thumb.value || !instance.value || !scrollbar.wrapElement)
              return;
            const offset2 = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
            const thumbHalf = thumb.value[bar.value.offset] / 2;
            const thumbPositionPercentage = (offset2 - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
          };
          const startDrag = (e) => {
            e.stopImmediatePropagation();
            cursorDown = true;
            baseScrollHeight = scrollbar.wrapElement.scrollHeight;
            baseScrollWidth = scrollbar.wrapElement.scrollWidth;
            document.addEventListener("mousemove", mouseMoveDocumentHandler);
            document.addEventListener("mouseup", mouseUpDocumentHandler);
            originalOnSelectStart = document.onselectstart;
            document.onselectstart = () => false;
          };
          const mouseMoveDocumentHandler = (e) => {
            if (!instance.value || !thumb.value)
              return;
            if (cursorDown === false)
              return;
            const prevPage = thumbState.value[bar.value.axis];
            if (!prevPage)
              return;
            const offset2 = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
            const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
            const thumbPositionPercentage = (offset2 - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
            if (bar.value.scroll === "scrollLeft") {
              scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * baseScrollWidth / 100;
            } else {
              scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * baseScrollHeight / 100;
            }
          };
          const mouseUpDocumentHandler = () => {
            cursorDown = false;
            thumbState.value[bar.value.axis] = 0;
            document.removeEventListener("mousemove", mouseMoveDocumentHandler);
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
            restoreOnselectstart();
            if (cursorLeave)
              visible.value = false;
          };
          const mouseMoveScrollbarHandler = () => {
            cursorLeave = false;
            visible.value = !!props2.size;
          };
          const mouseLeaveScrollbarHandler = () => {
            cursorLeave = true;
            visible.value = cursorDown;
          };
          onBeforeUnmount(() => {
            restoreOnselectstart();
            document.removeEventListener("mouseup", mouseUpDocumentHandler);
          });
          const restoreOnselectstart = () => {
            if (document.onselectstart !== originalOnSelectStart)
              document.onselectstart = originalOnSelectStart;
          };
          useEventListener(toRef(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
          useEventListener(toRef(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createElementVNode("div", {
                  ref_key: "instance",
                  ref: instance,
                  class: normalizeClass([unref(ns).e("bar"), unref(ns).is(unref(bar).key)]),
                  onMousedown: clickTrackHandler,
                  onClick: withModifiers(() => {
                  }, ["stop"])
                }, [
                  createElementVNode("div", {
                    ref_key: "thumb",
                    ref: thumb,
                    class: normalizeClass(unref(ns).e("thumb")),
                    style: normalizeStyle(unref(thumbStyle)),
                    onMousedown: clickThumbHandler
                  }, null, 38)
                ], 42, ["onClick"]), [
                  [vShow, _ctx.always || visible.value]
                ])
              ]),
              _: 1
            }, 8, ["name"]);
          };
        }
      });
      var Thumb = /* @__PURE__ */ _export_sfc(_sfc_main$2u, [["__file", "thumb.vue"]]);
      const barProps = buildProps({
        always: {
          type: Boolean,
          default: true
        },
        minSize: {
          type: Number,
          required: true
        }
      });
      const _sfc_main$2t = /* @__PURE__ */ defineComponent({
        __name: "bar",
        props: barProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const scrollbar = inject(scrollbarContextKey);
          const moveX = ref(0);
          const moveY = ref(0);
          const sizeWidth = ref("");
          const sizeHeight = ref("");
          const ratioY = ref(1);
          const ratioX = ref(1);
          const handleScroll2 = (wrap2) => {
            if (wrap2) {
              const offsetHeight = wrap2.offsetHeight - GAP;
              const offsetWidth = wrap2.offsetWidth - GAP;
              moveY.value = wrap2.scrollTop * 100 / offsetHeight * ratioY.value;
              moveX.value = wrap2.scrollLeft * 100 / offsetWidth * ratioX.value;
            }
          };
          const update2 = () => {
            const wrap2 = scrollbar == null ? void 0 : scrollbar.wrapElement;
            if (!wrap2)
              return;
            const offsetHeight = wrap2.offsetHeight - GAP;
            const offsetWidth = wrap2.offsetWidth - GAP;
            const originalHeight = offsetHeight ** 2 / wrap2.scrollHeight;
            const originalWidth = offsetWidth ** 2 / wrap2.scrollWidth;
            const height = Math.max(originalHeight, props2.minSize);
            const width = Math.max(originalWidth, props2.minSize);
            ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
            ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
            sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
            sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
          };
          expose({
            handleScroll: handleScroll2,
            update: update2
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(Thumb, {
                move: moveX.value,
                ratio: ratioX.value,
                size: sizeWidth.value,
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"]),
              createVNode(Thumb, {
                move: moveY.value,
                ratio: ratioY.value,
                size: sizeHeight.value,
                vertical: "",
                always: _ctx.always
              }, null, 8, ["move", "ratio", "size", "always"])
            ], 64);
          };
        }
      });
      var Bar = /* @__PURE__ */ _export_sfc(_sfc_main$2t, [["__file", "bar.vue"]]);
      const scrollbarProps = exports("scrollbarProps", buildProps({
        distance: {
          type: Number,
          default: 0
        },
        height: {
          type: [String, Number],
          default: ""
        },
        maxHeight: {
          type: [String, Number],
          default: ""
        },
        native: Boolean,
        wrapStyle: {
          type: definePropType([String, Object, Array]),
          default: ""
        },
        wrapClass: {
          type: [String, Array],
          default: ""
        },
        viewClass: {
          type: [String, Array],
          default: ""
        },
        viewStyle: {
          type: [String, Array, Object],
          default: ""
        },
        noresize: Boolean,
        tag: {
          type: String,
          default: "div"
        },
        always: Boolean,
        minSize: {
          type: Number,
          default: 20
        },
        tabindex: {
          type: [String, Number],
          default: void 0
        },
        id: String,
        role: String,
        ...useAriaProps(["ariaLabel", "ariaOrientation"])
      }));
      const scrollbarEmits = exports("scrollbarEmits", {
        "end-reached": (direction2) => ["left", "right", "top", "bottom"].includes(direction2),
        scroll: ({
          scrollTop,
          scrollLeft
        }) => [scrollTop, scrollLeft].every(isNumber)
      });
      const COMPONENT_NAME$l = "ElScrollbar";
      const __default__$1U = defineComponent({
        name: COMPONENT_NAME$l
      });
      const _sfc_main$2s = /* @__PURE__ */ defineComponent({
        ...__default__$1U,
        props: scrollbarProps,
        emits: scrollbarEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const ns = useNamespace("scrollbar");
          let stopResizeObserver = void 0;
          let stopWrapResizeObserver = void 0;
          let stopResizeListener = void 0;
          let wrapScrollTop = 0;
          let wrapScrollLeft = 0;
          let direction2 = "";
          const distanceScrollState = {
            bottom: false,
            top: false,
            right: false,
            left: false
          };
          const scrollbarRef = ref();
          const wrapRef = ref();
          const resizeRef = ref();
          const barRef = ref();
          const wrapStyle = computed(() => {
            const style = {};
            if (props2.height)
              style.height = addUnit(props2.height);
            if (props2.maxHeight)
              style.maxHeight = addUnit(props2.maxHeight);
            return [props2.wrapStyle, style];
          });
          const wrapKls = computed(() => {
            return [
              props2.wrapClass,
              ns.e("wrap"),
              { [ns.em("wrap", "hidden-default")]: !props2.native }
            ];
          });
          const resizeKls = computed(() => {
            return [ns.e("view"), props2.viewClass];
          });
          const shouldSkipDirection = (direction22) => {
            var _a;
            return (_a = distanceScrollState[direction22]) != null ? _a : false;
          };
          const DIRECTION_PAIRS = {
            top: "bottom",
            bottom: "top",
            left: "right",
            right: "left"
          };
          const updateTriggerStatus = (arrivedStates) => {
            const oppositeDirection = DIRECTION_PAIRS[direction2];
            if (!oppositeDirection)
              return;
            const arrived = arrivedStates[direction2];
            const oppositeArrived = arrivedStates[oppositeDirection];
            if (arrived && !distanceScrollState[direction2]) {
              distanceScrollState[direction2] = true;
            }
            if (!oppositeArrived && distanceScrollState[oppositeDirection]) {
              distanceScrollState[oppositeDirection] = false;
            }
          };
          const handleScroll2 = () => {
            var _a;
            if (wrapRef.value) {
              (_a = barRef.value) == null ? void 0 : _a.handleScroll(wrapRef.value);
              const prevTop = wrapScrollTop;
              const prevLeft = wrapScrollLeft;
              wrapScrollTop = wrapRef.value.scrollTop;
              wrapScrollLeft = wrapRef.value.scrollLeft;
              const arrivedStates = {
                bottom: wrapScrollTop + wrapRef.value.clientHeight >= wrapRef.value.scrollHeight - props2.distance,
                top: wrapScrollTop <= props2.distance && prevTop !== 0,
                right: wrapScrollLeft + wrapRef.value.clientWidth >= wrapRef.value.scrollWidth - props2.distance && prevLeft !== wrapScrollLeft,
                left: wrapScrollLeft <= props2.distance && prevLeft !== 0
              };
              emit("scroll", {
                scrollTop: wrapScrollTop,
                scrollLeft: wrapScrollLeft
              });
              if (prevTop !== wrapScrollTop) {
                direction2 = wrapScrollTop > prevTop ? "bottom" : "top";
              }
              if (prevLeft !== wrapScrollLeft) {
                direction2 = wrapScrollLeft > prevLeft ? "right" : "left";
              }
              if (props2.distance > 0) {
                if (shouldSkipDirection(direction2)) {
                  return;
                }
                updateTriggerStatus(arrivedStates);
              }
              if (arrivedStates[direction2])
                emit("end-reached", direction2);
            }
          };
          function scrollTo(arg1, arg2) {
            if (isObject$1(arg1)) {
              wrapRef.value.scrollTo(arg1);
            } else if (isNumber(arg1) && isNumber(arg2)) {
              wrapRef.value.scrollTo(arg1, arg2);
            }
          }
          const setScrollTop = (value) => {
            if (!isNumber(value)) {
              return;
            }
            wrapRef.value.scrollTop = value;
          };
          const setScrollLeft = (value) => {
            if (!isNumber(value)) {
              return;
            }
            wrapRef.value.scrollLeft = value;
          };
          const update2 = () => {
            var _a;
            (_a = barRef.value) == null ? void 0 : _a.update();
            distanceScrollState[direction2] = false;
          };
          watch(() => props2.noresize, (noresize) => {
            if (noresize) {
              stopResizeObserver == null ? void 0 : stopResizeObserver();
              stopWrapResizeObserver == null ? void 0 : stopWrapResizeObserver();
              stopResizeListener == null ? void 0 : stopResizeListener();
            } else {
              ({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update2));
              ({ stop: stopWrapResizeObserver } = useResizeObserver(wrapRef, update2));
              stopResizeListener = useEventListener("resize", update2);
            }
          }, { immediate: true });
          watch(() => [props2.maxHeight, props2.height], () => {
            if (!props2.native)
              nextTick(() => {
                var _a;
                update2();
                if (wrapRef.value) {
                  (_a = barRef.value) == null ? void 0 : _a.handleScroll(wrapRef.value);
                }
              });
          });
          provide(scrollbarContextKey, reactive({
            scrollbarElement: scrollbarRef,
            wrapElement: wrapRef
          }));
          onActivated(() => {
            if (wrapRef.value) {
              wrapRef.value.scrollTop = wrapScrollTop;
              wrapRef.value.scrollLeft = wrapScrollLeft;
            }
          });
          onMounted(() => {
            if (!props2.native)
              nextTick(() => {
                update2();
              });
          });
          onUpdated(() => update2());
          expose({
            wrapRef,
            update: update2,
            scrollTo,
            setScrollTop,
            setScrollLeft,
            handleScroll: handleScroll2
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "scrollbarRef",
              ref: scrollbarRef,
              class: normalizeClass(unref(ns).b())
            }, [
              createElementVNode("div", {
                ref_key: "wrapRef",
                ref: wrapRef,
                class: normalizeClass(unref(wrapKls)),
                style: normalizeStyle(unref(wrapStyle)),
                tabindex: _ctx.tabindex,
                onScroll: handleScroll2
              }, [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
                  id: _ctx.id,
                  ref_key: "resizeRef",
                  ref: resizeRef,
                  class: normalizeClass(unref(resizeKls)),
                  style: normalizeStyle(_ctx.viewStyle),
                  role: _ctx.role,
                  "aria-label": _ctx.ariaLabel,
                  "aria-orientation": _ctx.ariaOrientation
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
              ], 46, ["tabindex"]),
              !_ctx.native ? (openBlock(), createBlock(Bar, {
                key: 0,
                ref_key: "barRef",
                ref: barRef,
                always: _ctx.always,
                "min-size": _ctx.minSize
              }, null, 8, ["always", "min-size"])) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Scrollbar$1 = /* @__PURE__ */ _export_sfc(_sfc_main$2s, [["__file", "scrollbar.vue"]]);
      const ElScrollbar = exports("ElScrollbar", withInstall(Scrollbar$1));
      const POPPER_INJECTION_KEY = exports("POPPER_INJECTION_KEY", Symbol("popper"));
      const POPPER_CONTENT_INJECTION_KEY = exports("POPPER_CONTENT_INJECTION_KEY", Symbol("popperContent"));
      const Effect = exports("Effect", {
        LIGHT: "light",
        DARK: "dark"
      });
      const roleTypes = exports("roleTypes", [
        "dialog",
        "grid",
        "group",
        "listbox",
        "menu",
        "navigation",
        "tooltip",
        "tree"
      ]);
      const popperProps = exports("popperProps", buildProps({
        role: {
          type: String,
          values: roleTypes,
          default: "tooltip"
        }
      }));
      const usePopperProps = exports("usePopperProps", popperProps);
      const __default__$1T = defineComponent({
        name: "ElPopper",
        inheritAttrs: false
      });
      const _sfc_main$2r = /* @__PURE__ */ defineComponent({
        ...__default__$1T,
        props: popperProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const triggerRef2 = ref();
          const popperInstanceRef = ref();
          const contentRef = ref();
          const referenceRef = ref();
          const role = computed(() => props2.role);
          const popperProvides = {
            triggerRef: triggerRef2,
            popperInstanceRef,
            contentRef,
            referenceRef,
            role
          };
          expose(popperProvides);
          provide(POPPER_INJECTION_KEY, popperProvides);
          return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default");
          };
        }
      });
      var Popper = /* @__PURE__ */ _export_sfc(_sfc_main$2r, [["__file", "popper.vue"]]);
      const __default__$1S = defineComponent({
        name: "ElPopperArrow",
        inheritAttrs: false
      });
      const _sfc_main$2q = /* @__PURE__ */ defineComponent({
        ...__default__$1S,
        setup(__props, { expose }) {
          const ns = useNamespace("popper");
          const { arrowRef, arrowStyle } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
          onBeforeUnmount(() => {
            arrowRef.value = void 0;
          });
          expose({
            arrowRef
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              ref_key: "arrowRef",
              ref: arrowRef,
              class: normalizeClass(unref(ns).e("arrow")),
              style: normalizeStyle(unref(arrowStyle)),
              "data-popper-arrow": ""
            }, null, 6);
          };
        }
      });
      var ElPopperArrow = exports("ElPopperArrow", /* @__PURE__ */ _export_sfc(_sfc_main$2q, [["__file", "arrow.vue"]]));
      const NAME = "ElOnlyChild";
      const OnlyChild = defineComponent({
        name: NAME,
        setup(_2, {
          slots,
          attrs
        }) {
          var _a;
          const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
          const forwardRefDirective = useForwardRefDirective((_a = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a : NOOP);
          return () => {
            var _a2;
            const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots, attrs);
            if (!defaultSlot)
              return null;
            if (defaultSlot.length > 1) {
              return null;
            }
            const firstLegitNode = findFirstLegitChild(defaultSlot);
            if (!firstLegitNode) {
              return null;
            }
            return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
          };
        }
      });
      function findFirstLegitChild(node) {
        if (!node)
          return null;
        const children = node;
        for (const child of children) {
          if (isObject$1(child)) {
            switch (child.type) {
              case Comment:
                continue;
              case Text$1:
              case "svg":
                return wrapTextContent(child);
              case Fragment:
                return findFirstLegitChild(child.children);
              default:
                return child;
            }
          }
          return wrapTextContent(child);
        }
        return null;
      }
      function wrapTextContent(s2) {
        const ns = useNamespace("only-child");
        return createVNode("span", {
          "class": ns.e("content")
        }, [s2]);
      }
      const popperTriggerProps = exports("popperTriggerProps", buildProps({
        virtualRef: {
          type: definePropType(Object)
        },
        virtualTriggering: Boolean,
        onMouseenter: {
          type: definePropType(Function)
        },
        onMouseleave: {
          type: definePropType(Function)
        },
        onClick: {
          type: definePropType(Function)
        },
        onKeydown: {
          type: definePropType(Function)
        },
        onFocus: {
          type: definePropType(Function)
        },
        onBlur: {
          type: definePropType(Function)
        },
        onContextmenu: {
          type: definePropType(Function)
        },
        id: String,
        open: Boolean
      }));
      const usePopperTriggerProps = exports("usePopperTriggerProps", popperTriggerProps);
      const __default__$1R = defineComponent({
        name: "ElPopperTrigger",
        inheritAttrs: false
      });
      const _sfc_main$2p = /* @__PURE__ */ defineComponent({
        ...__default__$1R,
        props: popperTriggerProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const { role, triggerRef: triggerRef2 } = inject(POPPER_INJECTION_KEY, void 0);
          useForwardRef(triggerRef2);
          const ariaControls = computed(() => {
            return ariaHaspopup.value ? props2.id : void 0;
          });
          const ariaDescribedby = computed(() => {
            if (role && role.value === "tooltip") {
              return props2.open && props2.id ? props2.id : void 0;
            }
            return void 0;
          });
          const ariaHaspopup = computed(() => {
            if (role && role.value !== "tooltip") {
              return role.value;
            }
            return void 0;
          });
          const ariaExpanded = computed(() => {
            return ariaHaspopup.value ? `${props2.open}` : void 0;
          });
          let virtualTriggerAriaStopWatch = void 0;
          const TRIGGER_ELE_EVENTS = [
            "onMouseenter",
            "onMouseleave",
            "onClick",
            "onKeydown",
            "onFocus",
            "onBlur",
            "onContextmenu"
          ];
          onMounted(() => {
            watch(() => props2.virtualRef, (virtualEl) => {
              if (virtualEl) {
                triggerRef2.value = unrefElement(virtualEl);
              }
            }, {
              immediate: true
            });
            watch(triggerRef2, (el, prevEl) => {
              virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
              virtualTriggerAriaStopWatch = void 0;
              if (isElement$2(el)) {
                TRIGGER_ELE_EVENTS.forEach((eventName) => {
                  var _a;
                  const handler = props2[eventName];
                  if (handler) {
                    el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                    (_a = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a.call(prevEl, eventName.slice(2).toLowerCase(), handler);
                  }
                });
                if (isFocusable(el)) {
                  virtualTriggerAriaStopWatch = watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
                    [
                      "aria-controls",
                      "aria-describedby",
                      "aria-haspopup",
                      "aria-expanded"
                    ].forEach((key, idx) => {
                      isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                    });
                  }, { immediate: true });
                }
              }
              if (isElement$2(prevEl) && isFocusable(prevEl)) {
                [
                  "aria-controls",
                  "aria-describedby",
                  "aria-haspopup",
                  "aria-expanded"
                ].forEach((key) => prevEl.removeAttribute(key));
              }
            }, {
              immediate: true
            });
          });
          onBeforeUnmount(() => {
            virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
            virtualTriggerAriaStopWatch = void 0;
            if (triggerRef2.value && isElement$2(triggerRef2.value)) {
              const el = triggerRef2.value;
              TRIGGER_ELE_EVENTS.forEach((eventName) => {
                const handler = props2[eventName];
                if (handler) {
                  el.removeEventListener(eventName.slice(2).toLowerCase(), handler);
                }
              });
              triggerRef2.value = void 0;
            }
          });
          expose({
            triggerRef: triggerRef2
          });
          return (_ctx, _cache) => {
            return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
              "aria-controls": unref(ariaControls),
              "aria-describedby": unref(ariaDescribedby),
              "aria-expanded": unref(ariaExpanded),
              "aria-haspopup": unref(ariaHaspopup)
            }), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : createCommentVNode("v-if", true);
          };
        }
      });
      var ElPopperTrigger = exports("ElPopperTrigger", /* @__PURE__ */ _export_sfc(_sfc_main$2p, [["__file", "trigger.vue"]]));
      const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
      const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
      const FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
      const FOCUS_AFTER_TRAPPED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const FOCUSOUT_PREVENTED_OPTS = {
        cancelable: true,
        bubbles: false
      };
      const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
      const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
      const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
      const focusReason = ref();
      const lastUserFocusTimestamp = ref(0);
      const lastAutomatedFocusTimestamp = ref(0);
      let focusReasonUserCount = 0;
      const obtainAllFocusableElements = (element) => {
        const nodes = [];
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
          acceptNode: (node) => {
            const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
            if (node.disabled || node.hidden || isHiddenInput)
              return NodeFilter.FILTER_SKIP;
            return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
          }
        });
        while (walker.nextNode())
          nodes.push(walker.currentNode);
        return nodes;
      };
      const getVisibleElement = (elements, container) => {
        for (const element of elements) {
          if (!isHidden(element, container))
            return element;
        }
      };
      const isHidden = (element, container) => {
        if (getComputedStyle(element).visibility === "hidden")
          return true;
        while (element) {
          if (container && element === container)
            return false;
          if (getComputedStyle(element).display === "none")
            return true;
          element = element.parentElement;
        }
        return false;
      };
      const getEdges = (container) => {
        const focusable = obtainAllFocusableElements(container);
        const first = getVisibleElement(focusable, container);
        const last2 = getVisibleElement(focusable.reverse(), container);
        return [first, last2];
      };
      const isSelectable = (element) => {
        return element instanceof HTMLInputElement && "select" in element;
      };
      const tryFocus = (element, shouldSelect) => {
        if (element && element.focus) {
          const prevFocusedElement = document.activeElement;
          let cleanup = false;
          if (isElement$2(element) && !isFocusable(element) && !element.getAttribute("tabindex")) {
            element.setAttribute("tabindex", "-1");
            cleanup = true;
          }
          element.focus({ preventScroll: true });
          lastAutomatedFocusTimestamp.value = window.performance.now();
          if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
            element.select();
          }
          if (isElement$2(element) && cleanup) {
            element.removeAttribute("tabindex");
          }
        }
      };
      function removeFromStack(list, item) {
        const copy = [...list];
        const idx = list.indexOf(item);
        if (idx !== -1) {
          copy.splice(idx, 1);
        }
        return copy;
      }
      const createFocusableStack = () => {
        let stack = [];
        const push = (layer) => {
          const currentLayer = stack[0];
          if (currentLayer && layer !== currentLayer) {
            currentLayer.pause();
          }
          stack = removeFromStack(stack, layer);
          stack.unshift(layer);
        };
        const remove2 = (layer) => {
          var _a, _b;
          stack = removeFromStack(stack, layer);
          (_b = (_a = stack[0]) == null ? void 0 : _a.resume) == null ? void 0 : _b.call(_a);
        };
        return {
          push,
          remove: remove2
        };
      };
      const focusFirstDescendant = (elements, shouldSelect = false) => {
        const prevFocusedElement = document.activeElement;
        for (const element of elements) {
          tryFocus(element, shouldSelect);
          if (document.activeElement !== prevFocusedElement)
            return;
        }
      };
      const focusableStack = createFocusableStack();
      const isFocusCausedByUserEvent = () => {
        return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
      };
      const notifyFocusReasonPointer = () => {
        focusReason.value = "pointer";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const notifyFocusReasonKeydown = () => {
        focusReason.value = "keyboard";
        lastUserFocusTimestamp.value = window.performance.now();
      };
      const useFocusReason = () => {
        onMounted(() => {
          if (focusReasonUserCount === 0) {
            document.addEventListener("mousedown", notifyFocusReasonPointer);
            document.addEventListener("touchstart", notifyFocusReasonPointer);
            document.addEventListener("keydown", notifyFocusReasonKeydown);
          }
          focusReasonUserCount++;
        });
        onBeforeUnmount(() => {
          focusReasonUserCount--;
          if (focusReasonUserCount <= 0) {
            document.removeEventListener("mousedown", notifyFocusReasonPointer);
            document.removeEventListener("touchstart", notifyFocusReasonPointer);
            document.removeEventListener("keydown", notifyFocusReasonKeydown);
          }
        });
        return {
          focusReason,
          lastUserFocusTimestamp,
          lastAutomatedFocusTimestamp
        };
      };
      const createFocusOutPreventedEvent = (detail) => {
        return new CustomEvent(FOCUSOUT_PREVENTED, {
          ...FOCUSOUT_PREVENTED_OPTS,
          detail
        });
      };
      const _sfc_main$2o = defineComponent({
        name: "ElFocusTrap",
        inheritAttrs: false,
        props: {
          loop: Boolean,
          trapped: Boolean,
          focusTrapEl: Object,
          focusStartEl: {
            type: [Object, String],
            default: "first"
          }
        },
        emits: [
          ON_TRAP_FOCUS_EVT,
          ON_RELEASE_FOCUS_EVT,
          "focusin",
          "focusout",
          "focusout-prevented",
          "release-requested"
        ],
        setup(props2, { emit }) {
          const forwardRef = ref();
          let lastFocusBeforeTrapped;
          let lastFocusAfterTrapped;
          const { focusReason: focusReason2 } = useFocusReason();
          useEscapeKeydown((event) => {
            if (props2.trapped && !focusLayer.paused) {
              emit("release-requested", event);
            }
          });
          const focusLayer = {
            paused: false,
            pause() {
              this.paused = true;
            },
            resume() {
              this.paused = false;
            }
          };
          const onKeydown = (e) => {
            if (!props2.loop && !props2.trapped)
              return;
            if (focusLayer.paused)
              return;
            const { code, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
            const { loop } = props2;
            const isTabbing = code === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
            const currentFocusingEl = document.activeElement;
            if (isTabbing && currentFocusingEl) {
              const container = currentTarget;
              const [first, last2] = getEdges(container);
              const isTabbable = first && last2;
              if (!isTabbable) {
                if (currentFocusingEl === container) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                  }
                }
              } else {
                if (!shiftKey && currentFocusingEl === last2) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                    if (loop)
                      tryFocus(first, true);
                  }
                } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    e.preventDefault();
                    if (loop)
                      tryFocus(last2, true);
                  }
                }
              }
            }
          };
          provide(FOCUS_TRAP_INJECTION_KEY, {
            focusTrapRef: forwardRef,
            onKeydown
          });
          watch(() => props2.focusTrapEl, (focusTrapEl) => {
            if (focusTrapEl) {
              forwardRef.value = focusTrapEl;
            }
          }, { immediate: true });
          watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
            if (forwardRef2) {
              forwardRef2.addEventListener("keydown", onKeydown);
              forwardRef2.addEventListener("focusin", onFocusIn);
              forwardRef2.addEventListener("focusout", onFocusOut);
            }
            if (oldForwardRef) {
              oldForwardRef.removeEventListener("keydown", onKeydown);
              oldForwardRef.removeEventListener("focusin", onFocusIn);
              oldForwardRef.removeEventListener("focusout", onFocusOut);
            }
          });
          const trapOnFocus = (e) => {
            emit(ON_TRAP_FOCUS_EVT, e);
          };
          const releaseOnFocus = (e) => emit(ON_RELEASE_FOCUS_EVT, e);
          const onFocusIn = (e) => {
            const trapContainer = unref(forwardRef);
            if (!trapContainer)
              return;
            const target2 = e.target;
            const relatedTarget = e.relatedTarget;
            const isFocusedInTrap = target2 && trapContainer.contains(target2);
            if (!props2.trapped) {
              const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
              if (!isPrevFocusedInTrap) {
                lastFocusBeforeTrapped = relatedTarget;
              }
            }
            if (isFocusedInTrap)
              emit("focusin", e);
            if (focusLayer.paused)
              return;
            if (props2.trapped) {
              if (isFocusedInTrap) {
                lastFocusAfterTrapped = target2;
              } else {
                tryFocus(lastFocusAfterTrapped, true);
              }
            }
          };
          const onFocusOut = (e) => {
            const trapContainer = unref(forwardRef);
            if (focusLayer.paused || !trapContainer)
              return;
            if (props2.trapped) {
              const relatedTarget = e.relatedTarget;
              if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
                setTimeout(() => {
                  if (!focusLayer.paused && props2.trapped) {
                    const focusoutPreventedEvent = createFocusOutPreventedEvent({
                      focusReason: focusReason2.value
                    });
                    emit("focusout-prevented", focusoutPreventedEvent);
                    if (!focusoutPreventedEvent.defaultPrevented) {
                      tryFocus(lastFocusAfterTrapped, true);
                    }
                  }
                }, 0);
              }
            } else {
              const target2 = e.target;
              const isFocusedInTrap = target2 && trapContainer.contains(target2);
              if (!isFocusedInTrap)
                emit("focusout", e);
            }
          };
          async function startTrap() {
            await nextTick();
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              focusableStack.push(focusLayer);
              const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
              lastFocusBeforeTrapped = prevFocusedElement;
              const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
              if (!isPrevFocusContained) {
                const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
                trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
                trapContainer.dispatchEvent(focusEvent);
                if (!focusEvent.defaultPrevented) {
                  nextTick(() => {
                    let focusStartEl = props2.focusStartEl;
                    if (!isString$1(focusStartEl)) {
                      tryFocus(focusStartEl);
                      if (document.activeElement !== focusStartEl) {
                        focusStartEl = "first";
                      }
                    }
                    if (focusStartEl === "first") {
                      focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                    }
                    if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                      tryFocus(trapContainer);
                    }
                  });
                }
              }
            }
          }
          function stopTrap() {
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
              const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
                ...FOCUS_AFTER_TRAPPED_OPTS,
                detail: {
                  focusReason: focusReason2.value
                }
              });
              trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              trapContainer.dispatchEvent(releasedEvent);
              if (!releasedEvent.defaultPrevented && (focusReason2.value == "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
                tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
              }
              trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
              focusableStack.remove(focusLayer);
            }
          }
          onMounted(() => {
            if (props2.trapped) {
              startTrap();
            }
            watch(() => props2.trapped, (trapped) => {
              if (trapped) {
                startTrap();
              } else {
                stopTrap();
              }
            });
          });
          onBeforeUnmount(() => {
            if (props2.trapped) {
              stopTrap();
            }
            if (forwardRef.value) {
              forwardRef.value.removeEventListener("keydown", onKeydown);
              forwardRef.value.removeEventListener("focusin", onFocusIn);
              forwardRef.value.removeEventListener("focusout", onFocusOut);
              forwardRef.value = void 0;
            }
          });
          return {
            onKeydown
          };
        }
      });
      function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
      }
      var ElFocusTrap = /* @__PURE__ */ _export_sfc(_sfc_main$2o, [["render", _sfc_render$o], ["__file", "focus-trap.vue"]]);
      const popperArrowProps = exports("popperArrowProps", buildProps({
        arrowOffset: {
          type: Number,
          default: 5
        }
      }));
      const usePopperArrowProps = exports("usePopperArrowProps", popperArrowProps);
      const POSITIONING_STRATEGIES = ["fixed", "absolute"];
      const popperCoreConfigProps = exports("popperCoreConfigProps", buildProps({
        boundariesPadding: {
          type: Number,
          default: 0
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: void 0
        },
        gpuAcceleration: {
          type: Boolean,
          default: true
        },
        offset: {
          type: Number,
          default: 12
        },
        placement: {
          type: String,
          values: Ee,
          default: "bottom"
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        strategy: {
          type: String,
          values: POSITIONING_STRATEGIES,
          default: "absolute"
        }
      }));
      const popperContentProps = exports("popperContentProps", buildProps({
        ...popperCoreConfigProps,
        ...popperArrowProps,
        id: String,
        style: {
          type: definePropType([String, Array, Object])
        },
        className: {
          type: definePropType([String, Array, Object])
        },
        effect: {
          type: definePropType(String),
          default: "dark"
        },
        visible: Boolean,
        enterable: {
          type: Boolean,
          default: true
        },
        pure: Boolean,
        focusOnShow: Boolean,
        trapping: Boolean,
        popperClass: {
          type: definePropType([String, Array, Object])
        },
        popperStyle: {
          type: definePropType([String, Array, Object])
        },
        referenceEl: {
          type: definePropType(Object)
        },
        triggerTargetEl: {
          type: definePropType(Object)
        },
        stopPopperMouseEvent: {
          type: Boolean,
          default: true
        },
        virtualTriggering: Boolean,
        zIndex: Number,
        ...useAriaProps(["ariaLabel"])
      }));
      const popperContentEmits = exports("popperContentEmits", {
        mouseenter: (evt) => evt instanceof MouseEvent,
        mouseleave: (evt) => evt instanceof MouseEvent,
        focus: () => true,
        blur: () => true,
        close: () => true
      });
      const usePopperCoreConfigProps = exports("usePopperCoreConfigProps", popperCoreConfigProps);
      const usePopperContentProps = exports("usePopperContentProps", popperContentProps);
      const usePopperContentEmits = exports("usePopperContentEmits", popperContentEmits);
      const buildPopperOptions = (props2, modifiers = []) => {
        const { placement, strategy, popperOptions } = props2;
        const options = {
          placement,
          strategy,
          ...popperOptions,
          modifiers: [...genModifiers(props2), ...modifiers]
        };
        deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
        return options;
      };
      const unwrapMeasurableEl = ($el) => {
        if (!isClient)
          return;
        return unrefElement($el);
      };
      function genModifiers(options) {
        const { offset: offset2, gpuAcceleration, fallbackPlacements } = options;
        return [
          {
            name: "offset",
            options: {
              offset: [0, offset2 != null ? offset2 : 12]
            }
          },
          {
            name: "preventOverflow",
            options: {
              padding: {
                top: 2,
                bottom: 2,
                left: 5,
                right: 5
              }
            }
          },
          {
            name: "flip",
            options: {
              padding: 5,
              fallbackPlacements
            }
          },
          {
            name: "computeStyles",
            options: {
              gpuAcceleration
            }
          }
        ];
      }
      function deriveExtraModifiers(options, modifiers) {
        if (modifiers) {
          options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
        }
      }
      const DEFAULT_ARROW_OFFSET = 0;
      const usePopperContent = (props2) => {
        const { popperInstanceRef, contentRef, triggerRef: triggerRef2, role } = inject(POPPER_INJECTION_KEY, void 0);
        const arrowRef = ref();
        const arrowOffset = computed(() => props2.arrowOffset);
        const eventListenerModifier = computed(() => {
          return {
            name: "eventListeners",
            enabled: !!props2.visible
          };
        });
        const arrowModifier = computed(() => {
          var _a;
          const arrowEl = unref(arrowRef);
          const offset2 = (_a = unref(arrowOffset)) != null ? _a : DEFAULT_ARROW_OFFSET;
          return {
            name: "arrow",
            enabled: !isUndefined$1(arrowEl),
            options: {
              element: arrowEl,
              padding: offset2
            }
          };
        });
        const options = computed(() => {
          return {
            onFirstUpdate: () => {
              update2();
            },
            ...buildPopperOptions(props2, [
              unref(arrowModifier),
              unref(eventListenerModifier)
            ])
          };
        });
        const computedReference = computed(() => unwrapMeasurableEl(props2.referenceEl) || unref(triggerRef2));
        const { attributes: attributes2, state, styles, update: update2, forceUpdate, instanceRef } = usePopper(computedReference, contentRef, options);
        watch(instanceRef, (instance) => popperInstanceRef.value = instance, {
          flush: "sync"
        });
        onMounted(() => {
          watch(() => {
            var _a;
            return (_a = unref(computedReference)) == null ? void 0 : _a.getBoundingClientRect();
          }, () => {
            update2();
          });
        });
        return {
          attributes: attributes2,
          arrowRef,
          contentRef,
          instanceRef,
          state,
          styles,
          role,
          forceUpdate,
          update: update2
        };
      };
      const usePopperContentDOM = (props2, {
        attributes: attributes2,
        styles,
        role
      }) => {
        const { nextZIndex } = useZIndex();
        const ns = useNamespace("popper");
        const contentAttrs = computed(() => unref(attributes2).popper);
        const contentZIndex = ref(isNumber(props2.zIndex) ? props2.zIndex : nextZIndex());
        const contentClass = computed(() => [
          ns.b(),
          ns.is("pure", props2.pure),
          ns.is(props2.effect),
          props2.popperClass
        ]);
        const contentStyle = computed(() => {
          return [
            { zIndex: unref(contentZIndex) },
            unref(styles).popper,
            props2.popperStyle || {}
          ];
        });
        const ariaModal = computed(() => role.value === "dialog" ? "false" : void 0);
        const arrowStyle = computed(() => unref(styles).arrow || {});
        const updateZIndex = () => {
          contentZIndex.value = isNumber(props2.zIndex) ? props2.zIndex : nextZIndex();
        };
        return {
          ariaModal,
          arrowStyle,
          contentAttrs,
          contentClass,
          contentStyle,
          contentZIndex,
          updateZIndex
        };
      };
      const usePopperContentFocusTrap = (props2, emit) => {
        const trapped = ref(false);
        const focusStartRef = ref();
        const onFocusAfterTrapped = () => {
          emit("focus");
        };
        const onFocusAfterReleased = (event) => {
          var _a;
          if (((_a = event.detail) == null ? void 0 : _a.focusReason) !== "pointer") {
            focusStartRef.value = "first";
            emit("blur");
          }
        };
        const onFocusInTrap = (event) => {
          if (props2.visible && !trapped.value) {
            if (event.target) {
              focusStartRef.value = event.target;
            }
            trapped.value = true;
          }
        };
        const onFocusoutPrevented = (event) => {
          if (!props2.trapping) {
            if (event.detail.focusReason === "pointer") {
              event.preventDefault();
            }
            trapped.value = false;
          }
        };
        const onReleaseRequested = () => {
          trapped.value = false;
          emit("close");
        };
        return {
          focusStartRef,
          trapped,
          onFocusAfterReleased,
          onFocusAfterTrapped,
          onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        };
      };
      const __default__$1Q = defineComponent({
        name: "ElPopperContent"
      });
      const _sfc_main$2n = /* @__PURE__ */ defineComponent({
        ...__default__$1Q,
        props: popperContentProps,
        emits: popperContentEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const {
            focusStartRef,
            trapped,
            onFocusAfterReleased,
            onFocusAfterTrapped,
            onFocusInTrap,
            onFocusoutPrevented,
            onReleaseRequested
          } = usePopperContentFocusTrap(props2, emit);
          const { attributes: attributes2, arrowRef, contentRef, styles, instanceRef, role, update: update2 } = usePopperContent(props2);
          const {
            ariaModal,
            arrowStyle,
            contentAttrs,
            contentClass,
            contentStyle,
            updateZIndex
          } = usePopperContentDOM(props2, {
            styles,
            attributes: attributes2,
            role
          });
          const formItemContext = inject(formItemContextKey, void 0);
          provide(POPPER_CONTENT_INJECTION_KEY, {
            arrowStyle,
            arrowRef
          });
          if (formItemContext) {
            provide(formItemContextKey, {
              ...formItemContext,
              addInputId: NOOP,
              removeInputId: NOOP
            });
          }
          let triggerTargetAriaStopWatch = void 0;
          const updatePopper = (shouldUpdateZIndex = true) => {
            update2();
            shouldUpdateZIndex && updateZIndex();
          };
          const togglePopperAlive = () => {
            updatePopper(false);
            if (props2.visible && props2.focusOnShow) {
              trapped.value = true;
            } else if (props2.visible === false) {
              trapped.value = false;
            }
          };
          onMounted(() => {
            watch(() => props2.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
              triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
              triggerTargetAriaStopWatch = void 0;
              const el = unref(triggerTargetEl || contentRef.value);
              const prevEl = unref(prevTriggerTargetEl || contentRef.value);
              if (isElement$2(el)) {
                triggerTargetAriaStopWatch = watch([role, () => props2.ariaLabel, ariaModal, () => props2.id], (watches) => {
                  ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
                    isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                  });
                }, { immediate: true });
              }
              if (prevEl !== el && isElement$2(prevEl)) {
                ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
                  prevEl.removeAttribute(key);
                });
              }
            }, { immediate: true });
            watch(() => props2.visible, togglePopperAlive, { immediate: true });
          });
          onBeforeUnmount(() => {
            triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
            triggerTargetAriaStopWatch = void 0;
          });
          expose({
            popperContentRef: contentRef,
            popperInstanceRef: instanceRef,
            updatePopper,
            contentStyle
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", mergeProps({
              ref_key: "contentRef",
              ref: contentRef
            }, unref(contentAttrs), {
              style: unref(contentStyle),
              class: unref(contentClass),
              tabindex: "-1",
              onMouseenter: (e) => _ctx.$emit("mouseenter", e),
              onMouseleave: (e) => _ctx.$emit("mouseleave", e)
            }), [
              createVNode(unref(ElFocusTrap), {
                trapped: unref(trapped),
                "trap-on-focus-in": true,
                "focus-trap-el": unref(contentRef),
                "focus-start-el": unref(focusStartRef),
                onFocusAfterTrapped: unref(onFocusAfterTrapped),
                onFocusAfterReleased: unref(onFocusAfterReleased),
                onFocusin: unref(onFocusInTrap),
                onFocusoutPrevented: unref(onFocusoutPrevented),
                onReleaseRequested: unref(onReleaseRequested)
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
            ], 16, ["onMouseenter", "onMouseleave"]);
          };
        }
      });
      var ElPopperContent = exports("ElPopperContent", /* @__PURE__ */ _export_sfc(_sfc_main$2n, [["__file", "content.vue"]]));
      const ElPopper = exports("ElPopper", withInstall(Popper));
      const TOOLTIP_INJECTION_KEY = exports("TOOLTIP_INJECTION_KEY", Symbol("elTooltip"));
      const teleportProps = buildProps({
        to: {
          type: definePropType([String, Object]),
          required: true
        },
        disabled: Boolean
      });
      const _sfc_main$2m = /* @__PURE__ */ defineComponent({
        __name: "teleport",
        props: teleportProps,
        setup(__props) {
          return (_ctx, _cache) => {
            return _ctx.disabled ? renderSlot(_ctx.$slots, "default", { key: 0 }) : (openBlock(), createBlock(Teleport$1, {
              key: 1,
              to: _ctx.to
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 8, ["to"]));
          };
        }
      });
      var Teleport = /* @__PURE__ */ _export_sfc(_sfc_main$2m, [["__file", "teleport.vue"]]);
      const ElTeleport = withInstall(Teleport);
      var ElTeleport$1 = ElTeleport;
      const useTooltipContentProps = exports("useTooltipContentProps", buildProps({
        ...useDelayedToggleProps,
        ...popperContentProps,
        appendTo: {
          type: teleportProps.to.type
        },
        content: {
          type: String,
          default: ""
        },
        rawContent: Boolean,
        persistent: Boolean,
        visible: {
          type: definePropType(Boolean),
          default: null
        },
        transition: String,
        teleported: {
          type: Boolean,
          default: true
        },
        disabled: Boolean,
        ...useAriaProps(["ariaLabel"])
      }));
      const useTooltipTriggerProps = exports("useTooltipTriggerProps", buildProps({
        ...popperTriggerProps,
        disabled: Boolean,
        trigger: {
          type: definePropType([String, Array]),
          default: "hover"
        },
        triggerKeys: {
          type: definePropType(Array),
          default: () => [EVENT_CODE.enter, EVENT_CODE.numpadEnter, EVENT_CODE.space]
        }
      }));
      const {
        useModelToggleProps: useTooltipModelToggleProps,
        useModelToggleEmits: useTooltipModelToggleEmits,
        useModelToggle: useTooltipModelToggle
      } = createModelToggleComposable("visible");
      exports({ useTooltipModelToggleProps, useTooltipModelToggleEmits, useTooltipModelToggle });
      const useTooltipProps = exports("useTooltipProps", buildProps({
        ...popperProps,
        ...useTooltipModelToggleProps,
        ...useTooltipContentProps,
        ...useTooltipTriggerProps,
        ...popperArrowProps,
        showArrow: {
          type: Boolean,
          default: true
        }
      }));
      const tooltipEmits = exports("tooltipEmits", [
        ...useTooltipModelToggleEmits,
        "before-show",
        "before-hide",
        "show",
        "hide",
        "open",
        "close"
      ]);
      const isTriggerType = (trigger, type) => {
        if (isArray$1(trigger)) {
          return trigger.includes(type);
        }
        return trigger === type;
      };
      const whenTrigger = (trigger, type, handler) => {
        return (e) => {
          isTriggerType(unref(trigger), type) && handler(e);
        };
      };
      const __default__$1P = defineComponent({
        name: "ElTooltipTrigger"
      });
      const _sfc_main$2l = /* @__PURE__ */ defineComponent({
        ...__default__$1P,
        props: useTooltipTriggerProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const ns = useNamespace("tooltip");
          const { controlled, id, open, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const triggerRef2 = ref(null);
          const stopWhenControlledOrDisabled = () => {
            if (unref(controlled) || props2.disabled) {
              return true;
            }
          };
          const trigger = toRef(props2, "trigger");
          const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onOpen));
          const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "hover", onClose));
          const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "click", (e) => {
            if (e.button === 0) {
              onToggle(e);
            }
          }));
          const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onOpen));
          const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "focus", onClose));
          const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger, "contextmenu", (e) => {
            e.preventDefault();
            onToggle(e);
          }));
          const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e) => {
            const { code } = e;
            if (props2.triggerKeys.includes(code)) {
              e.preventDefault();
              onToggle(e);
            }
          });
          expose({
            triggerRef: triggerRef2
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopperTrigger), {
              id: unref(id),
              "virtual-ref": _ctx.virtualRef,
              open: unref(open),
              "virtual-triggering": _ctx.virtualTriggering,
              class: normalizeClass(unref(ns).e("trigger")),
              onBlur: unref(onBlur),
              onClick: unref(onClick),
              onContextmenu: unref(onContextMenu),
              onFocus: unref(onFocus),
              onMouseenter: unref(onMouseenter),
              onMouseleave: unref(onMouseleave),
              onKeydown: unref(onKeydown)
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
          };
        }
      });
      var ElTooltipTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$2l, [["__file", "trigger.vue"]]);
      const __default__$1O = defineComponent({
        name: "ElTooltipContent",
        inheritAttrs: false
      });
      const _sfc_main$2k = /* @__PURE__ */ defineComponent({
        ...__default__$1O,
        props: useTooltipContentProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const { selector } = usePopperContainerId();
          const ns = useNamespace("tooltip");
          const contentRef = ref();
          const popperContentRef = computedEager(() => {
            var _a;
            return (_a = contentRef.value) == null ? void 0 : _a.popperContentRef;
          });
          let stopHandle;
          const {
            controlled,
            id,
            open,
            trigger,
            onClose,
            onOpen,
            onShow,
            onHide,
            onBeforeShow,
            onBeforeHide
          } = inject(TOOLTIP_INJECTION_KEY, void 0);
          const transitionClass = computed(() => {
            return props2.transition || `${ns.namespace.value}-fade-in-linear`;
          });
          const persistentRef = computed(() => {
            return props2.persistent;
          });
          onBeforeUnmount(() => {
            stopHandle == null ? void 0 : stopHandle();
          });
          const shouldRender = computed(() => {
            return unref(persistentRef) ? true : unref(open);
          });
          const shouldShow = computed(() => {
            return props2.disabled ? false : unref(open);
          });
          const appendTo = computed(() => {
            return props2.appendTo || selector.value;
          });
          const contentStyle = computed(() => {
            var _a;
            return (_a = props2.style) != null ? _a : {};
          });
          const ariaHidden = ref(true);
          const onTransitionLeave = () => {
            onHide();
            isFocusInsideContent() && tryFocus(document.body);
            ariaHidden.value = true;
          };
          const stopWhenControlled = () => {
            if (unref(controlled))
              return true;
          };
          const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
            if (props2.enterable && unref(trigger) === "hover") {
              onOpen();
            }
          });
          const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
            if (unref(trigger) === "hover") {
              onClose();
            }
          });
          const onBeforeEnter = () => {
            var _a, _b;
            (_b = (_a = contentRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
            onBeforeShow == null ? void 0 : onBeforeShow();
          };
          const onBeforeLeave = () => {
            onBeforeHide == null ? void 0 : onBeforeHide();
          };
          const onAfterShow = () => {
            onShow();
          };
          const onBlur = () => {
            if (!props2.virtualTriggering) {
              onClose();
            }
          };
          const isFocusInsideContent = (event) => {
            var _a;
            const popperContent = (_a = contentRef.value) == null ? void 0 : _a.popperContentRef;
            const activeElement = (event == null ? void 0 : event.relatedTarget) || document.activeElement;
            return popperContent == null ? void 0 : popperContent.contains(activeElement);
          };
          watch(() => unref(open), (val) => {
            if (!val) {
              stopHandle == null ? void 0 : stopHandle();
            } else {
              ariaHidden.value = false;
              stopHandle = onClickOutside(popperContentRef, () => {
                if (unref(controlled))
                  return;
                const $trigger = unref(trigger);
                if ($trigger !== "hover") {
                  onClose();
                }
              });
            }
          }, {
            flush: "post"
          });
          watch(() => props2.content, () => {
            var _a, _b;
            (_b = (_a = contentRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
          });
          expose({
            contentRef,
            isFocusInsideContent
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTeleport$1), {
              disabled: !_ctx.teleported,
              to: unref(appendTo)
            }, {
              default: withCtx(() => [
                unref(shouldRender) || !ariaHidden.value ? (openBlock(), createBlock(Transition, {
                  key: 0,
                  name: unref(transitionClass),
                  appear: !unref(persistentRef),
                  onAfterLeave: onTransitionLeave,
                  onBeforeEnter,
                  onAfterEnter: onAfterShow,
                  onBeforeLeave,
                  persisted: ""
                }, {
                  default: withCtx(() => [
                    withDirectives(createVNode(unref(ElPopperContent), mergeProps({
                      id: unref(id),
                      ref_key: "contentRef",
                      ref: contentRef
                    }, _ctx.$attrs, {
                      "aria-label": _ctx.ariaLabel,
                      "aria-hidden": ariaHidden.value,
                      "boundaries-padding": _ctx.boundariesPadding,
                      "fallback-placements": _ctx.fallbackPlacements,
                      "gpu-acceleration": _ctx.gpuAcceleration,
                      offset: _ctx.offset,
                      placement: _ctx.placement,
                      "popper-options": _ctx.popperOptions,
                      "arrow-offset": _ctx.arrowOffset,
                      strategy: _ctx.strategy,
                      effect: _ctx.effect,
                      enterable: _ctx.enterable,
                      pure: _ctx.pure,
                      "popper-class": _ctx.popperClass,
                      "popper-style": [_ctx.popperStyle, unref(contentStyle)],
                      "reference-el": _ctx.referenceEl,
                      "trigger-target-el": _ctx.triggerTargetEl,
                      visible: unref(shouldShow),
                      "z-index": _ctx.zIndex,
                      onMouseenter: unref(onContentEnter),
                      onMouseleave: unref(onContentLeave),
                      onBlur,
                      onClose: unref(onClose)
                    }), {
                      default: withCtx(() => [
                        renderSlot(_ctx.$slots, "default")
                      ]),
                      _: 3
                    }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "arrow-offset", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"]), [
                      [vShow, unref(shouldShow)]
                    ])
                  ]),
                  _: 3
                }, 8, ["name", "appear"])) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 8, ["disabled", "to"]);
          };
        }
      });
      var ElTooltipContent = /* @__PURE__ */ _export_sfc(_sfc_main$2k, [["__file", "content.vue"]]);
      const __default__$1N = defineComponent({
        name: "ElTooltip"
      });
      const _sfc_main$2j = /* @__PURE__ */ defineComponent({
        ...__default__$1N,
        props: useTooltipProps,
        emits: tooltipEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          usePopperContainer();
          const ns = useNamespace("tooltip");
          const id = useId();
          const popperRef = ref();
          const contentRef = ref();
          const updatePopper = () => {
            var _a;
            const popperComponent = unref(popperRef);
            if (popperComponent) {
              (_a = popperComponent.popperInstanceRef) == null ? void 0 : _a.update();
            }
          };
          const open = ref(false);
          const toggleReason = ref();
          const { show, hide, hasUpdateHandler } = useTooltipModelToggle({
            indicator: open,
            toggleReason
          });
          const { onOpen, onClose } = useDelayedToggle({
            showAfter: toRef(props2, "showAfter"),
            hideAfter: toRef(props2, "hideAfter"),
            autoClose: toRef(props2, "autoClose"),
            open: show,
            close: hide
          });
          const controlled = computed(() => isBoolean(props2.visible) && !hasUpdateHandler.value);
          const kls = computed(() => {
            return [ns.b(), props2.popperClass];
          });
          provide(TOOLTIP_INJECTION_KEY, {
            controlled,
            id,
            open: readonly(open),
            trigger: toRef(props2, "trigger"),
            onOpen,
            onClose,
            onToggle: (event) => {
              if (unref(open)) {
                onClose(event);
              } else {
                onOpen(event);
              }
            },
            onShow: () => {
              emit("show", toggleReason.value);
            },
            onHide: () => {
              emit("hide", toggleReason.value);
            },
            onBeforeShow: () => {
              emit("before-show", toggleReason.value);
            },
            onBeforeHide: () => {
              emit("before-hide", toggleReason.value);
            },
            updatePopper
          });
          watch(() => props2.disabled, (disabled) => {
            if (disabled && open.value) {
              open.value = false;
            }
          });
          const isFocusInsideContent = (event) => {
            var _a;
            return (_a = contentRef.value) == null ? void 0 : _a.isFocusInsideContent(event);
          };
          onDeactivated(() => open.value && hide());
          expose({
            popperRef,
            contentRef,
            isFocusInsideContent,
            updatePopper,
            onOpen,
            onClose,
            hide
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElPopper), {
              ref_key: "popperRef",
              ref: popperRef,
              role: _ctx.role
            }, {
              default: withCtx(() => [
                createVNode(ElTooltipTrigger, {
                  disabled: _ctx.disabled,
                  trigger: _ctx.trigger,
                  "trigger-keys": _ctx.triggerKeys,
                  "virtual-ref": _ctx.virtualRef,
                  "virtual-triggering": _ctx.virtualTriggering
                }, {
                  default: withCtx(() => [
                    _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
                createVNode(ElTooltipContent, {
                  ref_key: "contentRef",
                  ref: contentRef,
                  "aria-label": _ctx.ariaLabel,
                  "boundaries-padding": _ctx.boundariesPadding,
                  content: _ctx.content,
                  disabled: _ctx.disabled,
                  effect: _ctx.effect,
                  enterable: _ctx.enterable,
                  "fallback-placements": _ctx.fallbackPlacements,
                  "hide-after": _ctx.hideAfter,
                  "gpu-acceleration": _ctx.gpuAcceleration,
                  offset: _ctx.offset,
                  persistent: _ctx.persistent,
                  "popper-class": unref(kls),
                  "popper-style": _ctx.popperStyle,
                  placement: _ctx.placement,
                  "popper-options": _ctx.popperOptions,
                  "arrow-offset": _ctx.arrowOffset,
                  pure: _ctx.pure,
                  "raw-content": _ctx.rawContent,
                  "reference-el": _ctx.referenceEl,
                  "trigger-target-el": _ctx.triggerTargetEl,
                  "show-after": _ctx.showAfter,
                  strategy: _ctx.strategy,
                  teleported: _ctx.teleported,
                  transition: _ctx.transition,
                  "virtual-triggering": _ctx.virtualTriggering,
                  "z-index": _ctx.zIndex,
                  "append-to": _ctx.appendTo
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "content", {}, () => [
                      _ctx.rawContent ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        innerHTML: _ctx.content
                      }, null, 8, ["innerHTML"])) : (openBlock(), createElementBlock("span", { key: 1 }, toDisplayString(_ctx.content), 1))
                    ]),
                    _ctx.showArrow ? (openBlock(), createBlock(unref(ElPopperArrow), { key: 0 })) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "arrow-offset", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
              ]),
              _: 3
            }, 8, ["role"]);
          };
        }
      });
      var Tooltip = /* @__PURE__ */ _export_sfc(_sfc_main$2j, [["__file", "tooltip.vue"]]);
      const ElTooltip = exports("ElTooltip", withInstall(Tooltip));
      const autocompleteProps = exports("autocompleteProps", buildProps({
        ...inputProps,
        valueKey: {
          type: String,
          default: "value"
        },
        modelValue: {
          type: [String, Number],
          default: ""
        },
        debounce: {
          type: Number,
          default: 300
        },
        placement: {
          type: definePropType(String),
          values: [
            "top",
            "top-start",
            "top-end",
            "bottom",
            "bottom-start",
            "bottom-end"
          ],
          default: "bottom-start"
        },
        fetchSuggestions: {
          type: definePropType([Function, Array]),
          default: NOOP
        },
        popperClass: {
          type: String,
          default: ""
        },
        triggerOnFocus: {
          type: Boolean,
          default: true
        },
        selectWhenUnmatched: Boolean,
        hideLoading: Boolean,
        teleported: useTooltipContentProps.teleported,
        appendTo: useTooltipContentProps.appendTo,
        highlightFirstItem: Boolean,
        fitInputWidth: Boolean
      }));
      const autocompleteEmits = exports("autocompleteEmits", {
        [UPDATE_MODEL_EVENT]: (value) => isString$1(value),
        [INPUT_EVENT]: (value) => isString$1(value),
        [CHANGE_EVENT]: (value) => isString$1(value),
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent,
        clear: () => true,
        select: (item) => isObject$1(item)
      });
      const COMPONENT_NAME$k = "ElAutocomplete";
      const __default__$1M = defineComponent({
        name: COMPONENT_NAME$k,
        inheritAttrs: false
      });
      const _sfc_main$2i = /* @__PURE__ */ defineComponent({
        ...__default__$1M,
        props: autocompleteProps,
        emits: autocompleteEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const passInputProps = computed(() => pick(props2, Object.keys(inputProps)));
          const rawAttrs = useAttrs$1();
          const disabled = useFormDisabled();
          const ns = useNamespace("autocomplete");
          const inputRef = ref();
          const regionRef = ref();
          const popperRef = ref();
          const listboxRef = ref();
          let readonly2 = false;
          let ignoreFocusEvent = false;
          const suggestions = ref([]);
          const highlightedIndex = ref(-1);
          const dropdownWidth = ref("");
          const activated = ref(false);
          const suggestionDisabled = ref(false);
          const loading = ref(false);
          const listboxId = useId();
          const styles = computed(() => rawAttrs.style);
          const suggestionVisible = computed(() => {
            const isValidData = suggestions.value.length > 0;
            return (isValidData || loading.value) && activated.value;
          });
          const suggestionLoading = computed(() => !props2.hideLoading && loading.value);
          const refInput = computed(() => {
            if (inputRef.value) {
              return Array.from(inputRef.value.$el.querySelectorAll("input"));
            }
            return [];
          });
          const onSuggestionShow = () => {
            if (suggestionVisible.value) {
              dropdownWidth.value = `${inputRef.value.$el.offsetWidth}px`;
            }
          };
          const onHide = () => {
            highlightedIndex.value = -1;
          };
          const getData2 = async (queryString) => {
            if (suggestionDisabled.value)
              return;
            const cb = (suggestionList) => {
              loading.value = false;
              if (suggestionDisabled.value)
                return;
              if (isArray$1(suggestionList)) {
                suggestions.value = suggestionList;
                highlightedIndex.value = props2.highlightFirstItem ? 0 : -1;
              } else {
                throwError(COMPONENT_NAME$k, "autocomplete suggestions must be an array");
              }
            };
            loading.value = true;
            if (isArray$1(props2.fetchSuggestions)) {
              cb(props2.fetchSuggestions);
            } else {
              const result2 = await props2.fetchSuggestions(queryString, cb);
              if (isArray$1(result2))
                cb(result2);
            }
          };
          const debouncedGetData = debounce(getData2, props2.debounce);
          const handleInput = (value) => {
            const valuePresented = !!value;
            emit(INPUT_EVENT, value);
            emit(UPDATE_MODEL_EVENT, value);
            suggestionDisabled.value = false;
            activated.value || (activated.value = valuePresented);
            if (!props2.triggerOnFocus && !value) {
              suggestionDisabled.value = true;
              suggestions.value = [];
              return;
            }
            debouncedGetData(value);
          };
          const handleMouseDown = (event) => {
            var _a;
            if (disabled.value)
              return;
            if (((_a = event.target) == null ? void 0 : _a.tagName) !== "INPUT" || refInput.value.includes(document.activeElement)) {
              activated.value = true;
            }
          };
          const handleChange = (value) => {
            emit(CHANGE_EVENT, value);
          };
          const handleFocus = (evt) => {
            var _a;
            if (!ignoreFocusEvent) {
              activated.value = true;
              emit("focus", evt);
              const queryString = (_a = props2.modelValue) != null ? _a : "";
              if (props2.triggerOnFocus && !readonly2) {
                debouncedGetData(String(queryString));
              }
            } else {
              ignoreFocusEvent = false;
            }
          };
          const handleBlur = (evt) => {
            setTimeout(() => {
              var _a;
              if ((_a = popperRef.value) == null ? void 0 : _a.isFocusInsideContent()) {
                ignoreFocusEvent = true;
                return;
              }
              activated.value && close2();
              emit("blur", evt);
            });
          };
          const handleClear = () => {
            activated.value = false;
            emit(UPDATE_MODEL_EVENT, "");
            emit("clear");
          };
          const handleKeyEnter = async () => {
            if (suggestionVisible.value && highlightedIndex.value >= 0 && highlightedIndex.value < suggestions.value.length) {
              handleSelect(suggestions.value[highlightedIndex.value]);
            } else if (props2.selectWhenUnmatched) {
              emit("select", { value: props2.modelValue });
              suggestions.value = [];
              highlightedIndex.value = -1;
            }
          };
          const handleKeyEscape = (evt) => {
            if (suggestionVisible.value) {
              evt.preventDefault();
              evt.stopPropagation();
              close2();
            }
          };
          const close2 = () => {
            activated.value = false;
          };
          const focus = () => {
            var _a;
            (_a = inputRef.value) == null ? void 0 : _a.focus();
          };
          const blur = () => {
            var _a;
            (_a = inputRef.value) == null ? void 0 : _a.blur();
          };
          const handleSelect = async (item) => {
            emit(INPUT_EVENT, item[props2.valueKey]);
            emit(UPDATE_MODEL_EVENT, item[props2.valueKey]);
            emit("select", item);
            suggestions.value = [];
            highlightedIndex.value = -1;
          };
          const highlight = (index2) => {
            if (!suggestionVisible.value || loading.value)
              return;
            if (index2 < 0) {
              highlightedIndex.value = -1;
              return;
            }
            if (index2 >= suggestions.value.length) {
              index2 = suggestions.value.length - 1;
            }
            const suggestion = regionRef.value.querySelector(`.${ns.be("suggestion", "wrap")}`);
            const suggestionList = suggestion.querySelectorAll(`.${ns.be("suggestion", "list")} li`);
            const highlightItem = suggestionList[index2];
            const scrollTop = suggestion.scrollTop;
            const { offsetTop, scrollHeight } = highlightItem;
            if (offsetTop + scrollHeight > scrollTop + suggestion.clientHeight) {
              suggestion.scrollTop += scrollHeight;
            }
            if (offsetTop < scrollTop) {
              suggestion.scrollTop -= scrollHeight;
            }
            highlightedIndex.value = index2;
            inputRef.value.ref.setAttribute("aria-activedescendant", `${listboxId.value}-item-${highlightedIndex.value}`);
          };
          const stopHandle = onClickOutside(listboxRef, () => {
            var _a;
            if ((_a = popperRef.value) == null ? void 0 : _a.isFocusInsideContent())
              return;
            suggestionVisible.value && close2();
          });
          onBeforeUnmount(() => {
            stopHandle == null ? void 0 : stopHandle();
          });
          onMounted(() => {
            inputRef.value.ref.setAttribute("role", "textbox");
            inputRef.value.ref.setAttribute("aria-autocomplete", "list");
            inputRef.value.ref.setAttribute("aria-controls", "id");
            inputRef.value.ref.setAttribute("aria-activedescendant", `${listboxId.value}-item-${highlightedIndex.value}`);
            readonly2 = inputRef.value.ref.hasAttribute("readonly");
          });
          expose({
            highlightedIndex,
            activated,
            loading,
            inputRef,
            popperRef,
            suggestions,
            handleSelect,
            handleKeyEnter,
            focus,
            blur,
            close: close2,
            highlight,
            getData: getData2
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTooltip), {
              ref_key: "popperRef",
              ref: popperRef,
              visible: unref(suggestionVisible),
              placement: _ctx.placement,
              "fallback-placements": ["bottom-start", "top-start"],
              "popper-class": [unref(ns).e("popper"), _ctx.popperClass],
              teleported: _ctx.teleported,
              "append-to": _ctx.appendTo,
              "gpu-acceleration": false,
              pure: "",
              "manual-mode": "",
              effect: "light",
              trigger: "click",
              transition: `${unref(ns).namespace.value}-zoom-in-top`,
              persistent: "",
              role: "listbox",
              onBeforeShow: onSuggestionShow,
              onHide
            }, {
              content: withCtx(() => [
                createElementVNode("div", {
                  ref_key: "regionRef",
                  ref: regionRef,
                  class: normalizeClass([unref(ns).b("suggestion"), unref(ns).is("loading", unref(suggestionLoading))]),
                  style: normalizeStyle({
                    [_ctx.fitInputWidth ? "width" : "minWidth"]: dropdownWidth.value,
                    outline: "none"
                  }),
                  role: "region"
                }, [
                  _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(unref(ns).be("suggestion", "header")),
                    onClick: withModifiers(() => {
                    }, ["stop"])
                  }, [
                    renderSlot(_ctx.$slots, "header")
                  ], 10, ["onClick"])) : createCommentVNode("v-if", true),
                  createVNode(unref(ElScrollbar), {
                    id: unref(listboxId),
                    tag: "ul",
                    "wrap-class": unref(ns).be("suggestion", "wrap"),
                    "view-class": unref(ns).be("suggestion", "list"),
                    role: "listbox"
                  }, {
                    default: withCtx(() => [
                      unref(suggestionLoading) ? (openBlock(), createElementBlock("li", { key: 0 }, [
                        renderSlot(_ctx.$slots, "loading", {}, () => [
                          createVNode(unref(ElIcon), {
                            class: normalizeClass(unref(ns).is("loading"))
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(loading_default$1))
                            ]),
                            _: 1
                          }, 8, ["class"])
                        ])
                      ])) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(suggestions.value, (item, index2) => {
                        return openBlock(), createElementBlock("li", {
                          id: `${unref(listboxId)}-item-${index2}`,
                          key: index2,
                          class: normalizeClass({ highlighted: highlightedIndex.value === index2 }),
                          role: "option",
                          "aria-selected": highlightedIndex.value === index2,
                          onClick: ($event) => handleSelect(item)
                        }, [
                          renderSlot(_ctx.$slots, "default", { item }, () => [
                            createTextVNode(toDisplayString(item[_ctx.valueKey]), 1)
                          ])
                        ], 10, ["id", "aria-selected", "onClick"]);
                      }), 128))
                    ]),
                    _: 3
                  }, 8, ["id", "wrap-class", "view-class"]),
                  _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass(unref(ns).be("suggestion", "footer")),
                    onClick: withModifiers(() => {
                    }, ["stop"])
                  }, [
                    renderSlot(_ctx.$slots, "footer")
                  ], 10, ["onClick"])) : createCommentVNode("v-if", true)
                ], 6)
              ]),
              default: withCtx(() => [
                createElementVNode("div", {
                  ref_key: "listboxRef",
                  ref: listboxRef,
                  class: normalizeClass([unref(ns).b(), _ctx.$attrs.class]),
                  style: normalizeStyle(unref(styles)),
                  role: "combobox",
                  "aria-haspopup": "listbox",
                  "aria-expanded": unref(suggestionVisible),
                  "aria-owns": unref(listboxId)
                }, [
                  createVNode(unref(ElInput), mergeProps({
                    ref_key: "inputRef",
                    ref: inputRef
                  }, mergeProps(unref(passInputProps), _ctx.$attrs), {
                    "model-value": _ctx.modelValue,
                    disabled: unref(disabled),
                    onInput: handleInput,
                    onChange: handleChange,
                    onFocus: handleFocus,
                    onBlur: handleBlur,
                    onClear: handleClear,
                    onKeydown: [
                      withKeys(withModifiers(($event) => highlight(highlightedIndex.value - 1), ["prevent"]), ["up"]),
                      withKeys(withModifiers(($event) => highlight(highlightedIndex.value + 1), ["prevent"]), ["down"]),
                      withKeys(handleKeyEnter, ["enter"]),
                      withKeys(close2, ["tab"]),
                      withKeys(handleKeyEscape, ["esc"])
                    ],
                    onMousedown: handleMouseDown
                  }), createSlots({
                    _: 2
                  }, [
                    _ctx.$slots.prepend ? {
                      name: "prepend",
                      fn: withCtx(() => [
                        renderSlot(_ctx.$slots, "prepend")
                      ])
                    } : void 0,
                    _ctx.$slots.append ? {
                      name: "append",
                      fn: withCtx(() => [
                        renderSlot(_ctx.$slots, "append")
                      ])
                    } : void 0,
                    _ctx.$slots.prefix ? {
                      name: "prefix",
                      fn: withCtx(() => [
                        renderSlot(_ctx.$slots, "prefix")
                      ])
                    } : void 0,
                    _ctx.$slots.suffix ? {
                      name: "suffix",
                      fn: withCtx(() => [
                        renderSlot(_ctx.$slots, "suffix")
                      ])
                    } : void 0
                  ]), 1040, ["model-value", "disabled", "onKeydown"])
                ], 14, ["aria-expanded", "aria-owns"])
              ]),
              _: 3
            }, 8, ["visible", "placement", "popper-class", "teleported", "append-to", "transition"]);
          };
        }
      });
      var Autocomplete = /* @__PURE__ */ _export_sfc(_sfc_main$2i, [["__file", "autocomplete.vue"]]);
      const ElAutocomplete = exports("ElAutocomplete", withInstall(Autocomplete));
      const avatarProps = exports("avatarProps", buildProps({
        size: {
          type: [Number, String],
          values: componentSizes,
          default: "",
          validator: (val) => isNumber(val)
        },
        shape: {
          type: String,
          values: ["circle", "square"],
          default: "circle"
        },
        icon: {
          type: iconPropType
        },
        src: {
          type: String,
          default: ""
        },
        alt: String,
        srcSet: String,
        fit: {
          type: definePropType(String),
          default: "cover"
        }
      }));
      const avatarEmits = exports("avatarEmits", {
        error: (evt) => evt instanceof Event
      });
      const __default__$1L = defineComponent({
        name: "ElAvatar"
      });
      const _sfc_main$2h = /* @__PURE__ */ defineComponent({
        ...__default__$1L,
        props: avatarProps,
        emits: avatarEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const ns = useNamespace("avatar");
          const hasLoadError = ref(false);
          const avatarClass = computed(() => {
            const { size, icon, shape } = props2;
            const classList = [ns.b()];
            if (isString$1(size))
              classList.push(ns.m(size));
            if (icon)
              classList.push(ns.m("icon"));
            if (shape)
              classList.push(ns.m(shape));
            return classList;
          });
          const sizeStyle = computed(() => {
            const { size } = props2;
            return isNumber(size) ? ns.cssVarBlock({
              size: addUnit(size) || ""
            }) : void 0;
          });
          const fitStyle = computed(() => ({
            objectFit: props2.fit
          }));
          watch(() => props2.src, () => hasLoadError.value = false);
          function handleError(e) {
            hasLoadError.value = true;
            emit("error", e);
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              class: normalizeClass(unref(avatarClass)),
              style: normalizeStyle(unref(sizeStyle))
            }, [
              (_ctx.src || _ctx.srcSet) && !hasLoadError.value ? (openBlock(), createElementBlock("img", {
                key: 0,
                src: _ctx.src,
                alt: _ctx.alt,
                srcset: _ctx.srcSet,
                style: normalizeStyle(unref(fitStyle)),
                onError: handleError
              }, null, 44, ["src", "alt", "srcset"])) : _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                ]),
                _: 1
              })) : renderSlot(_ctx.$slots, "default", { key: 2 })
            ], 6);
          };
        }
      });
      var Avatar = /* @__PURE__ */ _export_sfc(_sfc_main$2h, [["__file", "avatar.vue"]]);
      const ElAvatar = exports("ElAvatar", withInstall(Avatar));
      const backtopProps = exports("backtopProps", {
        visibilityHeight: {
          type: Number,
          default: 200
        },
        target: {
          type: String,
          default: ""
        },
        right: {
          type: Number,
          default: 40
        },
        bottom: {
          type: Number,
          default: 40
        }
      });
      const backtopEmits = exports("backtopEmits", {
        click: (evt) => evt instanceof MouseEvent
      });
      const useBackTop = (props2, emit, componentName2) => {
        const el = shallowRef();
        const container = shallowRef();
        const visible = ref(false);
        const handleScroll2 = () => {
          if (el.value)
            visible.value = el.value.scrollTop >= props2.visibilityHeight;
        };
        const handleClick = (event) => {
          var _a;
          (_a = el.value) == null ? void 0 : _a.scrollTo({ top: 0, behavior: "smooth" });
          emit("click", event);
        };
        const handleScrollThrottled = useThrottleFn(handleScroll2, 300, true);
        useEventListener(container, "scroll", handleScrollThrottled);
        onMounted(() => {
          var _a;
          container.value = document;
          el.value = document.documentElement;
          if (props2.target) {
            el.value = (_a = document.querySelector(props2.target)) != null ? _a : void 0;
            if (!el.value) {
              throwError(componentName2, `target does not exist: ${props2.target}`);
            }
            container.value = el.value;
          }
          handleScroll2();
        });
        return {
          visible,
          handleClick
        };
      };
      const COMPONENT_NAME$j = "ElBacktop";
      const __default__$1K = defineComponent({
        name: COMPONENT_NAME$j
      });
      const _sfc_main$2g = /* @__PURE__ */ defineComponent({
        ...__default__$1K,
        props: backtopProps,
        emits: backtopEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const ns = useNamespace("backtop");
          const { handleClick, visible } = useBackTop(props2, emit, COMPONENT_NAME$j);
          const backTopStyle = computed(() => ({
            right: `${props2.right}px`,
            bottom: `${props2.bottom}px`
          }));
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: `${unref(ns).namespace.value}-fade-in`
            }, {
              default: withCtx(() => [
                unref(visible) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  style: normalizeStyle(unref(backTopStyle)),
                  class: normalizeClass(unref(ns).b()),
                  onClick: withModifiers(unref(handleClick), ["stop"])
                }, [
                  renderSlot(_ctx.$slots, "default", {}, () => [
                    createVNode(unref(ElIcon), {
                      class: normalizeClass(unref(ns).e("icon"))
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(caret_top_default$1))
                      ]),
                      _: 1
                    }, 8, ["class"])
                  ])
                ], 14, ["onClick"])) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 8, ["name"]);
          };
        }
      });
      var Backtop = /* @__PURE__ */ _export_sfc(_sfc_main$2g, [["__file", "backtop.vue"]]);
      const ElBacktop = exports("ElBacktop", withInstall(Backtop));
      const badgeProps = exports("badgeProps", buildProps({
        value: {
          type: [String, Number],
          default: ""
        },
        max: {
          type: Number,
          default: 99
        },
        isDot: Boolean,
        hidden: Boolean,
        type: {
          type: String,
          values: ["primary", "success", "warning", "info", "danger"],
          default: "danger"
        },
        showZero: {
          type: Boolean,
          default: true
        },
        color: String,
        badgeStyle: {
          type: definePropType([String, Object, Array])
        },
        offset: {
          type: definePropType(Array),
          default: [0, 0]
        },
        badgeClass: {
          type: String
        }
      }));
      const __default__$1J = defineComponent({
        name: "ElBadge"
      });
      const _sfc_main$2f = /* @__PURE__ */ defineComponent({
        ...__default__$1J,
        props: badgeProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const ns = useNamespace("badge");
          const content = computed(() => {
            if (props2.isDot)
              return "";
            if (isNumber(props2.value) && isNumber(props2.max)) {
              return props2.max < props2.value ? `${props2.max}+` : `${props2.value}`;
            }
            return `${props2.value}`;
          });
          const style = computed(() => {
            var _a, _b, _c, _d, _e;
            return [
              {
                backgroundColor: props2.color,
                marginRight: addUnit(-((_b = (_a = props2.offset) == null ? void 0 : _a[0]) != null ? _b : 0)),
                marginTop: addUnit((_d = (_c = props2.offset) == null ? void 0 : _c[1]) != null ? _d : 0)
              },
              (_e = props2.badgeStyle) != null ? _e : {}
            ];
          });
          expose({
            content
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b())
            }, [
              renderSlot(_ctx.$slots, "default"),
              createVNode(Transition, {
                name: `${unref(ns).namespace.value}-zoom-in-center`,
                persisted: ""
              }, {
                default: withCtx(() => [
                  withDirectives(createElementVNode("sup", {
                    class: normalizeClass([
                      unref(ns).e("content"),
                      unref(ns).em("content", _ctx.type),
                      unref(ns).is("fixed", !!_ctx.$slots.default),
                      unref(ns).is("dot", _ctx.isDot),
                      unref(ns).is("hide-zero", !_ctx.showZero && props2.value === 0),
                      _ctx.badgeClass
                    ]),
                    style: normalizeStyle(unref(style))
                  }, [
                    renderSlot(_ctx.$slots, "content", { value: unref(content) }, () => [
                      createTextVNode(toDisplayString(unref(content)), 1)
                    ])
                  ], 6), [
                    [vShow, !_ctx.hidden && (unref(content) || _ctx.isDot || _ctx.$slots.content)]
                  ])
                ]),
                _: 3
              }, 8, ["name"])
            ], 2);
          };
        }
      });
      var Badge = /* @__PURE__ */ _export_sfc(_sfc_main$2f, [["__file", "badge.vue"]]);
      const ElBadge = exports("ElBadge", withInstall(Badge));
      const breadcrumbKey = exports("breadcrumbKey", Symbol("breadcrumbKey"));
      const breadcrumbProps = exports("breadcrumbProps", buildProps({
        separator: {
          type: String,
          default: "/"
        },
        separatorIcon: {
          type: iconPropType
        }
      }));
      const __default__$1I = defineComponent({
        name: "ElBreadcrumb"
      });
      const _sfc_main$2e = /* @__PURE__ */ defineComponent({
        ...__default__$1I,
        props: breadcrumbProps,
        setup(__props) {
          const props2 = __props;
          const { t } = useLocale();
          const ns = useNamespace("breadcrumb");
          const breadcrumb = ref();
          provide(breadcrumbKey, props2);
          onMounted(() => {
            const items = breadcrumb.value.querySelectorAll(`.${ns.e("item")}`);
            if (items.length) {
              items[items.length - 1].setAttribute("aria-current", "page");
            }
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "breadcrumb",
              ref: breadcrumb,
              class: normalizeClass(unref(ns).b()),
              "aria-label": unref(t)("el.breadcrumb.label"),
              role: "navigation"
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 10, ["aria-label"]);
          };
        }
      });
      var Breadcrumb = /* @__PURE__ */ _export_sfc(_sfc_main$2e, [["__file", "breadcrumb.vue"]]);
      const breadcrumbItemProps = exports("breadcrumbItemProps", buildProps({
        to: {
          type: definePropType([String, Object]),
          default: ""
        },
        replace: Boolean
      }));
      const __default__$1H = defineComponent({
        name: "ElBreadcrumbItem"
      });
      const _sfc_main$2d = /* @__PURE__ */ defineComponent({
        ...__default__$1H,
        props: breadcrumbItemProps,
        setup(__props) {
          const props2 = __props;
          const instance = getCurrentInstance();
          const breadcrumbContext = inject(breadcrumbKey, void 0);
          const ns = useNamespace("breadcrumb");
          const router = instance.appContext.config.globalProperties.$router;
          const link = ref();
          const onClick = () => {
            if (!props2.to || !router)
              return;
            props2.replace ? router.replace(props2.to) : router.push(props2.to);
          };
          return (_ctx, _cache) => {
            var _a, _b;
            return openBlock(), createElementBlock("span", {
              class: normalizeClass(unref(ns).e("item"))
            }, [
              createElementVNode("span", {
                ref_key: "link",
                ref: link,
                class: normalizeClass([unref(ns).e("inner"), unref(ns).is("link", !!_ctx.to)]),
                role: "link",
                onClick
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2),
              ((_a = unref(breadcrumbContext)) == null ? void 0 : _a.separatorIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                key: 0,
                class: normalizeClass(unref(ns).e("separator"))
              }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(unref(breadcrumbContext).separatorIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : (openBlock(), createElementBlock("span", {
                key: 1,
                class: normalizeClass(unref(ns).e("separator")),
                role: "presentation"
              }, toDisplayString((_b = unref(breadcrumbContext)) == null ? void 0 : _b.separator), 3))
            ], 2);
          };
        }
      });
      var BreadcrumbItem = /* @__PURE__ */ _export_sfc(_sfc_main$2d, [["__file", "breadcrumb-item.vue"]]);
      const ElBreadcrumb = exports("ElBreadcrumb", withInstall(Breadcrumb, {
        BreadcrumbItem
      }));
      const ElBreadcrumbItem = exports("ElBreadcrumbItem", withNoopInstall(BreadcrumbItem));
      const buttonGroupContextKey = exports("buttonGroupContextKey", Symbol("buttonGroupContextKey"));
      const useButton = (props2, emit) => {
        useDeprecated({
          from: "type.text",
          replacement: "link",
          version: "3.0.0",
          scope: "props",
          ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
        }, computed(() => props2.type === "text"));
        const buttonGroupContext = inject(buttonGroupContextKey, void 0);
        const globalConfig2 = useGlobalConfig("button");
        const { form } = useFormItem();
        const _size = useFormSize(computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
        const _disabled = useFormDisabled();
        const _ref = ref();
        const slots = useSlots();
        const _type = computed(() => {
          var _a;
          return props2.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || ((_a = globalConfig2.value) == null ? void 0 : _a.type) || "";
        });
        const autoInsertSpace = computed(() => {
          var _a, _b, _c;
          return (_c = (_b = props2.autoInsertSpace) != null ? _b : (_a = globalConfig2.value) == null ? void 0 : _a.autoInsertSpace) != null ? _c : false;
        });
        const _plain = computed(() => {
          var _a, _b, _c;
          return (_c = (_b = props2.plain) != null ? _b : (_a = globalConfig2.value) == null ? void 0 : _a.plain) != null ? _c : false;
        });
        const _round = computed(() => {
          var _a, _b, _c;
          return (_c = (_b = props2.round) != null ? _b : (_a = globalConfig2.value) == null ? void 0 : _a.round) != null ? _c : false;
        });
        const _props = computed(() => {
          if (props2.tag === "button") {
            return {
              ariaDisabled: _disabled.value || props2.loading,
              disabled: _disabled.value || props2.loading,
              autofocus: props2.autofocus,
              type: props2.nativeType
            };
          }
          return {};
        });
        const shouldAddSpace = computed(() => {
          var _a;
          const defaultSlot = (_a = slots.default) == null ? void 0 : _a.call(slots);
          if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
            const slot = defaultSlot[0];
            if ((slot == null ? void 0 : slot.type) === Text$1) {
              const text = slot.children;
              return /^\p{Unified_Ideograph}{2}$/u.test(text.trim());
            }
          }
          return false;
        });
        const handleClick = (evt) => {
          if (_disabled.value || props2.loading) {
            evt.stopPropagation();
            return;
          }
          if (props2.nativeType === "reset") {
            form == null ? void 0 : form.resetFields();
          }
          emit("click", evt);
        };
        return {
          _disabled,
          _size,
          _type,
          _ref,
          _props,
          _plain,
          _round,
          shouldAddSpace,
          handleClick
        };
      };
      const buttonTypes = exports("buttonTypes", [
        "default",
        "primary",
        "success",
        "warning",
        "info",
        "danger",
        "text",
        ""
      ]);
      const buttonNativeTypes = exports("buttonNativeTypes", ["button", "submit", "reset"]);
      const buttonProps = exports("buttonProps", buildProps({
        size: useSizeProp,
        disabled: Boolean,
        type: {
          type: String,
          values: buttonTypes,
          default: ""
        },
        icon: {
          type: iconPropType
        },
        nativeType: {
          type: String,
          values: buttonNativeTypes,
          default: "button"
        },
        loading: Boolean,
        loadingIcon: {
          type: iconPropType,
          default: () => loading_default$1
        },
        plain: {
          type: Boolean,
          default: void 0
        },
        text: Boolean,
        link: Boolean,
        bg: Boolean,
        autofocus: Boolean,
        round: {
          type: Boolean,
          default: void 0
        },
        circle: Boolean,
        color: String,
        dark: Boolean,
        autoInsertSpace: {
          type: Boolean,
          default: void 0
        },
        tag: {
          type: definePropType([String, Object]),
          default: "button"
        }
      }));
      const buttonEmits = exports("buttonEmits", {
        click: (evt) => evt instanceof MouseEvent
      });
      function bound01(n, max2) {
        if (isOnePointZero(n)) {
          n = "100%";
        }
        var isPercent = isPercentage(n);
        n = max2 === 360 ? n : Math.min(max2, Math.max(0, parseFloat(n)));
        if (isPercent) {
          n = parseInt(String(n * max2), 10) / 100;
        }
        if (Math.abs(n - max2) < 1e-6) {
          return 1;
        }
        if (max2 === 360) {
          n = (n < 0 ? n % max2 + max2 : n % max2) / parseFloat(String(max2));
        } else {
          n = n % max2 / parseFloat(String(max2));
        }
        return n;
      }
      function clamp01(val) {
        return Math.min(1, Math.max(0, val));
      }
      function isOnePointZero(n) {
        return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
      }
      function isPercentage(n) {
        return typeof n === "string" && n.indexOf("%") !== -1;
      }
      function boundAlpha(a2) {
        a2 = parseFloat(a2);
        if (isNaN(a2) || a2 < 0 || a2 > 1) {
          a2 = 1;
        }
        return a2;
      }
      function convertToPercentage(n) {
        if (n <= 1) {
          return "".concat(Number(n) * 100, "%");
        }
        return n;
      }
      function pad2(c2) {
        return c2.length === 1 ? "0" + c2 : String(c2);
      }
      function rgbToRgb(r, g, b2) {
        return {
          r: bound01(r, 255) * 255,
          g: bound01(g, 255) * 255,
          b: bound01(b2, 255) * 255
        };
      }
      function rgbToHsl(r, g, b2) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b2 = bound01(b2, 255);
        var max2 = Math.max(r, g, b2);
        var min2 = Math.min(r, g, b2);
        var h2 = 0;
        var s2 = 0;
        var l2 = (max2 + min2) / 2;
        if (max2 === min2) {
          s2 = 0;
          h2 = 0;
        } else {
          var d2 = max2 - min2;
          s2 = l2 > 0.5 ? d2 / (2 - max2 - min2) : d2 / (max2 + min2);
          switch (max2) {
            case r:
              h2 = (g - b2) / d2 + (g < b2 ? 6 : 0);
              break;
            case g:
              h2 = (b2 - r) / d2 + 2;
              break;
            case b2:
              h2 = (r - g) / d2 + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s: s2, l: l2 };
      }
      function hue2rgb(p2, q2, t) {
        if (t < 0) {
          t += 1;
        }
        if (t > 1) {
          t -= 1;
        }
        if (t < 1 / 6) {
          return p2 + (q2 - p2) * (6 * t);
        }
        if (t < 1 / 2) {
          return q2;
        }
        if (t < 2 / 3) {
          return p2 + (q2 - p2) * (2 / 3 - t) * 6;
        }
        return p2;
      }
      function hslToRgb(h2, s2, l2) {
        var r;
        var g;
        var b2;
        h2 = bound01(h2, 360);
        s2 = bound01(s2, 100);
        l2 = bound01(l2, 100);
        if (s2 === 0) {
          g = l2;
          b2 = l2;
          r = l2;
        } else {
          var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
          var p2 = 2 * l2 - q2;
          r = hue2rgb(p2, q2, h2 + 1 / 3);
          g = hue2rgb(p2, q2, h2);
          b2 = hue2rgb(p2, q2, h2 - 1 / 3);
        }
        return { r: r * 255, g: g * 255, b: b2 * 255 };
      }
      function rgbToHsv(r, g, b2) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b2 = bound01(b2, 255);
        var max2 = Math.max(r, g, b2);
        var min2 = Math.min(r, g, b2);
        var h2 = 0;
        var v2 = max2;
        var d2 = max2 - min2;
        var s2 = max2 === 0 ? 0 : d2 / max2;
        if (max2 === min2) {
          h2 = 0;
        } else {
          switch (max2) {
            case r:
              h2 = (g - b2) / d2 + (g < b2 ? 6 : 0);
              break;
            case g:
              h2 = (b2 - r) / d2 + 2;
              break;
            case b2:
              h2 = (r - g) / d2 + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s: s2, v: v2 };
      }
      function hsvToRgb(h2, s2, v2) {
        h2 = bound01(h2, 360) * 6;
        s2 = bound01(s2, 100);
        v2 = bound01(v2, 100);
        var i = Math.floor(h2);
        var f2 = h2 - i;
        var p2 = v2 * (1 - s2);
        var q2 = v2 * (1 - f2 * s2);
        var t = v2 * (1 - (1 - f2) * s2);
        var mod = i % 6;
        var r = [v2, q2, p2, p2, t, v2][mod];
        var g = [t, v2, v2, q2, p2, p2][mod];
        var b2 = [p2, p2, t, v2, v2, q2][mod];
        return { r: r * 255, g: g * 255, b: b2 * 255 };
      }
      function rgbToHex(r, g, b2, allow3Char) {
        var hex = [
          pad2(Math.round(r).toString(16)),
          pad2(Math.round(g).toString(16)),
          pad2(Math.round(b2).toString(16))
        ];
        if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToHex(r, g, b2, a2, allow4Char) {
        var hex = [
          pad2(Math.round(r).toString(16)),
          pad2(Math.round(g).toString(16)),
          pad2(Math.round(b2).toString(16)),
          pad2(convertDecimalToHex(a2))
        ];
        if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }
        return hex.join("");
      }
      function convertDecimalToHex(d2) {
        return Math.round(parseFloat(d2) * 255).toString(16);
      }
      function convertHexToDecimal(h2) {
        return parseIntFromHex(h2) / 255;
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function numberInputToObject(color) {
        return {
          r: color >> 16,
          g: (color & 65280) >> 8,
          b: color & 255
        };
      }
      var names = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        goldenrod: "#daa520",
        gold: "#ffd700",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavenderblush: "#fff0f5",
        lavender: "#e6e6fa",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        rebeccapurple: "#663399",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
      };
      function inputToRGB(color) {
        var rgb = { r: 0, g: 0, b: 0 };
        var a2 = 1;
        var s2 = null;
        var v2 = null;
        var l2 = null;
        var ok = false;
        var format2 = false;
        if (typeof color === "string") {
          color = stringInputToObject(color);
        }
        if (typeof color === "object") {
          if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s2 = convertToPercentage(color.s);
            v2 = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s2, v2);
            ok = true;
            format2 = "hsv";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s2 = convertToPercentage(color.s);
            l2 = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s2, l2);
            ok = true;
            format2 = "hsl";
          }
          if (Object.prototype.hasOwnProperty.call(color, "a")) {
            a2 = color.a;
          }
        }
        a2 = boundAlpha(a2);
        return {
          ok,
          format: color.format || format2,
          r: Math.min(255, Math.max(rgb.r, 0)),
          g: Math.min(255, Math.max(rgb.g, 0)),
          b: Math.min(255, Math.max(rgb.b, 0)),
          a: a2
        };
      }
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
      var matchers = {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
      function stringInputToObject(color) {
        color = color.trim().toLowerCase();
        if (color.length === 0) {
          return false;
        }
        var named = false;
        if (names[color]) {
          color = names[color];
          named = true;
        } else if (color === "transparent") {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }
        var match = matchers.rgb.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3] };
        }
        match = matchers.rgba.exec(color);
        if (match) {
          return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        match = matchers.hsl.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3] };
        }
        match = matchers.hsla.exec(color);
        if (match) {
          return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        match = matchers.hsv.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3] };
        }
        match = matchers.hsva.exec(color);
        if (match) {
          return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        match = matchers.hex8.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex6.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
          };
        }
        match = matchers.hex4.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            a: convertHexToDecimal(match[4] + match[4]),
            format: named ? "name" : "hex8"
          };
        }
        match = matchers.hex3.exec(color);
        if (match) {
          return {
            r: parseIntFromHex(match[1] + match[1]),
            g: parseIntFromHex(match[2] + match[2]),
            b: parseIntFromHex(match[3] + match[3]),
            format: named ? "name" : "hex"
          };
        }
        return false;
      }
      function isValidCSSUnit(color) {
        return Boolean(matchers.CSS_UNIT.exec(String(color)));
      }
      var TinyColor = function() {
        function TinyColor2(color, opts) {
          if (color === void 0) {
            color = "";
          }
          if (opts === void 0) {
            opts = {};
          }
          var _a;
          if (color instanceof TinyColor2) {
            return color;
          }
          if (typeof color === "number") {
            color = numberInputToObject(color);
          }
          this.originalInput = color;
          var rgb = inputToRGB(color);
          this.originalInput = color;
          this.r = rgb.r;
          this.g = rgb.g;
          this.b = rgb.b;
          this.a = rgb.a;
          this.roundA = Math.round(100 * this.a) / 100;
          this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
          this.gradientType = opts.gradientType;
          if (this.r < 1) {
            this.r = Math.round(this.r);
          }
          if (this.g < 1) {
            this.g = Math.round(this.g);
          }
          if (this.b < 1) {
            this.b = Math.round(this.b);
          }
          this.isValid = rgb.ok;
        }
        TinyColor2.prototype.isDark = function() {
          return this.getBrightness() < 128;
        };
        TinyColor2.prototype.isLight = function() {
          return !this.isDark();
        };
        TinyColor2.prototype.getBrightness = function() {
          var rgb = this.toRgb();
          return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
        };
        TinyColor2.prototype.getLuminance = function() {
          var rgb = this.toRgb();
          var R2;
          var G2;
          var B2;
          var RsRGB = rgb.r / 255;
          var GsRGB = rgb.g / 255;
          var BsRGB = rgb.b / 255;
          if (RsRGB <= 0.03928) {
            R2 = RsRGB / 12.92;
          } else {
            R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
          }
          if (GsRGB <= 0.03928) {
            G2 = GsRGB / 12.92;
          } else {
            G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
          }
          if (BsRGB <= 0.03928) {
            B2 = BsRGB / 12.92;
          } else {
            B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
          }
          return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
        };
        TinyColor2.prototype.getAlpha = function() {
          return this.a;
        };
        TinyColor2.prototype.setAlpha = function(alpha) {
          this.a = boundAlpha(alpha);
          this.roundA = Math.round(100 * this.a) / 100;
          return this;
        };
        TinyColor2.prototype.isMonochrome = function() {
          var s2 = this.toHsl().s;
          return s2 === 0;
        };
        TinyColor2.prototype.toHsv = function() {
          var hsv = rgbToHsv(this.r, this.g, this.b);
          return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
        };
        TinyColor2.prototype.toHsvString = function() {
          var hsv = rgbToHsv(this.r, this.g, this.b);
          var h2 = Math.round(hsv.h * 360);
          var s2 = Math.round(hsv.s * 100);
          var v2 = Math.round(hsv.v * 100);
          return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHsl = function() {
          var hsl = rgbToHsl(this.r, this.g, this.b);
          return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
        };
        TinyColor2.prototype.toHslString = function() {
          var hsl = rgbToHsl(this.r, this.g, this.b);
          var h2 = Math.round(hsl.h * 360);
          var s2 = Math.round(hsl.s * 100);
          var l2 = Math.round(hsl.l * 100);
          return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHex = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return rgbToHex(this.r, this.g, this.b, allow3Char);
        };
        TinyColor2.prototype.toHexString = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return "#" + this.toHex(allow3Char);
        };
        TinyColor2.prototype.toHex8 = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
        };
        TinyColor2.prototype.toHex8String = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return "#" + this.toHex8(allow4Char);
        };
        TinyColor2.prototype.toHexShortString = function(allowShortChar) {
          if (allowShortChar === void 0) {
            allowShortChar = false;
          }
          return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
        };
        TinyColor2.prototype.toRgb = function() {
          return {
            r: Math.round(this.r),
            g: Math.round(this.g),
            b: Math.round(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toRgbString = function() {
          var r = Math.round(this.r);
          var g = Math.round(this.g);
          var b2 = Math.round(this.b);
          return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b2, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b2, ", ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toPercentageRgb = function() {
          var fmt = function(x2) {
            return "".concat(Math.round(bound01(x2, 255) * 100), "%");
          };
          return {
            r: fmt(this.r),
            g: fmt(this.g),
            b: fmt(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toPercentageRgbString = function() {
          var rnd = function(x2) {
            return Math.round(bound01(x2, 255) * 100);
          };
          return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toName = function() {
          if (this.a === 0) {
            return "transparent";
          }
          if (this.a < 1) {
            return false;
          }
          var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
          for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            if (hex === value) {
              return key;
            }
          }
          return false;
        };
        TinyColor2.prototype.toString = function(format2) {
          var formatSet = Boolean(format2);
          format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
          var formattedString = false;
          var hasAlpha = this.a < 1 && this.a >= 0;
          var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
          if (needsAlphaFormat) {
            if (format2 === "name" && this.a === 0) {
              return this.toName();
            }
            return this.toRgbString();
          }
          if (format2 === "rgb") {
            formattedString = this.toRgbString();
          }
          if (format2 === "prgb") {
            formattedString = this.toPercentageRgbString();
          }
          if (format2 === "hex" || format2 === "hex6") {
            formattedString = this.toHexString();
          }
          if (format2 === "hex3") {
            formattedString = this.toHexString(true);
          }
          if (format2 === "hex4") {
            formattedString = this.toHex8String(true);
          }
          if (format2 === "hex8") {
            formattedString = this.toHex8String();
          }
          if (format2 === "name") {
            formattedString = this.toName();
          }
          if (format2 === "hsl") {
            formattedString = this.toHslString();
          }
          if (format2 === "hsv") {
            formattedString = this.toHsvString();
          }
          return formattedString || this.toHexString();
        };
        TinyColor2.prototype.toNumber = function() {
          return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
        };
        TinyColor2.prototype.clone = function() {
          return new TinyColor2(this.toString());
        };
        TinyColor2.prototype.lighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.l += amount / 100;
          hsl.l = clamp01(hsl.l);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.brighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var rgb = this.toRgb();
          rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
          rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
          rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
          return new TinyColor2(rgb);
        };
        TinyColor2.prototype.darken = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.l -= amount / 100;
          hsl.l = clamp01(hsl.l);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.tint = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("white", amount);
        };
        TinyColor2.prototype.shade = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("black", amount);
        };
        TinyColor2.prototype.desaturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.s -= amount / 100;
          hsl.s = clamp01(hsl.s);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.saturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.s += amount / 100;
          hsl.s = clamp01(hsl.s);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.greyscale = function() {
          return this.desaturate(100);
        };
        TinyColor2.prototype.spin = function(amount) {
          var hsl = this.toHsl();
          var hue = (hsl.h + amount) % 360;
          hsl.h = hue < 0 ? 360 + hue : hue;
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.mix = function(color, amount) {
          if (amount === void 0) {
            amount = 50;
          }
          var rgb1 = this.toRgb();
          var rgb2 = new TinyColor2(color).toRgb();
          var p2 = amount / 100;
          var rgba = {
            r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
            g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
            b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
            a: (rgb2.a - rgb1.a) * p2 + rgb1.a
          };
          return new TinyColor2(rgba);
        };
        TinyColor2.prototype.analogous = function(results, slices) {
          if (results === void 0) {
            results = 6;
          }
          if (slices === void 0) {
            slices = 30;
          }
          var hsl = this.toHsl();
          var part = 360 / slices;
          var ret = [this];
          for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(new TinyColor2(hsl));
          }
          return ret;
        };
        TinyColor2.prototype.complement = function() {
          var hsl = this.toHsl();
          hsl.h = (hsl.h + 180) % 360;
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.monochromatic = function(results) {
          if (results === void 0) {
            results = 6;
          }
          var hsv = this.toHsv();
          var h2 = hsv.h;
          var s2 = hsv.s;
          var v2 = hsv.v;
          var res = [];
          var modification = 1 / results;
          while (results--) {
            res.push(new TinyColor2({ h: h2, s: s2, v: v2 }));
            v2 = (v2 + modification) % 1;
          }
          return res;
        };
        TinyColor2.prototype.splitcomplement = function() {
          var hsl = this.toHsl();
          var h2 = hsl.h;
          return [
            this,
            new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
            new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
          ];
        };
        TinyColor2.prototype.onBackground = function(background) {
          var fg = this.toRgb();
          var bg = new TinyColor2(background).toRgb();
          var alpha = fg.a + bg.a * (1 - fg.a);
          return new TinyColor2({
            r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
            g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
            b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
            a: alpha
          });
        };
        TinyColor2.prototype.triad = function() {
          return this.polyad(3);
        };
        TinyColor2.prototype.tetrad = function() {
          return this.polyad(4);
        };
        TinyColor2.prototype.polyad = function(n) {
          var hsl = this.toHsl();
          var h2 = hsl.h;
          var result2 = [this];
          var increment = 360 / n;
          for (var i = 1; i < n; i++) {
            result2.push(new TinyColor2({ h: (h2 + i * increment) % 360, s: hsl.s, l: hsl.l }));
          }
          return result2;
        };
        TinyColor2.prototype.equals = function(color) {
          return this.toRgbString() === new TinyColor2(color).toRgbString();
        };
        return TinyColor2;
      }();
      function darken(color, amount = 20) {
        return color.mix("#141414", amount).toString();
      }
      function useButtonCustomStyle(props2) {
        const _disabled = useFormDisabled();
        const ns = useNamespace("button");
        return computed(() => {
          let styles = {};
          let buttonColor = props2.color;
          if (buttonColor) {
            const match = buttonColor.match(/var\((.*?)\)/);
            if (match) {
              buttonColor = window.getComputedStyle(window.document.documentElement).getPropertyValue(match[1]);
            }
            const color = new TinyColor(buttonColor);
            const activeBgColor = props2.dark ? color.tint(20).toString() : darken(color, 20);
            if (props2.plain) {
              styles = ns.cssVarBlock({
                "bg-color": props2.dark ? darken(color, 90) : color.tint(90).toString(),
                "text-color": buttonColor,
                "border-color": props2.dark ? darken(color, 50) : color.tint(50).toString(),
                "hover-text-color": `var(${ns.cssVarName("color-white")})`,
                "hover-bg-color": buttonColor,
                "hover-border-color": buttonColor,
                "active-bg-color": activeBgColor,
                "active-text-color": `var(${ns.cssVarName("color-white")})`,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                styles[ns.cssVarBlockName("disabled-bg-color")] = props2.dark ? darken(color, 90) : color.tint(90).toString();
                styles[ns.cssVarBlockName("disabled-text-color")] = props2.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-border-color")] = props2.dark ? darken(color, 80) : color.tint(80).toString();
              }
            } else {
              const hoverBgColor = props2.dark ? darken(color, 30) : color.tint(30).toString();
              const textColor = color.isDark() ? `var(${ns.cssVarName("color-white")})` : `var(${ns.cssVarName("color-black")})`;
              styles = ns.cssVarBlock({
                "bg-color": buttonColor,
                "text-color": textColor,
                "border-color": buttonColor,
                "hover-bg-color": hoverBgColor,
                "hover-text-color": textColor,
                "hover-border-color": hoverBgColor,
                "active-bg-color": activeBgColor,
                "active-border-color": activeBgColor
              });
              if (_disabled.value) {
                const disabledButtonColor = props2.dark ? darken(color, 50) : color.tint(50).toString();
                styles[ns.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
                styles[ns.cssVarBlockName("disabled-text-color")] = props2.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns.cssVarName("color-white")})`;
                styles[ns.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
              }
            }
          }
          return styles;
        });
      }
      const __default__$1G = defineComponent({
        name: "ElButton"
      });
      const _sfc_main$2c = /* @__PURE__ */ defineComponent({
        ...__default__$1G,
        props: buttonProps,
        emits: buttonEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const buttonStyle = useButtonCustomStyle(props2);
          const ns = useNamespace("button");
          const {
            _ref,
            _size,
            _type,
            _disabled,
            _props,
            _plain,
            _round,
            shouldAddSpace,
            handleClick
          } = useButton(props2, emit);
          const buttonKls = computed(() => [
            ns.b(),
            ns.m(_type.value),
            ns.m(_size.value),
            ns.is("disabled", _disabled.value),
            ns.is("loading", props2.loading),
            ns.is("plain", _plain.value),
            ns.is("round", _round.value),
            ns.is("circle", props2.circle),
            ns.is("text", props2.text),
            ns.is("link", props2.link),
            ns.is("has-bg", props2.bg)
          ]);
          expose({
            ref: _ref,
            size: _size,
            type: _type,
            disabled: _disabled,
            shouldAddSpace
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({
              ref_key: "_ref",
              ref: _ref
            }, unref(_props), {
              class: unref(buttonKls),
              style: unref(buttonStyle),
              onClick: unref(handleClick)
            }), {
              default: withCtx(() => [
                _ctx.loading ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass(unref(ns).is("loading"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"]))
                ], 64)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                  default: withCtx(() => [
                    _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
                  ]),
                  _: 3
                })) : createCommentVNode("v-if", true),
                _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                  key: 2,
                  class: normalizeClass({ [unref(ns).em("text", "expand")]: unref(shouldAddSpace) })
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16, ["class", "style", "onClick"]);
          };
        }
      });
      var Button = /* @__PURE__ */ _export_sfc(_sfc_main$2c, [["__file", "button.vue"]]);
      const buttonGroupProps = {
        size: buttonProps.size,
        type: buttonProps.type
      };
      const __default__$1F = defineComponent({
        name: "ElButtonGroup"
      });
      const _sfc_main$2b = /* @__PURE__ */ defineComponent({
        ...__default__$1F,
        props: buttonGroupProps,
        setup(__props) {
          const props2 = __props;
          provide(buttonGroupContextKey, reactive({
            size: toRef(props2, "size"),
            type: toRef(props2, "type")
          }));
          const ns = useNamespace("button");
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b("group"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var ButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$2b, [["__file", "button-group.vue"]]);
      const ElButton = exports("ElButton", withInstall(Button, {
        ButtonGroup
      }));
      const ElButtonGroup$1 = exports("ElButtonGroup", withNoopInstall(ButtonGroup));
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      var dayjs_min = { exports: {} };
      (function(module2, exports2) {
        !function(t, e) {
          module2.exports = e();
        }(commonjsGlobal, function() {
          var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
            var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
            return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
          } }, m2 = function(t2, e2, n2) {
            var r2 = String(t2);
            return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
          }, v2 = { s: m2, z: function(t2) {
            var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
            return (e2 <= 0 ? "+" : "-") + m2(r2, 2, "0") + ":" + m2(i2, 2, "0");
          }, m: function t2(e2, n2) {
            if (e2.date() < n2.date())
              return -t2(n2, e2);
            var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c2), s22 = n2 - i2 < 0, u22 = e2.clone().add(r2 + (s22 ? -1 : 1), c2);
            return +(-(r2 + (n2 - i2) / (s22 ? i2 - u22 : u22 - i2)) || 0);
          }, a: function(t2) {
            return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
          }, p: function(t2) {
            return { M: c2, y: h2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i, ms: r, Q: f2 }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
          }, u: function(t2) {
            return t2 === void 0;
          } }, g = "en", D2 = {};
          D2[g] = M2;
          var p2 = "$isDayjsObject", S2 = function(t2) {
            return t2 instanceof _2 || !(!t2 || !t2[p2]);
          }, w2 = function t2(e2, n2, r2) {
            var i2;
            if (!e2)
              return g;
            if (typeof e2 == "string") {
              var s22 = e2.toLowerCase();
              D2[s22] && (i2 = s22), n2 && (D2[s22] = n2, i2 = s22);
              var u22 = e2.split("-");
              if (!i2 && u22.length > 1)
                return t2(u22[0]);
            } else {
              var a22 = e2.name;
              D2[a22] = e2, i2 = a22;
            }
            return !r2 && i2 && (g = i2), i2 || !r2 && g;
          }, O2 = function(t2, e2) {
            if (S2(t2))
              return t2.clone();
            var n2 = typeof e2 == "object" ? e2 : {};
            return n2.date = t2, n2.args = arguments, new _2(n2);
          }, b2 = v2;
          b2.l = w2, b2.i = S2, b2.w = function(t2, e2) {
            return O2(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
          };
          var _2 = function() {
            function M22(t2) {
              this.$L = w2(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p2] = true;
            }
            var m22 = M22.prototype;
            return m22.parse = function(t2) {
              this.$d = function(t3) {
                var e2 = t3.date, n2 = t3.utc;
                if (e2 === null)
                  return /* @__PURE__ */ new Date(NaN);
                if (b2.u(e2))
                  return /* @__PURE__ */ new Date();
                if (e2 instanceof Date)
                  return new Date(e2);
                if (typeof e2 == "string" && !/Z$/i.test(e2)) {
                  var r2 = e2.match($);
                  if (r2) {
                    var i2 = r2[2] - 1 || 0, s22 = (r2[7] || "0").substring(0, 3);
                    return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s22)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s22);
                  }
                }
                return new Date(e2);
              }(t2), this.init();
            }, m22.init = function() {
              var t2 = this.$d;
              this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
            }, m22.$utils = function() {
              return b2;
            }, m22.isValid = function() {
              return !(this.$d.toString() === l2);
            }, m22.isSame = function(t2, e2) {
              var n2 = O2(t2);
              return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
            }, m22.isAfter = function(t2, e2) {
              return O2(t2) < this.startOf(e2);
            }, m22.isBefore = function(t2, e2) {
              return this.endOf(e2) < O2(t2);
            }, m22.$g = function(t2, e2, n2) {
              return b2.u(t2) ? this[e2] : this.set(n2, t2);
            }, m22.unix = function() {
              return Math.floor(this.valueOf() / 1e3);
            }, m22.valueOf = function() {
              return this.$d.getTime();
            }, m22.startOf = function(t2, e2) {
              var n2 = this, r2 = !!b2.u(e2) || e2, f22 = b2.p(t2), l22 = function(t3, e3) {
                var i2 = b2.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
                return r2 ? i2 : i2.endOf(a2);
              }, $2 = function(t3, e3) {
                return b2.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
              }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v22 = "set" + (this.$u ? "UTC" : "");
              switch (f22) {
                case h2:
                  return r2 ? l22(1, 0) : l22(31, 11);
                case c2:
                  return r2 ? l22(1, M3) : l22(0, M3 + 1);
                case o2:
                  var g2 = this.$locale().weekStart || 0, D22 = (y2 < g2 ? y2 + 7 : y2) - g2;
                  return l22(r2 ? m3 - D22 : m3 + (6 - D22), M3);
                case a2:
                case d2:
                  return $2(v22 + "Hours", 0);
                case u2:
                  return $2(v22 + "Minutes", 1);
                case s2:
                  return $2(v22 + "Seconds", 2);
                case i:
                  return $2(v22 + "Milliseconds", 3);
                default:
                  return this.clone();
              }
            }, m22.endOf = function(t2) {
              return this.startOf(t2, false);
            }, m22.$set = function(t2, e2) {
              var n2, o22 = b2.p(t2), f22 = "set" + (this.$u ? "UTC" : ""), l22 = (n2 = {}, n2[a2] = f22 + "Date", n2[d2] = f22 + "Date", n2[c2] = f22 + "Month", n2[h2] = f22 + "FullYear", n2[u2] = f22 + "Hours", n2[s2] = f22 + "Minutes", n2[i] = f22 + "Seconds", n2[r] = f22 + "Milliseconds", n2)[o22], $2 = o22 === a2 ? this.$D + (e2 - this.$W) : e2;
              if (o22 === c2 || o22 === h2) {
                var y2 = this.clone().set(d2, 1);
                y2.$d[l22]($2), y2.init(), this.$d = y2.set(d2, Math.min(this.$D, y2.daysInMonth())).$d;
              } else
                l22 && this.$d[l22]($2);
              return this.init(), this;
            }, m22.set = function(t2, e2) {
              return this.clone().$set(t2, e2);
            }, m22.get = function(t2) {
              return this[b2.p(t2)]();
            }, m22.add = function(r2, f22) {
              var d22, l22 = this;
              r2 = Number(r2);
              var $2 = b2.p(f22), y2 = function(t2) {
                var e2 = O2(l22);
                return b2.w(e2.date(e2.date() + Math.round(t2 * r2)), l22);
              };
              if ($2 === c2)
                return this.set(c2, this.$M + r2);
              if ($2 === h2)
                return this.set(h2, this.$y + r2);
              if ($2 === a2)
                return y2(1);
              if ($2 === o2)
                return y2(7);
              var M3 = (d22 = {}, d22[s2] = e, d22[u2] = n, d22[i] = t, d22)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
              return b2.w(m3, this);
            }, m22.subtract = function(t2, e2) {
              return this.add(-1 * t2, e2);
            }, m22.format = function(t2) {
              var e2 = this, n2 = this.$locale();
              if (!this.isValid())
                return n2.invalidDate || l2;
              var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b2.z(this), s22 = this.$H, u22 = this.$m, a22 = this.$M, o22 = n2.weekdays, c22 = n2.months, f22 = n2.meridiem, h22 = function(t3, n3, i3, s3) {
                return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
              }, d22 = function(t3) {
                return b2.s(s22 % 12 || 12, t3, "0");
              }, $2 = f22 || function(t3, e3, n3) {
                var r3 = t3 < 12 ? "AM" : "PM";
                return n3 ? r3.toLowerCase() : r3;
              };
              return r2.replace(y, function(t3, r3) {
                return r3 || function(t4) {
                  switch (t4) {
                    case "YY":
                      return String(e2.$y).slice(-2);
                    case "YYYY":
                      return b2.s(e2.$y, 4, "0");
                    case "M":
                      return a22 + 1;
                    case "MM":
                      return b2.s(a22 + 1, 2, "0");
                    case "MMM":
                      return h22(n2.monthsShort, a22, c22, 3);
                    case "MMMM":
                      return h22(c22, a22);
                    case "D":
                      return e2.$D;
                    case "DD":
                      return b2.s(e2.$D, 2, "0");
                    case "d":
                      return String(e2.$W);
                    case "dd":
                      return h22(n2.weekdaysMin, e2.$W, o22, 2);
                    case "ddd":
                      return h22(n2.weekdaysShort, e2.$W, o22, 3);
                    case "dddd":
                      return o22[e2.$W];
                    case "H":
                      return String(s22);
                    case "HH":
                      return b2.s(s22, 2, "0");
                    case "h":
                      return d22(1);
                    case "hh":
                      return d22(2);
                    case "a":
                      return $2(s22, u22, true);
                    case "A":
                      return $2(s22, u22, false);
                    case "m":
                      return String(u22);
                    case "mm":
                      return b2.s(u22, 2, "0");
                    case "s":
                      return String(e2.$s);
                    case "ss":
                      return b2.s(e2.$s, 2, "0");
                    case "SSS":
                      return b2.s(e2.$ms, 3, "0");
                    case "Z":
                      return i2;
                  }
                  return null;
                }(t3) || i2.replace(":", "");
              });
            }, m22.utcOffset = function() {
              return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
            }, m22.diff = function(r2, d22, l22) {
              var $2, y2 = this, M3 = b2.p(d22), m3 = O2(r2), v22 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D22 = function() {
                return b2.m(y2, m3);
              };
              switch (M3) {
                case h2:
                  $2 = D22() / 12;
                  break;
                case c2:
                  $2 = D22();
                  break;
                case f2:
                  $2 = D22() / 3;
                  break;
                case o2:
                  $2 = (g2 - v22) / 6048e5;
                  break;
                case a2:
                  $2 = (g2 - v22) / 864e5;
                  break;
                case u2:
                  $2 = g2 / n;
                  break;
                case s2:
                  $2 = g2 / e;
                  break;
                case i:
                  $2 = g2 / t;
                  break;
                default:
                  $2 = g2;
              }
              return l22 ? $2 : b2.a($2);
            }, m22.daysInMonth = function() {
              return this.endOf(c2).$D;
            }, m22.$locale = function() {
              return D2[this.$L];
            }, m22.locale = function(t2, e2) {
              if (!t2)
                return this.$L;
              var n2 = this.clone(), r2 = w2(t2, e2, true);
              return r2 && (n2.$L = r2), n2;
            }, m22.clone = function() {
              return b2.w(this.$d, this);
            }, m22.toDate = function() {
              return new Date(this.valueOf());
            }, m22.toJSON = function() {
              return this.isValid() ? this.toISOString() : null;
            }, m22.toISOString = function() {
              return this.$d.toISOString();
            }, m22.toString = function() {
              return this.$d.toUTCString();
            }, M22;
          }(), k = _2.prototype;
          return O2.prototype = k, [["$ms", r], ["$s", i], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t2) {
            k[t2[1]] = function(e2) {
              return this.$g(e2, t2[0], t2[1]);
            };
          }), O2.extend = function(t2, e2) {
            return t2.$i || (t2(e2, _2, O2), t2.$i = true), O2;
          }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t2) {
            return O2(1e3 * t2);
          }, O2.en = D2[g], O2.Ls = D2, O2.p = {}, O2;
        });
      })(dayjs_min);
      var dayjs = exports("dayjs", dayjs_min.exports);
      var customParseFormat$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e, t) {
          module2.exports = t();
        }(commonjsGlobal, function() {
          var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d/, r = /\d\d/, i = /\d\d?/, o2 = /\d*[^-_:/,()\s\d]+/, s2 = {}, a2 = function(e2) {
            return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
          };
          var f2 = function(e2) {
            return function(t2) {
              this[e2] = +t2;
            };
          }, h2 = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
            (this.zone || (this.zone = {})).offset = function(e3) {
              if (!e3)
                return 0;
              if (e3 === "Z")
                return 0;
              var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
              return n2 === 0 ? 0 : t2[0] === "+" ? -n2 : n2;
            }(e2);
          }], u2 = function(e2) {
            var t2 = s2[e2];
            return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
          }, d2 = function(e2, t2) {
            var n2, r2 = s2.meridiem;
            if (r2) {
              for (var i2 = 1; i2 <= 24; i2 += 1)
                if (e2.indexOf(r2(i2, 0, t2)) > -1) {
                  n2 = i2 > 12;
                  break;
                }
            } else
              n2 = e2 === (t2 ? "pm" : "PM");
            return n2;
          }, c2 = { A: [o2, function(e2) {
            this.afternoon = d2(e2, false);
          }], a: [o2, function(e2) {
            this.afternoon = d2(e2, true);
          }], Q: [n, function(e2) {
            this.month = 3 * (e2 - 1) + 1;
          }], S: [n, function(e2) {
            this.milliseconds = 100 * +e2;
          }], SS: [r, function(e2) {
            this.milliseconds = 10 * +e2;
          }], SSS: [/\d{3}/, function(e2) {
            this.milliseconds = +e2;
          }], s: [i, f2("seconds")], ss: [i, f2("seconds")], m: [i, f2("minutes")], mm: [i, f2("minutes")], H: [i, f2("hours")], h: [i, f2("hours")], HH: [i, f2("hours")], hh: [i, f2("hours")], D: [i, f2("day")], DD: [r, f2("day")], Do: [o2, function(e2) {
            var t2 = s2.ordinal, n2 = e2.match(/\d+/);
            if (this.day = n2[0], t2)
              for (var r2 = 1; r2 <= 31; r2 += 1)
                t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
          }], w: [i, f2("week")], ww: [r, f2("week")], M: [i, f2("month")], MM: [r, f2("month")], MMM: [o2, function(e2) {
            var t2 = u2("months"), n2 = (u2("monthsShort") || t2.map(function(e3) {
              return e3.slice(0, 3);
            })).indexOf(e2) + 1;
            if (n2 < 1)
              throw new Error();
            this.month = n2 % 12 || n2;
          }], MMMM: [o2, function(e2) {
            var t2 = u2("months").indexOf(e2) + 1;
            if (t2 < 1)
              throw new Error();
            this.month = t2 % 12 || t2;
          }], Y: [/[+-]?\d+/, f2("year")], YY: [r, function(e2) {
            this.year = a2(e2);
          }], YYYY: [/\d{4}/, f2("year")], Z: h2, ZZ: h2 };
          function l2(n2) {
            var r2, i2;
            r2 = n2, i2 = s2 && s2.formats;
            for (var o22 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
              var o3 = r3 && r3.toUpperCase();
              return n3 || i2[r3] || e[r3] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
                return t3 || n4.slice(1);
              });
            })).match(t), a22 = o22.length, f22 = 0; f22 < a22; f22 += 1) {
              var h22 = o22[f22], u22 = c2[h22], d22 = u22 && u22[0], l22 = u22 && u22[1];
              o22[f22] = l22 ? { regex: d22, parser: l22 } : h22.replace(/^\[|\]$/g, "");
            }
            return function(e2) {
              for (var t2 = {}, n3 = 0, r3 = 0; n3 < a22; n3 += 1) {
                var i3 = o22[n3];
                if (typeof i3 == "string")
                  r3 += i3.length;
                else {
                  var s22 = i3.regex, f3 = i3.parser, h3 = e2.slice(r3), u3 = s22.exec(h3)[0];
                  f3.call(t2, u3), e2 = e2.replace(u3, "");
                }
              }
              return function(e3) {
                var t3 = e3.afternoon;
                if (t3 !== void 0) {
                  var n4 = e3.hours;
                  t3 ? n4 < 12 && (e3.hours += 12) : n4 === 12 && (e3.hours = 0), delete e3.afternoon;
                }
              }(t2), t2;
            };
          }
          return function(e2, t2, n2) {
            n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (a2 = e2.parseTwoDigitYear);
            var r2 = t2.prototype, i2 = r2.parse;
            r2.parse = function(e3) {
              var t3 = e3.date, r3 = e3.utc, o22 = e3.args;
              this.$u = r3;
              var a22 = o22[1];
              if (typeof a22 == "string") {
                var f22 = o22[2] === true, h22 = o22[3] === true, u22 = f22 || h22, d22 = o22[2];
                h22 && (d22 = o22[2]), s2 = this.$locale(), !f22 && d22 && (s2 = n2.Ls[d22]), this.$d = function(e4, t4, n3, r4) {
                  try {
                    if (["x", "X"].indexOf(t4) > -1)
                      return new Date((t4 === "X" ? 1e3 : 1) * e4);
                    var i3 = l2(t4)(e4), o3 = i3.year, s22 = i3.month, a3 = i3.day, f3 = i3.hours, h3 = i3.minutes, u3 = i3.seconds, d3 = i3.milliseconds, c3 = i3.zone, m22 = i3.week, M22 = /* @__PURE__ */ new Date(), Y2 = a3 || (o3 || s22 ? 1 : M22.getDate()), p2 = o3 || M22.getFullYear(), v2 = 0;
                    o3 && !s22 || (v2 = s22 > 0 ? s22 - 1 : M22.getMonth());
                    var D2, w2 = f3 || 0, g = h3 || 0, y = u3 || 0, L = d3 || 0;
                    return c3 ? new Date(Date.UTC(p2, v2, Y2, w2, g, y, L + 60 * c3.offset * 1e3)) : n3 ? new Date(Date.UTC(p2, v2, Y2, w2, g, y, L)) : (D2 = new Date(p2, v2, Y2, w2, g, y, L), m22 && (D2 = r4(D2).week(m22).toDate()), D2);
                  } catch (e5) {
                    return /* @__PURE__ */ new Date("");
                  }
                }(t3, a22, r3, n2), this.init(), d22 && d22 !== true && (this.$L = this.locale(d22).$L), u22 && t3 != this.format(a22) && (this.$d = /* @__PURE__ */ new Date("")), s2 = {};
              } else if (a22 instanceof Array)
                for (var c22 = a22.length, m2 = 1; m2 <= c22; m2 += 1) {
                  o22[1] = a22[m2 - 1];
                  var M2 = n2.apply(this, o22);
                  if (M2.isValid()) {
                    this.$d = M2.$d, this.$L = M2.$L, this.init();
                    break;
                  }
                  m2 === c22 && (this.$d = /* @__PURE__ */ new Date(""));
                }
              else
                i2.call(this, e3);
            };
          };
        });
      })(customParseFormat$1);
      var customParseFormat = customParseFormat$1.exports;
      const timeUnits$1 = exports("timeUnits", ["hours", "minutes", "seconds"]);
      const PICKER_BASE_INJECTION_KEY = exports("PICKER_BASE_INJECTION_KEY", "EP_PICKER_BASE");
      const PICKER_POPPER_OPTIONS_INJECTION_KEY = exports("PICKER_POPPER_OPTIONS_INJECTION_KEY", "ElPopperOptions");
      const DEFAULT_FORMATS_TIME = exports("DEFAULT_FORMATS_TIME", "HH:mm:ss");
      const DEFAULT_FORMATS_DATE = exports("DEFAULT_FORMATS_DATE", "YYYY-MM-DD");
      const DEFAULT_FORMATS_DATEPICKER = exports("DEFAULT_FORMATS_DATEPICKER", {
        date: DEFAULT_FORMATS_DATE,
        dates: DEFAULT_FORMATS_DATE,
        week: "gggg[w]ww",
        year: "YYYY",
        years: "YYYY",
        month: "YYYY-MM",
        months: "YYYY-MM",
        datetime: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`,
        monthrange: "YYYY-MM",
        yearrange: "YYYY",
        daterange: DEFAULT_FORMATS_DATE,
        datetimerange: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`
      });
      const buildTimeList = exports("buildTimeList", (value, bound) => {
        return [
          value > 0 ? value - 1 : void 0,
          value,
          value < bound ? value + 1 : void 0
        ];
      });
      const rangeArr = exports("rangeArr", (n) => Array.from(Array.from({ length: n }).keys()));
      const extractDateFormat = exports("extractDateFormat", (format2) => {
        return format2.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim();
      });
      const extractTimeFormat = exports("extractTimeFormat", (format2) => {
        return format2.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim();
      });
      const dateEquals = exports("dateEquals", function(a2, b2) {
        const aIsDate = isDate$1(a2);
        const bIsDate = isDate$1(b2);
        if (aIsDate && bIsDate) {
          return a2.getTime() === b2.getTime();
        }
        if (!aIsDate && !bIsDate) {
          return a2 === b2;
        }
        return false;
      });
      const valueEquals = exports("valueEquals", function(a2, b2) {
        const aIsArray = isArray$1(a2);
        const bIsArray = isArray$1(b2);
        if (aIsArray && bIsArray) {
          if (a2.length !== b2.length) {
            return false;
          }
          return a2.every((item, index2) => dateEquals(item, b2[index2]));
        }
        if (!aIsArray && !bIsArray) {
          return dateEquals(a2, b2);
        }
        return false;
      });
      const parseDate = exports("parseDate", function(date3, format2, lang2) {
        const day = isEmpty(format2) || format2 === "x" ? dayjs(date3).locale(lang2) : dayjs(date3, format2).locale(lang2);
        return day.isValid() ? day : void 0;
      });
      const formatter = exports("formatter", function(date3, format2, lang2) {
        if (isEmpty(format2))
          return date3;
        if (format2 === "x")
          return +date3;
        return dayjs(date3).locale(lang2).format(format2);
      });
      const makeList = exports("makeList", (total2, method3) => {
        var _a;
        const arr = [];
        const disabledArr = method3 == null ? void 0 : method3();
        for (let i = 0; i < total2; i++) {
          arr.push((_a = disabledArr == null ? void 0 : disabledArr.includes(i)) != null ? _a : false);
        }
        return arr;
      });
      const dayOrDaysToDate = exports("dayOrDaysToDate", (dayOrDays) => {
        return isArray$1(dayOrDays) ? dayOrDays.map((d2) => d2.toDate()) : dayOrDays.toDate();
      });
      const disabledTimeListsProps = buildProps({
        disabledHours: {
          type: definePropType(Function)
        },
        disabledMinutes: {
          type: definePropType(Function)
        },
        disabledSeconds: {
          type: definePropType(Function)
        }
      });
      const timePanelSharedProps = buildProps({
        visible: Boolean,
        actualVisible: {
          type: Boolean,
          default: void 0
        },
        format: {
          type: String,
          default: ""
        }
      });
      const timePickerDefaultProps = exports("timePickerDefaultProps", buildProps({
        id: {
          type: definePropType([Array, String])
        },
        name: {
          type: definePropType([Array, String])
        },
        popperClass: {
          type: String,
          default: ""
        },
        format: String,
        valueFormat: String,
        dateFormat: String,
        timeFormat: String,
        type: {
          type: String,
          default: ""
        },
        clearable: {
          type: Boolean,
          default: true
        },
        clearIcon: {
          type: definePropType([String, Object]),
          default: circle_close_default$1
        },
        editable: {
          type: Boolean,
          default: true
        },
        prefixIcon: {
          type: definePropType([String, Object]),
          default: ""
        },
        size: useSizeProp,
        readonly: Boolean,
        disabled: Boolean,
        placeholder: {
          type: String,
          default: ""
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        modelValue: {
          type: definePropType([Date, Array, String, Number]),
          default: ""
        },
        rangeSeparator: {
          type: String,
          default: "-"
        },
        startPlaceholder: String,
        endPlaceholder: String,
        defaultValue: {
          type: definePropType([Date, Array])
        },
        defaultTime: {
          type: definePropType([Date, Array])
        },
        isRange: Boolean,
        ...disabledTimeListsProps,
        disabledDate: {
          type: Function
        },
        cellClassName: {
          type: Function
        },
        shortcuts: {
          type: Array,
          default: () => []
        },
        arrowControl: Boolean,
        tabindex: {
          type: definePropType([String, Number]),
          default: 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        unlinkPanels: Boolean,
        placement: {
          type: definePropType(String),
          values: Ee,
          default: "bottom"
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: ["bottom", "top", "right", "left"]
        },
        ...useEmptyValuesProps,
        ...useAriaProps(["ariaLabel"]),
        showNow: {
          type: Boolean,
          default: true
        },
        showFooter: {
          type: Boolean,
          default: true
        },
        showWeekNumber: Boolean
      }));
      const timePickerRangeTriggerProps = exports("timePickerRangeTriggerProps", buildProps({
        id: {
          type: definePropType(Array)
        },
        name: {
          type: definePropType(Array)
        },
        modelValue: {
          type: definePropType([Array, String])
        },
        startPlaceholder: String,
        endPlaceholder: String,
        disabled: Boolean
      }));
      const timePickerRngeTriggerProps = exports("timePickerRngeTriggerProps", timePickerRangeTriggerProps);
      const __default__$1E = defineComponent({
        name: "PickerRangeTrigger",
        inheritAttrs: false
      });
      const _sfc_main$2a = /* @__PURE__ */ defineComponent({
        ...__default__$1E,
        props: timePickerRangeTriggerProps,
        emits: [
          "mouseenter",
          "mouseleave",
          "click",
          "touchstart",
          "focus",
          "blur",
          "startInput",
          "endInput",
          "startChange",
          "endChange"
        ],
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const attrs = useAttrs();
          const nsDate = useNamespace("date");
          const nsRange = useNamespace("range");
          const inputRef = ref();
          const endInputRef = ref();
          const { wrapperRef, isFocused } = useFocusController(inputRef, {
            disabled: computed(() => props2.disabled)
          });
          const handleClick = (evt) => {
            emit("click", evt);
          };
          const handleMouseEnter = (evt) => {
            emit("mouseenter", evt);
          };
          const handleMouseLeave = (evt) => {
            emit("mouseleave", evt);
          };
          const handleTouchStart = (evt) => {
            emit("touchstart", evt);
          };
          const handleStartInput = (evt) => {
            emit("startInput", evt);
          };
          const handleEndInput = (evt) => {
            emit("endInput", evt);
          };
          const handleStartChange = (evt) => {
            emit("startChange", evt);
          };
          const handleEndChange = (evt) => {
            emit("endChange", evt);
          };
          const focus = () => {
            var _a;
            (_a = inputRef.value) == null ? void 0 : _a.focus();
          };
          const blur = () => {
            var _a, _b;
            (_a = inputRef.value) == null ? void 0 : _a.blur();
            (_b = endInputRef.value) == null ? void 0 : _b.blur();
          };
          expose({
            focus,
            blur
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "wrapperRef",
              ref: wrapperRef,
              class: normalizeClass([unref(nsDate).is("active", unref(isFocused)), _ctx.$attrs.class]),
              style: normalizeStyle(_ctx.$attrs.style),
              onClick: handleClick,
              onMouseenter: handleMouseEnter,
              onMouseleave: handleMouseLeave,
              onTouchstartPassive: handleTouchStart
            }, [
              renderSlot(_ctx.$slots, "prefix"),
              createElementVNode("input", mergeProps(unref(attrs), {
                id: _ctx.id && _ctx.id[0],
                ref_key: "inputRef",
                ref: inputRef,
                name: _ctx.name && _ctx.name[0],
                placeholder: _ctx.startPlaceholder,
                value: _ctx.modelValue && _ctx.modelValue[0],
                class: unref(nsRange).b("input"),
                disabled: _ctx.disabled,
                onInput: handleStartInput,
                onChange: handleStartChange
              }), null, 16, ["id", "name", "placeholder", "value", "disabled"]),
              renderSlot(_ctx.$slots, "range-separator"),
              createElementVNode("input", mergeProps(unref(attrs), {
                id: _ctx.id && _ctx.id[1],
                ref_key: "endInputRef",
                ref: endInputRef,
                name: _ctx.name && _ctx.name[1],
                placeholder: _ctx.endPlaceholder,
                value: _ctx.modelValue && _ctx.modelValue[1],
                class: unref(nsRange).b("input"),
                disabled: _ctx.disabled,
                onInput: handleEndInput,
                onChange: handleEndChange
              }), null, 16, ["id", "name", "placeholder", "value", "disabled"]),
              renderSlot(_ctx.$slots, "suffix")
            ], 38);
          };
        }
      });
      var PickerRangeTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$2a, [["__file", "picker-range-trigger.vue"]]);
      const __default__$1D = defineComponent({
        name: "Picker"
      });
      const _sfc_main$29 = /* @__PURE__ */ defineComponent({
        ...__default__$1D,
        props: timePickerDefaultProps,
        emits: [
          UPDATE_MODEL_EVENT,
          CHANGE_EVENT,
          "focus",
          "blur",
          "clear",
          "calendar-change",
          "panel-change",
          "visible-change",
          "keydown"
        ],
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const attrs = useAttrs$1();
          const { lang: lang2 } = useLocale();
          const nsDate = useNamespace("date");
          const nsInput = useNamespace("input");
          const nsRange = useNamespace("range");
          const { form, formItem } = useFormItem();
          const elPopperOptions = inject(PICKER_POPPER_OPTIONS_INJECTION_KEY, {});
          const { valueOnClear } = useEmptyValues(props2, null);
          const refPopper = ref();
          const inputRef = ref();
          const pickerVisible = ref(false);
          const pickerActualVisible = ref(false);
          const valueOnOpen = ref(null);
          let hasJustTabExitedInput = false;
          const pickerDisabled = computed(() => {
            return props2.disabled || !!(form == null ? void 0 : form.disabled);
          });
          const { isFocused, handleFocus, handleBlur } = useFocusController(inputRef, {
            disabled: pickerDisabled,
            beforeFocus() {
              return props2.readonly;
            },
            afterFocus() {
              pickerVisible.value = true;
            },
            beforeBlur(event) {
              var _a;
              return !hasJustTabExitedInput && ((_a = refPopper.value) == null ? void 0 : _a.isFocusInsideContent(event));
            },
            afterBlur() {
              handleChange();
              pickerVisible.value = false;
              hasJustTabExitedInput = false;
              props2.validateEvent && (formItem == null ? void 0 : formItem.validate("blur").catch((err) => debugWarn()));
            }
          });
          const rangeInputKls = computed(() => [
            nsDate.b("editor"),
            nsDate.bm("editor", props2.type),
            nsInput.e("wrapper"),
            nsDate.is("disabled", pickerDisabled.value),
            nsDate.is("active", pickerVisible.value),
            nsRange.b("editor"),
            pickerSize ? nsRange.bm("editor", pickerSize.value) : "",
            attrs.class
          ]);
          const clearIconKls = computed(() => [
            nsInput.e("icon"),
            nsRange.e("close-icon"),
            !showClose.value ? nsRange.e("close-icon--hidden") : ""
          ]);
          watch(pickerVisible, (val) => {
            if (!val) {
              userInput.value = null;
              nextTick(() => {
                emitChange(props2.modelValue);
              });
            } else {
              nextTick(() => {
                if (val) {
                  valueOnOpen.value = props2.modelValue;
                }
              });
            }
          });
          const emitChange = (val, isClear) => {
            if (isClear || !valueEquals(val, valueOnOpen.value)) {
              emit(CHANGE_EVENT, val);
              isClear && (valueOnOpen.value = val);
              props2.validateEvent && (formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn()));
            }
          };
          const emitInput = (input) => {
            if (!valueEquals(props2.modelValue, input)) {
              let formatted;
              if (isArray$1(input)) {
                formatted = input.map((item) => formatter(item, props2.valueFormat, lang2.value));
              } else if (input) {
                formatted = formatter(input, props2.valueFormat, lang2.value);
              }
              emit(UPDATE_MODEL_EVENT, input ? formatted : input, lang2.value);
            }
          };
          const emitKeydown = (e) => {
            emit("keydown", e);
          };
          const refInput = computed(() => {
            if (inputRef.value) {
              return Array.from(inputRef.value.$el.querySelectorAll("input"));
            }
            return [];
          });
          const setSelectionRange = (start, end, pos) => {
            const _inputs = refInput.value;
            if (!_inputs.length)
              return;
            if (!pos || pos === "min") {
              _inputs[0].setSelectionRange(start, end);
              _inputs[0].focus();
            } else if (pos === "max") {
              _inputs[1].setSelectionRange(start, end);
              _inputs[1].focus();
            }
          };
          const onPick = (date3 = "", visible = false) => {
            pickerVisible.value = visible;
            let result2;
            if (isArray$1(date3)) {
              result2 = date3.map((_2) => _2.toDate());
            } else {
              result2 = date3 ? date3.toDate() : date3;
            }
            userInput.value = null;
            emitInput(result2);
          };
          const onBeforeShow = () => {
            pickerActualVisible.value = true;
          };
          const onShow = () => {
            emit("visible-change", true);
          };
          const onHide = () => {
            pickerActualVisible.value = false;
            pickerVisible.value = false;
            emit("visible-change", false);
          };
          const handleOpen = () => {
            pickerVisible.value = true;
          };
          const handleClose = () => {
            pickerVisible.value = false;
          };
          const parsedValue = computed(() => {
            var _a;
            let dayOrDays;
            if (valueIsEmpty.value) {
              if (pickerOptions.value.getDefaultValue) {
                dayOrDays = pickerOptions.value.getDefaultValue();
              }
            } else {
              if (isArray$1(props2.modelValue)) {
                dayOrDays = props2.modelValue.map((d2) => parseDate(d2, props2.valueFormat, lang2.value));
              } else {
                dayOrDays = parseDate((_a = props2.modelValue) != null ? _a : "", props2.valueFormat, lang2.value);
              }
            }
            if (pickerOptions.value.getRangeAvailableTime) {
              const availableResult = pickerOptions.value.getRangeAvailableTime(dayOrDays);
              if (!isEqual$1(availableResult, dayOrDays)) {
                dayOrDays = availableResult;
                if (!valueIsEmpty.value) {
                  emitInput(dayOrDaysToDate(dayOrDays));
                }
              }
            }
            if (isArray$1(dayOrDays) && dayOrDays.some((day) => !day)) {
              dayOrDays = [];
            }
            return dayOrDays;
          });
          const displayValue = computed(() => {
            if (!pickerOptions.value.panelReady)
              return "";
            const formattedValue = formatDayjsToString(parsedValue.value);
            if (isArray$1(userInput.value)) {
              return [
                userInput.value[0] || formattedValue && formattedValue[0] || "",
                userInput.value[1] || formattedValue && formattedValue[1] || ""
              ];
            } else if (userInput.value !== null) {
              return userInput.value;
            }
            if (!isTimePicker.value && valueIsEmpty.value)
              return "";
            if (!pickerVisible.value && valueIsEmpty.value)
              return "";
            if (formattedValue) {
              return isDatesPicker.value || isMonthsPicker.value || isYearsPicker.value ? formattedValue.join(", ") : formattedValue;
            }
            return "";
          });
          const isTimeLikePicker = computed(() => props2.type.includes("time"));
          const isTimePicker = computed(() => props2.type.startsWith("time"));
          const isDatesPicker = computed(() => props2.type === "dates");
          const isMonthsPicker = computed(() => props2.type === "months");
          const isYearsPicker = computed(() => props2.type === "years");
          const triggerIcon = computed(() => props2.prefixIcon || (isTimeLikePicker.value ? clock_default$1 : calendar_default$1));
          const showClose = ref(false);
          const onClearIconClick = (event) => {
            if (props2.readonly || pickerDisabled.value)
              return;
            if (showClose.value) {
              event.stopPropagation();
              if (pickerOptions.value.handleClear) {
                pickerOptions.value.handleClear();
              } else {
                emitInput(valueOnClear.value);
              }
              emitChange(valueOnClear.value, true);
              showClose.value = false;
              onHide();
            }
            emit("clear");
          };
          const valueIsEmpty = computed(() => {
            const { modelValue } = props2;
            return !modelValue || isArray$1(modelValue) && !modelValue.filter(Boolean).length;
          });
          const onMouseDownInput = async (event) => {
            var _a;
            if (props2.readonly || pickerDisabled.value)
              return;
            if (((_a = event.target) == null ? void 0 : _a.tagName) !== "INPUT" || isFocused.value) {
              pickerVisible.value = true;
            }
          };
          const onMouseEnter = () => {
            if (props2.readonly || pickerDisabled.value)
              return;
            if (!valueIsEmpty.value && props2.clearable) {
              showClose.value = true;
            }
          };
          const onMouseLeave = () => {
            showClose.value = false;
          };
          const onTouchStartInput = (event) => {
            var _a;
            if (props2.readonly || pickerDisabled.value)
              return;
            if (((_a = event.touches[0].target) == null ? void 0 : _a.tagName) !== "INPUT" || isFocused.value) {
              pickerVisible.value = true;
            }
          };
          const isRangeInput = computed(() => {
            return props2.type.includes("range");
          });
          const pickerSize = useFormSize();
          const popperEl = computed(() => {
            var _a, _b;
            return (_b = (_a = unref(refPopper)) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
          });
          const stophandle = onClickOutside(inputRef, (e) => {
            const unrefedPopperEl = unref(popperEl);
            const inputEl = unrefElement(inputRef);
            if (unrefedPopperEl && (e.target === unrefedPopperEl || e.composedPath().includes(unrefedPopperEl)) || e.target === inputEl || inputEl && e.composedPath().includes(inputEl))
              return;
            pickerVisible.value = false;
          });
          onBeforeUnmount(() => {
            stophandle == null ? void 0 : stophandle();
          });
          const userInput = ref(null);
          const handleChange = () => {
            if (userInput.value) {
              const value = parseUserInputToDayjs(displayValue.value);
              if (value) {
                if (isValidValue2(value)) {
                  emitInput(dayOrDaysToDate(value));
                  userInput.value = null;
                }
              }
            }
            if (userInput.value === "") {
              emitInput(valueOnClear.value);
              emitChange(valueOnClear.value, true);
              userInput.value = null;
            }
          };
          const parseUserInputToDayjs = (value) => {
            if (!value)
              return null;
            return pickerOptions.value.parseUserInput(value);
          };
          const formatDayjsToString = (value) => {
            if (!value)
              return null;
            return pickerOptions.value.formatToString(value);
          };
          const isValidValue2 = (value) => {
            return pickerOptions.value.isValidValue(value);
          };
          const handleKeydownInput = async (event) => {
            if (props2.readonly || pickerDisabled.value)
              return;
            const { code } = event;
            emitKeydown(event);
            if (code === EVENT_CODE.esc) {
              if (pickerVisible.value === true) {
                pickerVisible.value = false;
                event.preventDefault();
                event.stopPropagation();
              }
              return;
            }
            if (code === EVENT_CODE.down) {
              if (pickerOptions.value.handleFocusPicker) {
                event.preventDefault();
                event.stopPropagation();
              }
              if (pickerVisible.value === false) {
                pickerVisible.value = true;
                await nextTick();
              }
              if (pickerOptions.value.handleFocusPicker) {
                pickerOptions.value.handleFocusPicker();
                return;
              }
            }
            if (code === EVENT_CODE.tab) {
              hasJustTabExitedInput = true;
              return;
            }
            if (code === EVENT_CODE.enter || code === EVENT_CODE.numpadEnter) {
              if (userInput.value === null || userInput.value === "" || isValidValue2(parseUserInputToDayjs(displayValue.value))) {
                handleChange();
                pickerVisible.value = false;
              }
              event.stopPropagation();
              return;
            }
            if (userInput.value) {
              event.stopPropagation();
              return;
            }
            if (pickerOptions.value.handleKeydownInput) {
              pickerOptions.value.handleKeydownInput(event);
            }
          };
          const onUserInput = (e) => {
            userInput.value = e;
            if (!pickerVisible.value) {
              pickerVisible.value = true;
            }
          };
          const handleStartInput = (event) => {
            const target2 = event.target;
            if (userInput.value) {
              userInput.value = [target2.value, userInput.value[1]];
            } else {
              userInput.value = [target2.value, null];
            }
          };
          const handleEndInput = (event) => {
            const target2 = event.target;
            if (userInput.value) {
              userInput.value = [userInput.value[0], target2.value];
            } else {
              userInput.value = [null, target2.value];
            }
          };
          const handleStartChange = () => {
            var _a;
            const values2 = userInput.value;
            const value = parseUserInputToDayjs(values2 && values2[0]);
            const parsedVal = unref(parsedValue);
            if (value && value.isValid()) {
              userInput.value = [
                formatDayjsToString(value),
                ((_a = displayValue.value) == null ? void 0 : _a[1]) || null
              ];
              const newValue = [value, parsedVal && (parsedVal[1] || null)];
              if (isValidValue2(newValue)) {
                emitInput(dayOrDaysToDate(newValue));
                userInput.value = null;
              }
            }
          };
          const handleEndChange = () => {
            var _a;
            const values2 = unref(userInput);
            const value = parseUserInputToDayjs(values2 && values2[1]);
            const parsedVal = unref(parsedValue);
            if (value && value.isValid()) {
              userInput.value = [
                ((_a = unref(displayValue)) == null ? void 0 : _a[0]) || null,
                formatDayjsToString(value)
              ];
              const newValue = [parsedVal && parsedVal[0], value];
              if (isValidValue2(newValue)) {
                emitInput(dayOrDaysToDate(newValue));
                userInput.value = null;
              }
            }
          };
          const pickerOptions = ref({});
          const onSetPickerOption = (e) => {
            pickerOptions.value[e[0]] = e[1];
            pickerOptions.value.panelReady = true;
          };
          const onCalendarChange = (e) => {
            emit("calendar-change", e);
          };
          const onPanelChange = (value, mode, view) => {
            emit("panel-change", value, mode, view);
          };
          const focus = () => {
            var _a;
            (_a = inputRef.value) == null ? void 0 : _a.focus();
          };
          const blur = () => {
            var _a;
            (_a = inputRef.value) == null ? void 0 : _a.blur();
          };
          provide(PICKER_BASE_INJECTION_KEY, {
            props: props2
          });
          expose({
            focus,
            blur,
            handleOpen,
            handleClose,
            onPick
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTooltip), mergeProps({
              ref_key: "refPopper",
              ref: refPopper,
              visible: pickerVisible.value,
              effect: "light",
              pure: "",
              trigger: "click"
            }, _ctx.$attrs, {
              role: "dialog",
              teleported: "",
              transition: `${unref(nsDate).namespace.value}-zoom-in-top`,
              "popper-class": [`${unref(nsDate).namespace.value}-picker__popper`, _ctx.popperClass],
              "popper-options": unref(elPopperOptions),
              "fallback-placements": _ctx.fallbackPlacements,
              "gpu-acceleration": false,
              placement: _ctx.placement,
              "stop-popper-mouse-event": false,
              "hide-after": 0,
              persistent: "",
              onBeforeShow,
              onShow,
              onHide
            }), {
              default: withCtx(() => [
                !unref(isRangeInput) ? (openBlock(), createBlock(unref(ElInput), {
                  key: 0,
                  id: _ctx.id,
                  ref_key: "inputRef",
                  ref: inputRef,
                  "container-role": "combobox",
                  "model-value": unref(displayValue),
                  name: _ctx.name,
                  size: unref(pickerSize),
                  disabled: unref(pickerDisabled),
                  placeholder: _ctx.placeholder,
                  class: normalizeClass([unref(nsDate).b("editor"), unref(nsDate).bm("editor", _ctx.type), _ctx.$attrs.class]),
                  style: normalizeStyle(_ctx.$attrs.style),
                  readonly: !_ctx.editable || _ctx.readonly || unref(isDatesPicker) || unref(isMonthsPicker) || unref(isYearsPicker) || _ctx.type === "week",
                  "aria-label": _ctx.ariaLabel,
                  tabindex: _ctx.tabindex,
                  "validate-event": false,
                  onInput: onUserInput,
                  onFocus: unref(handleFocus),
                  onBlur: unref(handleBlur),
                  onKeydown: handleKeydownInput,
                  onChange: handleChange,
                  onMousedown: onMouseDownInput,
                  onMouseenter: onMouseEnter,
                  onMouseleave: onMouseLeave,
                  onTouchstartPassive: onTouchStartInput,
                  onClick: withModifiers(() => {
                  }, ["stop"])
                }, {
                  prefix: withCtx(() => [
                    unref(triggerIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(unref(nsInput).e("icon")),
                      onMousedown: withModifiers(onMouseDownInput, ["prevent"]),
                      onTouchstartPassive: onTouchStartInput
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(triggerIcon))))
                      ]),
                      _: 1
                    }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true)
                  ]),
                  suffix: withCtx(() => [
                    showClose.value && _ctx.clearIcon ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(`${unref(nsInput).e("icon")} clear-icon`),
                      onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                      onClick: onClearIconClick
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                      ]),
                      _: 1
                    }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 1
                }, 8, ["id", "model-value", "name", "size", "disabled", "placeholder", "class", "style", "readonly", "aria-label", "tabindex", "onFocus", "onBlur", "onClick"])) : (openBlock(), createBlock(PickerRangeTrigger, {
                  key: 1,
                  id: _ctx.id,
                  ref_key: "inputRef",
                  ref: inputRef,
                  "model-value": unref(displayValue),
                  name: _ctx.name,
                  disabled: unref(pickerDisabled),
                  readonly: !_ctx.editable || _ctx.readonly,
                  "start-placeholder": _ctx.startPlaceholder,
                  "end-placeholder": _ctx.endPlaceholder,
                  class: normalizeClass(unref(rangeInputKls)),
                  style: normalizeStyle(_ctx.$attrs.style),
                  "aria-label": _ctx.ariaLabel,
                  tabindex: _ctx.tabindex,
                  autocomplete: "off",
                  role: "combobox",
                  onClick: onMouseDownInput,
                  onFocus: unref(handleFocus),
                  onBlur: unref(handleBlur),
                  onStartInput: handleStartInput,
                  onStartChange: handleStartChange,
                  onEndInput: handleEndInput,
                  onEndChange: handleEndChange,
                  onMousedown: onMouseDownInput,
                  onMouseenter: onMouseEnter,
                  onMouseleave: onMouseLeave,
                  onTouchstartPassive: onTouchStartInput,
                  onKeydown: handleKeydownInput
                }, {
                  prefix: withCtx(() => [
                    unref(triggerIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass([unref(nsInput).e("icon"), unref(nsRange).e("icon")])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(triggerIcon))))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true)
                  ]),
                  "range-separator": withCtx(() => [
                    renderSlot(_ctx.$slots, "range-separator", {}, () => [
                      createElementVNode("span", {
                        class: normalizeClass(unref(nsRange).b("separator"))
                      }, toDisplayString(_ctx.rangeSeparator), 3)
                    ])
                  ]),
                  suffix: withCtx(() => [
                    _ctx.clearIcon ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(unref(clearIconKls)),
                      onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                      onClick: onClearIconClick
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                      ]),
                      _: 1
                    }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 8, ["id", "model-value", "name", "disabled", "readonly", "start-placeholder", "end-placeholder", "class", "style", "aria-label", "tabindex", "onFocus", "onBlur"]))
              ]),
              content: withCtx(() => [
                renderSlot(_ctx.$slots, "default", {
                  visible: pickerVisible.value,
                  actualVisible: pickerActualVisible.value,
                  parsedValue: unref(parsedValue),
                  format: _ctx.format,
                  dateFormat: _ctx.dateFormat,
                  timeFormat: _ctx.timeFormat,
                  unlinkPanels: _ctx.unlinkPanels,
                  type: _ctx.type,
                  defaultValue: _ctx.defaultValue,
                  showNow: _ctx.showNow,
                  showFooter: _ctx.showFooter,
                  showWeekNumber: _ctx.showWeekNumber,
                  onPick,
                  onSelectRange: setSelectionRange,
                  onSetPickerOption,
                  onCalendarChange,
                  onPanelChange,
                  onMousedown: withModifiers(() => {
                  }, ["stop"])
                })
              ]),
              _: 3
            }, 16, ["visible", "transition", "popper-class", "popper-options", "fallback-placements", "placement"]);
          };
        }
      });
      var CommonPicker = exports("CommonPicker", /* @__PURE__ */ _export_sfc(_sfc_main$29, [["__file", "picker.vue"]]));
      const panelTimePickerProps = buildProps({
        ...timePanelSharedProps,
        datetimeRole: String,
        parsedValue: {
          type: definePropType(Object)
        }
      });
      const useTimePanel = ({
        getAvailableHours,
        getAvailableMinutes,
        getAvailableSeconds
      }) => {
        const getAvailableTime = (date3, role, first, compareDate) => {
          const availableTimeGetters = {
            hour: getAvailableHours,
            minute: getAvailableMinutes,
            second: getAvailableSeconds
          };
          let result2 = date3;
          ["hour", "minute", "second"].forEach((type) => {
            if (availableTimeGetters[type]) {
              let availableTimeSlots;
              const method3 = availableTimeGetters[type];
              switch (type) {
                case "minute": {
                  availableTimeSlots = method3(result2.hour(), role, compareDate);
                  break;
                }
                case "second": {
                  availableTimeSlots = method3(result2.hour(), result2.minute(), role, compareDate);
                  break;
                }
                default: {
                  availableTimeSlots = method3(role, compareDate);
                  break;
                }
              }
              if ((availableTimeSlots == null ? void 0 : availableTimeSlots.length) && !availableTimeSlots.includes(result2[type]())) {
                const pos = first ? 0 : availableTimeSlots.length - 1;
                result2 = result2[type](availableTimeSlots[pos]);
              }
            }
          });
          return result2;
        };
        const timePickerOptions = {};
        const onSetOption = ([key, val]) => {
          timePickerOptions[key] = val;
        };
        return {
          timePickerOptions,
          getAvailableTime,
          onSetOption
        };
      };
      const makeAvailableArr = (disabledList) => {
        const trueOrNumber = (isDisabled, index2) => isDisabled || index2;
        const getNumber = (predicate) => predicate !== true;
        return disabledList.map(trueOrNumber).filter(getNumber);
      };
      const getTimeLists = (disabledHours, disabledMinutes, disabledSeconds) => {
        const getHoursList = (role, compare) => {
          return makeList(24, disabledHours && (() => disabledHours == null ? void 0 : disabledHours(role, compare)));
        };
        const getMinutesList = (hour, role, compare) => {
          return makeList(60, disabledMinutes && (() => disabledMinutes == null ? void 0 : disabledMinutes(hour, role, compare)));
        };
        const getSecondsList = (hour, minute, role, compare) => {
          return makeList(60, disabledSeconds && (() => disabledSeconds == null ? void 0 : disabledSeconds(hour, minute, role, compare)));
        };
        return {
          getHoursList,
          getMinutesList,
          getSecondsList
        };
      };
      const buildAvailableTimeSlotGetter = (disabledHours, disabledMinutes, disabledSeconds) => {
        const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(disabledHours, disabledMinutes, disabledSeconds);
        const getAvailableHours = (role, compare) => {
          return makeAvailableArr(getHoursList(role, compare));
        };
        const getAvailableMinutes = (hour, role, compare) => {
          return makeAvailableArr(getMinutesList(hour, role, compare));
        };
        const getAvailableSeconds = (hour, minute, role, compare) => {
          return makeAvailableArr(getSecondsList(hour, minute, role, compare));
        };
        return {
          getAvailableHours,
          getAvailableMinutes,
          getAvailableSeconds
        };
      };
      const useOldValue = (props2) => {
        const oldValue = ref(props2.parsedValue);
        watch(() => props2.visible, (val) => {
          if (!val) {
            oldValue.value = props2.parsedValue;
          }
        });
        return oldValue;
      };
      const nodeList = /* @__PURE__ */ new Map();
      if (isClient) {
        let startClick;
        document.addEventListener("mousedown", (e) => startClick = e);
        document.addEventListener("mouseup", (e) => {
          if (startClick) {
            for (const handlers of nodeList.values()) {
              for (const { documentHandler } of handlers) {
                documentHandler(e, startClick);
              }
            }
            startClick = void 0;
          }
        });
      }
      function createDocumentHandler(el, binding) {
        let excludes = [];
        if (isArray$1(binding.arg)) {
          excludes = binding.arg;
        } else if (isElement$2(binding.arg)) {
          excludes.push(binding.arg);
        }
        return function(mouseup, mousedown) {
          const popperRef = binding.instance.popperRef;
          const mouseUpTarget = mouseup.target;
          const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
          const isBound = !binding || !binding.instance;
          const isTargetExists = !mouseUpTarget || !mouseDownTarget;
          const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
          const isSelf = el === mouseUpTarget;
          const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
          const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
          if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
            return;
          }
          binding.value(mouseup, mousedown);
        };
      }
      const ClickOutside = exports("ClickOutside", {
        beforeMount(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          nodeList.get(el).push({
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          });
        },
        updated(el, binding) {
          if (!nodeList.has(el)) {
            nodeList.set(el, []);
          }
          const handlers = nodeList.get(el);
          const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
          const newHandler = {
            documentHandler: createDocumentHandler(el, binding),
            bindingFn: binding.value
          };
          if (oldHandlerIndex >= 0) {
            handlers.splice(oldHandlerIndex, 1, newHandler);
          } else {
            handlers.push(newHandler);
          }
        },
        unmounted(el) {
          nodeList.delete(el);
        }
      });
      const REPEAT_INTERVAL = 100;
      const REPEAT_DELAY = 600;
      const vRepeatClick = exports("vRepeatClick", {
        beforeMount(el, binding) {
          const value = binding.value;
          const { interval = REPEAT_INTERVAL, delay: delay2 = REPEAT_DELAY } = isFunction$1(value) ? {} : value;
          let intervalId;
          let delayId;
          const handler = () => isFunction$1(value) ? value() : value.handler();
          const clear = () => {
            if (delayId) {
              clearTimeout(delayId);
              delayId = void 0;
            }
            if (intervalId) {
              clearInterval(intervalId);
              intervalId = void 0;
            }
          };
          el.addEventListener("mousedown", (evt) => {
            if (evt.button !== 0)
              return;
            clear();
            handler();
            document.addEventListener("mouseup", () => clear(), {
              once: true
            });
            delayId = setTimeout(() => {
              intervalId = setInterval(() => {
                handler();
              }, interval);
            }, delay2);
          });
        }
      });
      const FOCUSABLE_CHILDREN = "_trap-focus-children";
      const FOCUS_STACK = [];
      const FOCUS_HANDLER = (e) => {
        if (FOCUS_STACK.length === 0)
          return;
        const focusableElement = FOCUS_STACK[FOCUS_STACK.length - 1][FOCUSABLE_CHILDREN];
        if (focusableElement.length > 0 && e.code === EVENT_CODE.tab) {
          if (focusableElement.length === 1) {
            e.preventDefault();
            if (document.activeElement !== focusableElement[0]) {
              focusableElement[0].focus();
            }
            return;
          }
          const goingBackward = e.shiftKey;
          const isFirst = e.target === focusableElement[0];
          const isLast = e.target === focusableElement[focusableElement.length - 1];
          if (isFirst && goingBackward) {
            e.preventDefault();
            focusableElement[focusableElement.length - 1].focus();
          }
          if (isLast && !goingBackward) {
            e.preventDefault();
            focusableElement[0].focus();
          }
        }
      };
      const TrapFocus = exports("TrapFocus", {
        beforeMount(el) {
          el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
          FOCUS_STACK.push(el);
          if (FOCUS_STACK.length <= 1) {
            document.addEventListener("keydown", FOCUS_HANDLER);
          }
        },
        updated(el) {
          nextTick(() => {
            el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements$1(el);
          });
        },
        unmounted() {
          FOCUS_STACK.shift();
          if (FOCUS_STACK.length === 0) {
            document.removeEventListener("keydown", FOCUS_HANDLER);
          }
        }
      });
      var v = false, o, f, s, u, d, N, l, p, m, w, D, x, E, M, F;
      function a() {
        if (!v) {
          v = true;
          var e = navigator.userAgent, n = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e), i = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
          if (x = /\b(iPhone|iP[ao]d)/.exec(e), E = /\b(iP[ao]d)/.exec(e), w = /Android/i.exec(e), M = /FBAN\/\w+;/i.exec(e), F = /Mobile/i.exec(e), D = !!/Win64/.exec(e), n) {
            o = n[1] ? parseFloat(n[1]) : n[5] ? parseFloat(n[5]) : NaN, o && document && document.documentMode && (o = document.documentMode);
            var r = /(?:Trident\/(\d+.\d+))/.exec(e);
            N = r ? parseFloat(r[1]) + 4 : o, f = n[2] ? parseFloat(n[2]) : NaN, s = n[3] ? parseFloat(n[3]) : NaN, u = n[4] ? parseFloat(n[4]) : NaN, u ? (n = /(?:Chrome\/(\d+\.\d+))/.exec(e), d = n && n[1] ? parseFloat(n[1]) : NaN) : d = NaN;
          } else
            o = f = s = d = u = NaN;
          if (i) {
            if (i[1]) {
              var t = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
              l = t ? parseFloat(t[1].replace("_", ".")) : true;
            } else
              l = false;
            p = !!i[2], m = !!i[3];
          } else
            l = p = m = false;
        }
      }
      var _ = { ie: function() {
        return a() || o;
      }, ieCompatibilityMode: function() {
        return a() || N > o;
      }, ie64: function() {
        return _.ie() && D;
      }, firefox: function() {
        return a() || f;
      }, opera: function() {
        return a() || s;
      }, webkit: function() {
        return a() || u;
      }, safari: function() {
        return _.webkit();
      }, chrome: function() {
        return a() || d;
      }, windows: function() {
        return a() || p;
      }, osx: function() {
        return a() || l;
      }, linux: function() {
        return a() || m;
      }, iphone: function() {
        return a() || x;
      }, mobile: function() {
        return a() || x || E || w || F;
      }, nativeApp: function() {
        return a() || M;
      }, android: function() {
        return a() || w;
      }, ipad: function() {
        return a() || E;
      } }, A = _;
      var c = !!(typeof window < "u" && window.document && window.document.createElement), U = { canUseDOM: c, canUseWorkers: typeof Worker < "u", canUseEventListeners: c && !!(window.addEventListener || window.attachEvent), canUseViewport: c && !!window.screen, isInWorker: !c }, h = U;
      var X;
      h.canUseDOM && (X = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== true);
      function S(e, n) {
        if (!h.canUseDOM || n && !("addEventListener" in document))
          return false;
        var i = "on" + e, r = i in document;
        if (!r) {
          var t = document.createElement("div");
          t.setAttribute(i, "return;"), r = typeof t[i] == "function";
        }
        return !r && X && e === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
      }
      var b = S;
      var O = 10, I = 40, P = 800;
      function T(e) {
        var n = 0, i = 0, r = 0, t = 0;
        return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (n = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (n = i, i = 0), r = n * O, t = i * O, "deltaY" in e && (t = e.deltaY), "deltaX" in e && (r = e.deltaX), (r || t) && e.deltaMode && (e.deltaMode == 1 ? (r *= I, t *= I) : (r *= P, t *= P)), r && !n && (n = r < 1 ? -1 : 1), t && !i && (i = t < 1 ? -1 : 1), { spinX: n, spinY: i, pixelX: r, pixelY: t };
      }
      T.getEventType = function() {
        return A.firefox() ? "DOMMouseScroll" : b("wheel") ? "wheel" : "mousewheel";
      };
      var Y = T;
      /**
      * Checks if an event is supported in the current execution environment.
      *
      * NOTE: This will not work correctly for non-generic events such as `change`,
      * `reset`, `load`, `error`, and `select`.
      *
      * Borrows from Modernizr.
      *
      * @param {string} eventNameSuffix Event name, e.g. "click".
      * @param {?boolean} capture Check if the capture phase is supported.
      * @return {boolean} True if the event is supported.
      * @internal
      * @license Modernizr 3.0.0pre (Custom Build) | MIT
      */
      const mousewheel = function(element, callback) {
        if (element && element.addEventListener) {
          const fn2 = function(event) {
            const normalized = Y(event);
            callback && Reflect.apply(callback, this, [event, normalized]);
          };
          element.addEventListener("wheel", fn2, { passive: true });
        }
      };
      const Mousewheel = exports("Mousewheel", {
        beforeMount(el, binding) {
          mousewheel(el, binding.value);
        }
      });
      const basicTimeSpinnerProps = buildProps({
        role: {
          type: String,
          required: true
        },
        spinnerDate: {
          type: definePropType(Object),
          required: true
        },
        showSeconds: {
          type: Boolean,
          default: true
        },
        arrowControl: Boolean,
        amPmMode: {
          type: definePropType(String),
          default: ""
        },
        ...disabledTimeListsProps
      });
      const _sfc_main$28 = /* @__PURE__ */ defineComponent({
        __name: "basic-time-spinner",
        props: basicTimeSpinnerProps,
        emits: [CHANGE_EVENT, "select-range", "set-option"],
        setup(__props, { emit }) {
          const props2 = __props;
          const pickerBase = inject(PICKER_BASE_INJECTION_KEY);
          const { isRange, format: format2 } = pickerBase.props;
          const ns = useNamespace("time");
          const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(props2.disabledHours, props2.disabledMinutes, props2.disabledSeconds);
          let isScrolling = false;
          const currentScrollbar = ref();
          const listHoursRef = ref();
          const listMinutesRef = ref();
          const listSecondsRef = ref();
          const listRefsMap = {
            hours: listHoursRef,
            minutes: listMinutesRef,
            seconds: listSecondsRef
          };
          const spinnerItems = computed(() => {
            return props2.showSeconds ? timeUnits$1 : timeUnits$1.slice(0, 2);
          });
          const timePartials = computed(() => {
            const { spinnerDate } = props2;
            const hours = spinnerDate.hour();
            const minutes = spinnerDate.minute();
            const seconds = spinnerDate.second();
            return { hours, minutes, seconds };
          });
          const timeList = computed(() => {
            const { hours, minutes } = unref(timePartials);
            const { role, spinnerDate } = props2;
            const compare = !isRange ? spinnerDate : void 0;
            return {
              hours: getHoursList(role, compare),
              minutes: getMinutesList(hours, role, compare),
              seconds: getSecondsList(hours, minutes, role, compare)
            };
          });
          const arrowControlTimeList = computed(() => {
            const { hours, minutes, seconds } = unref(timePartials);
            return {
              hours: buildTimeList(hours, 23),
              minutes: buildTimeList(minutes, 59),
              seconds: buildTimeList(seconds, 59)
            };
          });
          const debouncedResetScroll = debounce((type) => {
            isScrolling = false;
            adjustCurrentSpinner(type);
          }, 200);
          const getAmPmFlag = (hour) => {
            const shouldShowAmPm = !!props2.amPmMode;
            if (!shouldShowAmPm)
              return "";
            const isCapital = props2.amPmMode === "A";
            let content = hour < 12 ? " am" : " pm";
            if (isCapital)
              content = content.toUpperCase();
            return content;
          };
          const emitSelectRange = (type) => {
            let range2 = [0, 0];
            const actualFormat = format2 || DEFAULT_FORMATS_TIME;
            const hourIndex = actualFormat.indexOf("HH");
            const minuteIndex = actualFormat.indexOf("mm");
            const secondIndex = actualFormat.indexOf("ss");
            switch (type) {
              case "hours":
                if (hourIndex !== -1) {
                  range2 = [hourIndex, hourIndex + 2];
                }
                break;
              case "minutes":
                if (minuteIndex !== -1) {
                  range2 = [minuteIndex, minuteIndex + 2];
                }
                break;
              case "seconds":
                if (secondIndex !== -1) {
                  range2 = [secondIndex, secondIndex + 2];
                }
                break;
            }
            const [left, right] = range2;
            emit("select-range", left, right);
            currentScrollbar.value = type;
          };
          const adjustCurrentSpinner = (type) => {
            adjustSpinner(type, unref(timePartials)[type]);
          };
          const adjustSpinners = () => {
            adjustCurrentSpinner("hours");
            adjustCurrentSpinner("minutes");
            adjustCurrentSpinner("seconds");
          };
          const getScrollbarElement = (el) => el.querySelector(`.${ns.namespace.value}-scrollbar__wrap`);
          const adjustSpinner = (type, value) => {
            if (props2.arrowControl)
              return;
            const scrollbar = unref(listRefsMap[type]);
            if (scrollbar && scrollbar.$el) {
              getScrollbarElement(scrollbar.$el).scrollTop = Math.max(0, value * typeItemHeight(type));
            }
          };
          const typeItemHeight = (type) => {
            const scrollbar = unref(listRefsMap[type]);
            const listItem = scrollbar == null ? void 0 : scrollbar.$el.querySelector("li");
            if (listItem) {
              return Number.parseFloat(getStyle(listItem, "height")) || 0;
            }
            return 0;
          };
          const onIncrement = () => {
            scrollDown(1);
          };
          const onDecrement = () => {
            scrollDown(-1);
          };
          const scrollDown = (step2) => {
            if (!currentScrollbar.value) {
              emitSelectRange("hours");
            }
            const label = currentScrollbar.value;
            const now2 = unref(timePartials)[label];
            const total2 = currentScrollbar.value === "hours" ? 24 : 60;
            const next = findNextUnDisabled(label, now2, step2, total2);
            modifyDateField(label, next);
            adjustSpinner(label, next);
            nextTick(() => emitSelectRange(label));
          };
          const findNextUnDisabled = (type, now2, step2, total2) => {
            let next = (now2 + step2 + total2) % total2;
            const list = unref(timeList)[type];
            while (list[next] && next !== now2) {
              next = (next + step2 + total2) % total2;
            }
            return next;
          };
          const modifyDateField = (type, value) => {
            const list = unref(timeList)[type];
            const isDisabled = list[value];
            if (isDisabled)
              return;
            const { hours, minutes, seconds } = unref(timePartials);
            let changeTo;
            switch (type) {
              case "hours":
                changeTo = props2.spinnerDate.hour(value).minute(minutes).second(seconds);
                break;
              case "minutes":
                changeTo = props2.spinnerDate.hour(hours).minute(value).second(seconds);
                break;
              case "seconds":
                changeTo = props2.spinnerDate.hour(hours).minute(minutes).second(value);
                break;
            }
            emit(CHANGE_EVENT, changeTo);
          };
          const handleClick = (type, { value, disabled }) => {
            if (!disabled) {
              modifyDateField(type, value);
              emitSelectRange(type);
              adjustSpinner(type, value);
            }
          };
          const handleScroll2 = (type) => {
            const scrollbar = unref(listRefsMap[type]);
            if (!scrollbar)
              return;
            isScrolling = true;
            debouncedResetScroll(type);
            const value = Math.min(Math.round((getScrollbarElement(scrollbar.$el).scrollTop - (scrollBarHeight(type) * 0.5 - 10) / typeItemHeight(type) + 3) / typeItemHeight(type)), type === "hours" ? 23 : 59);
            modifyDateField(type, value);
          };
          const scrollBarHeight = (type) => {
            return unref(listRefsMap[type]).$el.offsetHeight;
          };
          const bindScrollEvent = () => {
            const bindFunction = (type) => {
              const scrollbar = unref(listRefsMap[type]);
              if (scrollbar && scrollbar.$el) {
                getScrollbarElement(scrollbar.$el).onscroll = () => {
                  handleScroll2(type);
                };
              }
            };
            bindFunction("hours");
            bindFunction("minutes");
            bindFunction("seconds");
          };
          onMounted(() => {
            nextTick(() => {
              !props2.arrowControl && bindScrollEvent();
              adjustSpinners();
              if (props2.role === "start")
                emitSelectRange("hours");
            });
          });
          const setRef = (scrollbar, type) => {
            listRefsMap[type].value = scrollbar != null ? scrollbar : void 0;
          };
          emit("set-option", [`${props2.role}_scrollDown`, scrollDown]);
          emit("set-option", [`${props2.role}_emitSelectRange`, emitSelectRange]);
          watch(() => props2.spinnerDate, () => {
            if (isScrolling)
              return;
            adjustSpinners();
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b("spinner"), { "has-seconds": _ctx.showSeconds }])
            }, [
              !_ctx.arrowControl ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(spinnerItems), (item) => {
                return openBlock(), createBlock(unref(ElScrollbar), {
                  key: item,
                  ref_for: true,
                  ref: (scrollbar) => setRef(scrollbar, item),
                  class: normalizeClass(unref(ns).be("spinner", "wrapper")),
                  "wrap-style": "max-height: inherit;",
                  "view-class": unref(ns).be("spinner", "list"),
                  noresize: "",
                  tag: "ul",
                  onMouseenter: ($event) => emitSelectRange(item),
                  onMousemove: ($event) => adjustCurrentSpinner(item)
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(timeList)[item], (disabled, key) => {
                      return openBlock(), createElementBlock("li", {
                        key,
                        class: normalizeClass([
                          unref(ns).be("spinner", "item"),
                          unref(ns).is("active", key === unref(timePartials)[item]),
                          unref(ns).is("disabled", disabled)
                        ]),
                        onClick: ($event) => handleClick(item, { value: key, disabled })
                      }, [
                        item === "hours" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                          createTextVNode(toDisplayString(("0" + (_ctx.amPmMode ? key % 12 || 12 : key)).slice(-2)) + toDisplayString(getAmPmFlag(key)), 1)
                        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                          createTextVNode(toDisplayString(("0" + key).slice(-2)), 1)
                        ], 64))
                      ], 10, ["onClick"]);
                    }), 128))
                  ]),
                  _: 2
                }, 1032, ["class", "view-class", "onMouseenter", "onMousemove"]);
              }), 128)) : createCommentVNode("v-if", true),
              _ctx.arrowControl ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(spinnerItems), (item) => {
                return openBlock(), createElementBlock("div", {
                  key: item,
                  class: normalizeClass([unref(ns).be("spinner", "wrapper"), unref(ns).is("arrow")]),
                  onMouseenter: ($event) => emitSelectRange(item)
                }, [
                  withDirectives((openBlock(), createBlock(unref(ElIcon), {
                    class: normalizeClass(["arrow-up", unref(ns).be("spinner", "arrow")])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(arrow_up_default$1))
                    ]),
                    _: 1
                  }, 8, ["class"])), [
                    [unref(vRepeatClick), onDecrement]
                  ]),
                  withDirectives((openBlock(), createBlock(unref(ElIcon), {
                    class: normalizeClass(["arrow-down", unref(ns).be("spinner", "arrow")])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(arrow_down_default$1))
                    ]),
                    _: 1
                  }, 8, ["class"])), [
                    [unref(vRepeatClick), onIncrement]
                  ]),
                  createElementVNode("ul", {
                    class: normalizeClass(unref(ns).be("spinner", "list"))
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(arrowControlTimeList)[item], (time, key) => {
                      return openBlock(), createElementBlock("li", {
                        key,
                        class: normalizeClass([
                          unref(ns).be("spinner", "item"),
                          unref(ns).is("active", time === unref(timePartials)[item]),
                          unref(ns).is("disabled", unref(timeList)[item][time])
                        ])
                      }, [
                        unref(isNumber)(time) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                          item === "hours" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                            createTextVNode(toDisplayString(("0" + (_ctx.amPmMode ? time % 12 || 12 : time)).slice(-2)) + toDisplayString(getAmPmFlag(time)), 1)
                          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                            createTextVNode(toDisplayString(("0" + time).slice(-2)), 1)
                          ], 64))
                        ], 64)) : createCommentVNode("v-if", true)
                      ], 2);
                    }), 128))
                  ], 2)
                ], 42, ["onMouseenter"]);
              }), 128)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var TimeSpinner = /* @__PURE__ */ _export_sfc(_sfc_main$28, [["__file", "basic-time-spinner.vue"]]);
      const _sfc_main$27 = /* @__PURE__ */ defineComponent({
        __name: "panel-time-pick",
        props: panelTimePickerProps,
        emits: ["pick", "select-range", "set-picker-option"],
        setup(__props, { emit }) {
          const props2 = __props;
          const pickerBase = inject(PICKER_BASE_INJECTION_KEY);
          const {
            arrowControl,
            disabledHours,
            disabledMinutes,
            disabledSeconds,
            defaultValue
          } = pickerBase.props;
          const { getAvailableHours, getAvailableMinutes, getAvailableSeconds } = buildAvailableTimeSlotGetter(disabledHours, disabledMinutes, disabledSeconds);
          const ns = useNamespace("time");
          const { t, lang: lang2 } = useLocale();
          const selectionRange = ref([0, 2]);
          const oldValue = useOldValue(props2);
          const transitionName = computed(() => {
            return isUndefined(props2.actualVisible) ? `${ns.namespace.value}-zoom-in-top` : "";
          });
          const showSeconds = computed(() => {
            return props2.format.includes("ss");
          });
          const amPmMode = computed(() => {
            if (props2.format.includes("A"))
              return "A";
            if (props2.format.includes("a"))
              return "a";
            return "";
          });
          const isValidValue2 = (_date) => {
            const parsedDate = dayjs(_date).locale(lang2.value);
            const result2 = getRangeAvailableTime(parsedDate);
            return parsedDate.isSame(result2);
          };
          const handleCancel = () => {
            emit("pick", oldValue.value, false);
          };
          const handleConfirm = (visible = false, first = false) => {
            if (first)
              return;
            emit("pick", props2.parsedValue, visible);
          };
          const handleChange = (_date) => {
            if (!props2.visible) {
              return;
            }
            const result2 = getRangeAvailableTime(_date).millisecond(0);
            emit("pick", result2, true);
          };
          const setSelectionRange = (start, end) => {
            emit("select-range", start, end);
            selectionRange.value = [start, end];
          };
          const changeSelectionRange = (step2) => {
            const actualFormat = props2.format;
            const hourIndex = actualFormat.indexOf("HH");
            const minuteIndex = actualFormat.indexOf("mm");
            const secondIndex = actualFormat.indexOf("ss");
            const list = [];
            const mapping = [];
            if (hourIndex !== -1) {
              list.push(hourIndex);
              mapping.push("hours");
            }
            if (minuteIndex !== -1) {
              list.push(minuteIndex);
              mapping.push("minutes");
            }
            if (secondIndex !== -1 && showSeconds.value) {
              list.push(secondIndex);
              mapping.push("seconds");
            }
            const index2 = list.indexOf(selectionRange.value[0]);
            const next = (index2 + step2 + list.length) % list.length;
            timePickerOptions["start_emitSelectRange"](mapping[next]);
          };
          const handleKeydown = (event) => {
            const code = event.code;
            const { left, right, up, down } = EVENT_CODE;
            if ([left, right].includes(code)) {
              const step2 = code === left ? -1 : 1;
              changeSelectionRange(step2);
              event.preventDefault();
              return;
            }
            if ([up, down].includes(code)) {
              const step2 = code === up ? -1 : 1;
              timePickerOptions["start_scrollDown"](step2);
              event.preventDefault();
              return;
            }
          };
          const { timePickerOptions, onSetOption, getAvailableTime } = useTimePanel({
            getAvailableHours,
            getAvailableMinutes,
            getAvailableSeconds
          });
          const getRangeAvailableTime = (date3) => {
            return getAvailableTime(date3, props2.datetimeRole || "", true);
          };
          const parseUserInput = (value) => {
            if (!value)
              return null;
            return dayjs(value, props2.format).locale(lang2.value);
          };
          const formatToString = (value) => {
            if (!value)
              return null;
            return value.format(props2.format);
          };
          const getDefaultValue2 = () => {
            return dayjs(defaultValue).locale(lang2.value);
          };
          emit("set-picker-option", ["isValidValue", isValidValue2]);
          emit("set-picker-option", ["formatToString", formatToString]);
          emit("set-picker-option", ["parseUserInput", parseUserInput]);
          emit("set-picker-option", ["handleKeydownInput", handleKeydown]);
          emit("set-picker-option", ["getRangeAvailableTime", getRangeAvailableTime]);
          emit("set-picker-option", ["getDefaultValue", getDefaultValue2]);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, { name: unref(transitionName) }, {
              default: withCtx(() => [
                _ctx.actualVisible || _ctx.visible ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).b("panel"))
                }, [
                  createElementVNode("div", {
                    class: normalizeClass([unref(ns).be("panel", "content"), { "has-seconds": unref(showSeconds) }])
                  }, [
                    createVNode(TimeSpinner, {
                      ref: "spinner",
                      role: _ctx.datetimeRole || "start",
                      "arrow-control": unref(arrowControl),
                      "show-seconds": unref(showSeconds),
                      "am-pm-mode": unref(amPmMode),
                      "spinner-date": _ctx.parsedValue,
                      "disabled-hours": unref(disabledHours),
                      "disabled-minutes": unref(disabledMinutes),
                      "disabled-seconds": unref(disabledSeconds),
                      onChange: handleChange,
                      onSetOption: unref(onSetOption),
                      onSelectRange: setSelectionRange
                    }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onSetOption"])
                  ], 2),
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).be("panel", "footer"))
                  }, [
                    createElementVNode("button", {
                      type: "button",
                      class: normalizeClass([unref(ns).be("panel", "btn"), "cancel"]),
                      onClick: handleCancel
                    }, toDisplayString(unref(t)("el.datepicker.cancel")), 3),
                    createElementVNode("button", {
                      type: "button",
                      class: normalizeClass([unref(ns).be("panel", "btn"), "confirm"]),
                      onClick: ($event) => handleConfirm()
                    }, toDisplayString(unref(t)("el.datepicker.confirm")), 11, ["onClick"])
                  ], 2)
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 1
            }, 8, ["name"]);
          };
        }
      });
      var TimePickPanel = exports("TimePickPanel", /* @__PURE__ */ _export_sfc(_sfc_main$27, [["__file", "panel-time-pick.vue"]]));
      const panelTimeRangeProps = buildProps({
        ...timePanelSharedProps,
        parsedValue: {
          type: definePropType(Array)
        }
      });
      const _sfc_main$26 = /* @__PURE__ */ defineComponent({
        __name: "panel-time-range",
        props: panelTimeRangeProps,
        emits: ["pick", "select-range", "set-picker-option"],
        setup(__props, { emit }) {
          const props2 = __props;
          const makeSelectRange = (start, end) => {
            const result2 = [];
            for (let i = start; i <= end; i++) {
              result2.push(i);
            }
            return result2;
          };
          const { t, lang: lang2 } = useLocale();
          const nsTime = useNamespace("time");
          const nsPicker = useNamespace("picker");
          const pickerBase = inject(PICKER_BASE_INJECTION_KEY);
          const {
            arrowControl,
            disabledHours,
            disabledMinutes,
            disabledSeconds,
            defaultValue
          } = pickerBase.props;
          const startContainerKls = computed(() => [
            nsTime.be("range-picker", "body"),
            nsTime.be("panel", "content"),
            nsTime.is("arrow", arrowControl),
            showSeconds.value ? "has-seconds" : ""
          ]);
          const endContainerKls = computed(() => [
            nsTime.be("range-picker", "body"),
            nsTime.be("panel", "content"),
            nsTime.is("arrow", arrowControl),
            showSeconds.value ? "has-seconds" : ""
          ]);
          const startTime = computed(() => props2.parsedValue[0]);
          const endTime = computed(() => props2.parsedValue[1]);
          const oldValue = useOldValue(props2);
          const handleCancel = () => {
            emit("pick", oldValue.value, false);
          };
          const showSeconds = computed(() => {
            return props2.format.includes("ss");
          });
          const amPmMode = computed(() => {
            if (props2.format.includes("A"))
              return "A";
            if (props2.format.includes("a"))
              return "a";
            return "";
          });
          const handleConfirm = (visible = false) => {
            emit("pick", [startTime.value, endTime.value], visible);
          };
          const handleMinChange = (date3) => {
            handleChange(date3.millisecond(0), endTime.value);
          };
          const handleMaxChange = (date3) => {
            handleChange(startTime.value, date3.millisecond(0));
          };
          const isValidValue2 = (_date) => {
            const parsedDate = _date.map((_2) => dayjs(_2).locale(lang2.value));
            const result2 = getRangeAvailableTime(parsedDate);
            return parsedDate[0].isSame(result2[0]) && parsedDate[1].isSame(result2[1]);
          };
          const handleChange = (start, end) => {
            if (!props2.visible) {
              return;
            }
            emit("pick", [start, end], true);
          };
          const btnConfirmDisabled = computed(() => {
            return startTime.value > endTime.value;
          });
          const selectionRange = ref([0, 2]);
          const setMinSelectionRange = (start, end) => {
            emit("select-range", start, end, "min");
            selectionRange.value = [start, end];
          };
          const offset2 = computed(() => showSeconds.value ? 11 : 8);
          const setMaxSelectionRange = (start, end) => {
            emit("select-range", start, end, "max");
            const _offset = unref(offset2);
            selectionRange.value = [start + _offset, end + _offset];
          };
          const changeSelectionRange = (step2) => {
            const list = showSeconds.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11];
            const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
            const index2 = list.indexOf(selectionRange.value[0]);
            const next = (index2 + step2 + list.length) % list.length;
            const half = list.length / 2;
            if (next < half) {
              timePickerOptions["start_emitSelectRange"](mapping[next]);
            } else {
              timePickerOptions["end_emitSelectRange"](mapping[next - half]);
            }
          };
          const handleKeydown = (event) => {
            const code = event.code;
            const { left, right, up, down } = EVENT_CODE;
            if ([left, right].includes(code)) {
              const step2 = code === left ? -1 : 1;
              changeSelectionRange(step2);
              event.preventDefault();
              return;
            }
            if ([up, down].includes(code)) {
              const step2 = code === up ? -1 : 1;
              const role = selectionRange.value[0] < offset2.value ? "start" : "end";
              timePickerOptions[`${role}_scrollDown`](step2);
              event.preventDefault();
              return;
            }
          };
          const disabledHours_ = (role, compare) => {
            const defaultDisable = disabledHours ? disabledHours(role) : [];
            const isStart = role === "start";
            const compareDate = compare || (isStart ? endTime.value : startTime.value);
            const compareHour = compareDate.hour();
            const nextDisable = isStart ? makeSelectRange(compareHour + 1, 23) : makeSelectRange(0, compareHour - 1);
            return union(defaultDisable, nextDisable);
          };
          const disabledMinutes_ = (hour, role, compare) => {
            const defaultDisable = disabledMinutes ? disabledMinutes(hour, role) : [];
            const isStart = role === "start";
            const compareDate = compare || (isStart ? endTime.value : startTime.value);
            const compareHour = compareDate.hour();
            if (hour !== compareHour) {
              return defaultDisable;
            }
            const compareMinute = compareDate.minute();
            const nextDisable = isStart ? makeSelectRange(compareMinute + 1, 59) : makeSelectRange(0, compareMinute - 1);
            return union(defaultDisable, nextDisable);
          };
          const disabledSeconds_ = (hour, minute, role, compare) => {
            const defaultDisable = disabledSeconds ? disabledSeconds(hour, minute, role) : [];
            const isStart = role === "start";
            const compareDate = compare || (isStart ? endTime.value : startTime.value);
            const compareHour = compareDate.hour();
            const compareMinute = compareDate.minute();
            if (hour !== compareHour || minute !== compareMinute) {
              return defaultDisable;
            }
            const compareSecond = compareDate.second();
            const nextDisable = isStart ? makeSelectRange(compareSecond + 1, 59) : makeSelectRange(0, compareSecond - 1);
            return union(defaultDisable, nextDisable);
          };
          const getRangeAvailableTime = ([start, end]) => {
            return [
              getAvailableTime(start, "start", true, end),
              getAvailableTime(end, "end", false, start)
            ];
          };
          const { getAvailableHours, getAvailableMinutes, getAvailableSeconds } = buildAvailableTimeSlotGetter(disabledHours_, disabledMinutes_, disabledSeconds_);
          const {
            timePickerOptions,
            getAvailableTime,
            onSetOption
          } = useTimePanel({
            getAvailableHours,
            getAvailableMinutes,
            getAvailableSeconds
          });
          const parseUserInput = (days) => {
            if (!days)
              return null;
            if (isArray$1(days)) {
              return days.map((d2) => dayjs(d2, props2.format).locale(lang2.value));
            }
            return dayjs(days, props2.format).locale(lang2.value);
          };
          const formatToString = (days) => {
            if (!days)
              return null;
            if (isArray$1(days)) {
              return days.map((d2) => d2.format(props2.format));
            }
            return days.format(props2.format);
          };
          const getDefaultValue2 = () => {
            if (isArray$1(defaultValue)) {
              return defaultValue.map((d2) => dayjs(d2).locale(lang2.value));
            }
            const defaultDay = dayjs(defaultValue).locale(lang2.value);
            return [defaultDay, defaultDay.add(60, "m")];
          };
          emit("set-picker-option", ["formatToString", formatToString]);
          emit("set-picker-option", ["parseUserInput", parseUserInput]);
          emit("set-picker-option", ["isValidValue", isValidValue2]);
          emit("set-picker-option", ["handleKeydownInput", handleKeydown]);
          emit("set-picker-option", ["getDefaultValue", getDefaultValue2]);
          emit("set-picker-option", ["getRangeAvailableTime", getRangeAvailableTime]);
          return (_ctx, _cache) => {
            return _ctx.actualVisible ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass([unref(nsTime).b("range-picker"), unref(nsPicker).b("panel")])
            }, [
              createElementVNode("div", {
                class: normalizeClass(unref(nsTime).be("range-picker", "content"))
              }, [
                createElementVNode("div", {
                  class: normalizeClass(unref(nsTime).be("range-picker", "cell"))
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(unref(nsTime).be("range-picker", "header"))
                  }, toDisplayString(unref(t)("el.datepicker.startTime")), 3),
                  createElementVNode("div", {
                    class: normalizeClass(unref(startContainerKls))
                  }, [
                    createVNode(TimeSpinner, {
                      ref: "minSpinner",
                      role: "start",
                      "show-seconds": unref(showSeconds),
                      "am-pm-mode": unref(amPmMode),
                      "arrow-control": unref(arrowControl),
                      "spinner-date": unref(startTime),
                      "disabled-hours": disabledHours_,
                      "disabled-minutes": disabledMinutes_,
                      "disabled-seconds": disabledSeconds_,
                      onChange: handleMinChange,
                      onSetOption: unref(onSetOption),
                      onSelectRange: setMinSelectionRange
                    }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
                  ], 2)
                ], 2),
                createElementVNode("div", {
                  class: normalizeClass(unref(nsTime).be("range-picker", "cell"))
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(unref(nsTime).be("range-picker", "header"))
                  }, toDisplayString(unref(t)("el.datepicker.endTime")), 3),
                  createElementVNode("div", {
                    class: normalizeClass(unref(endContainerKls))
                  }, [
                    createVNode(TimeSpinner, {
                      ref: "maxSpinner",
                      role: "end",
                      "show-seconds": unref(showSeconds),
                      "am-pm-mode": unref(amPmMode),
                      "arrow-control": unref(arrowControl),
                      "spinner-date": unref(endTime),
                      "disabled-hours": disabledHours_,
                      "disabled-minutes": disabledMinutes_,
                      "disabled-seconds": disabledSeconds_,
                      onChange: handleMaxChange,
                      onSetOption: unref(onSetOption),
                      onSelectRange: setMaxSelectionRange
                    }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
                  ], 2)
                ], 2)
              ], 2),
              createElementVNode("div", {
                class: normalizeClass(unref(nsTime).be("panel", "footer"))
              }, [
                createElementVNode("button", {
                  type: "button",
                  class: normalizeClass([unref(nsTime).be("panel", "btn"), "cancel"]),
                  onClick: ($event) => handleCancel()
                }, toDisplayString(unref(t)("el.datepicker.cancel")), 11, ["onClick"]),
                createElementVNode("button", {
                  type: "button",
                  class: normalizeClass([unref(nsTime).be("panel", "btn"), "confirm"]),
                  disabled: unref(btnConfirmDisabled),
                  onClick: ($event) => handleConfirm()
                }, toDisplayString(unref(t)("el.datepicker.confirm")), 11, ["disabled", "onClick"])
              ], 2)
            ], 2)) : createCommentVNode("v-if", true);
          };
        }
      });
      var TimeRangePanel = /* @__PURE__ */ _export_sfc(_sfc_main$26, [["__file", "panel-time-range.vue"]]);
      dayjs.extend(customParseFormat);
      var TimePicker = defineComponent({
        name: "ElTimePicker",
        install: null,
        props: {
          ...timePickerDefaultProps,
          isRange: Boolean
        },
        emits: [UPDATE_MODEL_EVENT],
        setup(props2, ctx) {
          const commonPicker = ref();
          const [type, Panel] = props2.isRange ? ["timerange", TimeRangePanel] : ["time", TimePickPanel];
          const modelUpdater = (value) => ctx.emit(UPDATE_MODEL_EVENT, value);
          provide(PICKER_POPPER_OPTIONS_INJECTION_KEY, props2.popperOptions);
          ctx.expose({
            focus: () => {
              var _a;
              (_a = commonPicker.value) == null ? void 0 : _a.focus();
            },
            blur: () => {
              var _a;
              (_a = commonPicker.value) == null ? void 0 : _a.blur();
            },
            handleOpen: () => {
              var _a;
              (_a = commonPicker.value) == null ? void 0 : _a.handleOpen();
            },
            handleClose: () => {
              var _a;
              (_a = commonPicker.value) == null ? void 0 : _a.handleClose();
            }
          });
          return () => {
            var _a;
            const format2 = (_a = props2.format) != null ? _a : DEFAULT_FORMATS_TIME;
            return createVNode(CommonPicker, mergeProps(props2, {
              "ref": commonPicker,
              "type": type,
              "format": format2,
              "onUpdate:modelValue": modelUpdater
            }), {
              default: (props22) => createVNode(Panel, props22, null)
            });
          };
        }
      });
      const ElTimePicker = exports("ElTimePicker", withInstall(TimePicker));
      const getPrevMonthLastDays = (date3, count) => {
        const lastDay = date3.subtract(1, "month").endOf("month").date();
        return rangeArr(count).map((_2, index2) => lastDay - (count - index2 - 1));
      };
      const getMonthDays = (date3) => {
        const days = date3.daysInMonth();
        return rangeArr(days).map((_2, index2) => index2 + 1);
      };
      const toNestedArr = (days) => rangeArr(days.length / 7).map((index2) => {
        const start = index2 * 7;
        return days.slice(start, start + 7);
      });
      const dateTableProps = buildProps({
        selectedDay: {
          type: definePropType(Object)
        },
        range: {
          type: definePropType(Array)
        },
        date: {
          type: definePropType(Object),
          required: true
        },
        hideHeader: {
          type: Boolean
        }
      });
      const dateTableEmits = {
        pick: (value) => isObject$1(value)
      };
      var localeData$1 = { exports: {} };
      (function(module2, exports2) {
        !function(n, e) {
          module2.exports = e();
        }(commonjsGlobal, function() {
          return function(n, e, t) {
            var r = e.prototype, o2 = function(n2) {
              return n2 && (n2.indexOf ? n2 : n2.s);
            }, u2 = function(n2, e2, t2, r2, u22) {
              var i2 = n2.name ? n2 : n2.$locale(), a22 = o2(i2[e2]), s22 = o2(i2[t2]), f2 = a22 || s22.map(function(n3) {
                return n3.slice(0, r2);
              });
              if (!u22)
                return f2;
              var d2 = i2.weekStart;
              return f2.map(function(n3, e3) {
                return f2[(e3 + (d2 || 0)) % 7];
              });
            }, i = function() {
              return t.Ls[t.locale()];
            }, a2 = function(n2, e2) {
              return n2.formats[e2] || function(n3) {
                return n3.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n4, e3, t2) {
                  return e3 || t2.slice(1);
                });
              }(n2.formats[e2.toUpperCase()]);
            }, s2 = function() {
              var n2 = this;
              return { months: function(e2) {
                return e2 ? e2.format("MMMM") : u2(n2, "months");
              }, monthsShort: function(e2) {
                return e2 ? e2.format("MMM") : u2(n2, "monthsShort", "months", 3);
              }, firstDayOfWeek: function() {
                return n2.$locale().weekStart || 0;
              }, weekdays: function(e2) {
                return e2 ? e2.format("dddd") : u2(n2, "weekdays");
              }, weekdaysMin: function(e2) {
                return e2 ? e2.format("dd") : u2(n2, "weekdaysMin", "weekdays", 2);
              }, weekdaysShort: function(e2) {
                return e2 ? e2.format("ddd") : u2(n2, "weekdaysShort", "weekdays", 3);
              }, longDateFormat: function(e2) {
                return a2(n2.$locale(), e2);
              }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
            };
            r.localeData = function() {
              return s2.bind(this)();
            }, t.localeData = function() {
              var n2 = i();
              return { firstDayOfWeek: function() {
                return n2.weekStart || 0;
              }, weekdays: function() {
                return t.weekdays();
              }, weekdaysShort: function() {
                return t.weekdaysShort();
              }, weekdaysMin: function() {
                return t.weekdaysMin();
              }, months: function() {
                return t.months();
              }, monthsShort: function() {
                return t.monthsShort();
              }, longDateFormat: function(e2) {
                return a2(n2, e2);
              }, meridiem: n2.meridiem, ordinal: n2.ordinal };
            }, t.months = function() {
              return u2(i(), "months");
            }, t.monthsShort = function() {
              return u2(i(), "monthsShort", "months", 3);
            }, t.weekdays = function(n2) {
              return u2(i(), "weekdays", null, null, n2);
            }, t.weekdaysShort = function(n2) {
              return u2(i(), "weekdaysShort", "weekdays", 3, n2);
            }, t.weekdaysMin = function(n2) {
              return u2(i(), "weekdaysMin", "weekdays", 2, n2);
            };
          };
        });
      })(localeData$1);
      var localeData = localeData$1.exports;
      const useDateTable = (props2, emit) => {
        dayjs.extend(localeData);
        const firstDayOfWeek = dayjs.localeData().firstDayOfWeek();
        const { t, lang: lang2 } = useLocale();
        const now2 = dayjs().locale(lang2.value);
        const isInRange = computed(() => !!props2.range && !!props2.range.length);
        const rows = computed(() => {
          let days = [];
          if (isInRange.value) {
            const [start, end] = props2.range;
            const currentMonthRange = rangeArr(end.date() - start.date() + 1).map((index2) => ({
              text: start.date() + index2,
              type: "current"
            }));
            let remaining = currentMonthRange.length % 7;
            remaining = remaining === 0 ? 0 : 7 - remaining;
            const nextMonthRange = rangeArr(remaining).map((_2, index2) => ({
              text: index2 + 1,
              type: "next"
            }));
            days = currentMonthRange.concat(nextMonthRange);
          } else {
            const firstDay = props2.date.startOf("month").day();
            const prevMonthDays = getPrevMonthLastDays(props2.date, (firstDay - firstDayOfWeek + 7) % 7).map((day) => ({
              text: day,
              type: "prev"
            }));
            const currentMonthDays = getMonthDays(props2.date).map((day) => ({
              text: day,
              type: "current"
            }));
            days = [...prevMonthDays, ...currentMonthDays];
            const remaining = 7 - (days.length % 7 || 7);
            const nextMonthDays = rangeArr(remaining).map((_2, index2) => ({
              text: index2 + 1,
              type: "next"
            }));
            days = days.concat(nextMonthDays);
          }
          return toNestedArr(days);
        });
        const weekDays = computed(() => {
          const start = firstDayOfWeek;
          if (start === 0) {
            return WEEK_DAYS.map((_2) => t(`el.datepicker.weeks.${_2}`));
          } else {
            return WEEK_DAYS.slice(start).concat(WEEK_DAYS.slice(0, start)).map((_2) => t(`el.datepicker.weeks.${_2}`));
          }
        });
        const getFormattedDate = (day, type) => {
          switch (type) {
            case "prev":
              return props2.date.startOf("month").subtract(1, "month").date(day);
            case "next":
              return props2.date.startOf("month").add(1, "month").date(day);
            case "current":
              return props2.date.date(day);
          }
        };
        const handlePickDay = ({ text, type }) => {
          const date3 = getFormattedDate(text, type);
          emit("pick", date3);
        };
        const getSlotData = ({ text, type }) => {
          const day = getFormattedDate(text, type);
          return {
            isSelected: day.isSame(props2.selectedDay),
            type: `${type}-month`,
            day: day.format("YYYY-MM-DD"),
            date: day.toDate()
          };
        };
        return {
          now: now2,
          isInRange,
          rows,
          weekDays,
          getFormattedDate,
          handlePickDay,
          getSlotData
        };
      };
      const __default__$1C = defineComponent({
        name: "DateTable"
      });
      const _sfc_main$25 = /* @__PURE__ */ defineComponent({
        ...__default__$1C,
        props: dateTableProps,
        emits: dateTableEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const {
            isInRange,
            now: now2,
            rows,
            weekDays,
            getFormattedDate,
            handlePickDay,
            getSlotData
          } = useDateTable(props2, emit);
          const nsTable = useNamespace("calendar-table");
          const nsDay = useNamespace("calendar-day");
          const getCellClass = ({ text, type }) => {
            const classes = [type];
            if (type === "current") {
              const date3 = getFormattedDate(text, type);
              if (date3.isSame(props2.selectedDay, "day")) {
                classes.push(nsDay.is("selected"));
              }
              if (date3.isSame(now2, "day")) {
                classes.push(nsDay.is("today"));
              }
            }
            return classes;
          };
          expose({
            getFormattedDate
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("table", {
              class: normalizeClass([unref(nsTable).b(), unref(nsTable).is("range", unref(isInRange))]),
              cellspacing: "0",
              cellpadding: "0"
            }, [
              !_ctx.hideHeader ? (openBlock(), createElementBlock("thead", { key: 0 }, [
                createElementVNode("tr", null, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(weekDays), (day) => {
                    return openBlock(), createElementBlock("th", {
                      key: day,
                      scope: "col"
                    }, toDisplayString(day), 1);
                  }), 128))
                ])
              ])) : createCommentVNode("v-if", true),
              createElementVNode("tbody", null, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(rows), (row, index2) => {
                  return openBlock(), createElementBlock("tr", {
                    key: index2,
                    class: normalizeClass({
                      [unref(nsTable).e("row")]: true,
                      [unref(nsTable).em("row", "hide-border")]: index2 === 0 && _ctx.hideHeader
                    })
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, key) => {
                      return openBlock(), createElementBlock("td", {
                        key,
                        class: normalizeClass(getCellClass(cell)),
                        onClick: ($event) => unref(handlePickDay)(cell)
                      }, [
                        createElementVNode("div", {
                          class: normalizeClass(unref(nsDay).b())
                        }, [
                          renderSlot(_ctx.$slots, "date-cell", {
                            data: unref(getSlotData)(cell)
                          }, () => [
                            createElementVNode("span", null, toDisplayString(cell.text), 1)
                          ])
                        ], 2)
                      ], 10, ["onClick"]);
                    }), 128))
                  ], 2);
                }), 128))
              ])
            ], 2);
          };
        }
      });
      var DateTable$1 = /* @__PURE__ */ _export_sfc(_sfc_main$25, [["__file", "date-table.vue"]]);
      const adjacentMonth = (start, end) => {
        const firstMonthLastDay = start.endOf("month");
        const lastMonthFirstDay = end.startOf("month");
        const isSameWeek = firstMonthLastDay.isSame(lastMonthFirstDay, "week");
        const lastMonthStartDay = isSameWeek ? lastMonthFirstDay.add(1, "week") : lastMonthFirstDay;
        return [
          [start, firstMonthLastDay],
          [lastMonthStartDay.startOf("week"), end]
        ];
      };
      const threeConsecutiveMonth = (start, end) => {
        const firstMonthLastDay = start.endOf("month");
        const secondMonthFirstDay = start.add(1, "month").startOf("month");
        const secondMonthStartDay = firstMonthLastDay.isSame(secondMonthFirstDay, "week") ? secondMonthFirstDay.add(1, "week") : secondMonthFirstDay;
        const secondMonthLastDay = secondMonthStartDay.endOf("month");
        const lastMonthFirstDay = end.startOf("month");
        const lastMonthStartDay = secondMonthLastDay.isSame(lastMonthFirstDay, "week") ? lastMonthFirstDay.add(1, "week") : lastMonthFirstDay;
        return [
          [start, firstMonthLastDay],
          [secondMonthStartDay.startOf("week"), secondMonthLastDay],
          [lastMonthStartDay.startOf("week"), end]
        ];
      };
      const useCalendar = (props2, emit, componentName2) => {
        const { lang: lang2 } = useLocale();
        const selectedDay = ref();
        const now2 = dayjs().locale(lang2.value);
        const realSelectedDay = computed({
          get() {
            if (!props2.modelValue)
              return selectedDay.value;
            return date3.value;
          },
          set(val) {
            if (!val)
              return;
            selectedDay.value = val;
            const result2 = val.toDate();
            emit(INPUT_EVENT, result2);
            emit(UPDATE_MODEL_EVENT, result2);
          }
        });
        const validatedRange = computed(() => {
          if (!props2.range || !isArray$1(props2.range) || props2.range.length !== 2 || props2.range.some((item) => !isDate$1(item)))
            return [];
          const rangeArrDayjs = props2.range.map((_2) => dayjs(_2).locale(lang2.value));
          const [startDayjs, endDayjs] = rangeArrDayjs;
          if (startDayjs.isAfter(endDayjs)) {
            return [];
          }
          if (startDayjs.isSame(endDayjs, "month")) {
            return calculateValidatedDateRange(startDayjs, endDayjs);
          } else {
            if (startDayjs.add(1, "month").month() !== endDayjs.month()) {
              return [];
            }
            return calculateValidatedDateRange(startDayjs, endDayjs);
          }
        });
        const date3 = computed(() => {
          if (!props2.modelValue) {
            return realSelectedDay.value || (validatedRange.value.length ? validatedRange.value[0][0] : now2);
          } else {
            return dayjs(props2.modelValue).locale(lang2.value);
          }
        });
        const prevMonthDayjs = computed(() => date3.value.subtract(1, "month").date(1));
        const nextMonthDayjs = computed(() => date3.value.add(1, "month").date(1));
        const prevYearDayjs = computed(() => date3.value.subtract(1, "year").date(1));
        const nextYearDayjs = computed(() => date3.value.add(1, "year").date(1));
        const calculateValidatedDateRange = (startDayjs, endDayjs) => {
          const firstDay = startDayjs.startOf("week");
          const lastDay = endDayjs.endOf("week");
          const firstMonth = firstDay.get("month");
          const lastMonth = lastDay.get("month");
          if (firstMonth === lastMonth) {
            return [[firstDay, lastDay]];
          } else if ((firstMonth + 1) % 12 === lastMonth) {
            return adjacentMonth(firstDay, lastDay);
          } else if (firstMonth + 2 === lastMonth || (firstMonth + 1) % 11 === lastMonth) {
            return threeConsecutiveMonth(firstDay, lastDay);
          } else {
            return [];
          }
        };
        const pickDay = (day) => {
          realSelectedDay.value = day;
        };
        const selectDate = (type) => {
          const dateMap = {
            "prev-month": prevMonthDayjs.value,
            "next-month": nextMonthDayjs.value,
            "prev-year": prevYearDayjs.value,
            "next-year": nextYearDayjs.value,
            today: now2
          };
          const day = dateMap[type];
          if (!day.isSame(date3.value, "day")) {
            pickDay(day);
          }
        };
        return {
          calculateValidatedDateRange,
          date: date3,
          realSelectedDay,
          pickDay,
          selectDate,
          validatedRange
        };
      };
      const isValidRange$1 = (range2) => isArray$1(range2) && range2.length === 2 && range2.every((item) => isDate$1(item));
      const calendarProps = exports("calendarProps", buildProps({
        modelValue: {
          type: Date
        },
        range: {
          type: definePropType(Array),
          validator: isValidRange$1
        }
      }));
      const calendarEmits = exports("calendarEmits", {
        [UPDATE_MODEL_EVENT]: (value) => isDate$1(value),
        [INPUT_EVENT]: (value) => isDate$1(value)
      });
      const COMPONENT_NAME$i = "ElCalendar";
      const __default__$1B = defineComponent({
        name: COMPONENT_NAME$i
      });
      const _sfc_main$24 = /* @__PURE__ */ defineComponent({
        ...__default__$1B,
        props: calendarProps,
        emits: calendarEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const ns = useNamespace("calendar");
          const {
            calculateValidatedDateRange,
            date: date3,
            pickDay,
            realSelectedDay,
            selectDate,
            validatedRange
          } = useCalendar(props2, emit);
          const { t } = useLocale();
          const i18nDate = computed(() => {
            const pickedMonth = `el.datepicker.month${date3.value.format("M")}`;
            return `${date3.value.year()} ${t("el.datepicker.year")} ${t(pickedMonth)}`;
          });
          expose({
            selectedDay: realSelectedDay,
            pickDay,
            selectDate,
            calculateValidatedDateRange
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b())
            }, [
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("header"))
              }, [
                renderSlot(_ctx.$slots, "header", { date: unref(i18nDate) }, () => [
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).e("title"))
                  }, toDisplayString(unref(i18nDate)), 3),
                  unref(validatedRange).length === 0 ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(unref(ns).e("button-group"))
                  }, [
                    createVNode(unref(ElButtonGroup$1), null, {
                      default: withCtx(() => [
                        createVNode(unref(ElButton), {
                          size: "small",
                          onClick: ($event) => unref(selectDate)("prev-month")
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(unref(t)("el.datepicker.prevMonth")), 1)
                          ]),
                          _: 1
                        }, 8, ["onClick"]),
                        createVNode(unref(ElButton), {
                          size: "small",
                          onClick: ($event) => unref(selectDate)("today")
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(unref(t)("el.datepicker.today")), 1)
                          ]),
                          _: 1
                        }, 8, ["onClick"]),
                        createVNode(unref(ElButton), {
                          size: "small",
                          onClick: ($event) => unref(selectDate)("next-month")
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(unref(t)("el.datepicker.nextMonth")), 1)
                          ]),
                          _: 1
                        }, 8, ["onClick"])
                      ]),
                      _: 1
                    })
                  ], 2)) : createCommentVNode("v-if", true)
                ])
              ], 2),
              unref(validatedRange).length === 0 ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).e("body"))
              }, [
                createVNode(DateTable$1, {
                  date: unref(date3),
                  "selected-day": unref(realSelectedDay),
                  onPick: unref(pickDay)
                }, createSlots({
                  _: 2
                }, [
                  _ctx.$slots["date-cell"] ? {
                    name: "date-cell",
                    fn: withCtx((data) => [
                      renderSlot(_ctx.$slots, "date-cell", normalizeProps(guardReactiveProps(data)))
                    ])
                  } : void 0
                ]), 1032, ["date", "selected-day", "onPick"])
              ], 2)) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(ns).e("body"))
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(validatedRange), (range_, index2) => {
                  return openBlock(), createBlock(DateTable$1, {
                    key: index2,
                    date: range_[0],
                    "selected-day": unref(realSelectedDay),
                    range: range_,
                    "hide-header": index2 !== 0,
                    onPick: unref(pickDay)
                  }, createSlots({
                    _: 2
                  }, [
                    _ctx.$slots["date-cell"] ? {
                      name: "date-cell",
                      fn: withCtx((data) => [
                        renderSlot(_ctx.$slots, "date-cell", normalizeProps(guardReactiveProps(data)))
                      ])
                    } : void 0
                  ]), 1032, ["date", "selected-day", "range", "hide-header", "onPick"]);
                }), 128))
              ], 2))
            ], 2);
          };
        }
      });
      var Calendar = /* @__PURE__ */ _export_sfc(_sfc_main$24, [["__file", "calendar.vue"]]);
      const ElCalendar = exports("ElCalendar", withInstall(Calendar));
      const cardProps = exports("cardProps", buildProps({
        header: {
          type: String,
          default: ""
        },
        footer: {
          type: String,
          default: ""
        },
        bodyStyle: {
          type: definePropType([String, Object, Array]),
          default: ""
        },
        headerClass: String,
        bodyClass: String,
        footerClass: String,
        shadow: {
          type: String,
          values: ["always", "hover", "never"],
          default: void 0
        }
      }));
      const cardContextKey = exports("cardContextKey", Symbol("cardContextKey"));
      const __default__$1A = defineComponent({
        name: "ElCard"
      });
      const _sfc_main$23 = /* @__PURE__ */ defineComponent({
        ...__default__$1A,
        props: cardProps,
        setup(__props) {
          const globalConfig2 = useGlobalConfig("card");
          const ns = useNamespace("card");
          return (_ctx, _cache) => {
            var _a;
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).is(`${_ctx.shadow || ((_a = unref(globalConfig2)) == null ? void 0 : _a.shadow) || "always"}-shadow`)
              ])
            }, [
              _ctx.$slots.header || _ctx.header ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass([unref(ns).e("header"), _ctx.headerClass])
              }, [
                renderSlot(_ctx.$slots, "header", {}, () => [
                  createTextVNode(toDisplayString(_ctx.header), 1)
                ])
              ], 2)) : createCommentVNode("v-if", true),
              createElementVNode("div", {
                class: normalizeClass([unref(ns).e("body"), _ctx.bodyClass]),
                style: normalizeStyle(_ctx.bodyStyle)
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 6),
              _ctx.$slots.footer || _ctx.footer ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass([unref(ns).e("footer"), _ctx.footerClass])
              }, [
                renderSlot(_ctx.$slots, "footer", {}, () => [
                  createTextVNode(toDisplayString(_ctx.footer), 1)
                ])
              ], 2)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Card = /* @__PURE__ */ _export_sfc(_sfc_main$23, [["__file", "card.vue"]]);
      const ElCard = exports("ElCard", withInstall(Card));
      const carouselProps = exports("carouselProps", buildProps({
        initialIndex: {
          type: Number,
          default: 0
        },
        height: {
          type: String,
          default: ""
        },
        trigger: {
          type: String,
          values: ["hover", "click"],
          default: "hover"
        },
        autoplay: {
          type: Boolean,
          default: true
        },
        interval: {
          type: Number,
          default: 3e3
        },
        indicatorPosition: {
          type: String,
          values: ["", "none", "outside"],
          default: ""
        },
        arrow: {
          type: String,
          values: ["always", "hover", "never"],
          default: "hover"
        },
        type: {
          type: String,
          values: ["", "card"],
          default: ""
        },
        cardScale: {
          type: Number,
          default: 0.83
        },
        loop: {
          type: Boolean,
          default: true
        },
        direction: {
          type: String,
          values: ["horizontal", "vertical"],
          default: "horizontal"
        },
        pauseOnHover: {
          type: Boolean,
          default: true
        },
        motionBlur: Boolean
      }));
      const carouselEmits = exports("carouselEmits", {
        change: (current, prev) => [current, prev].every(isNumber)
      });
      const carouselContextKey = exports("carouselContextKey", Symbol("carouselContextKey"));
      const CAROUSEL_ITEM_NAME = exports("CAROUSEL_ITEM_NAME", "ElCarouselItem");
      const THROTTLE_TIME = 300;
      const useCarousel = (props2, emit, componentName2) => {
        const {
          children: items,
          addChild: addItem,
          removeChild: removeItem,
          ChildrenSorter: ItemsSorter
        } = useOrderedChildren(getCurrentInstance(), CAROUSEL_ITEM_NAME);
        const slots = useSlots();
        const activeIndex = ref(-1);
        const timer = ref(null);
        const hover = ref(false);
        const root2 = ref();
        const containerHeight = ref(0);
        const isItemsTwoLength = ref(true);
        const arrowDisplay = computed(() => props2.arrow !== "never" && !unref(isVertical));
        const hasLabel = computed(() => {
          return items.value.some((item) => item.props.label.toString().length > 0);
        });
        const isCardType = computed(() => props2.type === "card");
        const isVertical = computed(() => props2.direction === "vertical");
        const containerStyle = computed(() => {
          if (props2.height !== "auto") {
            return {
              height: props2.height
            };
          }
          return {
            height: `${containerHeight.value}px`,
            overflow: "hidden"
          };
        });
        const throttledArrowClick = throttle((index2) => {
          setActiveItem(index2);
        }, THROTTLE_TIME, { trailing: true });
        const throttledIndicatorHover = throttle((index2) => {
          handleIndicatorHover(index2);
        }, THROTTLE_TIME);
        const isTwoLengthShow = (index2) => {
          if (!isItemsTwoLength.value)
            return true;
          return activeIndex.value <= 1 ? index2 <= 1 : index2 > 1;
        };
        function pauseTimer() {
          if (timer.value) {
            clearInterval(timer.value);
            timer.value = null;
          }
        }
        function startTimer() {
          if (props2.interval <= 0 || !props2.autoplay || timer.value)
            return;
          timer.value = setInterval(() => playSlides(), props2.interval);
        }
        const playSlides = () => {
          if (activeIndex.value < items.value.length - 1) {
            activeIndex.value = activeIndex.value + 1;
          } else if (props2.loop) {
            activeIndex.value = 0;
          }
        };
        function setActiveItem(index2) {
          if (isString$1(index2)) {
            const filteredItems = items.value.filter((item) => item.props.name === index2);
            if (filteredItems.length > 0) {
              index2 = items.value.indexOf(filteredItems[0]);
            }
          }
          index2 = Number(index2);
          if (Number.isNaN(index2) || index2 !== Math.floor(index2)) {
            return;
          }
          const itemCount = items.value.length;
          const oldIndex = activeIndex.value;
          if (index2 < 0) {
            activeIndex.value = props2.loop ? itemCount - 1 : 0;
          } else if (index2 >= itemCount) {
            activeIndex.value = props2.loop ? 0 : itemCount - 1;
          } else {
            activeIndex.value = index2;
          }
          if (oldIndex === activeIndex.value) {
            resetItemPosition(oldIndex);
          }
          resetTimer();
        }
        function resetItemPosition(oldIndex) {
          items.value.forEach((item, index2) => {
            item.translateItem(index2, activeIndex.value, oldIndex);
          });
        }
        function itemInStage(item, index2) {
          var _a, _b, _c, _d;
          const _items = unref(items);
          const itemCount = _items.length;
          if (itemCount === 0 || !item.states.inStage)
            return false;
          const nextItemIndex = index2 + 1;
          const prevItemIndex = index2 - 1;
          const lastItemIndex = itemCount - 1;
          const isLastItemActive = _items[lastItemIndex].states.active;
          const isFirstItemActive = _items[0].states.active;
          const isNextItemActive = (_b = (_a = _items[nextItemIndex]) == null ? void 0 : _a.states) == null ? void 0 : _b.active;
          const isPrevItemActive = (_d = (_c = _items[prevItemIndex]) == null ? void 0 : _c.states) == null ? void 0 : _d.active;
          if (index2 === lastItemIndex && isFirstItemActive || isNextItemActive) {
            return "left";
          } else if (index2 === 0 && isLastItemActive || isPrevItemActive) {
            return "right";
          }
          return false;
        }
        function handleMouseEnter() {
          hover.value = true;
          if (props2.pauseOnHover) {
            pauseTimer();
          }
        }
        function handleMouseLeave() {
          hover.value = false;
          startTimer();
        }
        function handleButtonEnter(arrow2) {
          if (unref(isVertical))
            return;
          items.value.forEach((item, index2) => {
            if (arrow2 === itemInStage(item, index2)) {
              item.states.hover = true;
            }
          });
        }
        function handleButtonLeave() {
          if (unref(isVertical))
            return;
          items.value.forEach((item) => {
            item.states.hover = false;
          });
        }
        function handleIndicatorClick(index2) {
          activeIndex.value = index2;
        }
        function handleIndicatorHover(index2) {
          if (props2.trigger === "hover" && index2 !== activeIndex.value) {
            activeIndex.value = index2;
          }
        }
        function prev() {
          setActiveItem(activeIndex.value - 1);
        }
        function next() {
          setActiveItem(activeIndex.value + 1);
        }
        function resetTimer() {
          pauseTimer();
          if (!props2.pauseOnHover)
            startTimer();
        }
        function setContainerHeight(height) {
          if (props2.height !== "auto")
            return;
          containerHeight.value = height;
        }
        function PlaceholderItem() {
          var _a;
          const defaultSlots = (_a = slots.default) == null ? void 0 : _a.call(slots);
          if (!defaultSlots)
            return null;
          const flatSlots = flattedChildren(defaultSlots);
          const normalizeSlots = flatSlots.filter((slot) => {
            return isVNode(slot) && slot.type.name === CAROUSEL_ITEM_NAME;
          });
          if ((normalizeSlots == null ? void 0 : normalizeSlots.length) === 2 && props2.loop && !isCardType.value) {
            isItemsTwoLength.value = true;
            return normalizeSlots;
          }
          isItemsTwoLength.value = false;
          return null;
        }
        watch(() => activeIndex.value, (current, prev2) => {
          resetItemPosition(prev2);
          if (isItemsTwoLength.value) {
            current = current % 2;
            prev2 = prev2 % 2;
          }
          if (prev2 > -1) {
            emit(CHANGE_EVENT, current, prev2);
          }
        });
        watch(() => props2.autoplay, (autoplay) => {
          autoplay ? startTimer() : pauseTimer();
        });
        watch(() => props2.loop, () => {
          setActiveItem(activeIndex.value);
        });
        watch(() => props2.interval, () => {
          resetTimer();
        });
        const resizeObserver = shallowRef();
        onMounted(() => {
          watch(() => items.value, () => {
            if (items.value.length > 0)
              setActiveItem(props2.initialIndex);
          }, {
            immediate: true
          });
          resizeObserver.value = useResizeObserver(root2.value, () => {
            resetItemPosition();
          });
          startTimer();
        });
        onBeforeUnmount(() => {
          pauseTimer();
          if (root2.value && resizeObserver.value)
            resizeObserver.value.stop();
        });
        provide(carouselContextKey, {
          root: root2,
          isCardType,
          isVertical,
          items,
          loop: props2.loop,
          cardScale: props2.cardScale,
          addItem,
          removeItem,
          setActiveItem,
          setContainerHeight
        });
        return {
          root: root2,
          activeIndex,
          arrowDisplay,
          hasLabel,
          hover,
          isCardType,
          items,
          isVertical,
          containerStyle,
          isItemsTwoLength,
          handleButtonEnter,
          handleButtonLeave,
          handleIndicatorClick,
          handleMouseEnter,
          handleMouseLeave,
          setActiveItem,
          prev,
          next,
          PlaceholderItem,
          isTwoLengthShow,
          ItemsSorter,
          throttledArrowClick,
          throttledIndicatorHover
        };
      };
      const COMPONENT_NAME$h = "ElCarousel";
      const __default__$1z = defineComponent({
        name: COMPONENT_NAME$h
      });
      const _sfc_main$22 = /* @__PURE__ */ defineComponent({
        ...__default__$1z,
        props: carouselProps,
        emits: carouselEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const {
            root: root2,
            activeIndex,
            arrowDisplay,
            hasLabel,
            hover,
            isCardType,
            items,
            isVertical,
            containerStyle,
            handleButtonEnter,
            handleButtonLeave,
            handleIndicatorClick,
            handleMouseEnter,
            handleMouseLeave,
            setActiveItem,
            prev,
            next,
            PlaceholderItem,
            isTwoLengthShow,
            ItemsSorter,
            throttledArrowClick,
            throttledIndicatorHover
          } = useCarousel(props2, emit);
          const ns = useNamespace("carousel");
          const { t } = useLocale();
          const carouselClasses = computed(() => {
            const classes = [ns.b(), ns.m(props2.direction)];
            if (unref(isCardType)) {
              classes.push(ns.m("card"));
            }
            return classes;
          });
          const indicatorsClasses = computed(() => {
            const classes = [ns.e("indicators"), ns.em("indicators", props2.direction)];
            if (unref(hasLabel)) {
              classes.push(ns.em("indicators", "labels"));
            }
            if (props2.indicatorPosition === "outside") {
              classes.push(ns.em("indicators", "outside"));
            }
            if (unref(isVertical)) {
              classes.push(ns.em("indicators", "right"));
            }
            return classes;
          });
          function handleTransitionStart(e) {
            if (!props2.motionBlur)
              return;
            const kls = unref(isVertical) ? `${ns.namespace.value}-transitioning-vertical` : `${ns.namespace.value}-transitioning`;
            e.currentTarget.classList.add(kls);
          }
          function handleTransitionEnd(e) {
            if (!props2.motionBlur)
              return;
            const kls = unref(isVertical) ? `${ns.namespace.value}-transitioning-vertical` : `${ns.namespace.value}-transitioning`;
            e.currentTarget.classList.remove(kls);
          }
          expose({
            activeIndex,
            setActiveItem,
            prev,
            next
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "root",
              ref: root2,
              class: normalizeClass(unref(carouselClasses)),
              onMouseenter: withModifiers(unref(handleMouseEnter), ["stop"]),
              onMouseleave: withModifiers(unref(handleMouseLeave), ["stop"])
            }, [
              unref(arrowDisplay) ? (openBlock(), createBlock(Transition, {
                key: 0,
                name: "carousel-arrow-left",
                persisted: ""
              }, {
                default: withCtx(() => [
                  withDirectives(createElementVNode("button", {
                    type: "button",
                    class: normalizeClass([unref(ns).e("arrow"), unref(ns).em("arrow", "left")]),
                    "aria-label": unref(t)("el.carousel.leftArrow"),
                    onMouseenter: ($event) => unref(handleButtonEnter)("left"),
                    onMouseleave: unref(handleButtonLeave),
                    onClick: withModifiers(($event) => unref(throttledArrowClick)(unref(activeIndex) - 1), ["stop"])
                  }, [
                    createVNode(unref(ElIcon), null, {
                      default: withCtx(() => [
                        createVNode(unref(arrow_left_default$1))
                      ]),
                      _: 1
                    })
                  ], 42, ["aria-label", "onMouseenter", "onMouseleave", "onClick"]), [
                    [
                      vShow,
                      (_ctx.arrow === "always" || unref(hover)) && (props2.loop || unref(activeIndex) > 0)
                    ]
                  ])
                ]),
                _: 1
              })) : createCommentVNode("v-if", true),
              unref(arrowDisplay) ? (openBlock(), createBlock(Transition, {
                key: 1,
                name: "carousel-arrow-right",
                persisted: ""
              }, {
                default: withCtx(() => [
                  withDirectives(createElementVNode("button", {
                    type: "button",
                    class: normalizeClass([unref(ns).e("arrow"), unref(ns).em("arrow", "right")]),
                    "aria-label": unref(t)("el.carousel.rightArrow"),
                    onMouseenter: ($event) => unref(handleButtonEnter)("right"),
                    onMouseleave: unref(handleButtonLeave),
                    onClick: withModifiers(($event) => unref(throttledArrowClick)(unref(activeIndex) + 1), ["stop"])
                  }, [
                    createVNode(unref(ElIcon), null, {
                      default: withCtx(() => [
                        createVNode(unref(arrow_right_default$1))
                      ]),
                      _: 1
                    })
                  ], 42, ["aria-label", "onMouseenter", "onMouseleave", "onClick"]), [
                    [
                      vShow,
                      (_ctx.arrow === "always" || unref(hover)) && (props2.loop || unref(activeIndex) < unref(items).length - 1)
                    ]
                  ])
                ]),
                _: 1
              })) : createCommentVNode("v-if", true),
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("container")),
                style: normalizeStyle(unref(containerStyle)),
                onTransitionstart: handleTransitionStart,
                onTransitionend: handleTransitionEnd
              }, [
                createVNode(unref(PlaceholderItem)),
                renderSlot(_ctx.$slots, "default")
              ], 38),
              createVNode(unref(ItemsSorter), null, {
                default: withCtx(() => [
                  _ctx.indicatorPosition !== "none" ? (openBlock(), createElementBlock("ul", {
                    key: 0,
                    class: normalizeClass(unref(indicatorsClasses))
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(items), (item, index2) => {
                      return withDirectives((openBlock(), createElementBlock("li", {
                        key: index2,
                        class: normalizeClass([
                          unref(ns).e("indicator"),
                          unref(ns).em("indicator", _ctx.direction),
                          unref(ns).is("active", index2 === unref(activeIndex))
                        ]),
                        onMouseenter: ($event) => unref(throttledIndicatorHover)(index2),
                        onClick: withModifiers(($event) => unref(handleIndicatorClick)(index2), ["stop"])
                      }, [
                        createElementVNode("button", {
                          class: normalizeClass(unref(ns).e("button")),
                          "aria-label": unref(t)("el.carousel.indicator", { index: index2 + 1 })
                        }, [
                          unref(hasLabel) ? (openBlock(), createElementBlock("span", { key: 0 }, toDisplayString(item.props.label), 1)) : createCommentVNode("v-if", true)
                        ], 10, ["aria-label"])
                      ], 42, ["onMouseenter", "onClick"])), [
                        [vShow, unref(isTwoLengthShow)(index2)]
                      ]);
                    }), 128))
                  ], 2)) : createCommentVNode("v-if", true)
                ]),
                _: 1
              }),
              props2.motionBlur ? (openBlock(), createElementBlock("svg", {
                key: 2,
                xmlns: "http://www.w3.org/2000/svg",
                version: "1.1",
                style: { "display": "none" }
              }, [
                createElementVNode("defs", null, [
                  createElementVNode("filter", { id: "elCarouselHorizontal" }, [
                    createElementVNode("feGaussianBlur", {
                      in: "SourceGraphic",
                      stdDeviation: "12,0"
                    })
                  ]),
                  createElementVNode("filter", { id: "elCarouselVertical" }, [
                    createElementVNode("feGaussianBlur", {
                      in: "SourceGraphic",
                      stdDeviation: "0,10"
                    })
                  ])
                ])
              ])) : createCommentVNode("v-if", true)
            ], 42, ["onMouseenter", "onMouseleave"]);
          };
        }
      });
      var Carousel = /* @__PURE__ */ _export_sfc(_sfc_main$22, [["__file", "carousel.vue"]]);
      const carouselItemProps = exports("carouselItemProps", buildProps({
        name: { type: String, default: "" },
        label: {
          type: [String, Number],
          default: ""
        }
      }));
      const useCarouselItem = (props2) => {
        const carouselContext = inject(carouselContextKey);
        const instance = getCurrentInstance();
        const carouselItemRef = ref();
        const hover = ref(false);
        const translate2 = ref(0);
        const scale = ref(1);
        const active = ref(false);
        const ready = ref(false);
        const inStage = ref(false);
        const animating = ref(false);
        const { isCardType, isVertical, cardScale } = carouselContext;
        function processIndex(index2, activeIndex, length) {
          const lastItemIndex = length - 1;
          const prevItemIndex = activeIndex - 1;
          const nextItemIndex = activeIndex + 1;
          const halfItemIndex = length / 2;
          if (activeIndex === 0 && index2 === lastItemIndex) {
            return -1;
          } else if (activeIndex === lastItemIndex && index2 === 0) {
            return length;
          } else if (index2 < prevItemIndex && activeIndex - index2 >= halfItemIndex) {
            return length + 1;
          } else if (index2 > nextItemIndex && index2 - activeIndex >= halfItemIndex) {
            return -2;
          }
          return index2;
        }
        function calcCardTranslate(index2, activeIndex) {
          var _a, _b;
          const parentWidth = unref(isVertical) ? ((_a = carouselContext.root.value) == null ? void 0 : _a.offsetHeight) || 0 : ((_b = carouselContext.root.value) == null ? void 0 : _b.offsetWidth) || 0;
          if (inStage.value) {
            return parentWidth * ((2 - cardScale) * (index2 - activeIndex) + 1) / 4;
          } else if (index2 < activeIndex) {
            return -(1 + cardScale) * parentWidth / 4;
          } else {
            return (3 + cardScale) * parentWidth / 4;
          }
        }
        function calcTranslate(index2, activeIndex, isVertical2) {
          const rootEl = carouselContext.root.value;
          if (!rootEl)
            return 0;
          const distance = (isVertical2 ? rootEl.offsetHeight : rootEl.offsetWidth) || 0;
          return distance * (index2 - activeIndex);
        }
        const translateItem = (index2, activeIndex, oldIndex) => {
          var _a;
          const _isCardType = unref(isCardType);
          const carouselItemLength = (_a = carouselContext.items.value.length) != null ? _a : Number.NaN;
          const isActive = index2 === activeIndex;
          if (!_isCardType && !isUndefined(oldIndex)) {
            animating.value = isActive || index2 === oldIndex;
          }
          if (!isActive && carouselItemLength > 2 && carouselContext.loop) {
            index2 = processIndex(index2, activeIndex, carouselItemLength);
          }
          const _isVertical = unref(isVertical);
          active.value = isActive;
          if (_isCardType) {
            inStage.value = Math.round(Math.abs(index2 - activeIndex)) <= 1;
            translate2.value = calcCardTranslate(index2, activeIndex);
            scale.value = unref(active) ? 1 : cardScale;
          } else {
            translate2.value = calcTranslate(index2, activeIndex, _isVertical);
          }
          ready.value = true;
          if (isActive && carouselItemRef.value) {
            carouselContext.setContainerHeight(carouselItemRef.value.offsetHeight);
          }
        };
        function handleItemClick() {
          if (carouselContext && unref(isCardType)) {
            const index2 = carouselContext.items.value.findIndex(({ uid: uid2 }) => uid2 === instance.uid);
            carouselContext.setActiveItem(index2);
          }
        }
        const carouselItemContext = {
          props: props2,
          states: reactive({
            hover,
            translate: translate2,
            scale,
            active,
            ready,
            inStage,
            animating
          }),
          uid: instance.uid,
          getVnode: () => instance.vnode,
          translateItem
        };
        carouselContext.addItem(carouselItemContext);
        onBeforeUnmount(() => {
          carouselContext.removeItem(carouselItemContext);
        });
        return {
          carouselItemRef,
          active,
          animating,
          hover,
          inStage,
          isVertical,
          translate: translate2,
          isCardType,
          scale,
          ready,
          handleItemClick
        };
      };
      const __default__$1y = defineComponent({
        name: CAROUSEL_ITEM_NAME
      });
      const _sfc_main$21 = /* @__PURE__ */ defineComponent({
        ...__default__$1y,
        props: carouselItemProps,
        setup(__props) {
          const props2 = __props;
          const ns = useNamespace("carousel");
          const {
            carouselItemRef,
            active,
            animating,
            hover,
            inStage,
            isVertical,
            translate: translate2,
            isCardType,
            scale,
            ready,
            handleItemClick
          } = useCarouselItem(props2);
          const itemKls = computed(() => [
            ns.e("item"),
            ns.is("active", active.value),
            ns.is("in-stage", inStage.value),
            ns.is("hover", hover.value),
            ns.is("animating", animating.value),
            {
              [ns.em("item", "card")]: isCardType.value,
              [ns.em("item", "card-vertical")]: isCardType.value && isVertical.value
            }
          ]);
          const itemStyle = computed(() => {
            const translateType = `translate${unref(isVertical) ? "Y" : "X"}`;
            const _translate = `${translateType}(${unref(translate2)}px)`;
            const _scale = `scale(${unref(scale)})`;
            const transform2 = [_translate, _scale].join(" ");
            return {
              transform: transform2
            };
          });
          return (_ctx, _cache) => {
            return withDirectives((openBlock(), createElementBlock("div", {
              ref_key: "carouselItemRef",
              ref: carouselItemRef,
              class: normalizeClass(unref(itemKls)),
              style: normalizeStyle(unref(itemStyle)),
              onClick: unref(handleItemClick)
            }, [
              unref(isCardType) ? withDirectives((openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).e("mask"))
              }, null, 2)), [
                [vShow, !unref(active)]
              ]) : createCommentVNode("v-if", true),
              renderSlot(_ctx.$slots, "default")
            ], 14, ["onClick"])), [
              [vShow, unref(ready)]
            ]);
          };
        }
      });
      var CarouselItem = /* @__PURE__ */ _export_sfc(_sfc_main$21, [["__file", "carousel-item.vue"]]);
      const ElCarousel = exports("ElCarousel", withInstall(Carousel, {
        CarouselItem
      }));
      const ElCarouselItem = exports("ElCarouselItem", withNoopInstall(CarouselItem));
      const checkboxProps = exports("checkboxProps", {
        modelValue: {
          type: [Number, String, Boolean],
          default: void 0
        },
        label: {
          type: [String, Boolean, Number, Object],
          default: void 0
        },
        value: {
          type: [String, Boolean, Number, Object],
          default: void 0
        },
        indeterminate: Boolean,
        disabled: Boolean,
        checked: Boolean,
        name: {
          type: String,
          default: void 0
        },
        trueValue: {
          type: [String, Number],
          default: void 0
        },
        falseValue: {
          type: [String, Number],
          default: void 0
        },
        trueLabel: {
          type: [String, Number],
          default: void 0
        },
        falseLabel: {
          type: [String, Number],
          default: void 0
        },
        id: {
          type: String,
          default: void 0
        },
        border: Boolean,
        size: useSizeProp,
        tabindex: [String, Number],
        validateEvent: {
          type: Boolean,
          default: true
        },
        ...useAriaProps(["ariaControls"])
      });
      const checkboxEmits = exports("checkboxEmits", {
        [UPDATE_MODEL_EVENT]: (val) => isString$1(val) || isNumber(val) || isBoolean(val),
        change: (val) => isString$1(val) || isNumber(val) || isBoolean(val)
      });
      const checkboxGroupContextKey = exports("checkboxGroupContextKey", Symbol("checkboxGroupContextKey"));
      const useCheckboxDisabled = ({
        model,
        isChecked
      }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isLimitDisabled = computed(() => {
          var _a, _b;
          const max2 = (_a = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a.value;
          const min2 = (_b = checkboxGroup == null ? void 0 : checkboxGroup.min) == null ? void 0 : _b.value;
          return !isUndefined(max2) && model.value.length >= max2 && !isChecked.value || !isUndefined(min2) && model.value.length <= min2 && isChecked.value;
        });
        const isDisabled = useFormDisabled(computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.disabled.value) || isLimitDisabled.value));
        return {
          isDisabled,
          isLimitDisabled
        };
      };
      const useCheckboxEvent = (props2, {
        model,
        isLimitExceeded,
        hasOwnLabel,
        isDisabled,
        isLabeledByFormItem
      }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const { formItem } = useFormItem();
        const { emit } = getCurrentInstance();
        function getLabeledValue(value) {
          var _a, _b, _c, _d;
          return [true, props2.trueValue, props2.trueLabel].includes(value) ? (_b = (_a = props2.trueValue) != null ? _a : props2.trueLabel) != null ? _b : true : (_d = (_c = props2.falseValue) != null ? _c : props2.falseLabel) != null ? _d : false;
        }
        function emitChangeEvent(checked, e) {
          emit(CHANGE_EVENT, getLabeledValue(checked), e);
        }
        function handleChange(e) {
          if (isLimitExceeded.value)
            return;
          const target2 = e.target;
          emit(CHANGE_EVENT, getLabeledValue(target2.checked), e);
        }
        async function onClickRoot(e) {
          if (isLimitExceeded.value)
            return;
          if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {
            const eventTargets = e.composedPath();
            const hasLabel = eventTargets.some((item) => item.tagName === "LABEL");
            if (!hasLabel) {
              model.value = getLabeledValue([false, props2.falseValue, props2.falseLabel].includes(model.value));
              await nextTick();
              emitChangeEvent(model.value, e);
            }
          }
        }
        const validateEvent = computed(() => (checkboxGroup == null ? void 0 : checkboxGroup.validateEvent) || props2.validateEvent);
        watch(() => props2.modelValue, () => {
          if (validateEvent.value) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        });
        return {
          handleChange,
          onClickRoot
        };
      };
      const useCheckboxModel = (props2) => {
        const selfModel = ref(false);
        const { emit } = getCurrentInstance();
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isGroup = computed(() => isUndefined(checkboxGroup) === false);
        const isLimitExceeded = ref(false);
        const model = computed({
          get() {
            var _a, _b;
            return isGroup.value ? (_a = checkboxGroup == null ? void 0 : checkboxGroup.modelValue) == null ? void 0 : _a.value : (_b = props2.modelValue) != null ? _b : selfModel.value;
          },
          set(val) {
            var _a, _b;
            if (isGroup.value && isArray$1(val)) {
              isLimitExceeded.value = ((_a = checkboxGroup == null ? void 0 : checkboxGroup.max) == null ? void 0 : _a.value) !== void 0 && val.length > (checkboxGroup == null ? void 0 : checkboxGroup.max.value) && val.length > model.value.length;
              isLimitExceeded.value === false && ((_b = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _b.call(checkboxGroup, val));
            } else {
              emit(UPDATE_MODEL_EVENT, val);
              selfModel.value = val;
            }
          }
        });
        return {
          model,
          isGroup,
          isLimitExceeded
        };
      };
      const useCheckboxStatus = (props2, slots, { model }) => {
        const checkboxGroup = inject(checkboxGroupContextKey, void 0);
        const isFocused = ref(false);
        const actualValue = computed(() => {
          if (!isPropAbsent(props2.value)) {
            return props2.value;
          }
          return props2.label;
        });
        const isChecked = computed(() => {
          const value = model.value;
          if (isBoolean(value)) {
            return value;
          } else if (isArray$1(value)) {
            if (isObject$1(actualValue.value)) {
              return value.map(toRaw).some((o2) => isEqual$1(o2, actualValue.value));
            } else {
              return value.map(toRaw).includes(actualValue.value);
            }
          } else if (value !== null && value !== void 0) {
            return value === props2.trueValue || value === props2.trueLabel;
          } else {
            return !!value;
          }
        });
        const checkboxButtonSize = useFormSize(computed(() => {
          var _a;
          return (_a = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a.value;
        }), {
          prop: true
        });
        const checkboxSize = useFormSize(computed(() => {
          var _a;
          return (_a = checkboxGroup == null ? void 0 : checkboxGroup.size) == null ? void 0 : _a.value;
        }));
        const hasOwnLabel = computed(() => {
          return !!slots.default || !isPropAbsent(actualValue.value);
        });
        return {
          checkboxButtonSize,
          isChecked,
          isFocused,
          checkboxSize,
          hasOwnLabel,
          actualValue
        };
      };
      const useCheckbox = (props2, slots) => {
        const { formItem: elFormItem } = useFormItem();
        const { model, isGroup, isLimitExceeded } = useCheckboxModel(props2);
        const {
          isFocused,
          isChecked,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel,
          actualValue
        } = useCheckboxStatus(props2, slots, { model });
        const { isDisabled } = useCheckboxDisabled({ model, isChecked });
        const { inputId, isLabeledByFormItem } = useFormItemInputId(props2, {
          formItemContext: elFormItem,
          disableIdGeneration: hasOwnLabel,
          disableIdManagement: isGroup
        });
        const { handleChange, onClickRoot } = useCheckboxEvent(props2, {
          model,
          isLimitExceeded,
          hasOwnLabel,
          isDisabled,
          isLabeledByFormItem
        });
        const setStoreValue = () => {
          function addToStore() {
            var _a, _b;
            if (isArray$1(model.value) && !model.value.includes(actualValue.value)) {
              model.value.push(actualValue.value);
            } else {
              model.value = (_b = (_a = props2.trueValue) != null ? _a : props2.trueLabel) != null ? _b : true;
            }
          }
          props2.checked && addToStore();
        };
        setStoreValue();
        useDeprecated({
          from: "label act as value",
          replacement: "value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, computed(() => isGroup.value && isPropAbsent(props2.value)));
        useDeprecated({
          from: "true-label",
          replacement: "true-value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, computed(() => !!props2.trueLabel));
        useDeprecated({
          from: "false-label",
          replacement: "false-value",
          version: "3.0.0",
          scope: "el-checkbox",
          ref: "https://element-plus.org/en-US/component/checkbox.html"
        }, computed(() => !!props2.falseLabel));
        return {
          inputId,
          isLabeledByFormItem,
          isChecked,
          isDisabled,
          isFocused,
          checkboxButtonSize,
          checkboxSize,
          hasOwnLabel,
          model,
          actualValue,
          handleChange,
          onClickRoot
        };
      };
      const __default__$1x = defineComponent({
        name: "ElCheckbox"
      });
      const _sfc_main$20 = /* @__PURE__ */ defineComponent({
        ...__default__$1x,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props2 = __props;
          const slots = useSlots();
          const {
            inputId,
            isLabeledByFormItem,
            isChecked,
            isDisabled,
            isFocused,
            checkboxSize,
            hasOwnLabel,
            model,
            actualValue,
            handleChange,
            onClickRoot
          } = useCheckbox(props2, slots);
          const ns = useNamespace("checkbox");
          const compKls = computed(() => {
            return [
              ns.b(),
              ns.m(checkboxSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("bordered", props2.border),
              ns.is("checked", isChecked.value)
            ];
          });
          const spanKls = computed(() => {
            return [
              ns.e("input"),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("indeterminate", props2.indeterminate),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(!unref(hasOwnLabel) && unref(isLabeledByFormItem) ? "span" : "label"), {
              class: normalizeClass(unref(compKls)),
              "aria-controls": _ctx.indeterminate ? _ctx.ariaControls : null,
              onClick: unref(onClickRoot)
            }, {
              default: withCtx(() => {
                var _a, _b, _c, _d;
                return [
                  createElementVNode("span", {
                    class: normalizeClass(unref(spanKls))
                  }, [
                    _ctx.trueValue || _ctx.falseValue || _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                      key: 0,
                      id: unref(inputId),
                      "onUpdate:modelValue": ($event) => isRef(model) ? model.value = $event : null,
                      class: normalizeClass(unref(ns).e("original")),
                      type: "checkbox",
                      indeterminate: _ctx.indeterminate,
                      name: _ctx.name,
                      tabindex: _ctx.tabindex,
                      disabled: unref(isDisabled),
                      "true-value": (_b = (_a = _ctx.trueValue) != null ? _a : _ctx.trueLabel) != null ? _b : true,
                      "false-value": (_d = (_c = _ctx.falseValue) != null ? _c : _ctx.falseLabel) != null ? _d : false,
                      onChange: unref(handleChange),
                      onFocus: ($event) => isFocused.value = true,
                      onBlur: ($event) => isFocused.value = false,
                      onClick: withModifiers(() => {
                      }, ["stop"])
                    }, null, 42, ["id", "onUpdate:modelValue", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value", "onChange", "onFocus", "onBlur", "onClick"])), [
                      [vModelCheckbox, unref(model)]
                    ]) : withDirectives((openBlock(), createElementBlock("input", {
                      key: 1,
                      id: unref(inputId),
                      "onUpdate:modelValue": ($event) => isRef(model) ? model.value = $event : null,
                      class: normalizeClass(unref(ns).e("original")),
                      type: "checkbox",
                      indeterminate: _ctx.indeterminate,
                      disabled: unref(isDisabled),
                      value: unref(actualValue),
                      name: _ctx.name,
                      tabindex: _ctx.tabindex,
                      onChange: unref(handleChange),
                      onFocus: ($event) => isFocused.value = true,
                      onBlur: ($event) => isFocused.value = false,
                      onClick: withModifiers(() => {
                      }, ["stop"])
                    }, null, 42, ["id", "onUpdate:modelValue", "indeterminate", "disabled", "value", "name", "tabindex", "onChange", "onFocus", "onBlur", "onClick"])), [
                      [vModelCheckbox, unref(model)]
                    ]),
                    createElementVNode("span", {
                      class: normalizeClass(unref(ns).e("inner"))
                    }, null, 2)
                  ], 2),
                  unref(hasOwnLabel) ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(ns).e("label"))
                  }, [
                    renderSlot(_ctx.$slots, "default"),
                    !_ctx.$slots.default ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      createTextVNode(toDisplayString(_ctx.label), 1)
                    ], 64)) : createCommentVNode("v-if", true)
                  ], 2)) : createCommentVNode("v-if", true)
                ];
              }),
              _: 3
            }, 8, ["class", "aria-controls", "onClick"]);
          };
        }
      });
      var Checkbox = /* @__PURE__ */ _export_sfc(_sfc_main$20, [["__file", "checkbox.vue"]]);
      const __default__$1w = defineComponent({
        name: "ElCheckboxButton"
      });
      const _sfc_main$1$ = /* @__PURE__ */ defineComponent({
        ...__default__$1w,
        props: checkboxProps,
        emits: checkboxEmits,
        setup(__props) {
          const props2 = __props;
          const slots = useSlots();
          const {
            isFocused,
            isChecked,
            isDisabled,
            checkboxButtonSize,
            model,
            actualValue,
            handleChange
          } = useCheckbox(props2, slots);
          const checkboxGroup = inject(checkboxGroupContextKey, void 0);
          const ns = useNamespace("checkbox");
          const activeStyle = computed(() => {
            var _a, _b, _c, _d;
            const fillValue = (_b = (_a = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a.value) != null ? _b : "";
            return {
              backgroundColor: fillValue,
              borderColor: fillValue,
              color: (_d = (_c = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c.value) != null ? _d : "",
              boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : void 0
            };
          });
          const labelKls = computed(() => {
            return [
              ns.b("button"),
              ns.bm("button", checkboxButtonSize.value),
              ns.is("disabled", isDisabled.value),
              ns.is("checked", isChecked.value),
              ns.is("focus", isFocused.value)
            ];
          });
          return (_ctx, _cache) => {
            var _a, _b, _c, _d;
            return openBlock(), createElementBlock("label", {
              class: normalizeClass(unref(labelKls))
            }, [
              _ctx.trueValue || _ctx.falseValue || _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
                key: 0,
                "onUpdate:modelValue": ($event) => isRef(model) ? model.value = $event : null,
                class: normalizeClass(unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: unref(isDisabled),
                "true-value": (_b = (_a = _ctx.trueValue) != null ? _a : _ctx.trueLabel) != null ? _b : true,
                "false-value": (_d = (_c = _ctx.falseValue) != null ? _c : _ctx.falseLabel) != null ? _d : false,
                onChange: unref(handleChange),
                onFocus: ($event) => isFocused.value = true,
                onBlur: ($event) => isFocused.value = false,
                onClick: withModifiers(() => {
                }, ["stop"])
              }, null, 42, ["onUpdate:modelValue", "name", "tabindex", "disabled", "true-value", "false-value", "onChange", "onFocus", "onBlur", "onClick"])), [
                [vModelCheckbox, unref(model)]
              ]) : withDirectives((openBlock(), createElementBlock("input", {
                key: 1,
                "onUpdate:modelValue": ($event) => isRef(model) ? model.value = $event : null,
                class: normalizeClass(unref(ns).be("button", "original")),
                type: "checkbox",
                name: _ctx.name,
                tabindex: _ctx.tabindex,
                disabled: unref(isDisabled),
                value: unref(actualValue),
                onChange: unref(handleChange),
                onFocus: ($event) => isFocused.value = true,
                onBlur: ($event) => isFocused.value = false,
                onClick: withModifiers(() => {
                }, ["stop"])
              }, null, 42, ["onUpdate:modelValue", "name", "tabindex", "disabled", "value", "onChange", "onFocus", "onBlur", "onClick"])), [
                [vModelCheckbox, unref(model)]
              ]),
              _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", {
                key: 2,
                class: normalizeClass(unref(ns).be("button", "inner")),
                style: normalizeStyle(unref(isChecked) ? unref(activeStyle) : void 0)
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.label), 1)
                ])
              ], 6)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var CheckboxButton = /* @__PURE__ */ _export_sfc(_sfc_main$1$, [["__file", "checkbox-button.vue"]]);
      const checkboxGroupProps = exports("checkboxGroupProps", buildProps({
        modelValue: {
          type: definePropType(Array),
          default: () => []
        },
        disabled: Boolean,
        min: Number,
        max: Number,
        size: useSizeProp,
        fill: String,
        textColor: String,
        tag: {
          type: String,
          default: "div"
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        ...useAriaProps(["ariaLabel"])
      }));
      const checkboxGroupEmits = exports("checkboxGroupEmits", {
        [UPDATE_MODEL_EVENT]: (val) => isArray$1(val),
        change: (val) => isArray$1(val)
      });
      const __default__$1v = defineComponent({
        name: "ElCheckboxGroup"
      });
      const _sfc_main$1_ = /* @__PURE__ */ defineComponent({
        ...__default__$1v,
        props: checkboxGroupProps,
        emits: checkboxGroupEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const ns = useNamespace("checkbox");
          const { formItem } = useFormItem();
          const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props2, {
            formItemContext: formItem
          });
          const changeEvent = async (value) => {
            emit(UPDATE_MODEL_EVENT, value);
            await nextTick();
            emit(CHANGE_EVENT, value);
          };
          const modelValue = computed({
            get() {
              return props2.modelValue;
            },
            set(val) {
              changeEvent(val);
            }
          });
          provide(checkboxGroupContextKey, {
            ...pick(toRefs(props2), [
              "size",
              "min",
              "max",
              "disabled",
              "validateEvent",
              "fill",
              "textColor"
            ]),
            modelValue,
            changeEvent
          });
          watch(() => props2.modelValue, (newVal, oldValue) => {
            if (props2.validateEvent && !isEqual$1(newVal, oldValue)) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
            }
          });
          return (_ctx, _cache) => {
            var _a;
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              id: unref(groupId),
              class: normalizeClass(unref(ns).b("group")),
              role: "group",
              "aria-label": !unref(isLabeledByFormItem) ? _ctx.ariaLabel || "checkbox-group" : void 0,
              "aria-labelledby": unref(isLabeledByFormItem) ? (_a = unref(formItem)) == null ? void 0 : _a.labelId : void 0
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
          };
        }
      });
      var CheckboxGroup = /* @__PURE__ */ _export_sfc(_sfc_main$1_, [["__file", "checkbox-group.vue"]]);
      const ElCheckbox = exports("ElCheckbox", withInstall(Checkbox, {
        CheckboxButton,
        CheckboxGroup
      }));
      const ElCheckboxButton = exports("ElCheckboxButton", withNoopInstall(CheckboxButton));
      const ElCheckboxGroup$1 = exports("ElCheckboxGroup", withNoopInstall(CheckboxGroup));
      const radioPropsBase = exports("radioPropsBase", buildProps({
        modelValue: {
          type: [String, Number, Boolean],
          default: void 0
        },
        size: useSizeProp,
        disabled: Boolean,
        label: {
          type: [String, Number, Boolean],
          default: void 0
        },
        value: {
          type: [String, Number, Boolean],
          default: void 0
        },
        name: {
          type: String,
          default: void 0
        }
      }));
      const radioProps = exports("radioProps", buildProps({
        ...radioPropsBase,
        border: Boolean
      }));
      const radioEmits = exports("radioEmits", {
        [UPDATE_MODEL_EVENT]: (val) => isString$1(val) || isNumber(val) || isBoolean(val),
        [CHANGE_EVENT]: (val) => isString$1(val) || isNumber(val) || isBoolean(val)
      });
      const radioGroupKey = exports("radioGroupKey", Symbol("radioGroupKey"));
      const useRadio = (props2, emit) => {
        const radioRef = ref();
        const radioGroup = inject(radioGroupKey, void 0);
        const isGroup = computed(() => !!radioGroup);
        const actualValue = computed(() => {
          if (!isPropAbsent(props2.value)) {
            return props2.value;
          }
          return props2.label;
        });
        const modelValue = computed({
          get() {
            return isGroup.value ? radioGroup.modelValue : props2.modelValue;
          },
          set(val) {
            if (isGroup.value) {
              radioGroup.changeEvent(val);
            } else {
              emit && emit(UPDATE_MODEL_EVENT, val);
            }
            radioRef.value.checked = props2.modelValue === actualValue.value;
          }
        });
        const size = useFormSize(computed(() => radioGroup == null ? void 0 : radioGroup.size));
        const disabled = useFormDisabled(computed(() => radioGroup == null ? void 0 : radioGroup.disabled));
        const focus = ref(false);
        const tabIndex = computed(() => {
          return disabled.value || isGroup.value && modelValue.value !== actualValue.value ? -1 : 0;
        });
        useDeprecated({
          from: "label act as value",
          replacement: "value",
          version: "3.0.0",
          scope: "el-radio",
          ref: "https://element-plus.org/en-US/component/radio.html"
        }, computed(() => isGroup.value && isPropAbsent(props2.value)));
        return {
          radioRef,
          isGroup,
          radioGroup,
          focus,
          size,
          disabled,
          tabIndex,
          modelValue,
          actualValue
        };
      };
      const __default__$1u = defineComponent({
        name: "ElRadio"
      });
      const _sfc_main$1Z = /* @__PURE__ */ defineComponent({
        ...__default__$1u,
        props: radioProps,
        emits: radioEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const ns = useNamespace("radio");
          const { radioRef, radioGroup, focus, size, disabled, modelValue, actualValue } = useRadio(props2, emit);
          function handleChange() {
            nextTick(() => emit(CHANGE_EVENT, modelValue.value));
          }
          return (_ctx, _cache) => {
            var _a;
            return openBlock(), createElementBlock("label", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).is("disabled", unref(disabled)),
                unref(ns).is("focus", unref(focus)),
                unref(ns).is("bordered", _ctx.border),
                unref(ns).is("checked", unref(modelValue) === unref(actualValue)),
                unref(ns).m(unref(size))
              ])
            }, [
              createElementVNode("span", {
                class: normalizeClass([
                  unref(ns).e("input"),
                  unref(ns).is("disabled", unref(disabled)),
                  unref(ns).is("checked", unref(modelValue) === unref(actualValue))
                ])
              }, [
                withDirectives(createElementVNode("input", {
                  ref_key: "radioRef",
                  ref: radioRef,
                  "onUpdate:modelValue": ($event) => isRef(modelValue) ? modelValue.value = $event : null,
                  class: normalizeClass(unref(ns).e("original")),
                  value: unref(actualValue),
                  name: _ctx.name || ((_a = unref(radioGroup)) == null ? void 0 : _a.name),
                  disabled: unref(disabled),
                  checked: unref(modelValue) === unref(actualValue),
                  type: "radio",
                  onFocus: ($event) => focus.value = true,
                  onBlur: ($event) => focus.value = false,
                  onChange: handleChange,
                  onClick: withModifiers(() => {
                  }, ["stop"])
                }, null, 42, ["onUpdate:modelValue", "value", "name", "disabled", "checked", "onFocus", "onBlur", "onClick"]), [
                  [vModelRadio, unref(modelValue)]
                ]),
                createElementVNode("span", {
                  class: normalizeClass(unref(ns).e("inner"))
                }, null, 2)
              ], 2),
              createElementVNode("span", {
                class: normalizeClass(unref(ns).e("label")),
                onKeydown: withModifiers(() => {
                }, ["stop"])
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.label), 1)
                ])
              ], 42, ["onKeydown"])
            ], 2);
          };
        }
      });
      var Radio = /* @__PURE__ */ _export_sfc(_sfc_main$1Z, [["__file", "radio.vue"]]);
      const radioButtonProps = exports("radioButtonProps", buildProps({
        ...radioPropsBase
      }));
      const __default__$1t = defineComponent({
        name: "ElRadioButton"
      });
      const _sfc_main$1Y = /* @__PURE__ */ defineComponent({
        ...__default__$1t,
        props: radioButtonProps,
        setup(__props) {
          const props2 = __props;
          const ns = useNamespace("radio");
          const { radioRef, focus, size, disabled, modelValue, radioGroup, actualValue } = useRadio(props2);
          const activeStyle = computed(() => {
            return {
              backgroundColor: (radioGroup == null ? void 0 : radioGroup.fill) || "",
              borderColor: (radioGroup == null ? void 0 : radioGroup.fill) || "",
              boxShadow: (radioGroup == null ? void 0 : radioGroup.fill) ? `-1px 0 0 0 ${radioGroup.fill}` : "",
              color: (radioGroup == null ? void 0 : radioGroup.textColor) || ""
            };
          });
          return (_ctx, _cache) => {
            var _a;
            return openBlock(), createElementBlock("label", {
              class: normalizeClass([
                unref(ns).b("button"),
                unref(ns).is("active", unref(modelValue) === unref(actualValue)),
                unref(ns).is("disabled", unref(disabled)),
                unref(ns).is("focus", unref(focus)),
                unref(ns).bm("button", unref(size))
              ])
            }, [
              withDirectives(createElementVNode("input", {
                ref_key: "radioRef",
                ref: radioRef,
                "onUpdate:modelValue": ($event) => isRef(modelValue) ? modelValue.value = $event : null,
                class: normalizeClass(unref(ns).be("button", "original-radio")),
                value: unref(actualValue),
                type: "radio",
                name: _ctx.name || ((_a = unref(radioGroup)) == null ? void 0 : _a.name),
                disabled: unref(disabled),
                onFocus: ($event) => focus.value = true,
                onBlur: ($event) => focus.value = false,
                onClick: withModifiers(() => {
                }, ["stop"])
              }, null, 42, ["onUpdate:modelValue", "value", "name", "disabled", "onFocus", "onBlur", "onClick"]), [
                [vModelRadio, unref(modelValue)]
              ]),
              createElementVNode("span", {
                class: normalizeClass(unref(ns).be("button", "inner")),
                style: normalizeStyle(unref(modelValue) === unref(actualValue) ? unref(activeStyle) : {}),
                onKeydown: withModifiers(() => {
                }, ["stop"])
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.label), 1)
                ])
              ], 46, ["onKeydown"])
            ], 2);
          };
        }
      });
      var RadioButton = /* @__PURE__ */ _export_sfc(_sfc_main$1Y, [["__file", "radio-button.vue"]]);
      const radioGroupProps = exports("radioGroupProps", buildProps({
        id: {
          type: String,
          default: void 0
        },
        size: useSizeProp,
        disabled: Boolean,
        modelValue: {
          type: [String, Number, Boolean],
          default: void 0
        },
        fill: {
          type: String,
          default: ""
        },
        textColor: {
          type: String,
          default: ""
        },
        name: {
          type: String,
          default: void 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        ...useAriaProps(["ariaLabel"])
      }));
      const radioGroupEmits = exports("radioGroupEmits", radioEmits);
      const __default__$1s = defineComponent({
        name: "ElRadioGroup"
      });
      const _sfc_main$1X = /* @__PURE__ */ defineComponent({
        ...__default__$1s,
        props: radioGroupProps,
        emits: radioGroupEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const ns = useNamespace("radio");
          const radioId = useId();
          const radioGroupRef = ref();
          const { formItem } = useFormItem();
          const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props2, {
            formItemContext: formItem
          });
          const changeEvent = (value) => {
            emit(UPDATE_MODEL_EVENT, value);
            nextTick(() => emit(CHANGE_EVENT, value));
          };
          onMounted(() => {
            const radios = radioGroupRef.value.querySelectorAll("[type=radio]");
            const firstLabel = radios[0];
            if (!Array.from(radios).some((radio) => radio.checked) && firstLabel) {
              firstLabel.tabIndex = 0;
            }
          });
          const name = computed(() => {
            return props2.name || radioId.value;
          });
          provide(radioGroupKey, reactive({
            ...toRefs(props2),
            changeEvent,
            name
          }));
          watch(() => props2.modelValue, () => {
            if (props2.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
            }
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              id: unref(groupId),
              ref_key: "radioGroupRef",
              ref: radioGroupRef,
              class: normalizeClass(unref(ns).b("group")),
              role: "radiogroup",
              "aria-label": !unref(isLabeledByFormItem) ? _ctx.ariaLabel || "radio-group" : void 0,
              "aria-labelledby": unref(isLabeledByFormItem) ? unref(formItem).labelId : void 0
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 10, ["id", "aria-label", "aria-labelledby"]);
          };
        }
      });
      var RadioGroup = /* @__PURE__ */ _export_sfc(_sfc_main$1X, [["__file", "radio-group.vue"]]);
      const ElRadio = exports("ElRadio", withInstall(Radio, {
        RadioButton,
        RadioGroup
      }));
      const ElRadioGroup = exports("ElRadioGroup", withNoopInstall(RadioGroup));
      const ElRadioButton = exports("ElRadioButton", withNoopInstall(RadioButton));
      const CASCADER_PANEL_INJECTION_KEY = exports("CASCADER_PANEL_INJECTION_KEY", Symbol());
      function isVNodeEmpty(vnodes) {
        return !!(isArray$1(vnodes) ? vnodes.every(({
          type
        }) => type === Comment) : (vnodes == null ? void 0 : vnodes.type) === Comment);
      }
      var NodeContent$1 = defineComponent({
        name: "NodeContent",
        props: {
          node: {
            type: Object,
            required: true
          },
          disabled: Boolean
        },
        setup(props2, {
          emit
        }) {
          const ns = useNamespace("cascader-node");
          const {
            config,
            renderLabelFn
          } = inject(CASCADER_PANEL_INJECTION_KEY);
          const {
            checkOnClickNode,
            checkOnClickLeaf
          } = config;
          const {
            node,
            disabled
          } = props2;
          const {
            data,
            label: nodeLabel
          } = node;
          const label = () => {
            const renderLabel = renderLabelFn == null ? void 0 : renderLabelFn({
              node,
              data
            });
            return isVNodeEmpty(renderLabel) ? nodeLabel : renderLabel != null ? renderLabel : nodeLabel;
          };
          function handleClick() {
            if ((checkOnClickNode || node.isLeaf && checkOnClickLeaf) && !disabled) {
              emit("handleSelectCheck", !node.checked);
            }
          }
          return () => createVNode("span", {
            "class": ns.e("label"),
            "onClick": handleClick
          }, [label()]);
        }
      });
      const __default__$1r = defineComponent({
        name: "ElCascaderNode"
      });
      const _sfc_main$1W = /* @__PURE__ */ defineComponent({
        ...__default__$1r,
        props: {
          node: {
            type: Object,
            required: true
          },
          menuId: String
        },
        emits: ["expand"],
        setup(__props, { emit }) {
          const props2 = __props;
          const panel = inject(CASCADER_PANEL_INJECTION_KEY);
          const ns = useNamespace("cascader-node");
          const isHoverMenu = computed(() => panel.isHoverMenu);
          const multiple = computed(() => panel.config.multiple);
          const checkStrictly = computed(() => panel.config.checkStrictly);
          const showPrefix = computed(() => panel.config.showPrefix);
          const checkedNodeId = computed(() => {
            var _a;
            return (_a = panel.checkedNodes[0]) == null ? void 0 : _a.uid;
          });
          const isDisabled = computed(() => props2.node.isDisabled);
          const isLeaf2 = computed(() => props2.node.isLeaf);
          const expandable = computed(() => checkStrictly.value && !isLeaf2.value || !isDisabled.value);
          const inExpandingPath = computed(() => isInPath(panel.expandingNode));
          const inCheckedPath = computed(() => checkStrictly.value && panel.checkedNodes.some(isInPath));
          const isInPath = (node) => {
            var _a;
            const { level, uid: uid2 } = props2.node;
            return ((_a = node == null ? void 0 : node.pathNodes[level - 1]) == null ? void 0 : _a.uid) === uid2;
          };
          const doExpand = () => {
            if (inExpandingPath.value)
              return;
            panel.expandNode(props2.node);
          };
          const doCheck = (checked) => {
            const { node } = props2;
            if (checked === node.checked)
              return;
            panel.handleCheckChange(node, checked);
          };
          const doLoad = () => {
            panel.lazyLoad(props2.node, () => {
              if (!isLeaf2.value)
                doExpand();
            });
          };
          const handleHoverExpand = (e) => {
            if (!isHoverMenu.value)
              return;
            handleExpand();
            !isLeaf2.value && emit("expand", e);
          };
          const handleExpand = () => {
            const { node } = props2;
            if (!expandable.value || node.loading)
              return;
            node.loaded ? doExpand() : doLoad();
          };
          const handleClick = () => {
            if (isHoverMenu.value && !isLeaf2.value)
              return;
            if (isLeaf2.value && !isDisabled.value && !checkStrictly.value && !multiple.value) {
              handleCheck(true);
            } else {
              handleExpand();
            }
          };
          const handleSelectCheck = (checked) => {
            if (checkStrictly.value) {
              doCheck(checked);
              if (props2.node.loaded) {
                doExpand();
              }
            } else {
              handleCheck(checked);
            }
          };
          const handleCheck = (checked) => {
            if (!props2.node.loaded) {
              doLoad();
            } else {
              doCheck(checked);
              !checkStrictly.value && doExpand();
            }
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("li", {
              id: `${__props.menuId}-${__props.node.uid}`,
              role: "menuitem",
              "aria-haspopup": !unref(isLeaf2),
              "aria-owns": unref(isLeaf2) ? void 0 : __props.menuId,
              "aria-expanded": unref(inExpandingPath),
              tabindex: unref(expandable) ? -1 : void 0,
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).is("selectable", unref(checkStrictly)),
                unref(ns).is("active", __props.node.checked),
                unref(ns).is("disabled", !unref(expandable)),
                unref(inExpandingPath) && "in-active-path",
                unref(inCheckedPath) && "in-checked-path"
              ]),
              onMouseenter: handleHoverExpand,
              onFocus: handleHoverExpand,
              onClick: handleClick
            }, [
              createCommentVNode(" prefix "),
              unref(multiple) && unref(showPrefix) ? (openBlock(), createBlock(unref(ElCheckbox), {
                key: 0,
                "model-value": __props.node.checked,
                indeterminate: __props.node.indeterminate,
                disabled: unref(isDisabled),
                onClick: withModifiers(() => {
                }, ["stop"]),
                "onUpdate:modelValue": handleSelectCheck
              }, null, 8, ["model-value", "indeterminate", "disabled", "onClick"])) : unref(checkStrictly) && unref(showPrefix) ? (openBlock(), createBlock(unref(ElRadio), {
                key: 1,
                "model-value": unref(checkedNodeId),
                label: __props.node.uid,
                disabled: unref(isDisabled),
                "onUpdate:modelValue": handleSelectCheck,
                onClick: withModifiers(() => {
                }, ["stop"])
              }, {
                default: withCtx(() => [
                  createCommentVNode("\n        Add an empty element to avoid render label,\n        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485\n      "),
                  createElementVNode("span")
                ]),
                _: 1
              }, 8, ["model-value", "label", "disabled", "onClick"])) : unref(isLeaf2) && __props.node.checked ? (openBlock(), createBlock(unref(ElIcon), {
                key: 2,
                class: normalizeClass(unref(ns).e("prefix"))
              }, {
                default: withCtx(() => [
                  createVNode(unref(check_default$1))
                ]),
                _: 1
              }, 8, ["class"])) : createCommentVNode("v-if", true),
              createCommentVNode(" content "),
              createVNode(unref(NodeContent$1), {
                node: __props.node,
                disabled: unref(isDisabled),
                onHandleSelectCheck: handleSelectCheck
              }, null, 8, ["node", "disabled"]),
              createCommentVNode(" postfix "),
              !unref(isLeaf2) ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
                __props.node.loading ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass([unref(ns).is("loading"), unref(ns).e("postfix")])
                }, {
                  default: withCtx(() => [
                    createVNode(unref(loading_default$1))
                  ]),
                  _: 1
                }, 8, ["class"])) : (openBlock(), createBlock(unref(ElIcon), {
                  key: 1,
                  class: normalizeClass(["arrow-right", unref(ns).e("postfix")])
                }, {
                  default: withCtx(() => [
                    createVNode(unref(arrow_right_default$1))
                  ]),
                  _: 1
                }, 8, ["class"]))
              ], 64)) : createCommentVNode("v-if", true)
            ], 42, ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"]);
          };
        }
      });
      var ElCascaderNode = /* @__PURE__ */ _export_sfc(_sfc_main$1W, [["__file", "node.vue"]]);
      const __default__$1q = defineComponent({
        name: "ElCascaderMenu"
      });
      const _sfc_main$1V = /* @__PURE__ */ defineComponent({
        ...__default__$1q,
        props: {
          nodes: {
            type: Array,
            required: true
          },
          index: {
            type: Number,
            required: true
          }
        },
        setup(__props) {
          const props2 = __props;
          const instance = getCurrentInstance();
          const ns = useNamespace("cascader-menu");
          const { t } = useLocale();
          const id = useId();
          let activeNode;
          let hoverTimer;
          const panel = inject(CASCADER_PANEL_INJECTION_KEY);
          const hoverZone = ref();
          const isEmpty2 = computed(() => !props2.nodes.length);
          const isLoading = computed(() => !panel.initialLoaded);
          const menuId = computed(() => `${id.value}-${props2.index}`);
          const handleExpand = (e) => {
            activeNode = e.target;
          };
          const handleMouseMove = (e) => {
            if (!panel.isHoverMenu || !activeNode || !hoverZone.value)
              return;
            if (activeNode.contains(e.target)) {
              clearHoverTimer();
              const el = instance.vnode.el;
              const { left } = el.getBoundingClientRect();
              const { offsetWidth, offsetHeight } = el;
              const startX = e.clientX - left;
              const top = activeNode.offsetTop;
              const bottom = top + activeNode.offsetHeight;
              hoverZone.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${top} L${offsetWidth} 0 V${top} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${bottom} L${offsetWidth} ${offsetHeight} V${bottom} Z" />
        `;
            } else if (!hoverTimer) {
              hoverTimer = window.setTimeout(clearHoverZone, panel.config.hoverThreshold);
            }
          };
          const clearHoverTimer = () => {
            if (!hoverTimer)
              return;
            clearTimeout(hoverTimer);
            hoverTimer = void 0;
          };
          const clearHoverZone = () => {
            if (!hoverZone.value)
              return;
            hoverZone.value.innerHTML = "";
            clearHoverTimer();
          };
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElScrollbar), {
              key: unref(menuId),
              tag: "ul",
              role: "menu",
              class: normalizeClass(unref(ns).b()),
              "wrap-class": unref(ns).e("wrap"),
              "view-class": [unref(ns).e("list"), unref(ns).is("empty", unref(isEmpty2))],
              onMousemove: handleMouseMove,
              onMouseleave: clearHoverZone
            }, {
              default: withCtx(() => {
                var _a;
                return [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(__props.nodes, (node) => {
                    return openBlock(), createBlock(ElCascaderNode, {
                      key: node.uid,
                      node,
                      "menu-id": unref(menuId),
                      onExpand: handleExpand
                    }, null, 8, ["node", "menu-id"]);
                  }), 128)),
                  unref(isLoading) ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(unref(ns).e("empty-text"))
                  }, [
                    createVNode(unref(ElIcon), {
                      size: "14",
                      class: normalizeClass(unref(ns).is("loading"))
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(loading_default$1))
                      ]),
                      _: 1
                    }, 8, ["class"]),
                    createTextVNode(" " + toDisplayString(unref(t)("el.cascader.loading")), 1)
                  ], 2)) : unref(isEmpty2) ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass(unref(ns).e("empty-text"))
                  }, [
                    renderSlot(_ctx.$slots, "empty", {}, () => [
                      createTextVNode(toDisplayString(unref(t)("el.cascader.noData")), 1)
                    ])
                  ], 2)) : ((_a = unref(panel)) == null ? void 0 : _a.isHoverMenu) ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                    createCommentVNode(" eslint-disable-next-line vue/html-self-closing "),
                    (openBlock(), createElementBlock("svg", {
                      ref_key: "hoverZone",
                      ref: hoverZone,
                      class: normalizeClass(unref(ns).e("hover-zone"))
                    }, null, 2))
                  ], 2112)) : createCommentVNode("v-if", true)
                ];
              }),
              _: 3
            }, 8, ["class", "wrap-class", "view-class"]);
          };
        }
      });
      var ElCascaderMenu = /* @__PURE__ */ _export_sfc(_sfc_main$1V, [["__file", "menu.vue"]]);
      let uid = 0;
      const calculatePathNodes = (node) => {
        const nodes = [node];
        let { parent: parent2 } = node;
        while (parent2) {
          nodes.unshift(parent2);
          parent2 = parent2.parent;
        }
        return nodes;
      };
      class Node$3 {
        constructor(data, config, parent2, root2 = false) {
          this.data = data;
          this.config = config;
          this.parent = parent2;
          this.root = root2;
          this.uid = uid++;
          this.checked = false;
          this.indeterminate = false;
          this.loading = false;
          const { value: valueKey, label: labelKey, children: childrenKey } = config;
          const childrenData = data[childrenKey];
          const pathNodes = calculatePathNodes(this);
          this.level = root2 ? 0 : parent2 ? parent2.level + 1 : 1;
          this.value = data[valueKey];
          this.label = data[labelKey];
          this.pathNodes = pathNodes;
          this.pathValues = pathNodes.map((node) => node.value);
          this.pathLabels = pathNodes.map((node) => node.label);
          this.childrenData = childrenData;
          this.children = (childrenData || []).map((child) => new Node$3(child, config, this));
          this.loaded = !config.lazy || this.isLeaf || !isEmpty(childrenData);
          this.text = "";
        }
        get isDisabled() {
          const { data, parent: parent2, config } = this;
          const { disabled, checkStrictly } = config;
          const isDisabled = isFunction$1(disabled) ? disabled(data, this) : !!data[disabled];
          return isDisabled || !checkStrictly && !!(parent2 == null ? void 0 : parent2.isDisabled);
        }
        get isLeaf() {
          const { data, config, childrenData, loaded } = this;
          const { lazy, leaf } = config;
          const isLeaf2 = isFunction$1(leaf) ? leaf(data, this) : data[leaf];
          return isUndefined(isLeaf2) ? lazy && !loaded ? false : !(isArray$1(childrenData) && childrenData.length) : !!isLeaf2;
        }
        get valueByOption() {
          return this.config.emitPath ? this.pathValues : this.value;
        }
        appendChild(childData) {
          const { childrenData, children } = this;
          const node = new Node$3(childData, this.config, this);
          if (isArray$1(childrenData)) {
            childrenData.push(childData);
          } else {
            this.childrenData = [childData];
          }
          children.push(node);
          return node;
        }
        calcText(allLevels, separator) {
          const text = allLevels ? this.pathLabels.join(separator) : this.label;
          this.text = text;
          return text;
        }
        broadcast(checked) {
          this.children.forEach((child) => {
            var _a;
            if (child) {
              child.broadcast(checked);
              (_a = child.onParentCheck) == null ? void 0 : _a.call(child, checked);
            }
          });
        }
        emit() {
          var _a;
          const { parent: parent2 } = this;
          if (parent2) {
            (_a = parent2.onChildCheck) == null ? void 0 : _a.call(parent2);
            parent2.emit();
          }
        }
        onParentCheck(checked) {
          if (!this.isDisabled) {
            this.setCheckState(checked);
          }
        }
        onChildCheck() {
          const { children } = this;
          const validChildren = children.filter((child) => !child.isDisabled);
          const checked = validChildren.length ? validChildren.every((child) => child.checked) : false;
          this.setCheckState(checked);
        }
        setCheckState(checked) {
          const totalNum = this.children.length;
          const checkedNum = this.children.reduce((c2, p2) => {
            const num = p2.checked ? 1 : p2.indeterminate ? 0.5 : 0;
            return c2 + num;
          }, 0);
          this.checked = this.loaded && this.children.filter((child) => !child.isDisabled).every((child) => child.loaded && child.checked) && checked;
          this.indeterminate = this.loaded && checkedNum !== totalNum && checkedNum > 0;
        }
        doCheck(checked) {
          if (this.checked === checked)
            return;
          const { checkStrictly, multiple } = this.config;
          if (checkStrictly || !multiple) {
            this.checked = checked;
          } else {
            this.broadcast(checked);
            this.setCheckState(checked);
            this.emit();
          }
        }
      }
      var Node$4 = Node$3;
      const flatNodes = (nodes, leafOnly) => {
        return nodes.reduce((res, node) => {
          if (node.isLeaf) {
            res.push(node);
          } else {
            !leafOnly && res.push(node);
            res = res.concat(flatNodes(node.children, leafOnly));
          }
          return res;
        }, []);
      };
      class Store {
        constructor(data, config) {
          this.config = config;
          const nodes = (data || []).map((nodeData) => new Node$4(nodeData, this.config));
          this.nodes = nodes;
          this.allNodes = flatNodes(nodes, false);
          this.leafNodes = flatNodes(nodes, true);
        }
        getNodes() {
          return this.nodes;
        }
        getFlattedNodes(leafOnly) {
          return leafOnly ? this.leafNodes : this.allNodes;
        }
        appendNode(nodeData, parentNode) {
          const node = parentNode ? parentNode.appendChild(nodeData) : new Node$4(nodeData, this.config);
          if (!parentNode)
            this.nodes.push(node);
          this.appendAllNodesAndLeafNodes(node);
        }
        appendNodes(nodeDataList, parentNode) {
          nodeDataList.forEach((nodeData) => this.appendNode(nodeData, parentNode));
        }
        appendAllNodesAndLeafNodes(node) {
          this.allNodes.push(node);
          node.isLeaf && this.leafNodes.push(node);
          if (node.children) {
            node.children.forEach((subNode) => {
              this.appendAllNodesAndLeafNodes(subNode);
            });
          }
        }
        getNodeByValue(value, leafOnly = false) {
          if (isPropAbsent(value))
            return null;
          const node = this.getFlattedNodes(leafOnly).find((node2) => isEqual$1(node2.value, value) || isEqual$1(node2.pathValues, value));
          return node || null;
        }
        getSameNode(node) {
          if (!node)
            return null;
          const node_ = this.getFlattedNodes(false).find(({ value, level }) => isEqual$1(node.value, value) && node.level === level);
          return node_ || null;
        }
      }
      const CommonProps = exports("CommonProps", buildProps({
        modelValue: {
          type: definePropType([Number, String, Array])
        },
        options: {
          type: definePropType(Array),
          default: () => []
        },
        props: {
          type: definePropType(Object),
          default: () => ({})
        }
      }));
      const DefaultProps = exports("DefaultProps", {
        expandTrigger: "click",
        multiple: false,
        checkStrictly: false,
        emitPath: true,
        lazy: false,
        lazyLoad: NOOP,
        value: "value",
        label: "label",
        children: "children",
        leaf: "leaf",
        disabled: "disabled",
        hoverThreshold: 500,
        checkOnClickNode: false,
        checkOnClickLeaf: true,
        showPrefix: true
      });
      const cascaderPanelProps = exports("cascaderPanelProps", buildProps({
        ...CommonProps,
        border: {
          type: Boolean,
          default: true
        },
        renderLabel: {
          type: Function
        }
      }));
      const emitChangeFn$2 = (value) => true;
      const cascaderPanelEmits = exports("cascaderPanelEmits", {
        [UPDATE_MODEL_EVENT]: emitChangeFn$2,
        [CHANGE_EVENT]: emitChangeFn$2,
        close: () => true,
        "expand-change": (value) => value
      });
      const useCascaderConfig = exports("useCascaderConfig", (props2) => {
        return computed(() => ({
          ...DefaultProps,
          ...props2.props
        }));
      });
      const getMenuIndex = (el) => {
        if (!el)
          return 0;
        const pieces = el.id.split("-");
        return Number(pieces[pieces.length - 2]);
      };
      const checkNode = (el) => {
        if (!el)
          return;
        const input = el.querySelector("input");
        if (input) {
          input.click();
        } else if (isLeaf(el)) {
          el.click();
        }
      };
      const sortByOriginalOrder = (oldNodes, newNodes) => {
        const newNodesCopy = newNodes.slice(0);
        const newIds = newNodesCopy.map((node) => node.uid);
        const res = oldNodes.reduce((acc, item) => {
          const index2 = newIds.indexOf(item.uid);
          if (index2 > -1) {
            acc.push(item);
            newNodesCopy.splice(index2, 1);
            newIds.splice(index2, 1);
          }
          return acc;
        }, []);
        res.push(...newNodesCopy);
        return res;
      };
      const __default__$1p = defineComponent({
        name: "ElCascaderPanel",
        inheritAttrs: false
      });
      const _sfc_main$1U = /* @__PURE__ */ defineComponent({
        ...__default__$1p,
        props: cascaderPanelProps,
        emits: cascaderPanelEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          let manualChecked = false;
          const ns = useNamespace("cascader");
          const config = useCascaderConfig(props2);
          const slots = useSlots();
          let store;
          const initialLoaded = ref(true);
          const menuList = ref([]);
          const checkedValue = ref();
          const menus = ref([]);
          const expandingNode = ref();
          const checkedNodes = ref([]);
          const isHoverMenu = computed(() => config.value.expandTrigger === "hover");
          const renderLabelFn = computed(() => props2.renderLabel || slots.default);
          const initStore = () => {
            const { options } = props2;
            const cfg = config.value;
            manualChecked = false;
            store = new Store(options, cfg);
            menus.value = [store.getNodes()];
            if (cfg.lazy && isEmpty(props2.options)) {
              initialLoaded.value = false;
              lazyLoad(void 0, (list) => {
                if (list) {
                  store = new Store(list, cfg);
                  menus.value = [store.getNodes()];
                }
                initialLoaded.value = true;
                syncCheckedValue(false, true);
              });
            } else {
              syncCheckedValue(false, true);
            }
          };
          const lazyLoad = (node, cb) => {
            const cfg = config.value;
            node = node || new Node$4({}, cfg, void 0, true);
            node.loading = true;
            const resolve = (dataList) => {
              const _node = node;
              const parent2 = _node.root ? null : _node;
              dataList && (store == null ? void 0 : store.appendNodes(dataList, parent2));
              _node.loading = false;
              _node.loaded = true;
              _node.childrenData = _node.childrenData || [];
              dataList && (cb == null ? void 0 : cb(dataList));
            };
            cfg.lazyLoad(node, resolve);
          };
          const expandNode = (node, silent) => {
            var _a;
            const { level } = node;
            const newMenus = menus.value.slice(0, level);
            let newExpandingNode;
            if (node.isLeaf) {
              newExpandingNode = node.pathNodes[level - 2];
            } else {
              newExpandingNode = node;
              newMenus.push(node.children);
            }
            if (((_a = expandingNode.value) == null ? void 0 : _a.uid) !== (newExpandingNode == null ? void 0 : newExpandingNode.uid)) {
              expandingNode.value = node;
              menus.value = newMenus;
              !silent && emit("expand-change", (node == null ? void 0 : node.pathValues) || []);
            }
          };
          const handleCheckChange = (node, checked, emitClose = true) => {
            const { checkStrictly, multiple } = config.value;
            const oldNode = checkedNodes.value[0];
            manualChecked = true;
            !multiple && (oldNode == null ? void 0 : oldNode.doCheck(false));
            node.doCheck(checked);
            calculateCheckedValue();
            emitClose && !multiple && !checkStrictly && emit("close");
            !emitClose && !multiple && !checkStrictly && expandParentNode(node);
          };
          const expandParentNode = (node) => {
            if (!node)
              return;
            node = node.parent;
            expandParentNode(node);
            node && expandNode(node);
          };
          const getFlattedNodes = (leafOnly) => store == null ? void 0 : store.getFlattedNodes(leafOnly);
          const getCheckedNodes = (leafOnly) => {
            var _a;
            return (_a = getFlattedNodes(leafOnly)) == null ? void 0 : _a.filter(({ checked }) => checked !== false);
          };
          const clearCheckedNodes = () => {
            checkedNodes.value.forEach((node) => node.doCheck(false));
            calculateCheckedValue();
            menus.value = menus.value.slice(0, 1);
            expandingNode.value = void 0;
            emit("expand-change", []);
          };
          const calculateCheckedValue = () => {
            const { checkStrictly, multiple } = config.value;
            const oldNodes = checkedNodes.value;
            const newNodes = getCheckedNodes(!checkStrictly);
            const nodes = sortByOriginalOrder(oldNodes, newNodes);
            const values2 = nodes.map((node) => node.valueByOption);
            checkedNodes.value = nodes;
            checkedValue.value = multiple ? values2 : values2[0];
          };
          const syncCheckedValue = (loaded = false, forced = false) => {
            const { modelValue } = props2;
            const { lazy, multiple, checkStrictly } = config.value;
            const leafOnly = !checkStrictly;
            if (!initialLoaded.value || manualChecked || !forced && isEqual$1(modelValue, checkedValue.value))
              return;
            if (lazy && !loaded) {
              const values2 = unique(flattenDeep(castArray(modelValue)));
              const nodes = values2.map((val) => store == null ? void 0 : store.getNodeByValue(val)).filter((node) => !!node && !node.loaded && !node.loading);
              if (nodes.length) {
                nodes.forEach((node) => {
                  lazyLoad(node, () => syncCheckedValue(false, forced));
                });
              } else {
                syncCheckedValue(true, forced);
              }
            } else {
              const values2 = multiple ? castArray(modelValue) : [modelValue];
              const nodes = unique(values2.map((val) => store == null ? void 0 : store.getNodeByValue(val, leafOnly)));
              syncMenuState(nodes, forced);
              checkedValue.value = cloneDeep(modelValue != null ? modelValue : void 0);
            }
          };
          const syncMenuState = (newCheckedNodes, reserveExpandingState = true) => {
            const { checkStrictly } = config.value;
            const oldNodes = checkedNodes.value;
            const newNodes = newCheckedNodes.filter((node) => !!node && (checkStrictly || node.isLeaf));
            const oldExpandingNode = store == null ? void 0 : store.getSameNode(expandingNode.value);
            const newExpandingNode = reserveExpandingState && oldExpandingNode || newNodes[0];
            if (newExpandingNode) {
              newExpandingNode.pathNodes.forEach((node) => expandNode(node, true));
            } else {
              expandingNode.value = void 0;
            }
            oldNodes.forEach((node) => node.doCheck(false));
            reactive(newNodes).forEach((node) => node.doCheck(true));
            checkedNodes.value = newNodes;
            nextTick(scrollToExpandingNode);
          };
          const scrollToExpandingNode = () => {
            if (!isClient)
              return;
            menuList.value.forEach((menu) => {
              const menuElement = menu == null ? void 0 : menu.$el;
              if (menuElement) {
                const container = menuElement.querySelector(`.${ns.namespace.value}-scrollbar__wrap`);
                const activeNode = menuElement.querySelector(`.${ns.b("node")}.${ns.is("active")}:last-child`) || menuElement.querySelector(`.${ns.b("node")}.in-active-path`);
                scrollIntoView(container, activeNode);
              }
            });
          };
          const handleKeyDown = (e) => {
            const target2 = e.target;
            const { code } = e;
            switch (code) {
              case EVENT_CODE.up:
              case EVENT_CODE.down: {
                e.preventDefault();
                const distance = code === EVENT_CODE.up ? -1 : 1;
                focusNode(getSibling(target2, distance, `.${ns.b("node")}[tabindex="-1"]`));
                break;
              }
              case EVENT_CODE.left: {
                e.preventDefault();
                const preMenu = menuList.value[getMenuIndex(target2) - 1];
                const expandedNode = preMenu == null ? void 0 : preMenu.$el.querySelector(`.${ns.b("node")}[aria-expanded="true"]`);
                focusNode(expandedNode);
                break;
              }
              case EVENT_CODE.right: {
                e.preventDefault();
                const nextMenu = menuList.value[getMenuIndex(target2) + 1];
                const firstNode = nextMenu == null ? void 0 : nextMenu.$el.querySelector(`.${ns.b("node")}[tabindex="-1"]`);
                focusNode(firstNode);
                break;
              }
              case EVENT_CODE.enter:
              case EVENT_CODE.numpadEnter:
                checkNode(target2);
                break;
            }
          };
          provide(CASCADER_PANEL_INJECTION_KEY, reactive({
            config,
            expandingNode,
            checkedNodes,
            isHoverMenu,
            initialLoaded,
            renderLabelFn,
            lazyLoad,
            expandNode,
            handleCheckChange
          }));
          watch(config, (newVal, oldVal) => {
            if (isEqual$1(newVal, oldVal))
              return;
            initStore();
          }, {
            immediate: true
          });
          watch(() => props2.options, initStore, {
            deep: true
          });
          watch(() => props2.modelValue, () => {
            manualChecked = false;
            syncCheckedValue();
          }, {
            deep: true
          });
          watch(() => checkedValue.value, (val) => {
            if (!isEqual$1(val, props2.modelValue)) {
              emit(UPDATE_MODEL_EVENT, val);
              emit(CHANGE_EVENT, val);
            }
          });
          onBeforeUpdate(() => menuList.value = []);
          onMounted(() => !isEmpty(props2.modelValue) && syncCheckedValue());
          expose({
            menuList,
            menus,
            checkedNodes,
            handleKeyDown,
            handleCheckChange,
            getFlattedNodes,
            getCheckedNodes,
            clearCheckedNodes,
            calculateCheckedValue,
            scrollToExpandingNode
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b("panel"), unref(ns).is("bordered", _ctx.border)]),
              onKeydown: handleKeyDown
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(menus.value, (menu, index2) => {
                return openBlock(), createBlock(ElCascaderMenu, {
                  key: index2,
                  ref_for: true,
                  ref: (item) => menuList.value[index2] = item,
                  index: index2,
                  nodes: [...menu]
                }, {
                  empty: withCtx(() => [
                    renderSlot(_ctx.$slots, "empty")
                  ]),
                  _: 2
                }, 1032, ["index", "nodes"]);
              }), 128))
            ], 34);
          };
        }
      });
      var CascaderPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1U, [["__file", "index.vue"]]);
      const ElCascaderPanel = exports("ElCascaderPanel", withInstall(CascaderPanel));
      const tagProps = exports("tagProps", buildProps({
        type: {
          type: String,
          values: ["primary", "success", "info", "warning", "danger"],
          default: "primary"
        },
        closable: Boolean,
        disableTransitions: Boolean,
        hit: Boolean,
        color: String,
        size: {
          type: String,
          values: componentSizes
        },
        effect: {
          type: String,
          values: ["dark", "light", "plain"],
          default: "light"
        },
        round: Boolean
      }));
      const tagEmits = exports("tagEmits", {
        close: (evt) => evt instanceof MouseEvent,
        click: (evt) => evt instanceof MouseEvent
      });
      const __default__$1o = defineComponent({
        name: "ElTag"
      });
      const _sfc_main$1T = /* @__PURE__ */ defineComponent({
        ...__default__$1o,
        props: tagProps,
        emits: tagEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const tagSize = useFormSize();
          const ns = useNamespace("tag");
          const containerKls = computed(() => {
            const { type, hit, effect, closable, round: round2 } = props2;
            return [
              ns.b(),
              ns.is("closable", closable),
              ns.m(type || "primary"),
              ns.m(tagSize.value),
              ns.m(effect),
              ns.is("hit", hit),
              ns.is("round", round2)
            ];
          });
          const handleClose = (event) => {
            emit("close", event);
          };
          const handleClick = (event) => {
            emit("click", event);
          };
          const handleVNodeMounted = (vnode) => {
            var _a, _b, _c;
            if ((_c = (_b = (_a = vnode == null ? void 0 : vnode.component) == null ? void 0 : _a.subTree) == null ? void 0 : _b.component) == null ? void 0 : _c.bum) {
              vnode.component.subTree.component.bum = null;
            }
          };
          return (_ctx, _cache) => {
            return _ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass(unref(containerKls)),
              style: normalizeStyle({ backgroundColor: _ctx.color }),
              onClick: handleClick
            }, [
              createElementVNode("span", {
                class: normalizeClass(unref(ns).e("content"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2),
              _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                key: 0,
                class: normalizeClass(unref(ns).e("close")),
                onClick: withModifiers(handleClose, ["stop"])
              }, {
                default: withCtx(() => [
                  createVNode(unref(close_default$1))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
            ], 6)) : (openBlock(), createBlock(Transition, {
              key: 1,
              name: `${unref(ns).namespace.value}-zoom-in-center`,
              appear: "",
              onVnodeMounted: handleVNodeMounted
            }, {
              default: withCtx(() => [
                createElementVNode("span", {
                  class: normalizeClass(unref(containerKls)),
                  style: normalizeStyle({ backgroundColor: _ctx.color }),
                  onClick: handleClick
                }, [
                  createElementVNode("span", {
                    class: normalizeClass(unref(ns).e("content"))
                  }, [
                    renderSlot(_ctx.$slots, "default")
                  ], 2),
                  _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns).e("close")),
                    onClick: withModifiers(handleClose, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(close_default$1))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                ], 6)
              ]),
              _: 3
            }, 8, ["name"]));
          };
        }
      });
      var Tag = /* @__PURE__ */ _export_sfc(_sfc_main$1T, [["__file", "tag.vue"]]);
      const ElTag = exports("ElTag", withInstall(Tag));
      const cascaderProps = exports("cascaderProps", buildProps({
        ...CommonProps,
        size: useSizeProp,
        placeholder: String,
        disabled: Boolean,
        clearable: Boolean,
        filterable: Boolean,
        filterMethod: {
          type: definePropType(Function),
          default: (node, keyword) => node.text.includes(keyword)
        },
        separator: {
          type: String,
          default: " / "
        },
        showAllLevels: {
          type: Boolean,
          default: true
        },
        collapseTags: Boolean,
        maxCollapseTags: {
          type: Number,
          default: 1
        },
        collapseTagsTooltip: Boolean,
        maxCollapseTagsTooltipHeight: {
          type: [String, Number]
        },
        debounce: {
          type: Number,
          default: 300
        },
        beforeFilter: {
          type: definePropType(Function),
          default: () => true
        },
        placement: {
          type: definePropType(String),
          values: Ee,
          default: "bottom-start"
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: ["bottom-start", "bottom", "top-start", "top", "right", "left"]
        },
        popperClass: {
          type: String,
          default: ""
        },
        teleported: useTooltipContentProps.teleported,
        effect: {
          type: definePropType(String),
          default: "light"
        },
        tagType: { ...tagProps.type, default: "info" },
        tagEffect: { ...tagProps.effect, default: "light" },
        validateEvent: {
          type: Boolean,
          default: true
        },
        persistent: {
          type: Boolean,
          default: true
        },
        showCheckedStrategy: {
          type: String,
          values: ["parent", "child"],
          default: "child"
        },
        checkOnClickNode: Boolean,
        showPrefix: {
          type: Boolean,
          default: true
        },
        ...useEmptyValuesProps
      }));
      const emitChangeFn$1 = (value) => true;
      const cascaderEmits = exports("cascaderEmits", {
        [UPDATE_MODEL_EVENT]: emitChangeFn$1,
        [CHANGE_EVENT]: emitChangeFn$1,
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent,
        clear: () => true,
        visibleChange: (val) => isBoolean(val),
        expandChange: (val) => !!val,
        removeTag: (val) => !!val
      });
      const COMPONENT_NAME$g = "ElCascader";
      const __default__$1n = defineComponent({
        name: COMPONENT_NAME$g
      });
      const _sfc_main$1S = /* @__PURE__ */ defineComponent({
        ...__default__$1n,
        props: cascaderProps,
        emits: cascaderEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const popperOptions = {
            modifiers: [
              {
                name: "arrowPosition",
                enabled: true,
                phase: "main",
                fn: ({ state }) => {
                  const { modifiersData, placement } = state;
                  if (["right", "left", "bottom", "top"].includes(placement))
                    return;
                  if (modifiersData.arrow) {
                    modifiersData.arrow.x = 35;
                  }
                },
                requires: ["arrow"]
              }
            ]
          };
          const attrs = useAttrs$1();
          let inputInitialHeight = 0;
          let pressDeleteCount = 0;
          const nsCascader = useNamespace("cascader");
          const nsInput = useNamespace("input");
          const { t } = useLocale();
          const { form, formItem } = useFormItem();
          const { valueOnClear } = useEmptyValues(props2);
          const { isComposing, handleComposition } = useComposition({
            afterComposition(event) {
              var _a;
              const text = (_a = event.target) == null ? void 0 : _a.value;
              handleInput(text);
            }
          });
          const tooltipRef = ref(null);
          const input = ref(null);
          const tagWrapper = ref(null);
          const cascaderPanelRef = ref(null);
          const suggestionPanel = ref(null);
          const popperVisible = ref(false);
          const inputHover = ref(false);
          const filtering = ref(false);
          const filterFocus = ref(false);
          const inputValue = ref("");
          const searchInputValue = ref("");
          const presentTags = ref([]);
          const allPresentTags = ref([]);
          const suggestions = ref([]);
          const cascaderStyle = computed(() => {
            return attrs.style;
          });
          const isDisabled = computed(() => props2.disabled || (form == null ? void 0 : form.disabled));
          const inputPlaceholder = computed(() => {
            var _a;
            return (_a = props2.placeholder) != null ? _a : t("el.cascader.placeholder");
          });
          const currentPlaceholder = computed(() => searchInputValue.value || presentTags.value.length > 0 || isComposing.value ? "" : inputPlaceholder.value);
          const realSize = useFormSize();
          const tagSize = computed(() => realSize.value === "small" ? "small" : "default");
          const multiple = computed(() => !!props2.props.multiple);
          const readonly2 = computed(() => !props2.filterable || multiple.value);
          const searchKeyword = computed(() => multiple.value ? searchInputValue.value : inputValue.value);
          const checkedNodes = computed(() => {
            var _a;
            return ((_a = cascaderPanelRef.value) == null ? void 0 : _a.checkedNodes) || [];
          });
          const clearBtnVisible = computed(() => {
            if (!props2.clearable || isDisabled.value || filtering.value || !inputHover.value)
              return false;
            return !!checkedNodes.value.length;
          });
          const presentText = computed(() => {
            const { showAllLevels, separator } = props2;
            const nodes = checkedNodes.value;
            return nodes.length ? multiple.value ? "" : nodes[0].calcText(showAllLevels, separator) : "";
          });
          const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
          const checkedValue = computed({
            get() {
              return cloneDeep(props2.modelValue);
            },
            set(val) {
              const value = val != null ? val : valueOnClear.value;
              emit(UPDATE_MODEL_EVENT, value);
              emit(CHANGE_EVENT, value);
              if (props2.validateEvent) {
                formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
              }
            }
          });
          const cascaderKls = computed(() => {
            return [
              nsCascader.b(),
              nsCascader.m(realSize.value),
              nsCascader.is("disabled", isDisabled.value),
              attrs.class
            ];
          });
          const cascaderIconKls = computed(() => {
            return [
              nsInput.e("icon"),
              "icon-arrow-down",
              nsCascader.is("reverse", popperVisible.value)
            ];
          });
          const inputClass = computed(() => {
            return nsCascader.is("focus", popperVisible.value || filterFocus.value);
          });
          const contentRef = computed(() => {
            var _a, _b;
            return (_b = (_a = tooltipRef.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
          });
          const togglePopperVisible = (visible) => {
            var _a, _b, _c;
            if (isDisabled.value)
              return;
            visible = visible != null ? visible : !popperVisible.value;
            if (visible !== popperVisible.value) {
              popperVisible.value = visible;
              (_b = (_a = input.value) == null ? void 0 : _a.input) == null ? void 0 : _b.setAttribute("aria-expanded", `${visible}`);
              if (visible) {
                updatePopperPosition();
                nextTick((_c = cascaderPanelRef.value) == null ? void 0 : _c.scrollToExpandingNode);
              } else if (props2.filterable) {
                syncPresentTextValue();
              }
              emit("visibleChange", visible);
            }
          };
          const updatePopperPosition = () => {
            nextTick(() => {
              var _a;
              (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper();
            });
          };
          const hideSuggestionPanel = () => {
            filtering.value = false;
          };
          const genTag2 = (node) => {
            const { showAllLevels, separator } = props2;
            return {
              node,
              key: node.uid,
              text: node.calcText(showAllLevels, separator),
              hitState: false,
              closable: !isDisabled.value && !node.isDisabled,
              isCollapseTag: false
            };
          };
          const deleteTag = (tag) => {
            var _a;
            const node = tag.node;
            node.doCheck(false);
            (_a = cascaderPanelRef.value) == null ? void 0 : _a.calculateCheckedValue();
            emit("removeTag", node.valueByOption);
          };
          const getStrategyCheckedNodes = () => {
            switch (props2.showCheckedStrategy) {
              case "child":
                return checkedNodes.value;
              case "parent": {
                const clickedNodes = getCheckedNodes(false);
                const clickedNodesValue = clickedNodes.map((o2) => o2.value);
                const parentNodes = clickedNodes.filter((o2) => !o2.parent || !clickedNodesValue.includes(o2.parent.value));
                return parentNodes;
              }
              default:
                return [];
            }
          };
          const calculatePresentTags = () => {
            if (!multiple.value)
              return;
            const nodes = getStrategyCheckedNodes();
            const tags = [];
            const allTags = [];
            nodes.forEach((node) => allTags.push(genTag2(node)));
            allPresentTags.value = allTags;
            if (nodes.length) {
              nodes.slice(0, props2.maxCollapseTags).forEach((node) => tags.push(genTag2(node)));
              const rest2 = nodes.slice(props2.maxCollapseTags);
              const restCount = rest2.length;
              if (restCount) {
                if (props2.collapseTags) {
                  tags.push({
                    key: -1,
                    text: `+ ${restCount}`,
                    closable: false,
                    isCollapseTag: true
                  });
                } else {
                  rest2.forEach((node) => tags.push(genTag2(node)));
                }
              }
            }
            presentTags.value = tags;
          };
          const calculateSuggestions = () => {
            var _a, _b;
            const { filterMethod, showAllLevels, separator } = props2;
            const res = (_b = (_a = cascaderPanelRef.value) == null ? void 0 : _a.getFlattedNodes(!props2.props.checkStrictly)) == null ? void 0 : _b.filter((node) => {
              if (node.isDisabled)
                return false;
              node.calcText(showAllLevels, separator);
              return filterMethod(node, searchKeyword.value);
            });
            if (multiple.value) {
              presentTags.value.forEach((tag) => {
                tag.hitState = false;
              });
              allPresentTags.value.forEach((tag) => {
                tag.hitState = false;
              });
            }
            filtering.value = true;
            suggestions.value = res;
            updatePopperPosition();
          };
          const focusFirstNode = () => {
            var _a;
            let firstNode;
            if (filtering.value && suggestionPanel.value) {
              firstNode = suggestionPanel.value.$el.querySelector(`.${nsCascader.e("suggestion-item")}`);
            } else {
              firstNode = (_a = cascaderPanelRef.value) == null ? void 0 : _a.$el.querySelector(`.${nsCascader.b("node")}[tabindex="-1"]`);
            }
            if (firstNode) {
              firstNode.focus();
              !filtering.value && firstNode.click();
            }
          };
          const updateStyle = () => {
            var _a, _b;
            const inputInner = (_a = input.value) == null ? void 0 : _a.input;
            const tagWrapperEl = tagWrapper.value;
            const suggestionPanelEl = (_b = suggestionPanel.value) == null ? void 0 : _b.$el;
            if (!isClient || !inputInner)
              return;
            if (suggestionPanelEl) {
              const suggestionList = suggestionPanelEl.querySelector(`.${nsCascader.e("suggestion-list")}`);
              suggestionList.style.minWidth = `${inputInner.offsetWidth}px`;
            }
            if (tagWrapperEl) {
              const { offsetHeight } = tagWrapperEl;
              const height = presentTags.value.length > 0 ? `${Math.max(offsetHeight, inputInitialHeight) - 2}px` : `${inputInitialHeight}px`;
              inputInner.style.height = height;
              updatePopperPosition();
            }
          };
          const getCheckedNodes = (leafOnly) => {
            var _a;
            return (_a = cascaderPanelRef.value) == null ? void 0 : _a.getCheckedNodes(leafOnly);
          };
          const handleExpandChange = (value) => {
            updatePopperPosition();
            emit("expandChange", value);
          };
          const handleKeyDown = (e) => {
            if (isComposing.value)
              return;
            switch (e.code) {
              case EVENT_CODE.enter:
              case EVENT_CODE.numpadEnter:
                togglePopperVisible();
                break;
              case EVENT_CODE.down:
                togglePopperVisible(true);
                nextTick(focusFirstNode);
                e.preventDefault();
                break;
              case EVENT_CODE.esc:
                if (popperVisible.value === true) {
                  e.preventDefault();
                  e.stopPropagation();
                  togglePopperVisible(false);
                }
                break;
              case EVENT_CODE.tab:
                togglePopperVisible(false);
                break;
            }
          };
          const handleClear = () => {
            var _a;
            (_a = cascaderPanelRef.value) == null ? void 0 : _a.clearCheckedNodes();
            if (!popperVisible.value && props2.filterable) {
              syncPresentTextValue();
            }
            togglePopperVisible(false);
            emit("clear");
          };
          const syncPresentTextValue = () => {
            const { value } = presentText;
            inputValue.value = value;
            searchInputValue.value = value;
          };
          const handleSuggestionClick = (node) => {
            var _a, _b;
            const { checked } = node;
            if (multiple.value) {
              (_a = cascaderPanelRef.value) == null ? void 0 : _a.handleCheckChange(node, !checked, false);
            } else {
              !checked && ((_b = cascaderPanelRef.value) == null ? void 0 : _b.handleCheckChange(node, true, false));
              togglePopperVisible(false);
            }
          };
          const handleSuggestionKeyDown = (e) => {
            const target2 = e.target;
            const { code } = e;
            switch (code) {
              case EVENT_CODE.up:
              case EVENT_CODE.down: {
                e.preventDefault();
                const distance = code === EVENT_CODE.up ? -1 : 1;
                focusNode(getSibling(target2, distance, `.${nsCascader.e("suggestion-item")}[tabindex="-1"]`));
                break;
              }
              case EVENT_CODE.enter:
              case EVENT_CODE.numpadEnter:
                target2.click();
                break;
            }
          };
          const handleDelete = () => {
            const tags = presentTags.value;
            const lastTag = tags[tags.length - 1];
            pressDeleteCount = searchInputValue.value ? 0 : pressDeleteCount + 1;
            if (!lastTag || !pressDeleteCount || props2.collapseTags && tags.length > 1)
              return;
            if (lastTag.hitState) {
              deleteTag(lastTag);
            } else {
              lastTag.hitState = true;
            }
          };
          const handleFocus = (e) => {
            const el = e.target;
            const name = nsCascader.e("search-input");
            if (el.className === name) {
              filterFocus.value = true;
            }
            emit("focus", e);
          };
          const handleBlur = (e) => {
            filterFocus.value = false;
            emit("blur", e);
          };
          const handleFilter = debounce(() => {
            const { value } = searchKeyword;
            if (!value)
              return;
            const passed = props2.beforeFilter(value);
            if (isPromise(passed)) {
              passed.then(calculateSuggestions).catch(() => {
              });
            } else if (passed !== false) {
              calculateSuggestions();
            } else {
              hideSuggestionPanel();
            }
          }, props2.debounce);
          const handleInput = (val, e) => {
            !popperVisible.value && togglePopperVisible(true);
            if (e == null ? void 0 : e.isComposing)
              return;
            val ? handleFilter() : hideSuggestionPanel();
          };
          const getInputInnerHeight = (inputInner) => Number.parseFloat(useCssVar(nsInput.cssVarName("input-height"), inputInner).value) - 2;
          watch(filtering, updatePopperPosition);
          watch([checkedNodes, isDisabled, () => props2.collapseTags], calculatePresentTags);
          watch(presentTags, () => {
            nextTick(() => updateStyle());
          });
          watch(realSize, async () => {
            await nextTick();
            const inputInner = input.value.input;
            inputInitialHeight = getInputInnerHeight(inputInner) || inputInitialHeight;
            updateStyle();
          });
          watch(presentText, syncPresentTextValue, { immediate: true });
          onMounted(() => {
            const inputInner = input.value.input;
            const inputInnerHeight = getInputInnerHeight(inputInner);
            inputInitialHeight = inputInner.offsetHeight || inputInnerHeight;
            useResizeObserver(inputInner, updateStyle);
          });
          expose({
            getCheckedNodes,
            cascaderPanelRef,
            togglePopperVisible,
            contentRef,
            presentText
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTooltip), {
              ref_key: "tooltipRef",
              ref: tooltipRef,
              visible: popperVisible.value,
              teleported: _ctx.teleported,
              "popper-class": [unref(nsCascader).e("dropdown"), _ctx.popperClass],
              "popper-options": popperOptions,
              "fallback-placements": _ctx.fallbackPlacements,
              "stop-popper-mouse-event": false,
              "gpu-acceleration": false,
              placement: _ctx.placement,
              transition: `${unref(nsCascader).namespace.value}-zoom-in-top`,
              effect: _ctx.effect,
              pure: "",
              persistent: _ctx.persistent,
              onHide: hideSuggestionPanel
            }, {
              default: withCtx(() => [
                withDirectives((openBlock(), createElementBlock("div", {
                  class: normalizeClass(unref(cascaderKls)),
                  style: normalizeStyle(unref(cascaderStyle)),
                  onClick: () => togglePopperVisible(unref(readonly2) ? void 0 : true),
                  onKeydown: handleKeyDown,
                  onMouseenter: ($event) => inputHover.value = true,
                  onMouseleave: ($event) => inputHover.value = false
                }, [
                  createVNode(unref(ElInput), {
                    ref_key: "input",
                    ref: input,
                    modelValue: inputValue.value,
                    "onUpdate:modelValue": ($event) => inputValue.value = $event,
                    placeholder: unref(currentPlaceholder),
                    readonly: unref(readonly2),
                    disabled: unref(isDisabled),
                    "validate-event": false,
                    size: unref(realSize),
                    class: normalizeClass(unref(inputClass)),
                    tabindex: unref(multiple) && _ctx.filterable && !unref(isDisabled) ? -1 : void 0,
                    onCompositionstart: unref(handleComposition),
                    onCompositionupdate: unref(handleComposition),
                    onCompositionend: unref(handleComposition),
                    onFocus: handleFocus,
                    onBlur: handleBlur,
                    onInput: handleInput
                  }, createSlots({
                    suffix: withCtx(() => [
                      unref(clearBtnVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: "clear",
                        class: normalizeClass([unref(nsInput).e("icon"), "icon-circle-close"]),
                        onClick: withModifiers(handleClear, ["stop"])
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(circle_close_default$1))
                        ]),
                        _: 1
                      }, 8, ["class", "onClick"])) : (openBlock(), createBlock(unref(ElIcon), {
                        key: "arrow-down",
                        class: normalizeClass(unref(cascaderIconKls)),
                        onClick: withModifiers(($event) => togglePopperVisible(), ["stop"])
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(arrow_down_default$1))
                        ]),
                        _: 1
                      }, 8, ["class", "onClick"]))
                    ]),
                    _: 2
                  }, [
                    _ctx.$slots.prefix ? {
                      name: "prefix",
                      fn: withCtx(() => [
                        renderSlot(_ctx.$slots, "prefix")
                      ])
                    } : void 0
                  ]), 1032, ["modelValue", "onUpdate:modelValue", "placeholder", "readonly", "disabled", "size", "class", "tabindex", "onCompositionstart", "onCompositionupdate", "onCompositionend"]),
                  unref(multiple) ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    ref_key: "tagWrapper",
                    ref: tagWrapper,
                    class: normalizeClass([
                      unref(nsCascader).e("tags"),
                      unref(nsCascader).is("validate", Boolean(unref(validateState)))
                    ])
                  }, [
                    renderSlot(_ctx.$slots, "tag", {
                      data: allPresentTags.value,
                      deleteTag
                    }, () => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(presentTags.value, (tag) => {
                        return openBlock(), createBlock(unref(ElTag), {
                          key: tag.key,
                          type: _ctx.tagType,
                          size: unref(tagSize),
                          effect: _ctx.tagEffect,
                          hit: tag.hitState,
                          closable: tag.closable,
                          "disable-transitions": "",
                          onClose: ($event) => deleteTag(tag)
                        }, {
                          default: withCtx(() => [
                            tag.isCollapseTag === false ? (openBlock(), createElementBlock("span", { key: 0 }, toDisplayString(tag.text), 1)) : (openBlock(), createBlock(unref(ElTooltip), {
                              key: 1,
                              disabled: popperVisible.value || !_ctx.collapseTagsTooltip,
                              "fallback-placements": ["bottom", "top", "right", "left"],
                              placement: "bottom",
                              effect: _ctx.effect
                            }, {
                              default: withCtx(() => [
                                createElementVNode("span", null, toDisplayString(tag.text), 1)
                              ]),
                              content: withCtx(() => [
                                createVNode(unref(ElScrollbar), { "max-height": _ctx.maxCollapseTagsTooltipHeight }, {
                                  default: withCtx(() => [
                                    createElementVNode("div", {
                                      class: normalizeClass(unref(nsCascader).e("collapse-tags"))
                                    }, [
                                      (openBlock(true), createElementBlock(Fragment, null, renderList(allPresentTags.value.slice(_ctx.maxCollapseTags), (tag2, idx) => {
                                        return openBlock(), createElementBlock("div", {
                                          key: idx,
                                          class: normalizeClass(unref(nsCascader).e("collapse-tag"))
                                        }, [
                                          (openBlock(), createBlock(unref(ElTag), {
                                            key: tag2.key,
                                            class: "in-tooltip",
                                            type: _ctx.tagType,
                                            size: unref(tagSize),
                                            effect: _ctx.tagEffect,
                                            hit: tag2.hitState,
                                            closable: tag2.closable,
                                            "disable-transitions": "",
                                            onClose: ($event) => deleteTag(tag2)
                                          }, {
                                            default: withCtx(() => [
                                              createElementVNode("span", null, toDisplayString(tag2.text), 1)
                                            ]),
                                            _: 2
                                          }, 1032, ["type", "size", "effect", "hit", "closable", "onClose"]))
                                        ], 2);
                                      }), 128))
                                    ], 2)
                                  ]),
                                  _: 1
                                }, 8, ["max-height"])
                              ]),
                              _: 2
                            }, 1032, ["disabled", "effect"]))
                          ]),
                          _: 2
                        }, 1032, ["type", "size", "effect", "hit", "closable", "onClose"]);
                      }), 128))
                    ]),
                    _ctx.filterable && !unref(isDisabled) ? withDirectives((openBlock(), createElementBlock("input", {
                      key: 0,
                      "onUpdate:modelValue": ($event) => searchInputValue.value = $event,
                      type: "text",
                      class: normalizeClass(unref(nsCascader).e("search-input")),
                      placeholder: unref(presentText) ? "" : unref(inputPlaceholder),
                      onInput: (e) => handleInput(searchInputValue.value, e),
                      onClick: withModifiers(($event) => togglePopperVisible(true), ["stop"]),
                      onKeydown: withKeys(handleDelete, ["delete"]),
                      onCompositionstart: unref(handleComposition),
                      onCompositionupdate: unref(handleComposition),
                      onCompositionend: unref(handleComposition),
                      onFocus: handleFocus,
                      onBlur: handleBlur
                    }, null, 42, ["onUpdate:modelValue", "placeholder", "onInput", "onClick", "onKeydown", "onCompositionstart", "onCompositionupdate", "onCompositionend"])), [
                      [vModelText, searchInputValue.value]
                    ]) : createCommentVNode("v-if", true)
                  ], 2)) : createCommentVNode("v-if", true)
                ], 46, ["onClick", "onMouseenter", "onMouseleave"])), [
                  [unref(ClickOutside), () => togglePopperVisible(false), unref(contentRef)]
                ])
              ]),
              content: withCtx(() => [
                _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(nsCascader).e("header")),
                  onClick: withModifiers(() => {
                  }, ["stop"])
                }, [
                  renderSlot(_ctx.$slots, "header")
                ], 10, ["onClick"])) : createCommentVNode("v-if", true),
                withDirectives(createVNode(unref(ElCascaderPanel), {
                  ref_key: "cascaderPanelRef",
                  ref: cascaderPanelRef,
                  modelValue: unref(checkedValue),
                  "onUpdate:modelValue": ($event) => isRef(checkedValue) ? checkedValue.value = $event : null,
                  options: _ctx.options,
                  props: props2.props,
                  border: false,
                  "render-label": _ctx.$slots.default,
                  onExpandChange: handleExpandChange,
                  onClose: ($event) => _ctx.$nextTick(() => togglePopperVisible(false))
                }, {
                  empty: withCtx(() => [
                    renderSlot(_ctx.$slots, "empty")
                  ]),
                  _: 3
                }, 8, ["modelValue", "onUpdate:modelValue", "options", "props", "render-label", "onClose"]), [
                  [vShow, !filtering.value]
                ]),
                _ctx.filterable ? withDirectives((openBlock(), createBlock(unref(ElScrollbar), {
                  key: 1,
                  ref_key: "suggestionPanel",
                  ref: suggestionPanel,
                  tag: "ul",
                  class: normalizeClass(unref(nsCascader).e("suggestion-panel")),
                  "view-class": unref(nsCascader).e("suggestion-list"),
                  onKeydown: handleSuggestionKeyDown
                }, {
                  default: withCtx(() => [
                    suggestions.value.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(suggestions.value, (item) => {
                      return openBlock(), createElementBlock("li", {
                        key: item.uid,
                        class: normalizeClass([
                          unref(nsCascader).e("suggestion-item"),
                          unref(nsCascader).is("checked", item.checked)
                        ]),
                        tabindex: -1,
                        onClick: ($event) => handleSuggestionClick(item)
                      }, [
                        renderSlot(_ctx.$slots, "suggestion-item", { item }, () => [
                          createElementVNode("span", null, toDisplayString(item.text), 1),
                          item.checked ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                            default: withCtx(() => [
                              createVNode(unref(check_default$1))
                            ]),
                            _: 1
                          })) : createCommentVNode("v-if", true)
                        ])
                      ], 10, ["onClick"]);
                    }), 128)) : renderSlot(_ctx.$slots, "empty", { key: 1 }, () => [
                      createElementVNode("li", {
                        class: normalizeClass(unref(nsCascader).e("empty-text"))
                      }, toDisplayString(unref(t)("el.cascader.noMatch")), 3)
                    ])
                  ]),
                  _: 3
                }, 8, ["class", "view-class"])), [
                  [vShow, filtering.value]
                ]) : createCommentVNode("v-if", true),
                _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
                  key: 2,
                  class: normalizeClass(unref(nsCascader).e("footer")),
                  onClick: withModifiers(() => {
                  }, ["stop"])
                }, [
                  renderSlot(_ctx.$slots, "footer")
                ], 10, ["onClick"])) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 8, ["visible", "teleported", "popper-class", "fallback-placements", "placement", "transition", "effect", "persistent"]);
          };
        }
      });
      var Cascader = /* @__PURE__ */ _export_sfc(_sfc_main$1S, [["__file", "cascader.vue"]]);
      const ElCascader = exports("ElCascader", withInstall(Cascader));
      const checkTagProps = exports("checkTagProps", buildProps({
        checked: Boolean,
        disabled: Boolean,
        type: {
          type: String,
          values: ["primary", "success", "info", "warning", "danger"],
          default: "primary"
        }
      }));
      const checkTagEmits = exports("checkTagEmits", {
        "update:checked": (value) => isBoolean(value),
        [CHANGE_EVENT]: (value) => isBoolean(value)
      });
      const __default__$1m = defineComponent({
        name: "ElCheckTag"
      });
      const _sfc_main$1R = /* @__PURE__ */ defineComponent({
        ...__default__$1m,
        props: checkTagProps,
        emits: checkTagEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const ns = useNamespace("check-tag");
          const isDisabled = computed(() => props2.disabled);
          const containerKls = computed(() => [
            ns.b(),
            ns.is("checked", props2.checked),
            ns.is("disabled", isDisabled.value),
            ns.m(props2.type || "primary")
          ]);
          const handleChange = () => {
            if (isDisabled.value)
              return;
            const checked = !props2.checked;
            emit(CHANGE_EVENT, checked);
            emit("update:checked", checked);
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              class: normalizeClass(unref(containerKls)),
              onClick: handleChange
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var CheckTag = /* @__PURE__ */ _export_sfc(_sfc_main$1R, [["__file", "check-tag.vue"]]);
      const ElCheckTag = exports("ElCheckTag", withInstall(CheckTag));
      const rowContextKey = exports("rowContextKey", Symbol("rowContextKey"));
      const RowJustify = exports("RowJustify", [
        "start",
        "center",
        "end",
        "space-around",
        "space-between",
        "space-evenly"
      ]);
      const RowAlign = exports("RowAlign", ["top", "middle", "bottom"]);
      const rowProps = exports("rowProps", buildProps({
        tag: {
          type: String,
          default: "div"
        },
        gutter: {
          type: Number,
          default: 0
        },
        justify: {
          type: String,
          values: RowJustify,
          default: "start"
        },
        align: {
          type: String,
          values: RowAlign
        }
      }));
      const __default__$1l = defineComponent({
        name: "ElRow"
      });
      const _sfc_main$1Q = /* @__PURE__ */ defineComponent({
        ...__default__$1l,
        props: rowProps,
        setup(__props) {
          const props2 = __props;
          const ns = useNamespace("row");
          const gutter = computed(() => props2.gutter);
          provide(rowContextKey, {
            gutter
          });
          const style = computed(() => {
            const styles = {};
            if (!props2.gutter) {
              return styles;
            }
            styles.marginRight = styles.marginLeft = `-${props2.gutter / 2}px`;
            return styles;
          });
          const rowKls = computed(() => [
            ns.b(),
            ns.is(`justify-${props2.justify}`, props2.justify !== "start"),
            ns.is(`align-${props2.align}`, !!props2.align)
          ]);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              class: normalizeClass(unref(rowKls)),
              style: normalizeStyle(unref(style))
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["class", "style"]);
          };
        }
      });
      var Row$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1Q, [["__file", "row.vue"]]);
      const ElRow = exports("ElRow", withInstall(Row$1));
      const colProps = exports("colProps", buildProps({
        tag: {
          type: String,
          default: "div"
        },
        span: {
          type: Number,
          default: 24
        },
        offset: {
          type: Number,
          default: 0
        },
        pull: {
          type: Number,
          default: 0
        },
        push: {
          type: Number,
          default: 0
        },
        xs: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        },
        sm: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        },
        md: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        },
        lg: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        },
        xl: {
          type: definePropType([Number, Object]),
          default: () => mutable({})
        }
      }));
      const __default__$1k = defineComponent({
        name: "ElCol"
      });
      const _sfc_main$1P = /* @__PURE__ */ defineComponent({
        ...__default__$1k,
        props: colProps,
        setup(__props) {
          const props2 = __props;
          const { gutter } = inject(rowContextKey, { gutter: computed(() => 0) });
          const ns = useNamespace("col");
          const style = computed(() => {
            const styles = {};
            if (gutter.value) {
              styles.paddingLeft = styles.paddingRight = `${gutter.value / 2}px`;
            }
            return styles;
          });
          const colKls = computed(() => {
            const classes = [];
            const pos = ["span", "offset", "pull", "push"];
            pos.forEach((prop) => {
              const size = props2[prop];
              if (isNumber(size)) {
                if (prop === "span")
                  classes.push(ns.b(`${props2[prop]}`));
                else if (size > 0)
                  classes.push(ns.b(`${prop}-${props2[prop]}`));
              }
            });
            const sizes = ["xs", "sm", "md", "lg", "xl"];
            sizes.forEach((size) => {
              if (isNumber(props2[size])) {
                classes.push(ns.b(`${size}-${props2[size]}`));
              } else if (isObject$1(props2[size])) {
                Object.entries(props2[size]).forEach(([prop, sizeProp]) => {
                  classes.push(prop !== "span" ? ns.b(`${size}-${prop}-${sizeProp}`) : ns.b(`${size}-${sizeProp}`));
                });
              }
            });
            if (gutter.value) {
              classes.push(ns.is("guttered"));
            }
            return [ns.b(), classes];
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              class: normalizeClass(unref(colKls)),
              style: normalizeStyle(unref(style))
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["class", "style"]);
          };
        }
      });
      var Col = /* @__PURE__ */ _export_sfc(_sfc_main$1P, [["__file", "col.vue"]]);
      const ElCol = exports("ElCol", withInstall(Col));
      const emitChangeFn = exports("emitChangeFn", (value) => isNumber(value) || isString$1(value) || isArray$1(value));
      const collapseProps = exports("collapseProps", buildProps({
        accordion: Boolean,
        modelValue: {
          type: definePropType([Array, String, Number]),
          default: () => mutable([])
        },
        expandIconPosition: {
          type: definePropType([String]),
          default: "right"
        },
        beforeCollapse: {
          type: definePropType(Function)
        }
      }));
      const collapseEmits = exports("collapseEmits", {
        [UPDATE_MODEL_EVENT]: emitChangeFn,
        [CHANGE_EVENT]: emitChangeFn
      });
      const collapseContextKey = exports("collapseContextKey", Symbol("collapseContextKey"));
      const SCOPE$3 = "ElCollapse";
      const useCollapse = (props2, emit) => {
        const activeNames = ref(castArray$1(props2.modelValue));
        const setActiveNames = (_activeNames) => {
          activeNames.value = _activeNames;
          const value = props2.accordion ? activeNames.value[0] : activeNames.value;
          emit(UPDATE_MODEL_EVENT, value);
          emit(CHANGE_EVENT, value);
        };
        const handleChange = (name) => {
          if (props2.accordion) {
            setActiveNames([activeNames.value[0] === name ? "" : name]);
          } else {
            const _activeNames = [...activeNames.value];
            const index2 = _activeNames.indexOf(name);
            if (index2 > -1) {
              _activeNames.splice(index2, 1);
            } else {
              _activeNames.push(name);
            }
            setActiveNames(_activeNames);
          }
        };
        const handleItemClick = async (name) => {
          const { beforeCollapse } = props2;
          if (!beforeCollapse) {
            handleChange(name);
            return;
          }
          const shouldChange = beforeCollapse(name);
          const isPromiseOrBool = [
            isPromise(shouldChange),
            isBoolean(shouldChange)
          ].includes(true);
          if (!isPromiseOrBool) {
            throwError(SCOPE$3, "beforeCollapse must return type `Promise<boolean>` or `boolean`");
          }
          if (isPromise(shouldChange)) {
            shouldChange.then((result2) => {
              if (result2 !== false) {
                handleChange(name);
              }
            }).catch((e) => {
            });
          } else if (shouldChange) {
            handleChange(name);
          }
        };
        watch(() => props2.modelValue, () => activeNames.value = castArray$1(props2.modelValue), { deep: true });
        provide(collapseContextKey, {
          activeNames,
          handleItemClick
        });
        return {
          activeNames,
          setActiveNames
        };
      };
      const useCollapseDOM = (props2) => {
        const ns = useNamespace("collapse");
        const rootKls = computed(() => [
          ns.b(),
          ns.b(`icon-position-${props2.expandIconPosition}`)
        ]);
        return {
          rootKls
        };
      };
      const __default__$1j = defineComponent({
        name: "ElCollapse"
      });
      const _sfc_main$1O = /* @__PURE__ */ defineComponent({
        ...__default__$1j,
        props: collapseProps,
        emits: collapseEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const { activeNames, setActiveNames } = useCollapse(props2, emit);
          const { rootKls } = useCollapseDOM(props2);
          expose({
            activeNames,
            setActiveNames
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(rootKls))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Collapse = /* @__PURE__ */ _export_sfc(_sfc_main$1O, [["__file", "collapse.vue"]]);
      const __default__$1i = defineComponent({
        name: "ElCollapseTransition"
      });
      const _sfc_main$1N = /* @__PURE__ */ defineComponent({
        ...__default__$1i,
        setup(__props) {
          const ns = useNamespace("collapse-transition");
          const reset = (el) => {
            el.style.maxHeight = "";
            el.style.overflow = el.dataset.oldOverflow;
            el.style.paddingTop = el.dataset.oldPaddingTop;
            el.style.paddingBottom = el.dataset.oldPaddingBottom;
          };
          const on2 = {
            beforeEnter(el) {
              if (!el.dataset)
                el.dataset = {};
              el.dataset.oldPaddingTop = el.style.paddingTop;
              el.dataset.oldPaddingBottom = el.style.paddingBottom;
              if (el.style.height)
                el.dataset.elExistsHeight = el.style.height;
              el.style.maxHeight = 0;
              el.style.paddingTop = 0;
              el.style.paddingBottom = 0;
            },
            enter(el) {
              requestAnimationFrame(() => {
                el.dataset.oldOverflow = el.style.overflow;
                if (el.dataset.elExistsHeight) {
                  el.style.maxHeight = el.dataset.elExistsHeight;
                } else if (el.scrollHeight !== 0) {
                  el.style.maxHeight = `${el.scrollHeight}px`;
                } else {
                  el.style.maxHeight = 0;
                }
                el.style.paddingTop = el.dataset.oldPaddingTop;
                el.style.paddingBottom = el.dataset.oldPaddingBottom;
                el.style.overflow = "hidden";
              });
            },
            afterEnter(el) {
              el.style.maxHeight = "";
              el.style.overflow = el.dataset.oldOverflow;
            },
            enterCancelled(el) {
              reset(el);
            },
            beforeLeave(el) {
              if (!el.dataset)
                el.dataset = {};
              el.dataset.oldPaddingTop = el.style.paddingTop;
              el.dataset.oldPaddingBottom = el.style.paddingBottom;
              el.dataset.oldOverflow = el.style.overflow;
              el.style.maxHeight = `${el.scrollHeight}px`;
              el.style.overflow = "hidden";
            },
            leave(el) {
              if (el.scrollHeight !== 0) {
                el.style.maxHeight = 0;
                el.style.paddingTop = 0;
                el.style.paddingBottom = 0;
              }
            },
            afterLeave(el) {
              reset(el);
            },
            leaveCancelled(el) {
              reset(el);
            }
          };
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, mergeProps({
              name: unref(ns).b()
            }, toHandlers(on2)), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, ["name"]);
          };
        }
      });
      var CollapseTransition = /* @__PURE__ */ _export_sfc(_sfc_main$1N, [["__file", "collapse-transition.vue"]]);
      const ElCollapseTransition = exports("ElCollapseTransition", withInstall(CollapseTransition));
      const collapseItemProps = exports("collapseItemProps", buildProps({
        title: {
          type: String,
          default: ""
        },
        name: {
          type: definePropType([String, Number]),
          default: void 0
        },
        icon: {
          type: iconPropType,
          default: arrow_right_default$1
        },
        disabled: Boolean
      }));
      const useCollapseItem = (props2) => {
        const collapse = inject(collapseContextKey);
        const { namespace } = useNamespace("collapse");
        const focusing = ref(false);
        const isClick = ref(false);
        const idInjection = useIdInjection();
        const id = computed(() => idInjection.current++);
        const name = computed(() => {
          var _a;
          return (_a = props2.name) != null ? _a : `${namespace.value}-id-${idInjection.prefix}-${unref(id)}`;
        });
        const isActive = computed(() => collapse == null ? void 0 : collapse.activeNames.value.includes(unref(name)));
        const handleFocus = () => {
          setTimeout(() => {
            if (!isClick.value) {
              focusing.value = true;
            } else {
              isClick.value = false;
            }
          }, 50);
        };
        const handleHeaderClick = (e) => {
          if (props2.disabled)
            return;
          const target2 = e.target;
          if (target2 == null ? void 0 : target2.closest("input, textarea, select"))
            return;
          collapse == null ? void 0 : collapse.handleItemClick(unref(name));
          focusing.value = false;
          isClick.value = true;
        };
        const handleEnterClick = (e) => {
          const target2 = e.target;
          if (target2 == null ? void 0 : target2.closest("input, textarea, select"))
            return;
          e.preventDefault();
          collapse == null ? void 0 : collapse.handleItemClick(unref(name));
        };
        return {
          focusing,
          id,
          isActive,
          handleFocus,
          handleHeaderClick,
          handleEnterClick
        };
      };
      const useCollapseItemDOM = (props2, { focusing, isActive, id }) => {
        const ns = useNamespace("collapse");
        const rootKls = computed(() => [
          ns.b("item"),
          ns.is("active", unref(isActive)),
          ns.is("disabled", props2.disabled)
        ]);
        const headKls = computed(() => [
          ns.be("item", "header"),
          ns.is("active", unref(isActive)),
          { focusing: unref(focusing) && !props2.disabled }
        ]);
        const arrowKls = computed(() => [
          ns.be("item", "arrow"),
          ns.is("active", unref(isActive))
        ]);
        const itemTitleKls = computed(() => [ns.be("item", "title")]);
        const itemWrapperKls = computed(() => ns.be("item", "wrap"));
        const itemContentKls = computed(() => ns.be("item", "content"));
        const scopedContentId = computed(() => ns.b(`content-${unref(id)}`));
        const scopedHeadId = computed(() => ns.b(`head-${unref(id)}`));
        return {
          itemTitleKls,
          arrowKls,
          headKls,
          rootKls,
          itemWrapperKls,
          itemContentKls,
          scopedContentId,
          scopedHeadId
        };
      };
      const __default__$1h = defineComponent({
        name: "ElCollapseItem"
      });
      const _sfc_main$1M = /* @__PURE__ */ defineComponent({
        ...__default__$1h,
        props: collapseItemProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const {
            focusing,
            id,
            isActive,
            handleFocus,
            handleHeaderClick,
            handleEnterClick
          } = useCollapseItem(props2);
          const {
            arrowKls,
            headKls,
            rootKls,
            itemTitleKls,
            itemWrapperKls,
            itemContentKls,
            scopedContentId,
            scopedHeadId
          } = useCollapseItemDOM(props2, { focusing, isActive, id });
          expose({
            isActive
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(rootKls))
            }, [
              createElementVNode("div", {
                id: unref(scopedHeadId),
                class: normalizeClass(unref(headKls)),
                "aria-expanded": unref(isActive),
                "aria-controls": unref(scopedContentId),
                "aria-describedby": unref(scopedContentId),
                tabindex: _ctx.disabled ? -1 : 0,
                role: "button",
                onClick: unref(handleHeaderClick),
                onKeydown: withKeys(withModifiers(unref(handleEnterClick), ["stop"]), ["space", "enter"]),
                onFocus: unref(handleFocus),
                onBlur: ($event) => focusing.value = false
              }, [
                createElementVNode("span", {
                  class: normalizeClass(unref(itemTitleKls))
                }, [
                  renderSlot(_ctx.$slots, "title", { isActive: unref(isActive) }, () => [
                    createTextVNode(toDisplayString(_ctx.title), 1)
                  ])
                ], 2),
                renderSlot(_ctx.$slots, "icon", { isActive: unref(isActive) }, () => [
                  createVNode(unref(ElIcon), {
                    class: normalizeClass(unref(arrowKls))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ])
              ], 42, ["id", "aria-expanded", "aria-controls", "aria-describedby", "tabindex", "onClick", "onKeydown", "onFocus", "onBlur"]),
              createVNode(unref(ElCollapseTransition), null, {
                default: withCtx(() => [
                  withDirectives(createElementVNode("div", {
                    id: unref(scopedContentId),
                    role: "region",
                    class: normalizeClass(unref(itemWrapperKls)),
                    "aria-hidden": !unref(isActive),
                    "aria-labelledby": unref(scopedHeadId)
                  }, [
                    createElementVNode("div", {
                      class: normalizeClass(unref(itemContentKls))
                    }, [
                      renderSlot(_ctx.$slots, "default")
                    ], 2)
                  ], 10, ["id", "aria-hidden", "aria-labelledby"]), [
                    [vShow, unref(isActive)]
                  ])
                ]),
                _: 3
              })
            ], 2);
          };
        }
      });
      var CollapseItem = /* @__PURE__ */ _export_sfc(_sfc_main$1M, [["__file", "collapse-item.vue"]]);
      const ElCollapse = exports("ElCollapse", withInstall(Collapse, {
        CollapseItem
      }));
      const ElCollapseItem = exports("ElCollapseItem", withNoopInstall(CollapseItem));
      const alphaSliderProps = buildProps({
        color: {
          type: definePropType(Object),
          required: true
        },
        vertical: Boolean
      });
      let isDragging = false;
      function draggable(element, options) {
        if (!isClient)
          return;
        const moveFn = function(event) {
          var _a;
          (_a = options.drag) == null ? void 0 : _a.call(options, event);
        };
        const upFn = function(event) {
          var _a;
          document.removeEventListener("mousemove", moveFn);
          document.removeEventListener("mouseup", upFn);
          document.removeEventListener("touchmove", moveFn);
          document.removeEventListener("touchend", upFn);
          document.onselectstart = null;
          document.ondragstart = null;
          isDragging = false;
          (_a = options.end) == null ? void 0 : _a.call(options, event);
        };
        const downFn = function(event) {
          var _a;
          if (isDragging)
            return;
          event.preventDefault();
          document.onselectstart = () => false;
          document.ondragstart = () => false;
          document.addEventListener("mousemove", moveFn);
          document.addEventListener("mouseup", upFn);
          document.addEventListener("touchmove", moveFn);
          document.addEventListener("touchend", upFn);
          isDragging = true;
          (_a = options.start) == null ? void 0 : _a.call(options, event);
        };
        element.addEventListener("mousedown", downFn);
        element.addEventListener("touchstart", downFn, { passive: false });
      }
      const useAlphaSlider = (props2) => {
        const instance = getCurrentInstance();
        const { t } = useLocale();
        const thumb = shallowRef();
        const bar = shallowRef();
        const alpha = computed(() => props2.color.get("alpha"));
        const alphaLabel = computed(() => t("el.colorpicker.alphaLabel"));
        function handleClick(event) {
          var _a;
          const target2 = event.target;
          if (target2 !== thumb.value) {
            handleDrag(event);
          }
          (_a = thumb.value) == null ? void 0 : _a.focus();
        }
        function handleDrag(event) {
          if (!bar.value || !thumb.value)
            return;
          const el = instance.vnode.el;
          const rect = el.getBoundingClientRect();
          const { clientX, clientY } = getClientXY(event);
          if (!props2.vertical) {
            let left = clientX - rect.left;
            left = Math.max(thumb.value.offsetWidth / 2, left);
            left = Math.min(left, rect.width - thumb.value.offsetWidth / 2);
            props2.color.set("alpha", Math.round((left - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 100));
          } else {
            let top = clientY - rect.top;
            top = Math.max(thumb.value.offsetHeight / 2, top);
            top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);
            props2.color.set("alpha", Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 100));
          }
        }
        function handleKeydown(event) {
          const { code, shiftKey } = event;
          const step2 = shiftKey ? 10 : 1;
          switch (code) {
            case EVENT_CODE.left:
            case EVENT_CODE.down:
              event.preventDefault();
              event.stopPropagation();
              incrementPosition(-step2);
              break;
            case EVENT_CODE.right:
            case EVENT_CODE.up:
              event.preventDefault();
              event.stopPropagation();
              incrementPosition(step2);
              break;
          }
        }
        function incrementPosition(step2) {
          let next = alpha.value + step2;
          next = next < 0 ? 0 : next > 100 ? 100 : next;
          props2.color.set("alpha", next);
        }
        return {
          thumb,
          bar,
          alpha,
          alphaLabel,
          handleDrag,
          handleClick,
          handleKeydown
        };
      };
      const useAlphaSliderDOM = (props2, {
        bar,
        thumb,
        handleDrag
      }) => {
        const instance = getCurrentInstance();
        const ns = useNamespace("color-alpha-slider");
        const thumbLeft = ref(0);
        const thumbTop = ref(0);
        const background = ref();
        function getThumbLeft() {
          if (!thumb.value)
            return 0;
          if (props2.vertical)
            return 0;
          const el = instance.vnode.el;
          const alpha = props2.color.get("alpha");
          if (!el)
            return 0;
          return Math.round(alpha * (el.offsetWidth - thumb.value.offsetWidth / 2) / 100);
        }
        function getThumbTop() {
          if (!thumb.value)
            return 0;
          const el = instance.vnode.el;
          if (!props2.vertical)
            return 0;
          const alpha = props2.color.get("alpha");
          if (!el)
            return 0;
          return Math.round(alpha * (el.offsetHeight - thumb.value.offsetHeight / 2) / 100);
        }
        function getBackground() {
          if (props2.color && props2.color.value) {
            const { r, g, b: b2 } = props2.color.toRgb();
            return `linear-gradient(to right, rgba(${r}, ${g}, ${b2}, 0) 0%, rgba(${r}, ${g}, ${b2}, 1) 100%)`;
          }
          return "";
        }
        function update2() {
          thumbLeft.value = getThumbLeft();
          thumbTop.value = getThumbTop();
          background.value = getBackground();
        }
        onMounted(() => {
          if (!bar.value || !thumb.value)
            return;
          const dragConfig = {
            drag: (event) => {
              handleDrag(event);
            },
            end: (event) => {
              handleDrag(event);
            }
          };
          draggable(bar.value, dragConfig);
          draggable(thumb.value, dragConfig);
          update2();
        });
        watch(() => props2.color.get("alpha"), () => update2());
        watch(() => props2.color.value, () => update2());
        const rootKls = computed(() => [ns.b(), ns.is("vertical", props2.vertical)]);
        const barKls = computed(() => ns.e("bar"));
        const thumbKls = computed(() => ns.e("thumb"));
        const barStyle = computed(() => ({ background: background.value }));
        const thumbStyle = computed(() => ({
          left: addUnit(thumbLeft.value),
          top: addUnit(thumbTop.value)
        }));
        return { rootKls, barKls, barStyle, thumbKls, thumbStyle, update: update2 };
      };
      const COMPONENT_NAME$f = "ElColorAlphaSlider";
      const __default__$1g = defineComponent({
        name: COMPONENT_NAME$f
      });
      const _sfc_main$1L = /* @__PURE__ */ defineComponent({
        ...__default__$1g,
        props: alphaSliderProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const {
            alpha,
            alphaLabel,
            bar,
            thumb,
            handleDrag,
            handleClick,
            handleKeydown
          } = useAlphaSlider(props2);
          const { rootKls, barKls, barStyle, thumbKls, thumbStyle, update: update2 } = useAlphaSliderDOM(props2, {
            bar,
            thumb,
            handleDrag
          });
          expose({
            update: update2,
            bar,
            thumb
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(rootKls))
            }, [
              createElementVNode("div", {
                ref_key: "bar",
                ref: bar,
                class: normalizeClass(unref(barKls)),
                style: normalizeStyle(unref(barStyle)),
                onClick: unref(handleClick)
              }, null, 14, ["onClick"]),
              createElementVNode("div", {
                ref_key: "thumb",
                ref: thumb,
                class: normalizeClass(unref(thumbKls)),
                style: normalizeStyle(unref(thumbStyle)),
                "aria-label": unref(alphaLabel),
                "aria-valuenow": unref(alpha),
                "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
                "aria-valuemin": "0",
                "aria-valuemax": "100",
                role: "slider",
                tabindex: "0",
                onKeydown: unref(handleKeydown)
              }, null, 46, ["aria-label", "aria-valuenow", "aria-orientation", "onKeydown"])
            ], 2);
          };
        }
      });
      var AlphaSlider = /* @__PURE__ */ _export_sfc(_sfc_main$1L, [["__file", "alpha-slider.vue"]]);
      const _sfc_main$1K = defineComponent({
        name: "ElColorHueSlider",
        props: {
          color: {
            type: Object,
            required: true
          },
          vertical: Boolean
        },
        setup(props2) {
          const ns = useNamespace("color-hue-slider");
          const instance = getCurrentInstance();
          const thumb = ref();
          const bar = ref();
          const thumbLeft = ref(0);
          const thumbTop = ref(0);
          const hueValue = computed(() => {
            return props2.color.get("hue");
          });
          watch(() => hueValue.value, () => {
            update2();
          });
          function handleClick(event) {
            const target2 = event.target;
            if (target2 !== thumb.value) {
              handleDrag(event);
            }
          }
          function handleDrag(event) {
            if (!bar.value || !thumb.value)
              return;
            const el = instance.vnode.el;
            const rect = el.getBoundingClientRect();
            const { clientX, clientY } = getClientXY(event);
            let hue;
            if (!props2.vertical) {
              let left = clientX - rect.left;
              left = Math.min(left, rect.width - thumb.value.offsetWidth / 2);
              left = Math.max(thumb.value.offsetWidth / 2, left);
              hue = Math.round((left - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 360);
            } else {
              let top = clientY - rect.top;
              top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);
              top = Math.max(thumb.value.offsetHeight / 2, top);
              hue = Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 360);
            }
            props2.color.set("hue", hue);
          }
          function getThumbLeft() {
            if (!thumb.value)
              return 0;
            const el = instance.vnode.el;
            if (props2.vertical)
              return 0;
            const hue = props2.color.get("hue");
            if (!el)
              return 0;
            return Math.round(hue * (el.offsetWidth - thumb.value.offsetWidth / 2) / 360);
          }
          function getThumbTop() {
            if (!thumb.value)
              return 0;
            const el = instance.vnode.el;
            if (!props2.vertical)
              return 0;
            const hue = props2.color.get("hue");
            if (!el)
              return 0;
            return Math.round(hue * (el.offsetHeight - thumb.value.offsetHeight / 2) / 360);
          }
          function update2() {
            thumbLeft.value = getThumbLeft();
            thumbTop.value = getThumbTop();
          }
          onMounted(() => {
            if (!bar.value || !thumb.value)
              return;
            const dragConfig = {
              drag: (event) => {
                handleDrag(event);
              },
              end: (event) => {
                handleDrag(event);
              }
            };
            draggable(bar.value, dragConfig);
            draggable(thumb.value, dragConfig);
            update2();
          });
          return {
            bar,
            thumb,
            thumbLeft,
            thumbTop,
            hueValue,
            handleClick,
            update: update2,
            ns
          };
        }
      });
      function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass([_ctx.ns.b(), _ctx.ns.is("vertical", _ctx.vertical)])
        }, [
          createElementVNode("div", {
            ref: "bar",
            class: normalizeClass(_ctx.ns.e("bar")),
            onClick: _ctx.handleClick
          }, null, 10, ["onClick"]),
          createElementVNode("div", {
            ref: "thumb",
            class: normalizeClass(_ctx.ns.e("thumb")),
            style: normalizeStyle({
              left: _ctx.thumbLeft + "px",
              top: _ctx.thumbTop + "px"
            })
          }, null, 6)
        ], 2);
      }
      var HueSlider = /* @__PURE__ */ _export_sfc(_sfc_main$1K, [["render", _sfc_render$n], ["__file", "hue-slider.vue"]]);
      const colorPickerProps = exports("colorPickerProps", buildProps({
        persistent: {
          type: Boolean,
          default: true
        },
        modelValue: {
          type: definePropType(String),
          default: void 0
        },
        id: String,
        showAlpha: Boolean,
        colorFormat: String,
        disabled: Boolean,
        size: useSizeProp,
        popperClass: {
          type: String,
          default: ""
        },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        teleported: useTooltipContentProps.teleported,
        appendTo: useTooltipContentProps.appendTo,
        predefine: {
          type: definePropType(Array)
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        ...useEmptyValuesProps,
        ...useAriaProps(["ariaLabel"])
      }));
      const colorPickerEmits = exports("colorPickerEmits", {
        [UPDATE_MODEL_EVENT]: (val) => isString$1(val) || isNil(val),
        [CHANGE_EVENT]: (val) => isString$1(val) || isNil(val),
        activeChange: (val) => isString$1(val) || isNil(val),
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent
      });
      const colorPickerContextKey = exports("colorPickerContextKey", Symbol("colorPickerContextKey"));
      class Color {
        constructor(options = {}) {
          this._hue = 0;
          this._saturation = 100;
          this._value = 100;
          this._alpha = 100;
          this._tiny = new TinyColor();
          this._isValid = false;
          this.enableAlpha = false;
          this.format = "";
          this.value = "";
          for (const option in options) {
            if (hasOwn(options, option)) {
              this[option] = options[option];
            }
          }
          if (options.value) {
            this.fromString(options.value);
          } else {
            this.doOnChange();
          }
        }
        set(prop, value) {
          if (arguments.length === 1 && typeof prop === "object") {
            for (const p2 in prop) {
              if (hasOwn(prop, p2)) {
                this.set(p2, prop[p2]);
              }
            }
            return;
          }
          this[`_${prop}`] = value;
          this._isValid = true;
          this.doOnChange();
        }
        get(prop) {
          if (["hue", "saturation", "value", "alpha"].includes(prop)) {
            return Math.round(this[`_${prop}`]);
          }
          return this[`_${prop}`];
        }
        toRgb() {
          return this._isValid ? this._tiny.toRgb() : { r: 255, g: 255, b: 255, a: 0 };
        }
        fromString(value) {
          const color = new TinyColor(value);
          this._isValid = color.isValid;
          if (color.isValid) {
            const { h: h2, s: s2, v: v2, a: a2 } = color.toHsv();
            this._hue = h2;
            this._saturation = s2 * 100;
            this._value = v2 * 100;
            this._alpha = a2 * 100;
          } else {
            this._hue = 0;
            this._saturation = 100;
            this._value = 100;
            this._alpha = 100;
          }
          this.doOnChange();
        }
        compare(color) {
          const compareColor = new TinyColor({
            h: color._hue,
            s: color._saturation / 100,
            v: color._value / 100,
            a: color._alpha / 100
          });
          return this._tiny.equals(compareColor);
        }
        doOnChange() {
          const { _hue, _saturation, _value, _alpha, format: format2, enableAlpha } = this;
          let _format = format2 || (enableAlpha ? "rgb" : "hex");
          if (format2 === "hex" && enableAlpha) {
            _format = "hex8";
          }
          this._tiny = new TinyColor({
            h: _hue,
            s: _saturation / 100,
            v: _value / 100,
            a: _alpha / 100
          });
          this.value = this._isValid ? this._tiny.toString(_format) : "";
        }
      }
      const _sfc_main$1J = defineComponent({
        props: {
          colors: {
            type: Array,
            required: true
          },
          color: {
            type: Object,
            required: true
          },
          enableAlpha: {
            type: Boolean,
            required: true
          }
        },
        setup(props2) {
          const ns = useNamespace("color-predefine");
          const { currentColor } = inject(colorPickerContextKey);
          const rgbaColors = ref(parseColors(props2.colors, props2.color));
          watch(() => currentColor.value, (val) => {
            const color = new Color({
              value: val
            });
            rgbaColors.value.forEach((item) => {
              item.selected = color.compare(item);
            });
          });
          watchEffect(() => {
            rgbaColors.value = parseColors(props2.colors, props2.color);
          });
          function handleSelect(index2) {
            props2.color.fromString(props2.colors[index2]);
          }
          function parseColors(colors, color) {
            return colors.map((value) => {
              const c2 = new Color({
                value
              });
              c2.selected = c2.compare(color);
              return c2;
            });
          }
          return {
            rgbaColors,
            handleSelect,
            ns
          };
        }
      });
      function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(_ctx.ns.b())
        }, [
          createElementVNode("div", {
            class: normalizeClass(_ctx.ns.e("colors"))
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rgbaColors, (item, index2) => {
              return openBlock(), createElementBlock("div", {
                key: _ctx.colors[index2],
                class: normalizeClass([
                  _ctx.ns.e("color-selector"),
                  _ctx.ns.is("alpha", item.get("alpha") < 100),
                  { selected: item.selected }
                ]),
                onClick: ($event) => _ctx.handleSelect(index2)
              }, [
                createElementVNode("div", {
                  style: normalizeStyle({ backgroundColor: item.value })
                }, null, 4)
              ], 10, ["onClick"]);
            }), 128))
          ], 2)
        ], 2);
      }
      var Predefine = /* @__PURE__ */ _export_sfc(_sfc_main$1J, [["render", _sfc_render$m], ["__file", "predefine.vue"]]);
      const _sfc_main$1I = defineComponent({
        name: "ElSlPanel",
        props: {
          color: {
            type: Object,
            required: true
          }
        },
        setup(props2) {
          const ns = useNamespace("color-svpanel");
          const instance = getCurrentInstance();
          const cursorTop = ref(0);
          const cursorLeft = ref(0);
          const background = ref("hsl(0, 100%, 50%)");
          const colorValue = computed(() => {
            const hue = props2.color.get("hue");
            const value = props2.color.get("value");
            return { hue, value };
          });
          function update2() {
            const saturation = props2.color.get("saturation");
            const value = props2.color.get("value");
            const el = instance.vnode.el;
            const { clientWidth: width, clientHeight: height } = el;
            cursorLeft.value = saturation * width / 100;
            cursorTop.value = (100 - value) * height / 100;
            background.value = `hsl(${props2.color.get("hue")}, 100%, 50%)`;
          }
          function handleDrag(event) {
            const el = instance.vnode.el;
            const rect = el.getBoundingClientRect();
            const { clientX, clientY } = getClientXY(event);
            let left = clientX - rect.left;
            let top = clientY - rect.top;
            left = Math.max(0, left);
            left = Math.min(left, rect.width);
            top = Math.max(0, top);
            top = Math.min(top, rect.height);
            cursorLeft.value = left;
            cursorTop.value = top;
            props2.color.set({
              saturation: left / rect.width * 100,
              value: 100 - top / rect.height * 100
            });
          }
          watch(() => colorValue.value, () => {
            update2();
          });
          onMounted(() => {
            draggable(instance.vnode.el, {
              drag: (event) => {
                handleDrag(event);
              },
              end: (event) => {
                handleDrag(event);
              }
            });
            update2();
          });
          return {
            cursorTop,
            cursorLeft,
            background,
            colorValue,
            handleDrag,
            update: update2,
            ns
          };
        }
      });
      function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(_ctx.ns.b()),
          style: normalizeStyle({
            backgroundColor: _ctx.background
          })
        }, [
          createElementVNode("div", {
            class: normalizeClass(_ctx.ns.e("white"))
          }, null, 2),
          createElementVNode("div", {
            class: normalizeClass(_ctx.ns.e("black"))
          }, null, 2),
          createElementVNode("div", {
            class: normalizeClass(_ctx.ns.e("cursor")),
            style: normalizeStyle({
              top: _ctx.cursorTop + "px",
              left: _ctx.cursorLeft + "px"
            })
          }, [
            createElementVNode("div")
          ], 6)
        ], 6);
      }
      var SvPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1I, [["render", _sfc_render$l], ["__file", "sv-panel.vue"]]);
      const __default__$1f = defineComponent({
        name: "ElColorPicker"
      });
      const _sfc_main$1H = /* @__PURE__ */ defineComponent({
        ...__default__$1f,
        props: colorPickerProps,
        emits: colorPickerEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const { t } = useLocale();
          const ns = useNamespace("color");
          const { formItem } = useFormItem();
          const colorSize = useFormSize();
          const colorDisabled = useFormDisabled();
          const { valueOnClear, isEmptyValue: isEmptyValue2 } = useEmptyValues(props2, null);
          const { inputId: buttonId, isLabeledByFormItem } = useFormItemInputId(props2, {
            formItemContext: formItem
          });
          const hue = ref();
          const sv = ref();
          const alpha = ref();
          const popper = ref();
          const triggerRef2 = ref();
          const inputRef = ref();
          const { isFocused, handleFocus, handleBlur } = useFocusController(triggerRef2, {
            disabled: colorDisabled,
            beforeBlur(event) {
              var _a;
              return (_a = popper.value) == null ? void 0 : _a.isFocusInsideContent(event);
            },
            afterBlur() {
              setShowPicker(false);
              resetColor();
            }
          });
          let shouldActiveChange = true;
          const color = reactive(new Color({
            enableAlpha: props2.showAlpha,
            format: props2.colorFormat || "",
            value: props2.modelValue
          }));
          const showPicker = ref(false);
          const showPanelColor = ref(false);
          const customInput = ref("");
          const displayedColor = computed(() => {
            if (!props2.modelValue && !showPanelColor.value) {
              return "transparent";
            }
            return displayedRgb(color, props2.showAlpha);
          });
          const currentColor = computed(() => {
            return !props2.modelValue && !showPanelColor.value ? "" : color.value;
          });
          const buttonAriaLabel = computed(() => {
            return !isLabeledByFormItem.value ? props2.ariaLabel || t("el.colorpicker.defaultLabel") : void 0;
          });
          const buttonAriaLabelledby = computed(() => {
            return isLabeledByFormItem.value ? formItem == null ? void 0 : formItem.labelId : void 0;
          });
          const btnKls = computed(() => {
            return [
              ns.b("picker"),
              ns.is("disabled", colorDisabled.value),
              ns.bm("picker", colorSize.value),
              ns.is("focused", isFocused.value)
            ];
          });
          function displayedRgb(color2, showAlpha) {
            const { r, g, b: b2, a: a2 } = color2.toRgb();
            return showAlpha ? `rgba(${r}, ${g}, ${b2}, ${a2})` : `rgb(${r}, ${g}, ${b2})`;
          }
          function setShowPicker(value) {
            showPicker.value = value;
          }
          const debounceSetShowPicker = debounce(setShowPicker, 100, { leading: true });
          function show() {
            if (colorDisabled.value)
              return;
            setShowPicker(true);
          }
          function hide() {
            debounceSetShowPicker(false);
            resetColor();
          }
          function resetColor() {
            nextTick(() => {
              if (props2.modelValue) {
                color.fromString(props2.modelValue);
              } else {
                color.value = "";
                if (!currentColor.value && customInput.value) {
                  customInput.value = "";
                }
                nextTick(() => {
                  showPanelColor.value = false;
                });
              }
            });
          }
          function handleTrigger() {
            if (colorDisabled.value)
              return;
            if (showPicker.value) {
              resetColor();
            }
            debounceSetShowPicker(!showPicker.value);
          }
          function handleConfirm() {
            color.fromString(customInput.value);
            if (color.value !== customInput.value) {
              customInput.value = color.value;
            }
          }
          function confirmValue() {
            const value = isEmptyValue2(color.value) ? valueOnClear.value : color.value;
            emit(UPDATE_MODEL_EVENT, value);
            emit(CHANGE_EVENT, value);
            if (props2.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
            }
            debounceSetShowPicker(false);
            nextTick(() => {
              const newColor = new Color({
                enableAlpha: props2.showAlpha,
                format: props2.colorFormat || "",
                value: props2.modelValue
              });
              if (!color.compare(newColor)) {
                resetColor();
              }
            });
          }
          function clear() {
            debounceSetShowPicker(false);
            emit(UPDATE_MODEL_EVENT, valueOnClear.value);
            emit(CHANGE_EVENT, valueOnClear.value);
            if (props2.modelValue !== valueOnClear.value && props2.validateEvent) {
              formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
            }
            resetColor();
          }
          function handleClickOutside() {
            if (!showPicker.value)
              return;
            hide();
            isFocused.value && focus();
          }
          function handleEsc(event) {
            event.preventDefault();
            event.stopPropagation();
            setShowPicker(false);
            resetColor();
          }
          function handleKeyDown(event) {
            switch (event.code) {
              case EVENT_CODE.enter:
              case EVENT_CODE.numpadEnter:
              case EVENT_CODE.space:
                event.preventDefault();
                event.stopPropagation();
                show();
                inputRef.value.focus();
                break;
              case EVENT_CODE.esc:
                handleEsc(event);
                break;
            }
          }
          function focus() {
            triggerRef2.value.focus();
          }
          function blur() {
            triggerRef2.value.blur();
          }
          onMounted(() => {
            if (props2.modelValue) {
              customInput.value = currentColor.value;
            }
          });
          watch(() => props2.modelValue, (newVal) => {
            if (!newVal) {
              showPanelColor.value = false;
            } else if (newVal && newVal !== color.value) {
              shouldActiveChange = false;
              color.fromString(newVal);
            }
          });
          watch(() => [props2.colorFormat, props2.showAlpha], () => {
            color.enableAlpha = props2.showAlpha;
            color.format = props2.colorFormat || color.format;
            color.doOnChange();
            emit(UPDATE_MODEL_EVENT, color.value);
          });
          watch(() => currentColor.value, (val) => {
            customInput.value = val;
            shouldActiveChange && emit("activeChange", val);
            shouldActiveChange = true;
          });
          watch(() => color.value, () => {
            if (!props2.modelValue && !showPanelColor.value) {
              showPanelColor.value = true;
            }
          });
          watch(() => showPicker.value, () => {
            nextTick(() => {
              var _a, _b, _c;
              (_a = hue.value) == null ? void 0 : _a.update();
              (_b = sv.value) == null ? void 0 : _b.update();
              (_c = alpha.value) == null ? void 0 : _c.update();
            });
          });
          provide(colorPickerContextKey, {
            currentColor
          });
          expose({
            color,
            show,
            hide,
            focus,
            blur
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTooltip), {
              ref_key: "popper",
              ref: popper,
              visible: showPicker.value,
              "show-arrow": false,
              "fallback-placements": ["bottom", "top", "right", "left"],
              offset: 0,
              "gpu-acceleration": false,
              "popper-class": [unref(ns).be("picker", "panel"), unref(ns).b("dropdown"), _ctx.popperClass],
              "stop-popper-mouse-event": false,
              effect: "light",
              trigger: "click",
              teleported: _ctx.teleported,
              transition: `${unref(ns).namespace.value}-zoom-in-top`,
              persistent: _ctx.persistent,
              "append-to": _ctx.appendTo,
              onHide: ($event) => setShowPicker(false)
            }, {
              content: withCtx(() => [
                withDirectives((openBlock(), createElementBlock("div", {
                  onKeydown: withKeys(handleEsc, ["esc"])
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).be("dropdown", "main-wrapper"))
                  }, [
                    createVNode(HueSlider, {
                      ref_key: "hue",
                      ref: hue,
                      class: "hue-slider",
                      color: unref(color),
                      vertical: ""
                    }, null, 8, ["color"]),
                    createVNode(SvPanel, {
                      ref_key: "sv",
                      ref: sv,
                      color: unref(color)
                    }, null, 8, ["color"])
                  ], 2),
                  _ctx.showAlpha ? (openBlock(), createBlock(AlphaSlider, {
                    key: 0,
                    ref_key: "alpha",
                    ref: alpha,
                    color: unref(color)
                  }, null, 8, ["color"])) : createCommentVNode("v-if", true),
                  _ctx.predefine ? (openBlock(), createBlock(Predefine, {
                    key: 1,
                    ref: "predefine",
                    "enable-alpha": _ctx.showAlpha,
                    color: unref(color),
                    colors: _ctx.predefine
                  }, null, 8, ["enable-alpha", "color", "colors"])) : createCommentVNode("v-if", true),
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).be("dropdown", "btns"))
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass(unref(ns).be("dropdown", "value"))
                    }, [
                      createVNode(unref(ElInput), {
                        ref_key: "inputRef",
                        ref: inputRef,
                        modelValue: customInput.value,
                        "onUpdate:modelValue": ($event) => customInput.value = $event,
                        "validate-event": false,
                        size: "small",
                        onChange: handleConfirm
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ], 2),
                    createVNode(unref(ElButton), {
                      class: normalizeClass(unref(ns).be("dropdown", "link-btn")),
                      text: "",
                      size: "small",
                      onClick: clear
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(unref(t)("el.colorpicker.clear")), 1)
                      ]),
                      _: 1
                    }, 8, ["class"]),
                    createVNode(unref(ElButton), {
                      plain: "",
                      size: "small",
                      class: normalizeClass(unref(ns).be("dropdown", "btn")),
                      onClick: confirmValue
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(unref(t)("el.colorpicker.confirm")), 1)
                      ]),
                      _: 1
                    }, 8, ["class"])
                  ], 2)
                ], 40, ["onKeydown"])), [
                  [unref(ClickOutside), handleClickOutside, triggerRef2.value]
                ])
              ]),
              default: withCtx(() => [
                createElementVNode("div", mergeProps({
                  id: unref(buttonId),
                  ref_key: "triggerRef",
                  ref: triggerRef2
                }, _ctx.$attrs, {
                  class: unref(btnKls),
                  role: "button",
                  "aria-label": unref(buttonAriaLabel),
                  "aria-labelledby": unref(buttonAriaLabelledby),
                  "aria-description": unref(t)("el.colorpicker.description", { color: _ctx.modelValue || "" }),
                  "aria-disabled": unref(colorDisabled),
                  tabindex: unref(colorDisabled) ? void 0 : _ctx.tabindex,
                  onKeydown: handleKeyDown,
                  onFocus: unref(handleFocus),
                  onBlur: unref(handleBlur)
                }), [
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).be("picker", "trigger")),
                    onClick: handleTrigger
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass([unref(ns).be("picker", "color"), unref(ns).is("alpha", _ctx.showAlpha)])
                    }, [
                      createElementVNode("span", {
                        class: normalizeClass(unref(ns).be("picker", "color-inner")),
                        style: normalizeStyle({
                          backgroundColor: unref(displayedColor)
                        })
                      }, [
                        withDirectives(createVNode(unref(ElIcon), {
                          class: normalizeClass([unref(ns).be("picker", "icon"), unref(ns).is("icon-arrow-down")])
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(arrow_down_default$1))
                          ]),
                          _: 1
                        }, 8, ["class"]), [
                          [vShow, _ctx.modelValue || showPanelColor.value]
                        ]),
                        withDirectives(createVNode(unref(ElIcon), {
                          class: normalizeClass([unref(ns).be("picker", "empty"), unref(ns).is("icon-close")])
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(close_default$1))
                          ]),
                          _: 1
                        }, 8, ["class"]), [
                          [vShow, !_ctx.modelValue && !showPanelColor.value]
                        ])
                      ], 6)
                    ], 2)
                  ], 2)
                ], 16, ["id", "aria-label", "aria-labelledby", "aria-description", "aria-disabled", "tabindex", "onFocus", "onBlur"])
              ]),
              _: 1
            }, 8, ["visible", "popper-class", "teleported", "transition", "persistent", "append-to", "onHide"]);
          };
        }
      });
      var ColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$1H, [["__file", "color-picker.vue"]]);
      const ElColorPicker = exports("ElColorPicker", withInstall(ColorPicker));
      const __default__$1e = defineComponent({
        name: "ElContainer"
      });
      const _sfc_main$1G = /* @__PURE__ */ defineComponent({
        ...__default__$1e,
        props: {
          direction: {
            type: String
          }
        },
        setup(__props) {
          const props2 = __props;
          const slots = useSlots();
          const ns = useNamespace("container");
          const isVertical = computed(() => {
            if (props2.direction === "vertical") {
              return true;
            } else if (props2.direction === "horizontal") {
              return false;
            }
            if (slots && slots.default) {
              const vNodes = slots.default();
              return vNodes.some((vNode) => {
                const tag = vNode.type.name;
                return tag === "ElHeader" || tag === "ElFooter";
              });
            } else {
              return false;
            }
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("section", {
              class: normalizeClass([unref(ns).b(), unref(ns).is("vertical", unref(isVertical))])
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Container = /* @__PURE__ */ _export_sfc(_sfc_main$1G, [["__file", "container.vue"]]);
      const __default__$1d = defineComponent({
        name: "ElAside"
      });
      const _sfc_main$1F = /* @__PURE__ */ defineComponent({
        ...__default__$1d,
        props: {
          width: {
            type: String,
            default: null
          }
        },
        setup(__props) {
          const props2 = __props;
          const ns = useNamespace("aside");
          const style = computed(() => props2.width ? ns.cssVarBlock({ width: props2.width }) : {});
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("aside", {
              class: normalizeClass(unref(ns).b()),
              style: normalizeStyle(unref(style))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 6);
          };
        }
      });
      var Aside = /* @__PURE__ */ _export_sfc(_sfc_main$1F, [["__file", "aside.vue"]]);
      const __default__$1c = defineComponent({
        name: "ElFooter"
      });
      const _sfc_main$1E = /* @__PURE__ */ defineComponent({
        ...__default__$1c,
        props: {
          height: {
            type: String,
            default: null
          }
        },
        setup(__props) {
          const props2 = __props;
          const ns = useNamespace("footer");
          const style = computed(() => props2.height ? ns.cssVarBlock({ height: props2.height }) : {});
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("footer", {
              class: normalizeClass(unref(ns).b()),
              style: normalizeStyle(unref(style))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 6);
          };
        }
      });
      var Footer$2 = /* @__PURE__ */ _export_sfc(_sfc_main$1E, [["__file", "footer.vue"]]);
      const __default__$1b = defineComponent({
        name: "ElHeader"
      });
      const _sfc_main$1D = /* @__PURE__ */ defineComponent({
        ...__default__$1b,
        props: {
          height: {
            type: String,
            default: null
          }
        },
        setup(__props) {
          const props2 = __props;
          const ns = useNamespace("header");
          const style = computed(() => {
            return props2.height ? ns.cssVarBlock({
              height: props2.height
            }) : {};
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("header", {
              class: normalizeClass(unref(ns).b()),
              style: normalizeStyle(unref(style))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 6);
          };
        }
      });
      var Header$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1D, [["__file", "header.vue"]]);
      const __default__$1a = defineComponent({
        name: "ElMain"
      });
      const _sfc_main$1C = /* @__PURE__ */ defineComponent({
        ...__default__$1a,
        setup(__props) {
          const ns = useNamespace("main");
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("main", {
              class: normalizeClass(unref(ns).b())
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2);
          };
        }
      });
      var Main = /* @__PURE__ */ _export_sfc(_sfc_main$1C, [["__file", "main.vue"]]);
      const ElContainer = exports("ElContainer", withInstall(Container, {
        Aside,
        Footer: Footer$2,
        Header: Header$1,
        Main
      }));
      const ElAside = exports("ElAside", withNoopInstall(Aside));
      const ElFooter = exports("ElFooter", withNoopInstall(Footer$2));
      const ElHeader = exports("ElHeader", withNoopInstall(Header$1));
      const ElMain = exports("ElMain", withNoopInstall(Main));
      var advancedFormat$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e, t) {
          module2.exports = t();
        }(commonjsGlobal, function() {
          return function(e, t) {
            var r = t.prototype, n = r.format;
            r.format = function(e2) {
              var t2 = this, r2 = this.$locale();
              if (!this.isValid())
                return n.bind(this)(e2);
              var s2 = this.$utils(), a2 = (e2 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e3) {
                switch (e3) {
                  case "Q":
                    return Math.ceil((t2.$M + 1) / 3);
                  case "Do":
                    return r2.ordinal(t2.$D);
                  case "gggg":
                    return t2.weekYear();
                  case "GGGG":
                    return t2.isoWeekYear();
                  case "wo":
                    return r2.ordinal(t2.week(), "W");
                  case "w":
                  case "ww":
                    return s2.s(t2.week(), e3 === "w" ? 1 : 2, "0");
                  case "W":
                  case "WW":
                    return s2.s(t2.isoWeek(), e3 === "W" ? 1 : 2, "0");
                  case "k":
                  case "kk":
                    return s2.s(String(t2.$H === 0 ? 24 : t2.$H), e3 === "k" ? 1 : 2, "0");
                  case "X":
                    return Math.floor(t2.$d.getTime() / 1e3);
                  case "x":
                    return t2.$d.getTime();
                  case "z":
                    return "[" + t2.offsetName() + "]";
                  case "zzz":
                    return "[" + t2.offsetName("long") + "]";
                  default:
                    return e3;
                }
              });
              return n.bind(this)(a2);
            };
          };
        });
      })(advancedFormat$1);
      var advancedFormat = advancedFormat$1.exports;
      var weekOfYear$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e, t) {
          module2.exports = t();
        }(commonjsGlobal, function() {
          var e = "week", t = "year";
          return function(i, n, r) {
            var f2 = n.prototype;
            f2.week = function(i2) {
              if (i2 === void 0 && (i2 = null), i2 !== null)
                return this.add(7 * (i2 - this.week()), "day");
              var n2 = this.$locale().yearStart || 1;
              if (this.month() === 11 && this.date() > 25) {
                var f22 = r(this).startOf(t).add(1, t).date(n2), s2 = r(this).endOf(e);
                if (f22.isBefore(s2))
                  return 1;
              }
              var a2 = r(this).startOf(t).date(n2).startOf(e).subtract(1, "millisecond"), o2 = this.diff(a2, e, true);
              return o2 < 0 ? r(this).startOf("week").week() : Math.ceil(o2);
            }, f2.weeks = function(e2) {
              return e2 === void 0 && (e2 = null), this.week(e2);
            };
          };
        });
      })(weekOfYear$1);
      var weekOfYear = weekOfYear$1.exports;
      var weekYear$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e, t) {
          module2.exports = t();
        }(commonjsGlobal, function() {
          return function(e, t) {
            t.prototype.weekYear = function() {
              var e2 = this.month(), t2 = this.week(), n = this.year();
              return t2 === 1 && e2 === 11 ? n + 1 : e2 === 0 && t2 >= 52 ? n - 1 : n;
            };
          };
        });
      })(weekYear$1);
      var weekYear = weekYear$1.exports;
      var dayOfYear$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e, t) {
          module2.exports = t();
        }(commonjsGlobal, function() {
          return function(e, t, n) {
            t.prototype.dayOfYear = function(e2) {
              var t2 = Math.round((n(this).startOf("day") - n(this).startOf("year")) / 864e5) + 1;
              return e2 == null ? t2 : this.add(e2 - t2, "day");
            };
          };
        });
      })(dayOfYear$1);
      var dayOfYear = dayOfYear$1.exports;
      var isSameOrAfter$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e, t) {
          module2.exports = t();
        }(commonjsGlobal, function() {
          return function(e, t) {
            t.prototype.isSameOrAfter = function(e2, t2) {
              return this.isSame(e2, t2) || this.isAfter(e2, t2);
            };
          };
        });
      })(isSameOrAfter$1);
      var isSameOrAfter = isSameOrAfter$1.exports;
      var isSameOrBefore$1 = { exports: {} };
      (function(module2, exports2) {
        !function(e, i) {
          module2.exports = i();
        }(commonjsGlobal, function() {
          return function(e, i) {
            i.prototype.isSameOrBefore = function(e2, i2) {
              return this.isSame(e2, i2) || this.isBefore(e2, i2);
            };
          };
        });
      })(isSameOrBefore$1);
      var isSameOrBefore = isSameOrBefore$1.exports;
      const ROOT_PICKER_INJECTION_KEY = exports("ROOT_PICKER_INJECTION_KEY", Symbol());
      const ROOT_PICKER_IS_DEFAULT_FORMAT_INJECTION_KEY = exports("ROOT_PICKER_IS_DEFAULT_FORMAT_INJECTION_KEY", "ElIsDefaultFormat");
      const datePickerProps = exports("datePickerProps", buildProps({
        ...timePickerDefaultProps,
        type: {
          type: definePropType(String),
          default: "date"
        }
      }));
      const selectionModes = [
        "date",
        "dates",
        "year",
        "years",
        "month",
        "months",
        "week",
        "range"
      ];
      const datePickerSharedProps = buildProps({
        disabledDate: {
          type: definePropType(Function)
        },
        date: {
          type: definePropType(Object),
          required: true
        },
        minDate: {
          type: definePropType(Object)
        },
        maxDate: {
          type: definePropType(Object)
        },
        parsedValue: {
          type: definePropType([Object, Array])
        },
        rangeState: {
          type: definePropType(Object),
          default: () => ({
            endDate: null,
            selecting: false
          })
        }
      });
      const panelSharedProps = buildProps({
        type: {
          type: definePropType(String),
          required: true,
          values: datePickTypes
        },
        dateFormat: String,
        timeFormat: String,
        showNow: {
          type: Boolean,
          default: true
        },
        showFooter: {
          type: Boolean,
          default: true
        },
        showWeekNumber: Boolean
      });
      const panelRangeSharedProps = buildProps({
        unlinkPanels: Boolean,
        visible: Boolean,
        showFooter: {
          type: Boolean,
          default: true
        },
        parsedValue: {
          type: definePropType(Array)
        }
      });
      const selectionModeWithDefault = (mode) => {
        return {
          type: String,
          values: selectionModes,
          default: mode
        };
      };
      const panelDatePickProps = buildProps({
        ...panelSharedProps,
        parsedValue: {
          type: definePropType([Object, Array])
        },
        visible: {
          type: Boolean
        },
        format: {
          type: String,
          default: ""
        }
      });
      const isValidRange = (range2) => {
        if (!isArray$1(range2))
          return false;
        const [left, right] = range2;
        return dayjs.isDayjs(left) && dayjs.isDayjs(right) && dayjs(left).isValid() && dayjs(right).isValid() && left.isSameOrBefore(right);
      };
      const getDefaultValue = (defaultValue, { lang: lang2, step: step2 = 1, unit: unit2, unlinkPanels }) => {
        let start;
        if (isArray$1(defaultValue)) {
          let [left, right] = defaultValue.map((d2) => dayjs(d2).locale(lang2));
          if (!unlinkPanels) {
            right = left.add(step2, unit2);
          }
          return [left, right];
        } else if (defaultValue) {
          start = dayjs(defaultValue);
        } else {
          start = dayjs();
        }
        start = start.locale(lang2);
        return [start, start.add(step2, unit2)];
      };
      const buildPickerTable = (dimension, rows, {
        columnIndexOffset,
        startDate,
        nextEndDate,
        now: now2,
        unit: unit2,
        relativeDateGetter,
        setCellMetadata,
        setRowMetadata
      }) => {
        for (let rowIndex = 0; rowIndex < dimension.row; rowIndex++) {
          const row = rows[rowIndex];
          for (let columnIndex = 0; columnIndex < dimension.column; columnIndex++) {
            let cell = row[columnIndex + columnIndexOffset];
            if (!cell) {
              cell = {
                row: rowIndex,
                column: columnIndex,
                type: "normal",
                inRange: false,
                start: false,
                end: false
              };
            }
            const index2 = rowIndex * dimension.column + columnIndex;
            const nextStartDate = relativeDateGetter(index2);
            cell.dayjs = nextStartDate;
            cell.date = nextStartDate.toDate();
            cell.timestamp = nextStartDate.valueOf();
            cell.type = "normal";
            cell.inRange = !!(startDate && nextStartDate.isSameOrAfter(startDate, unit2) && nextEndDate && nextStartDate.isSameOrBefore(nextEndDate, unit2)) || !!(startDate && nextStartDate.isSameOrBefore(startDate, unit2) && nextEndDate && nextStartDate.isSameOrAfter(nextEndDate, unit2));
            if (startDate == null ? void 0 : startDate.isSameOrAfter(nextEndDate)) {
              cell.start = !!nextEndDate && nextStartDate.isSame(nextEndDate, unit2);
              cell.end = startDate && nextStartDate.isSame(startDate, unit2);
            } else {
              cell.start = !!startDate && nextStartDate.isSame(startDate, unit2);
              cell.end = !!nextEndDate && nextStartDate.isSame(nextEndDate, unit2);
            }
            const isToday = nextStartDate.isSame(now2, unit2);
            if (isToday) {
              cell.type = "today";
            }
            setCellMetadata == null ? void 0 : setCellMetadata(cell, { rowIndex, columnIndex });
            row[columnIndex + columnIndexOffset] = cell;
          }
          setRowMetadata == null ? void 0 : setRowMetadata(row);
        }
      };
      const datesInMonth = (date3, year, month, lang2) => {
        const firstDay = dayjs().locale(lang2).startOf("month").month(month).year(year).hour(date3.hour()).minute(date3.minute()).second(date3.second());
        const numOfDays = firstDay.daysInMonth();
        return rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
      };
      const getValidDateOfMonth = (date3, year, month, lang2, disabledDate) => {
        const _value = dayjs().year(year).month(month).startOf("month").hour(date3.hour()).minute(date3.minute()).second(date3.second());
        const _date = datesInMonth(date3, year, month, lang2).find((date22) => {
          return !(disabledDate == null ? void 0 : disabledDate(date22));
        });
        if (_date) {
          return dayjs(_date).locale(lang2);
        }
        return _value.locale(lang2);
      };
      const getValidDateOfYear = (value, lang2, disabledDate) => {
        const year = value.year();
        if (!(disabledDate == null ? void 0 : disabledDate(value.toDate()))) {
          return value.locale(lang2);
        }
        const month = value.month();
        if (!datesInMonth(value, year, month, lang2).every(disabledDate)) {
          return getValidDateOfMonth(value, year, month, lang2, disabledDate);
        }
        for (let i = 0; i < 12; i++) {
          if (!datesInMonth(value, year, i, lang2).every(disabledDate)) {
            return getValidDateOfMonth(value, year, i, lang2, disabledDate);
          }
        }
        return value;
      };
      const correctlyParseUserInput = (value, format2, lang2, defaultFormat) => {
        if (isArray$1(value)) {
          return value.map((v2) => correctlyParseUserInput(v2, format2, lang2, defaultFormat));
        }
        if (isString$1(value)) {
          const dayjsValue = defaultFormat.value ? dayjs(value) : dayjs(value, format2);
          if (!dayjsValue.isValid()) {
            return dayjsValue;
          }
        }
        return dayjs(value, format2).locale(lang2);
      };
      const basicDateTableProps = buildProps({
        ...datePickerSharedProps,
        cellClassName: {
          type: definePropType(Function)
        },
        showWeekNumber: Boolean,
        selectionMode: selectionModeWithDefault("date")
      });
      const basicDateTableEmits = ["changerange", "pick", "select"];
      const isNormalDay = (type = "") => {
        return ["normal", "today"].includes(type);
      };
      const useBasicDateTable = (props2, emit) => {
        const { lang: lang2 } = useLocale();
        const tbodyRef = ref();
        const currentCellRef = ref();
        const lastRow = ref();
        const lastColumn = ref();
        const tableRows = ref([[], [], [], [], [], []]);
        let focusWithClick = false;
        const firstDayOfWeek = props2.date.$locale().weekStart || 7;
        const WEEKS_CONSTANT = props2.date.locale("en").localeData().weekdaysShort().map((_2) => _2.toLowerCase());
        const offsetDay = computed(() => {
          return firstDayOfWeek > 3 ? 7 - firstDayOfWeek : -firstDayOfWeek;
        });
        const startDate = computed(() => {
          const startDayOfMonth = props2.date.startOf("month");
          return startDayOfMonth.subtract(startDayOfMonth.day() || 7, "day");
        });
        const WEEKS = computed(() => {
          return WEEKS_CONSTANT.concat(WEEKS_CONSTANT).slice(firstDayOfWeek, firstDayOfWeek + 7);
        });
        const hasCurrent = computed(() => {
          return flatten(unref(rows)).some((row) => {
            return row.isCurrent;
          });
        });
        const days = computed(() => {
          const startOfMonth = props2.date.startOf("month");
          const startOfMonthDay = startOfMonth.day() || 7;
          const dateCountOfMonth = startOfMonth.daysInMonth();
          const dateCountOfLastMonth = startOfMonth.subtract(1, "month").daysInMonth();
          return {
            startOfMonthDay,
            dateCountOfMonth,
            dateCountOfLastMonth
          };
        });
        const selectedDate = computed(() => {
          return props2.selectionMode === "dates" ? castArray(props2.parsedValue) : [];
        });
        const setDateText = (cell, { count, rowIndex, columnIndex }) => {
          const { startOfMonthDay, dateCountOfMonth, dateCountOfLastMonth } = unref(days);
          const offset2 = unref(offsetDay);
          if (rowIndex >= 0 && rowIndex <= 1) {
            const numberOfDaysFromPreviousMonth = startOfMonthDay + offset2 < 0 ? 7 + startOfMonthDay + offset2 : startOfMonthDay + offset2;
            if (columnIndex + rowIndex * 7 >= numberOfDaysFromPreviousMonth) {
              cell.text = count;
              return true;
            } else {
              cell.text = dateCountOfLastMonth - (numberOfDaysFromPreviousMonth - columnIndex % 7) + 1 + rowIndex * 7;
              cell.type = "prev-month";
            }
          } else {
            if (count <= dateCountOfMonth) {
              cell.text = count;
            } else {
              cell.text = count - dateCountOfMonth;
              cell.type = "next-month";
            }
            return true;
          }
          return false;
        };
        const setCellMetadata = (cell, { columnIndex, rowIndex }, count) => {
          const { disabledDate, cellClassName } = props2;
          const _selectedDate = unref(selectedDate);
          const shouldIncrement = setDateText(cell, { count, rowIndex, columnIndex });
          const cellDate = cell.dayjs.toDate();
          cell.selected = _selectedDate.find((d2) => d2.isSame(cell.dayjs, "day"));
          cell.isSelected = !!cell.selected;
          cell.isCurrent = isCurrent(cell);
          cell.disabled = disabledDate == null ? void 0 : disabledDate(cellDate);
          cell.customClass = cellClassName == null ? void 0 : cellClassName(cellDate);
          return shouldIncrement;
        };
        const setRowMetadata = (row) => {
          if (props2.selectionMode === "week") {
            const [start, end] = props2.showWeekNumber ? [1, 7] : [0, 6];
            const isActive = isWeekActive(row[start + 1]);
            row[start].inRange = isActive;
            row[start].start = isActive;
            row[end].inRange = isActive;
            row[end].end = isActive;
          }
        };
        const rows = computed(() => {
          const { minDate, maxDate, rangeState, showWeekNumber } = props2;
          const offset2 = unref(offsetDay);
          const rows_ = unref(tableRows);
          const dateUnit = "day";
          let count = 1;
          buildPickerTable({ row: 6, column: 7 }, rows_, {
            startDate: minDate,
            columnIndexOffset: showWeekNumber ? 1 : 0,
            nextEndDate: rangeState.endDate || maxDate || rangeState.selecting && minDate || null,
            now: dayjs().locale(unref(lang2)).startOf(dateUnit),
            unit: dateUnit,
            relativeDateGetter: (idx) => unref(startDate).add(idx - offset2, dateUnit),
            setCellMetadata: (...args) => {
              if (setCellMetadata(...args, count)) {
                count += 1;
              }
            },
            setRowMetadata
          });
          if (showWeekNumber) {
            for (let rowIndex = 0; rowIndex < 6; rowIndex++) {
              if (rows_[rowIndex][1].dayjs) {
                rows_[rowIndex][0] = {
                  type: "week",
                  text: rows_[rowIndex][1].dayjs.week()
                };
              }
            }
          }
          return rows_;
        });
        watch(() => props2.date, async () => {
          var _a;
          if ((_a = unref(tbodyRef)) == null ? void 0 : _a.contains(document.activeElement)) {
            await nextTick();
            await focus();
          }
        });
        const focus = async () => {
          var _a;
          return (_a = unref(currentCellRef)) == null ? void 0 : _a.focus();
        };
        const isCurrent = (cell) => {
          return props2.selectionMode === "date" && isNormalDay(cell.type) && cellMatchesDate(cell, props2.parsedValue);
        };
        const cellMatchesDate = (cell, date3) => {
          if (!date3)
            return false;
          return dayjs(date3).locale(unref(lang2)).isSame(props2.date.date(Number(cell.text)), "day");
        };
        const getDateOfCell = (row, column) => {
          const offsetFromStart = row * 7 + (column - (props2.showWeekNumber ? 1 : 0)) - unref(offsetDay);
          return unref(startDate).add(offsetFromStart, "day");
        };
        const handleMouseMove = (event) => {
          var _a;
          if (!props2.rangeState.selecting)
            return;
          let target2 = event.target;
          if (target2.tagName === "SPAN") {
            target2 = (_a = target2.parentNode) == null ? void 0 : _a.parentNode;
          }
          if (target2.tagName === "DIV") {
            target2 = target2.parentNode;
          }
          if (target2.tagName !== "TD")
            return;
          const row = target2.parentNode.rowIndex - 1;
          const column = target2.cellIndex;
          if (unref(rows)[row][column].disabled)
            return;
          if (row !== unref(lastRow) || column !== unref(lastColumn)) {
            lastRow.value = row;
            lastColumn.value = column;
            emit("changerange", {
              selecting: true,
              endDate: getDateOfCell(row, column)
            });
          }
        };
        const isSelectedCell = (cell) => {
          return !unref(hasCurrent) && (cell == null ? void 0 : cell.text) === 1 && cell.type === "normal" || cell.isCurrent;
        };
        const handleFocus = (event) => {
          if (focusWithClick || unref(hasCurrent) || props2.selectionMode !== "date")
            return;
          handlePickDate(event, true);
        };
        const handleMouseDown = (event) => {
          const target2 = event.target.closest("td");
          if (!target2)
            return;
          focusWithClick = true;
        };
        const handleMouseUp = (event) => {
          const target2 = event.target.closest("td");
          if (!target2)
            return;
          focusWithClick = false;
        };
        const handleRangePick = (newDate) => {
          if (!props2.rangeState.selecting || !props2.minDate) {
            emit("pick", { minDate: newDate, maxDate: null });
            emit("select", true);
          } else {
            if (newDate >= props2.minDate) {
              emit("pick", { minDate: props2.minDate, maxDate: newDate });
            } else {
              emit("pick", { minDate: newDate, maxDate: props2.minDate });
            }
            emit("select", false);
          }
        };
        const handleWeekPick = (newDate) => {
          const weekNumber = newDate.week();
          const value = `${newDate.year()}w${weekNumber}`;
          emit("pick", {
            year: newDate.year(),
            week: weekNumber,
            value,
            date: newDate.startOf("week")
          });
        };
        const handleDatesPick = (newDate, selected) => {
          const newValue = selected ? castArray(props2.parsedValue).filter((d2) => (d2 == null ? void 0 : d2.valueOf()) !== newDate.valueOf()) : castArray(props2.parsedValue).concat([newDate]);
          emit("pick", newValue);
        };
        const handlePickDate = (event, isKeyboardMovement = false) => {
          const target2 = event.target.closest("td");
          if (!target2)
            return;
          const row = target2.parentNode.rowIndex - 1;
          const column = target2.cellIndex;
          const cell = unref(rows)[row][column];
          if (cell.disabled || cell.type === "week")
            return;
          const newDate = getDateOfCell(row, column);
          switch (props2.selectionMode) {
            case "range": {
              handleRangePick(newDate);
              break;
            }
            case "date": {
              emit("pick", newDate, isKeyboardMovement);
              break;
            }
            case "week": {
              handleWeekPick(newDate);
              break;
            }
            case "dates": {
              handleDatesPick(newDate, !!cell.selected);
              break;
            }
          }
        };
        const isWeekActive = (cell) => {
          if (props2.selectionMode !== "week")
            return false;
          let newDate = props2.date.startOf("day");
          if (cell.type === "prev-month") {
            newDate = newDate.subtract(1, "month");
          }
          if (cell.type === "next-month") {
            newDate = newDate.add(1, "month");
          }
          newDate = newDate.date(Number.parseInt(cell.text, 10));
          if (props2.parsedValue && !isArray$1(props2.parsedValue)) {
            const dayOffset = (props2.parsedValue.day() - firstDayOfWeek + 7) % 7 - 1;
            const weekDate = props2.parsedValue.subtract(dayOffset, "day");
            return weekDate.isSame(newDate, "day");
          }
          return false;
        };
        return {
          WEEKS,
          rows,
          tbodyRef,
          currentCellRef,
          focus,
          isCurrent,
          isWeekActive,
          isSelectedCell,
          handlePickDate,
          handleMouseUp,
          handleMouseDown,
          handleMouseMove,
          handleFocus
        };
      };
      const useBasicDateTableDOM = (props2, {
        isCurrent,
        isWeekActive
      }) => {
        const ns = useNamespace("date-table");
        const { t } = useLocale();
        const tableKls = computed(() => [
          ns.b(),
          { "is-week-mode": props2.selectionMode === "week" }
        ]);
        const tableLabel = computed(() => t("el.datepicker.dateTablePrompt"));
        const getCellClasses = (cell) => {
          const classes = [];
          if (isNormalDay(cell.type) && !cell.disabled) {
            classes.push("available");
            if (cell.type === "today") {
              classes.push("today");
            }
          } else {
            classes.push(cell.type);
          }
          if (isCurrent(cell)) {
            classes.push("current");
          }
          if (cell.inRange && (isNormalDay(cell.type) || props2.selectionMode === "week")) {
            classes.push("in-range");
            if (cell.start) {
              classes.push("start-date");
            }
            if (cell.end) {
              classes.push("end-date");
            }
          }
          if (cell.disabled) {
            classes.push("disabled");
          }
          if (cell.selected) {
            classes.push("selected");
          }
          if (cell.customClass) {
            classes.push(cell.customClass);
          }
          return classes.join(" ");
        };
        const getRowKls = (cell) => [
          ns.e("row"),
          { current: isWeekActive(cell) }
        ];
        return {
          tableKls,
          tableLabel,
          weekHeaderClass: ns.e("week-header"),
          getCellClasses,
          getRowKls,
          t
        };
      };
      const basicCellProps = buildProps({
        cell: {
          type: definePropType(Object)
        }
      });
      var ElDatePickerCell = defineComponent({
        name: "ElDatePickerCell",
        props: basicCellProps,
        setup(props2) {
          const ns = useNamespace("date-table-cell");
          const {
            slots
          } = inject(ROOT_PICKER_INJECTION_KEY);
          return () => {
            const {
              cell
            } = props2;
            return renderSlot(slots, "default", {
              ...cell
            }, () => {
              var _a;
              return [createVNode("div", {
                "class": ns.b()
              }, [createVNode("span", {
                "class": ns.e("text")
              }, [(_a = cell == null ? void 0 : cell.renderText) != null ? _a : cell == null ? void 0 : cell.text])])];
            });
          };
        }
      });
      const _sfc_main$1B = /* @__PURE__ */ defineComponent({
        __name: "basic-date-table",
        props: basicDateTableProps,
        emits: basicDateTableEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const {
            WEEKS,
            rows,
            tbodyRef,
            currentCellRef,
            focus,
            isCurrent,
            isWeekActive,
            isSelectedCell,
            handlePickDate,
            handleMouseUp,
            handleMouseDown,
            handleMouseMove,
            handleFocus
          } = useBasicDateTable(props2, emit);
          const { tableLabel, tableKls, getCellClasses, getRowKls, weekHeaderClass, t } = useBasicDateTableDOM(props2, {
            isCurrent,
            isWeekActive
          });
          let isUnmounting = false;
          onBeforeUnmount(() => {
            isUnmounting = true;
          });
          expose({
            focus
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("table", {
              "aria-label": unref(tableLabel),
              class: normalizeClass(unref(tableKls)),
              cellspacing: "0",
              cellpadding: "0",
              role: "grid",
              onClick: unref(handlePickDate),
              onMousemove: unref(handleMouseMove),
              onMousedown: unref(handleMouseDown),
              onMouseup: unref(handleMouseUp)
            }, [
              createElementVNode("tbody", {
                ref_key: "tbodyRef",
                ref: tbodyRef
              }, [
                createElementVNode("tr", null, [
                  _ctx.showWeekNumber ? (openBlock(), createElementBlock("th", {
                    key: 0,
                    scope: "col",
                    class: normalizeClass(unref(weekHeaderClass))
                  }, null, 2)) : createCommentVNode("v-if", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(WEEKS), (week, key) => {
                    return openBlock(), createElementBlock("th", {
                      key,
                      "aria-label": unref(t)("el.datepicker.weeksFull." + week),
                      scope: "col"
                    }, toDisplayString(unref(t)("el.datepicker.weeks." + week)), 9, ["aria-label"]);
                  }), 128))
                ]),
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(rows), (row, rowKey2) => {
                  return openBlock(), createElementBlock("tr", {
                    key: rowKey2,
                    class: normalizeClass(unref(getRowKls)(row[1]))
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, columnKey) => {
                      return openBlock(), createElementBlock("td", {
                        key: `${rowKey2}.${columnKey}`,
                        ref_for: true,
                        ref: (el) => !unref(isUnmounting) && unref(isSelectedCell)(cell) && (currentCellRef.value = el),
                        class: normalizeClass(unref(getCellClasses)(cell)),
                        "aria-current": cell.isCurrent ? "date" : void 0,
                        "aria-selected": cell.isCurrent,
                        tabindex: unref(isSelectedCell)(cell) ? 0 : -1,
                        onFocus: unref(handleFocus)
                      }, [
                        createVNode(unref(ElDatePickerCell), { cell }, null, 8, ["cell"])
                      ], 42, ["aria-current", "aria-selected", "tabindex", "onFocus"]);
                    }), 128))
                  ], 2);
                }), 128))
              ], 512)
            ], 42, ["aria-label", "onClick", "onMousemove", "onMousedown", "onMouseup"]);
          };
        }
      });
      var DateTable = /* @__PURE__ */ _export_sfc(_sfc_main$1B, [["__file", "basic-date-table.vue"]]);
      const basicMonthTableProps = buildProps({
        ...datePickerSharedProps,
        selectionMode: selectionModeWithDefault("month")
      });
      const _sfc_main$1A = /* @__PURE__ */ defineComponent({
        __name: "basic-month-table",
        props: basicMonthTableProps,
        emits: ["changerange", "pick", "select"],
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const ns = useNamespace("month-table");
          const { t, lang: lang2 } = useLocale();
          const tbodyRef = ref();
          const currentCellRef = ref();
          const months = ref(props2.date.locale("en").localeData().monthsShort().map((_2) => _2.toLowerCase()));
          const tableRows = ref([
            [],
            [],
            []
          ]);
          const lastRow = ref();
          const lastColumn = ref();
          const rows = computed(() => {
            var _a, _b;
            const rows2 = tableRows.value;
            const now2 = dayjs().locale(lang2.value).startOf("month");
            for (let i = 0; i < 3; i++) {
              const row = rows2[i];
              for (let j = 0; j < 4; j++) {
                const cell = row[j] || (row[j] = {
                  row: i,
                  column: j,
                  type: "normal",
                  inRange: false,
                  start: false,
                  end: false,
                  text: -1,
                  disabled: false
                });
                cell.type = "normal";
                const index2 = i * 4 + j;
                const calTime = props2.date.startOf("year").month(index2);
                const calEndDate = props2.rangeState.endDate || props2.maxDate || props2.rangeState.selecting && props2.minDate || null;
                cell.inRange = !!(props2.minDate && calTime.isSameOrAfter(props2.minDate, "month") && calEndDate && calTime.isSameOrBefore(calEndDate, "month")) || !!(props2.minDate && calTime.isSameOrBefore(props2.minDate, "month") && calEndDate && calTime.isSameOrAfter(calEndDate, "month"));
                if ((_a = props2.minDate) == null ? void 0 : _a.isSameOrAfter(calEndDate)) {
                  cell.start = !!(calEndDate && calTime.isSame(calEndDate, "month"));
                  cell.end = props2.minDate && calTime.isSame(props2.minDate, "month");
                } else {
                  cell.start = !!(props2.minDate && calTime.isSame(props2.minDate, "month"));
                  cell.end = !!(calEndDate && calTime.isSame(calEndDate, "month"));
                }
                const isToday = now2.isSame(calTime);
                if (isToday) {
                  cell.type = "today";
                }
                cell.text = index2;
                cell.disabled = ((_b = props2.disabledDate) == null ? void 0 : _b.call(props2, calTime.toDate())) || false;
              }
            }
            return rows2;
          });
          const focus = () => {
            var _a;
            (_a = currentCellRef.value) == null ? void 0 : _a.focus();
          };
          const getCellStyle = (cell) => {
            const style = {};
            const year = props2.date.year();
            const today = /* @__PURE__ */ new Date();
            const month = cell.text;
            style.disabled = props2.disabledDate ? datesInMonth(props2.date, year, month, lang2.value).every(props2.disabledDate) : false;
            style.current = castArray(props2.parsedValue).findIndex((date3) => dayjs.isDayjs(date3) && date3.year() === year && date3.month() === month) >= 0;
            style.today = today.getFullYear() === year && today.getMonth() === month;
            if (cell.inRange) {
              style["in-range"] = true;
              if (cell.start) {
                style["start-date"] = true;
              }
              if (cell.end) {
                style["end-date"] = true;
              }
            }
            return style;
          };
          const isSelectedCell = (cell) => {
            const year = props2.date.year();
            const month = cell.text;
            return castArray(props2.date).findIndex((date3) => date3.year() === year && date3.month() === month) >= 0;
          };
          const handleMouseMove = (event) => {
            var _a;
            if (!props2.rangeState.selecting)
              return;
            let target2 = event.target;
            if (target2.tagName === "SPAN") {
              target2 = (_a = target2.parentNode) == null ? void 0 : _a.parentNode;
            }
            if (target2.tagName === "DIV") {
              target2 = target2.parentNode;
            }
            if (target2.tagName !== "TD")
              return;
            const row = target2.parentNode.rowIndex;
            const column = target2.cellIndex;
            if (rows.value[row][column].disabled)
              return;
            if (row !== lastRow.value || column !== lastColumn.value) {
              lastRow.value = row;
              lastColumn.value = column;
              emit("changerange", {
                selecting: true,
                endDate: props2.date.startOf("year").month(row * 4 + column)
              });
            }
          };
          const handleMonthTableClick = (event) => {
            var _a;
            const target2 = (_a = event.target) == null ? void 0 : _a.closest("td");
            if ((target2 == null ? void 0 : target2.tagName) !== "TD")
              return;
            if (hasClass(target2, "disabled"))
              return;
            const column = target2.cellIndex;
            const row = target2.parentNode.rowIndex;
            const month = row * 4 + column;
            const newDate = props2.date.startOf("year").month(month);
            if (props2.selectionMode === "months") {
              if (event.type === "keydown") {
                emit("pick", castArray(props2.parsedValue), false);
                return;
              }
              const newMonth = getValidDateOfMonth(props2.date, props2.date.year(), month, lang2.value, props2.disabledDate);
              const newValue = hasClass(target2, "current") ? castArray(props2.parsedValue).filter((d2) => (d2 == null ? void 0 : d2.year()) !== newMonth.year() || (d2 == null ? void 0 : d2.month()) !== newMonth.month()) : castArray(props2.parsedValue).concat([dayjs(newMonth)]);
              emit("pick", newValue);
            } else if (props2.selectionMode === "range") {
              if (!props2.rangeState.selecting) {
                emit("pick", { minDate: newDate, maxDate: null });
                emit("select", true);
              } else {
                if (props2.minDate && newDate >= props2.minDate) {
                  emit("pick", { minDate: props2.minDate, maxDate: newDate });
                } else {
                  emit("pick", { minDate: newDate, maxDate: props2.minDate });
                }
                emit("select", false);
              }
            } else {
              emit("pick", month);
            }
          };
          watch(() => props2.date, async () => {
            var _a, _b;
            if ((_a = tbodyRef.value) == null ? void 0 : _a.contains(document.activeElement)) {
              await nextTick();
              (_b = currentCellRef.value) == null ? void 0 : _b.focus();
            }
          });
          expose({
            focus
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("table", {
              role: "grid",
              "aria-label": unref(t)("el.datepicker.monthTablePrompt"),
              class: normalizeClass(unref(ns).b()),
              onClick: handleMonthTableClick,
              onMousemove: handleMouseMove
            }, [
              createElementVNode("tbody", {
                ref_key: "tbodyRef",
                ref: tbodyRef
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(rows), (row, key) => {
                  return openBlock(), createElementBlock("tr", { key }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, key_) => {
                      return openBlock(), createElementBlock("td", {
                        key: key_,
                        ref_for: true,
                        ref: (el) => isSelectedCell(cell) && (currentCellRef.value = el),
                        class: normalizeClass(getCellStyle(cell)),
                        "aria-selected": `${isSelectedCell(cell)}`,
                        "aria-label": unref(t)(`el.datepicker.month${+cell.text + 1}`),
                        tabindex: isSelectedCell(cell) ? 0 : -1,
                        onKeydown: [
                          withKeys(withModifiers(handleMonthTableClick, ["prevent", "stop"]), ["space"]),
                          withKeys(withModifiers(handleMonthTableClick, ["prevent", "stop"]), ["enter"])
                        ]
                      }, [
                        createVNode(unref(ElDatePickerCell), {
                          cell: {
                            ...cell,
                            renderText: unref(t)("el.datepicker.months." + months.value[cell.text])
                          }
                        }, null, 8, ["cell"])
                      ], 42, ["aria-selected", "aria-label", "tabindex", "onKeydown"]);
                    }), 128))
                  ]);
                }), 128))
              ], 512)
            ], 42, ["aria-label"]);
          };
        }
      });
      var MonthTable = /* @__PURE__ */ _export_sfc(_sfc_main$1A, [["__file", "basic-month-table.vue"]]);
      const basicYearTableProps = buildProps({
        ...datePickerSharedProps,
        selectionMode: selectionModeWithDefault("year")
      });
      const _sfc_main$1z = /* @__PURE__ */ defineComponent({
        __name: "basic-year-table",
        props: basicYearTableProps,
        emits: ["changerange", "pick", "select"],
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const datesInYear = (year, lang22) => {
            const firstDay = dayjs(String(year)).locale(lang22).startOf("year");
            const lastDay = firstDay.endOf("year");
            const numOfDays = lastDay.dayOfYear();
            return rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
          };
          const ns = useNamespace("year-table");
          const { t, lang: lang2 } = useLocale();
          const tbodyRef = ref();
          const currentCellRef = ref();
          const startYear = computed(() => {
            return Math.floor(props2.date.year() / 10) * 10;
          });
          const tableRows = ref([[], [], []]);
          const lastRow = ref();
          const lastColumn = ref();
          const rows = computed(() => {
            var _a;
            const rows2 = tableRows.value;
            const now2 = dayjs().locale(lang2.value).startOf("year");
            for (let i = 0; i < 3; i++) {
              const row = rows2[i];
              for (let j = 0; j < 4; j++) {
                if (i * 4 + j >= 10) {
                  break;
                }
                let cell = row[j];
                if (!cell) {
                  cell = {
                    row: i,
                    column: j,
                    type: "normal",
                    inRange: false,
                    start: false,
                    end: false,
                    text: -1,
                    disabled: false
                  };
                }
                cell.type = "normal";
                const index2 = i * 4 + j + startYear.value;
                const calTime = dayjs().year(index2);
                const calEndDate = props2.rangeState.endDate || props2.maxDate || props2.rangeState.selecting && props2.minDate || null;
                cell.inRange = !!(props2.minDate && calTime.isSameOrAfter(props2.minDate, "year") && calEndDate && calTime.isSameOrBefore(calEndDate, "year")) || !!(props2.minDate && calTime.isSameOrBefore(props2.minDate, "year") && calEndDate && calTime.isSameOrAfter(calEndDate, "year"));
                if ((_a = props2.minDate) == null ? void 0 : _a.isSameOrAfter(calEndDate)) {
                  cell.start = !!(calEndDate && calTime.isSame(calEndDate, "year"));
                  cell.end = !!(props2.minDate && calTime.isSame(props2.minDate, "year"));
                } else {
                  cell.start = !!(props2.minDate && calTime.isSame(props2.minDate, "year"));
                  cell.end = !!(calEndDate && calTime.isSame(calEndDate, "year"));
                }
                const isToday = now2.isSame(calTime);
                if (isToday) {
                  cell.type = "today";
                }
                cell.text = index2;
                const cellDate = calTime.toDate();
                cell.disabled = props2.disabledDate && props2.disabledDate(cellDate) || false;
                row[j] = cell;
              }
            }
            return rows2;
          });
          const focus = () => {
            var _a;
            (_a = currentCellRef.value) == null ? void 0 : _a.focus();
          };
          const getCellKls = (cell) => {
            const kls = {};
            const today = dayjs().locale(lang2.value);
            const year = cell.text;
            kls.disabled = props2.disabledDate ? datesInYear(year, lang2.value).every(props2.disabledDate) : false;
            kls.today = today.year() === year;
            kls.current = castArray(props2.parsedValue).findIndex((d2) => d2.year() === year) >= 0;
            if (cell.inRange) {
              kls["in-range"] = true;
              if (cell.start) {
                kls["start-date"] = true;
              }
              if (cell.end) {
                kls["end-date"] = true;
              }
            }
            return kls;
          };
          const isSelectedCell = (cell) => {
            const year = cell.text;
            return castArray(props2.date).findIndex((date3) => date3.year() === year) >= 0;
          };
          const handleYearTableClick = (event) => {
            var _a;
            const target2 = (_a = event.target) == null ? void 0 : _a.closest("td");
            if (!target2 || !target2.textContent || hasClass(target2, "disabled"))
              return;
            const column = target2.cellIndex;
            const row = target2.parentNode.rowIndex;
            const selectedYear = row * 4 + column + startYear.value;
            const newDate = dayjs().year(selectedYear);
            if (props2.selectionMode === "range") {
              if (!props2.rangeState.selecting) {
                emit("pick", { minDate: newDate, maxDate: null });
                emit("select", true);
              } else {
                if (props2.minDate && newDate >= props2.minDate) {
                  emit("pick", { minDate: props2.minDate, maxDate: newDate });
                } else {
                  emit("pick", { minDate: newDate, maxDate: props2.minDate });
                }
                emit("select", false);
              }
            } else if (props2.selectionMode === "years") {
              if (event.type === "keydown") {
                emit("pick", castArray(props2.parsedValue), false);
                return;
              }
              const vaildYear = getValidDateOfYear(newDate.startOf("year"), lang2.value, props2.disabledDate);
              const newValue = hasClass(target2, "current") ? castArray(props2.parsedValue).filter((d2) => (d2 == null ? void 0 : d2.year()) !== selectedYear) : castArray(props2.parsedValue).concat([vaildYear]);
              emit("pick", newValue);
            } else {
              emit("pick", selectedYear);
            }
          };
          const handleMouseMove = (event) => {
            var _a;
            if (!props2.rangeState.selecting)
              return;
            const target2 = (_a = event.target) == null ? void 0 : _a.closest("td");
            if (!target2)
              return;
            const row = target2.parentNode.rowIndex;
            const column = target2.cellIndex;
            if (rows.value[row][column].disabled)
              return;
            if (row !== lastRow.value || column !== lastColumn.value) {
              lastRow.value = row;
              lastColumn.value = column;
              emit("changerange", {
                selecting: true,
                endDate: dayjs().year(startYear.value).add(row * 4 + column, "year")
              });
            }
          };
          watch(() => props2.date, async () => {
            var _a, _b;
            if ((_a = tbodyRef.value) == null ? void 0 : _a.contains(document.activeElement)) {
              await nextTick();
              (_b = currentCellRef.value) == null ? void 0 : _b.focus();
            }
          });
          expose({
            focus
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("table", {
              role: "grid",
              "aria-label": unref(t)("el.datepicker.yearTablePrompt"),
              class: normalizeClass(unref(ns).b()),
              onClick: handleYearTableClick,
              onMousemove: handleMouseMove
            }, [
              createElementVNode("tbody", {
                ref_key: "tbodyRef",
                ref: tbodyRef
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(rows), (row, rowKey2) => {
                  return openBlock(), createElementBlock("tr", { key: rowKey2 }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, cellKey) => {
                      return openBlock(), createElementBlock("td", {
                        key: `${rowKey2}_${cellKey}`,
                        ref_for: true,
                        ref: (el) => isSelectedCell(cell) && (currentCellRef.value = el),
                        class: normalizeClass(["available", getCellKls(cell)]),
                        "aria-selected": isSelectedCell(cell),
                        "aria-label": String(cell.text),
                        tabindex: isSelectedCell(cell) ? 0 : -1,
                        onKeydown: [
                          withKeys(withModifiers(handleYearTableClick, ["prevent", "stop"]), ["space"]),
                          withKeys(withModifiers(handleYearTableClick, ["prevent", "stop"]), ["enter"])
                        ]
                      }, [
                        createVNode(unref(ElDatePickerCell), { cell }, null, 8, ["cell"])
                      ], 42, ["aria-selected", "aria-label", "tabindex", "onKeydown"]);
                    }), 128))
                  ]);
                }), 128))
              ], 512)
            ], 42, ["aria-label"]);
          };
        }
      });
      var YearTable = /* @__PURE__ */ _export_sfc(_sfc_main$1z, [["__file", "basic-year-table.vue"]]);
      const _sfc_main$1y = /* @__PURE__ */ defineComponent({
        __name: "panel-date-pick",
        props: panelDatePickProps,
        emits: ["pick", "set-picker-option", "panel-change"],
        setup(__props, { emit: contextEmit }) {
          const props2 = __props;
          const timeWithinRange = (_2, __, ___) => true;
          const ppNs = useNamespace("picker-panel");
          const dpNs = useNamespace("date-picker");
          const attrs = useAttrs$1();
          const slots = useSlots();
          const { t, lang: lang2 } = useLocale();
          const pickerBase = inject(PICKER_BASE_INJECTION_KEY);
          const isDefaultFormat = inject(ROOT_PICKER_IS_DEFAULT_FORMAT_INJECTION_KEY);
          const popper = inject(TOOLTIP_INJECTION_KEY);
          const { shortcuts, disabledDate, cellClassName, defaultTime } = pickerBase.props;
          const defaultValue = toRef(pickerBase.props, "defaultValue");
          const currentViewRef = ref();
          const innerDate = ref(dayjs().locale(lang2.value));
          const isChangeToNow = ref(false);
          let isShortcut = false;
          const defaultTimeD = computed(() => {
            return dayjs(defaultTime).locale(lang2.value);
          });
          const month = computed(() => {
            return innerDate.value.month();
          });
          const year = computed(() => {
            return innerDate.value.year();
          });
          const selectableRange = ref([]);
          const userInputDate = ref(null);
          const userInputTime = ref(null);
          const checkDateWithinRange = (date3) => {
            return selectableRange.value.length > 0 ? timeWithinRange(date3, selectableRange.value, props2.format || "HH:mm:ss") : true;
          };
          const formatEmit = (emitDayjs) => {
            if (defaultTime && !visibleTime.value && !isChangeToNow.value && !isShortcut) {
              return defaultTimeD.value.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
            }
            if (showTime.value)
              return emitDayjs.millisecond(0);
            return emitDayjs.startOf("day");
          };
          const emit = (value, ...args) => {
            if (!value) {
              contextEmit("pick", value, ...args);
            } else if (isArray$1(value)) {
              const dates = value.map(formatEmit);
              contextEmit("pick", dates, ...args);
            } else {
              contextEmit("pick", formatEmit(value), ...args);
            }
            userInputDate.value = null;
            userInputTime.value = null;
            isChangeToNow.value = false;
            isShortcut = false;
          };
          const handleDatePick = async (value, keepOpen) => {
            if (selectionMode.value === "date") {
              value = value;
              let newDate = props2.parsedValue ? props2.parsedValue.year(value.year()).month(value.month()).date(value.date()) : value;
              if (!checkDateWithinRange(newDate)) {
                newDate = selectableRange.value[0][0].year(value.year()).month(value.month()).date(value.date());
              }
              innerDate.value = newDate;
              emit(newDate, showTime.value || keepOpen);
            } else if (selectionMode.value === "week") {
              emit(value.date);
            } else if (selectionMode.value === "dates") {
              emit(value, true);
            }
          };
          const moveByMonth = (forward) => {
            const action = forward ? "add" : "subtract";
            innerDate.value = innerDate.value[action](1, "month");
            handlePanelChange("month");
          };
          const moveByYear = (forward) => {
            const currentDate = innerDate.value;
            const action = forward ? "add" : "subtract";
            innerDate.value = currentView.value === "year" ? currentDate[action](10, "year") : currentDate[action](1, "year");
            handlePanelChange("year");
          };
          const currentView = ref("date");
          const yearLabel = computed(() => {
            const yearTranslation = t("el.datepicker.year");
            if (currentView.value === "year") {
              const startYear = Math.floor(year.value / 10) * 10;
              if (yearTranslation) {
                return `${startYear} ${yearTranslation} - ${startYear + 9} ${yearTranslation}`;
              }
              return `${startYear} - ${startYear + 9}`;
            }
            return `${year.value} ${yearTranslation}`;
          });
          const handleShortcutClick = (shortcut) => {
            const shortcutValue = isFunction$1(shortcut.value) ? shortcut.value() : shortcut.value;
            if (shortcutValue) {
              isShortcut = true;
              emit(dayjs(shortcutValue).locale(lang2.value));
              return;
            }
            if (shortcut.onClick) {
              shortcut.onClick({
                attrs,
                slots,
                emit: contextEmit
              });
            }
          };
          const selectionMode = computed(() => {
            const { type } = props2;
            if (["week", "month", "months", "year", "years", "dates"].includes(type))
              return type;
            return "date";
          });
          const isMultipleType = computed(() => {
            return selectionMode.value === "dates" || selectionMode.value === "months" || selectionMode.value === "years";
          });
          const keyboardMode = computed(() => {
            return selectionMode.value === "date" ? currentView.value : selectionMode.value;
          });
          const hasShortcuts = computed(() => !!shortcuts.length);
          const handleMonthPick = async (month2, keepOpen) => {
            if (selectionMode.value === "month") {
              innerDate.value = getValidDateOfMonth(innerDate.value, innerDate.value.year(), month2, lang2.value, disabledDate);
              emit(innerDate.value, false);
            } else if (selectionMode.value === "months") {
              emit(month2, keepOpen != null ? keepOpen : true);
            } else {
              innerDate.value = getValidDateOfMonth(innerDate.value, innerDate.value.year(), month2, lang2.value, disabledDate);
              currentView.value = "date";
              if (["month", "year", "date", "week"].includes(selectionMode.value)) {
                emit(innerDate.value, true);
                await nextTick();
                handleFocusPicker();
              }
            }
            handlePanelChange("month");
          };
          const handleYearPick = async (year2, keepOpen) => {
            if (selectionMode.value === "year") {
              const data = innerDate.value.startOf("year").year(year2);
              innerDate.value = getValidDateOfYear(data, lang2.value, disabledDate);
              emit(innerDate.value, false);
            } else if (selectionMode.value === "years") {
              emit(year2, keepOpen != null ? keepOpen : true);
            } else {
              const data = innerDate.value.year(year2);
              innerDate.value = getValidDateOfYear(data, lang2.value, disabledDate);
              currentView.value = "month";
              if (["month", "year", "date", "week"].includes(selectionMode.value)) {
                emit(innerDate.value, true);
                await nextTick();
                handleFocusPicker();
              }
            }
            handlePanelChange("year");
          };
          const showPicker = async (view) => {
            currentView.value = view;
            await nextTick();
            handleFocusPicker();
          };
          const showTime = computed(() => props2.type === "datetime" || props2.type === "datetimerange");
          const footerVisible = computed(() => {
            const showDateFooter = showTime.value || selectionMode.value === "dates";
            const showYearFooter = selectionMode.value === "years";
            const showMonthFooter = selectionMode.value === "months";
            const isDateView = currentView.value === "date";
            const isYearView = currentView.value === "year";
            const isMonthView = currentView.value === "month";
            return showDateFooter && isDateView || showYearFooter && isYearView || showMonthFooter && isMonthView;
          });
          const disabledConfirm = computed(() => {
            if (!disabledDate)
              return false;
            if (!props2.parsedValue)
              return true;
            if (isArray$1(props2.parsedValue)) {
              return disabledDate(props2.parsedValue[0].toDate());
            }
            return disabledDate(props2.parsedValue.toDate());
          });
          const onConfirm = () => {
            if (isMultipleType.value) {
              emit(props2.parsedValue);
            } else {
              let result2 = props2.parsedValue;
              if (!result2) {
                const defaultTimeD2 = dayjs(defaultTime).locale(lang2.value);
                const defaultValueD = getDefaultValue2();
                result2 = defaultTimeD2.year(defaultValueD.year()).month(defaultValueD.month()).date(defaultValueD.date());
              }
              innerDate.value = result2;
              emit(result2);
            }
          };
          const disabledNow = computed(() => {
            if (!disabledDate)
              return false;
            return disabledDate(dayjs().locale(lang2.value).toDate());
          });
          const changeToNow = () => {
            const now2 = dayjs().locale(lang2.value);
            const nowDate = now2.toDate();
            isChangeToNow.value = true;
            if ((!disabledDate || !disabledDate(nowDate)) && checkDateWithinRange(nowDate)) {
              innerDate.value = dayjs().locale(lang2.value);
              emit(innerDate.value);
            }
          };
          const timeFormat = computed(() => {
            return props2.timeFormat || extractTimeFormat(props2.format);
          });
          const dateFormat = computed(() => {
            return props2.dateFormat || extractDateFormat(props2.format);
          });
          const visibleTime = computed(() => {
            if (userInputTime.value)
              return userInputTime.value;
            if (!props2.parsedValue && !defaultValue.value)
              return;
            return (props2.parsedValue || innerDate.value).format(timeFormat.value);
          });
          const visibleDate = computed(() => {
            if (userInputDate.value)
              return userInputDate.value;
            if (!props2.parsedValue && !defaultValue.value)
              return;
            return (props2.parsedValue || innerDate.value).format(dateFormat.value);
          });
          const timePickerVisible = ref(false);
          const onTimePickerInputFocus = () => {
            timePickerVisible.value = true;
          };
          const handleTimePickClose = () => {
            timePickerVisible.value = false;
          };
          const getUnits = (date3) => {
            return {
              hour: date3.hour(),
              minute: date3.minute(),
              second: date3.second(),
              year: date3.year(),
              month: date3.month(),
              date: date3.date()
            };
          };
          const handleTimePick = (value, visible, first) => {
            const { hour, minute, second } = getUnits(value);
            const newDate = props2.parsedValue ? props2.parsedValue.hour(hour).minute(minute).second(second) : value;
            innerDate.value = newDate;
            emit(innerDate.value, true);
            if (!first) {
              timePickerVisible.value = visible;
            }
          };
          const handleVisibleTimeChange = (value) => {
            const newDate = dayjs(value, timeFormat.value).locale(lang2.value);
            if (newDate.isValid() && checkDateWithinRange(newDate)) {
              const { year: year2, month: month2, date: date3 } = getUnits(innerDate.value);
              innerDate.value = newDate.year(year2).month(month2).date(date3);
              userInputTime.value = null;
              timePickerVisible.value = false;
              emit(innerDate.value, true);
            }
          };
          const handleVisibleDateChange = (value) => {
            const newDate = correctlyParseUserInput(value, dateFormat.value, lang2.value, isDefaultFormat);
            if (newDate.isValid()) {
              if (disabledDate && disabledDate(newDate.toDate())) {
                return;
              }
              const { hour, minute, second } = getUnits(innerDate.value);
              innerDate.value = newDate.hour(hour).minute(minute).second(second);
              userInputDate.value = null;
              emit(innerDate.value, true);
            }
          };
          const isValidValue2 = (date3) => {
            return dayjs.isDayjs(date3) && date3.isValid() && (disabledDate ? !disabledDate(date3.toDate()) : true);
          };
          const formatToString = (value) => {
            return isArray$1(value) ? value.map((_2) => _2.format(props2.format)) : value.format(props2.format);
          };
          const parseUserInput = (value) => {
            return correctlyParseUserInput(value, props2.format, lang2.value, isDefaultFormat);
          };
          const getDefaultValue2 = () => {
            const parseDate2 = dayjs(defaultValue.value).locale(lang2.value);
            if (!defaultValue.value) {
              const defaultTimeDValue = defaultTimeD.value;
              return dayjs().hour(defaultTimeDValue.hour()).minute(defaultTimeDValue.minute()).second(defaultTimeDValue.second()).locale(lang2.value);
            }
            return parseDate2;
          };
          const handleFocusPicker = () => {
            var _a;
            if (["week", "month", "year", "date"].includes(selectionMode.value)) {
              (_a = currentViewRef.value) == null ? void 0 : _a.focus();
            }
          };
          const _handleFocusPicker = () => {
            handleFocusPicker();
            if (selectionMode.value === "week") {
              handleKeyControl(EVENT_CODE.down);
            }
          };
          const handleKeydownTable = (event) => {
            const { code } = event;
            const validCode = [
              EVENT_CODE.up,
              EVENT_CODE.down,
              EVENT_CODE.left,
              EVENT_CODE.right,
              EVENT_CODE.home,
              EVENT_CODE.end,
              EVENT_CODE.pageUp,
              EVENT_CODE.pageDown
            ];
            if (validCode.includes(code)) {
              handleKeyControl(code);
              event.stopPropagation();
              event.preventDefault();
            }
            if ([EVENT_CODE.enter, EVENT_CODE.space, EVENT_CODE.numpadEnter].includes(code) && userInputDate.value === null && userInputTime.value === null) {
              event.preventDefault();
              emit(innerDate.value, false);
            }
          };
          const handleKeyControl = (code) => {
            var _a;
            const { up, down, left, right, home, end, pageUp, pageDown } = EVENT_CODE;
            const mapping = {
              year: {
                [up]: -4,
                [down]: 4,
                [left]: -1,
                [right]: 1,
                offset: (date3, step2) => date3.setFullYear(date3.getFullYear() + step2)
              },
              month: {
                [up]: -4,
                [down]: 4,
                [left]: -1,
                [right]: 1,
                offset: (date3, step2) => date3.setMonth(date3.getMonth() + step2)
              },
              week: {
                [up]: -1,
                [down]: 1,
                [left]: -1,
                [right]: 1,
                offset: (date3, step2) => date3.setDate(date3.getDate() + step2 * 7)
              },
              date: {
                [up]: -7,
                [down]: 7,
                [left]: -1,
                [right]: 1,
                [home]: (date3) => -date3.getDay(),
                [end]: (date3) => -date3.getDay() + 6,
                [pageUp]: (date3) => -new Date(date3.getFullYear(), date3.getMonth(), 0).getDate(),
                [pageDown]: (date3) => new Date(date3.getFullYear(), date3.getMonth() + 1, 0).getDate(),
                offset: (date3, step2) => date3.setDate(date3.getDate() + step2)
              }
            };
            const newDate = innerDate.value.toDate();
            while (Math.abs(innerDate.value.diff(newDate, "year", true)) < 1) {
              const map2 = mapping[keyboardMode.value];
              if (!map2)
                return;
              map2.offset(newDate, isFunction$1(map2[code]) ? map2[code](newDate) : (_a = map2[code]) != null ? _a : 0);
              if (disabledDate && disabledDate(newDate)) {
                break;
              }
              const result2 = dayjs(newDate).locale(lang2.value);
              innerDate.value = result2;
              contextEmit("pick", result2, true);
              break;
            }
          };
          const handlePanelChange = (mode) => {
            contextEmit("panel-change", innerDate.value.toDate(), mode, currentView.value);
          };
          watch(() => selectionMode.value, (val) => {
            if (["month", "year"].includes(val)) {
              currentView.value = val;
              return;
            } else if (val === "years") {
              currentView.value = "year";
              return;
            } else if (val === "months") {
              currentView.value = "month";
              return;
            }
            currentView.value = "date";
          }, { immediate: true });
          watch(() => currentView.value, () => {
            popper == null ? void 0 : popper.updatePopper();
          });
          watch(() => defaultValue.value, (val) => {
            if (val) {
              innerDate.value = getDefaultValue2();
            }
          }, { immediate: true });
          watch(() => props2.parsedValue, (val) => {
            if (val) {
              if (isMultipleType.value)
                return;
              if (isArray$1(val))
                return;
              innerDate.value = val;
            } else {
              innerDate.value = getDefaultValue2();
            }
          }, { immediate: true });
          contextEmit("set-picker-option", ["isValidValue", isValidValue2]);
          contextEmit("set-picker-option", ["formatToString", formatToString]);
          contextEmit("set-picker-option", ["parseUserInput", parseUserInput]);
          contextEmit("set-picker-option", ["handleFocusPicker", _handleFocusPicker]);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ppNs).b(),
                unref(dpNs).b(),
                {
                  "has-sidebar": _ctx.$slots.sidebar || unref(hasShortcuts),
                  "has-time": unref(showTime)
                }
              ])
            }, [
              createElementVNode("div", {
                class: normalizeClass(unref(ppNs).e("body-wrapper"))
              }, [
                renderSlot(_ctx.$slots, "sidebar", {
                  class: normalizeClass(unref(ppNs).e("sidebar"))
                }),
                unref(hasShortcuts) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ppNs).e("sidebar"))
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(shortcuts), (shortcut, key) => {
                    return openBlock(), createElementBlock("button", {
                      key,
                      type: "button",
                      class: normalizeClass(unref(ppNs).e("shortcut")),
                      onClick: ($event) => handleShortcutClick(shortcut)
                    }, toDisplayString(shortcut.text), 11, ["onClick"]);
                  }), 128))
                ], 2)) : createCommentVNode("v-if", true),
                createElementVNode("div", {
                  class: normalizeClass(unref(ppNs).e("body"))
                }, [
                  unref(showTime) ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(unref(dpNs).e("time-header"))
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass(unref(dpNs).e("editor-wrap"))
                    }, [
                      createVNode(unref(ElInput), {
                        placeholder: unref(t)("el.datepicker.selectDate"),
                        "model-value": unref(visibleDate),
                        size: "small",
                        "validate-event": false,
                        onInput: (val) => userInputDate.value = val,
                        onChange: handleVisibleDateChange
                      }, null, 8, ["placeholder", "model-value", "onInput"])
                    ], 2),
                    withDirectives((openBlock(), createElementBlock("span", {
                      class: normalizeClass(unref(dpNs).e("editor-wrap"))
                    }, [
                      createVNode(unref(ElInput), {
                        placeholder: unref(t)("el.datepicker.selectTime"),
                        "model-value": unref(visibleTime),
                        size: "small",
                        "validate-event": false,
                        onFocus: onTimePickerInputFocus,
                        onInput: (val) => userInputTime.value = val,
                        onChange: handleVisibleTimeChange
                      }, null, 8, ["placeholder", "model-value", "onInput"]),
                      createVNode(unref(TimePickPanel), {
                        visible: timePickerVisible.value,
                        format: unref(timeFormat),
                        "parsed-value": innerDate.value,
                        onPick: handleTimePick
                      }, null, 8, ["visible", "format", "parsed-value"])
                    ], 2)), [
                      [unref(ClickOutside), handleTimePickClose]
                    ])
                  ], 2)) : createCommentVNode("v-if", true),
                  withDirectives(createElementVNode("div", {
                    class: normalizeClass([
                      unref(dpNs).e("header"),
                      (currentView.value === "year" || currentView.value === "month") && unref(dpNs).e("header--bordered")
                    ])
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass(unref(dpNs).e("prev-btn"))
                    }, [
                      createElementVNode("button", {
                        type: "button",
                        "aria-label": unref(t)(`el.datepicker.prevYear`),
                        class: normalizeClass(["d-arrow-left", unref(ppNs).e("icon-btn")]),
                        onClick: ($event) => moveByYear(false)
                      }, [
                        renderSlot(_ctx.$slots, "prev-year", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(d_arrow_left_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["aria-label", "onClick"]),
                      withDirectives(createElementVNode("button", {
                        type: "button",
                        "aria-label": unref(t)(`el.datepicker.prevMonth`),
                        class: normalizeClass([unref(ppNs).e("icon-btn"), "arrow-left"]),
                        onClick: ($event) => moveByMonth(false)
                      }, [
                        renderSlot(_ctx.$slots, "prev-month", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(arrow_left_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["aria-label", "onClick"]), [
                        [vShow, currentView.value === "date"]
                      ])
                    ], 2),
                    createElementVNode("span", {
                      role: "button",
                      class: normalizeClass(unref(dpNs).e("header-label")),
                      "aria-live": "polite",
                      tabindex: "0",
                      onKeydown: withKeys(($event) => showPicker("year"), ["enter"]),
                      onClick: ($event) => showPicker("year")
                    }, toDisplayString(unref(yearLabel)), 43, ["onKeydown", "onClick"]),
                    withDirectives(createElementVNode("span", {
                      role: "button",
                      "aria-live": "polite",
                      tabindex: "0",
                      class: normalizeClass([
                        unref(dpNs).e("header-label"),
                        { active: currentView.value === "month" }
                      ]),
                      onKeydown: withKeys(($event) => showPicker("month"), ["enter"]),
                      onClick: ($event) => showPicker("month")
                    }, toDisplayString(unref(t)(`el.datepicker.month${unref(month) + 1}`)), 43, ["onKeydown", "onClick"]), [
                      [vShow, currentView.value === "date"]
                    ]),
                    createElementVNode("span", {
                      class: normalizeClass(unref(dpNs).e("next-btn"))
                    }, [
                      withDirectives(createElementVNode("button", {
                        type: "button",
                        "aria-label": unref(t)(`el.datepicker.nextMonth`),
                        class: normalizeClass([unref(ppNs).e("icon-btn"), "arrow-right"]),
                        onClick: ($event) => moveByMonth(true)
                      }, [
                        renderSlot(_ctx.$slots, "next-month", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(arrow_right_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["aria-label", "onClick"]), [
                        [vShow, currentView.value === "date"]
                      ]),
                      createElementVNode("button", {
                        type: "button",
                        "aria-label": unref(t)(`el.datepicker.nextYear`),
                        class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-right"]),
                        onClick: ($event) => moveByYear(true)
                      }, [
                        renderSlot(_ctx.$slots, "next-year", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(d_arrow_right_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["aria-label", "onClick"])
                    ], 2)
                  ], 2), [
                    [vShow, currentView.value !== "time"]
                  ]),
                  createElementVNode("div", {
                    class: normalizeClass(unref(ppNs).e("content")),
                    onKeydown: handleKeydownTable
                  }, [
                    currentView.value === "date" ? (openBlock(), createBlock(DateTable, {
                      key: 0,
                      ref_key: "currentViewRef",
                      ref: currentViewRef,
                      "selection-mode": unref(selectionMode),
                      date: innerDate.value,
                      "parsed-value": _ctx.parsedValue,
                      "disabled-date": unref(disabledDate),
                      "cell-class-name": unref(cellClassName),
                      "show-week-number": _ctx.showWeekNumber,
                      onPick: handleDatePick
                    }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "cell-class-name", "show-week-number"])) : createCommentVNode("v-if", true),
                    currentView.value === "year" ? (openBlock(), createBlock(YearTable, {
                      key: 1,
                      ref_key: "currentViewRef",
                      ref: currentViewRef,
                      "selection-mode": unref(selectionMode),
                      date: innerDate.value,
                      "disabled-date": unref(disabledDate),
                      "parsed-value": _ctx.parsedValue,
                      onPick: handleYearPick
                    }, null, 8, ["selection-mode", "date", "disabled-date", "parsed-value"])) : createCommentVNode("v-if", true),
                    currentView.value === "month" ? (openBlock(), createBlock(MonthTable, {
                      key: 2,
                      ref_key: "currentViewRef",
                      ref: currentViewRef,
                      "selection-mode": unref(selectionMode),
                      date: innerDate.value,
                      "parsed-value": _ctx.parsedValue,
                      "disabled-date": unref(disabledDate),
                      onPick: handleMonthPick
                    }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date"])) : createCommentVNode("v-if", true)
                  ], 34)
                ], 2)
              ], 2),
              _ctx.showFooter && unref(footerVisible) ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ppNs).e("footer"))
              }, [
                withDirectives(createVNode(unref(ElButton), {
                  text: "",
                  size: "small",
                  class: normalizeClass(unref(ppNs).e("link-btn")),
                  disabled: unref(disabledNow),
                  onClick: changeToNow
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(unref(t)("el.datepicker.now")), 1)
                  ]),
                  _: 1
                }, 8, ["class", "disabled"]), [
                  [vShow, !unref(isMultipleType) && _ctx.showNow]
                ]),
                createVNode(unref(ElButton), {
                  plain: "",
                  size: "small",
                  class: normalizeClass(unref(ppNs).e("link-btn")),
                  disabled: unref(disabledConfirm),
                  onClick: onConfirm
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(unref(t)("el.datepicker.confirm")), 1)
                  ]),
                  _: 1
                }, 8, ["class", "disabled"])
              ], 2)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var DatePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1y, [["__file", "panel-date-pick.vue"]]);
      const panelDateRangeProps = buildProps({
        ...panelSharedProps,
        ...panelRangeSharedProps
      });
      const useShortcut = (lang2) => {
        const { emit } = getCurrentInstance();
        const attrs = useAttrs$1();
        const slots = useSlots();
        const handleShortcutClick = (shortcut) => {
          const shortcutValues = isFunction$1(shortcut.value) ? shortcut.value() : shortcut.value;
          if (shortcutValues) {
            emit("pick", [
              dayjs(shortcutValues[0]).locale(lang2.value),
              dayjs(shortcutValues[1]).locale(lang2.value)
            ]);
            return;
          }
          if (shortcut.onClick) {
            shortcut.onClick({
              attrs,
              slots,
              emit
            });
          }
        };
        return handleShortcutClick;
      };
      const useRangePicker = (props2, {
        defaultValue,
        defaultTime,
        leftDate,
        rightDate,
        step: step2,
        unit: unit2,
        onParsedValueChanged
      }) => {
        const { emit } = getCurrentInstance();
        const { pickerNs } = inject(ROOT_PICKER_INJECTION_KEY);
        const drpNs = useNamespace("date-range-picker");
        const { t, lang: lang2 } = useLocale();
        const handleShortcutClick = useShortcut(lang2);
        const minDate = ref();
        const maxDate = ref();
        const rangeState = ref({
          endDate: null,
          selecting: false
        });
        const handleChangeRange = (val) => {
          rangeState.value = val;
        };
        const handleRangeConfirm = (visible = false) => {
          const _minDate = unref(minDate);
          const _maxDate = unref(maxDate);
          if (isValidRange([_minDate, _maxDate])) {
            emit("pick", [_minDate, _maxDate], visible);
          }
        };
        const onSelect = (selecting) => {
          rangeState.value.selecting = selecting;
          if (!selecting) {
            rangeState.value.endDate = null;
          }
        };
        const onReset = (parsedValue) => {
          if (isArray$1(parsedValue) && parsedValue.length === 2) {
            const [start, end] = parsedValue;
            minDate.value = start;
            leftDate.value = start;
            maxDate.value = end;
            onParsedValueChanged(unref(minDate), unref(maxDate));
          } else {
            restoreDefault();
          }
        };
        const restoreDefault = () => {
          let [start, end] = getDefaultValue(unref(defaultValue), {
            lang: unref(lang2),
            step: step2,
            unit: unit2,
            unlinkPanels: props2.unlinkPanels
          });
          const getShift = (day) => {
            return day.diff(day.startOf("d"), "ms");
          };
          const maybeTimes = unref(defaultTime);
          if (maybeTimes) {
            let leftShift = 0;
            let rightShift = 0;
            if (isArray$1(maybeTimes)) {
              const [timeStart, timeEnd] = maybeTimes.map(dayjs);
              leftShift = getShift(timeStart);
              rightShift = getShift(timeEnd);
            } else {
              const shift2 = getShift(dayjs(maybeTimes));
              leftShift = shift2;
              rightShift = shift2;
            }
            start = start.startOf("d").add(leftShift, "ms");
            end = end.startOf("d").add(rightShift, "ms");
          }
          minDate.value = void 0;
          maxDate.value = void 0;
          leftDate.value = start;
          rightDate.value = end;
        };
        watch(defaultValue, (val) => {
          if (val) {
            restoreDefault();
          }
        }, { immediate: true });
        watch(() => props2.parsedValue, (parsedValue) => {
          if (!(parsedValue == null ? void 0 : parsedValue.length)) {
            onReset(parsedValue);
          }
        }, { immediate: true });
        watch(() => props2.visible, () => {
          if (props2.visible) {
            onReset(props2.parsedValue);
          }
        }, { immediate: true });
        return {
          minDate,
          maxDate,
          rangeState,
          lang: lang2,
          ppNs: pickerNs,
          drpNs,
          handleChangeRange,
          handleRangeConfirm,
          handleShortcutClick,
          onSelect,
          onReset,
          t
        };
      };
      const usePanelDateRange = (props2, emit, leftDate, rightDate) => {
        const leftCurrentView = ref("date");
        const leftCurrentViewRef = ref();
        const rightCurrentView = ref("date");
        const rightCurrentViewRef = ref();
        const pickerBase = inject(PICKER_BASE_INJECTION_KEY);
        const { disabledDate } = pickerBase.props;
        const { t, lang: lang2 } = useLocale();
        const leftYear = computed(() => {
          return leftDate.value.year();
        });
        const leftMonth = computed(() => {
          return leftDate.value.month();
        });
        const rightYear = computed(() => {
          return rightDate.value.year();
        });
        const rightMonth = computed(() => {
          return rightDate.value.month();
        });
        function computedYearLabel(currentView, yearValue) {
          const yearTranslation = t("el.datepicker.year");
          if (currentView.value === "year") {
            const startYear = Math.floor(yearValue.value / 10) * 10;
            return yearTranslation ? `${startYear} ${yearTranslation} - ${startYear + 9} ${yearTranslation}` : `${startYear} - ${startYear + 9}`;
          }
          return `${yearValue.value} ${yearTranslation}`;
        }
        function focusPicker(currentViewRef) {
          currentViewRef == null ? void 0 : currentViewRef.focus();
        }
        async function showPicker(pickerType, view) {
          const currentView = pickerType === "left" ? leftCurrentView : rightCurrentView;
          const currentViewRef = pickerType === "left" ? leftCurrentViewRef : rightCurrentViewRef;
          currentView.value = view;
          await nextTick();
          focusPicker(currentViewRef.value);
        }
        async function handlePick(mode, pickerType, value) {
          const isLeftPicker = pickerType === "left";
          const startDate = isLeftPicker ? leftDate : rightDate;
          const endDate = isLeftPicker ? rightDate : leftDate;
          const currentView = isLeftPicker ? leftCurrentView : rightCurrentView;
          const currentViewRef = isLeftPicker ? leftCurrentViewRef : rightCurrentViewRef;
          if (mode === "year") {
            const data = startDate.value.year(value);
            startDate.value = getValidDateOfYear(data, lang2.value, disabledDate);
          }
          if (mode === "month") {
            startDate.value = getValidDateOfMonth(startDate.value, startDate.value.year(), value, lang2.value, disabledDate);
          }
          if (!props2.unlinkPanels) {
            endDate.value = pickerType === "left" ? startDate.value.add(1, "month") : startDate.value.subtract(1, "month");
          }
          currentView.value = mode === "year" ? "month" : "date";
          await nextTick();
          focusPicker(currentViewRef.value);
          handlePanelChange(mode);
        }
        function handlePanelChange(mode) {
          emit("panel-change", [leftDate.value.toDate(), rightDate.value.toDate()], mode);
        }
        function adjustDateByView(currentView, date3, forward) {
          const action = forward ? "add" : "subtract";
          return currentView === "year" ? date3[action](10, "year") : date3[action](1, "year");
        }
        return {
          leftCurrentView,
          rightCurrentView,
          leftCurrentViewRef,
          rightCurrentViewRef,
          leftYear,
          rightYear,
          leftMonth,
          rightMonth,
          leftYearLabel: computed(() => computedYearLabel(leftCurrentView, leftYear)),
          rightYearLabel: computed(() => computedYearLabel(rightCurrentView, rightYear)),
          showLeftPicker: (view) => showPicker("left", view),
          showRightPicker: (view) => showPicker("right", view),
          handleLeftYearPick: (year) => handlePick("year", "left", year),
          handleRightYearPick: (year) => handlePick("year", "right", year),
          handleLeftMonthPick: (month) => handlePick("month", "left", month),
          handleRightMonthPick: (month) => handlePick("month", "right", month),
          handlePanelChange,
          adjustDateByView
        };
      };
      const unit$2 = "month";
      const _sfc_main$1x = /* @__PURE__ */ defineComponent({
        __name: "panel-date-range",
        props: panelDateRangeProps,
        emits: [
          "pick",
          "set-picker-option",
          "calendar-change",
          "panel-change"
        ],
        setup(__props, { emit }) {
          const props2 = __props;
          const pickerBase = inject(PICKER_BASE_INJECTION_KEY);
          const isDefaultFormat = inject(ROOT_PICKER_IS_DEFAULT_FORMAT_INJECTION_KEY);
          const { disabledDate, cellClassName, defaultTime, clearable } = pickerBase.props;
          const format2 = toRef(pickerBase.props, "format");
          const shortcuts = toRef(pickerBase.props, "shortcuts");
          const defaultValue = toRef(pickerBase.props, "defaultValue");
          const { lang: lang2 } = useLocale();
          const leftDate = ref(dayjs().locale(lang2.value));
          const rightDate = ref(dayjs().locale(lang2.value).add(1, unit$2));
          let shouldBeVisible = true;
          const {
            minDate,
            maxDate,
            rangeState,
            ppNs,
            drpNs,
            handleChangeRange,
            handleRangeConfirm,
            handleShortcutClick,
            onSelect,
            onReset,
            t
          } = useRangePicker(props2, {
            defaultValue,
            defaultTime,
            leftDate,
            rightDate,
            unit: unit$2,
            onParsedValueChanged
          });
          watch(() => props2.visible, (visible) => {
            if (!visible && rangeState.value.selecting) {
              onReset(props2.parsedValue);
              onSelect(false);
            }
          });
          const dateUserInput = ref({
            min: null,
            max: null
          });
          const timeUserInput = ref({
            min: null,
            max: null
          });
          const {
            leftCurrentView,
            rightCurrentView,
            leftCurrentViewRef,
            rightCurrentViewRef,
            leftYear,
            rightYear,
            leftMonth,
            rightMonth,
            leftYearLabel,
            rightYearLabel,
            showLeftPicker,
            showRightPicker,
            handleLeftYearPick,
            handleRightYearPick,
            handleLeftMonthPick,
            handleRightMonthPick,
            handlePanelChange,
            adjustDateByView
          } = usePanelDateRange(props2, emit, leftDate, rightDate);
          const hasShortcuts = computed(() => !!shortcuts.value.length);
          const minVisibleDate = computed(() => {
            if (dateUserInput.value.min !== null)
              return dateUserInput.value.min;
            if (minDate.value)
              return minDate.value.format(dateFormat.value);
            return "";
          });
          const maxVisibleDate = computed(() => {
            if (dateUserInput.value.max !== null)
              return dateUserInput.value.max;
            if (maxDate.value || minDate.value)
              return (maxDate.value || minDate.value).format(dateFormat.value);
            return "";
          });
          const minVisibleTime = computed(() => {
            if (timeUserInput.value.min !== null)
              return timeUserInput.value.min;
            if (minDate.value)
              return minDate.value.format(timeFormat.value);
            return "";
          });
          const maxVisibleTime = computed(() => {
            if (timeUserInput.value.max !== null)
              return timeUserInput.value.max;
            if (maxDate.value || minDate.value)
              return (maxDate.value || minDate.value).format(timeFormat.value);
            return "";
          });
          const timeFormat = computed(() => {
            return props2.timeFormat || extractTimeFormat(format2.value);
          });
          const dateFormat = computed(() => {
            return props2.dateFormat || extractDateFormat(format2.value);
          });
          const isValidValue2 = (date3) => {
            return isValidRange(date3) && (disabledDate ? !disabledDate(date3[0].toDate()) && !disabledDate(date3[1].toDate()) : true);
          };
          const leftPrevYear = () => {
            leftDate.value = adjustDateByView(leftCurrentView.value, leftDate.value, false);
            if (!props2.unlinkPanels) {
              rightDate.value = leftDate.value.add(1, "month");
            }
            handlePanelChange("year");
          };
          const leftPrevMonth = () => {
            leftDate.value = leftDate.value.subtract(1, "month");
            if (!props2.unlinkPanels) {
              rightDate.value = leftDate.value.add(1, "month");
            }
            handlePanelChange("month");
          };
          const rightNextYear = () => {
            if (!props2.unlinkPanels) {
              leftDate.value = adjustDateByView(rightCurrentView.value, leftDate.value, true);
              rightDate.value = leftDate.value.add(1, "month");
            } else {
              rightDate.value = adjustDateByView(rightCurrentView.value, rightDate.value, true);
            }
            handlePanelChange("year");
          };
          const rightNextMonth = () => {
            if (!props2.unlinkPanels) {
              leftDate.value = leftDate.value.add(1, "month");
              rightDate.value = leftDate.value.add(1, "month");
            } else {
              rightDate.value = rightDate.value.add(1, "month");
            }
            handlePanelChange("month");
          };
          const leftNextYear = () => {
            leftDate.value = adjustDateByView(leftCurrentView.value, leftDate.value, true);
            handlePanelChange("year");
          };
          const leftNextMonth = () => {
            leftDate.value = leftDate.value.add(1, "month");
            handlePanelChange("month");
          };
          const rightPrevYear = () => {
            rightDate.value = adjustDateByView(rightCurrentView.value, rightDate.value, false);
            handlePanelChange("year");
          };
          const rightPrevMonth = () => {
            rightDate.value = rightDate.value.subtract(1, "month");
            handlePanelChange("month");
          };
          const enableMonthArrow = computed(() => {
            const nextMonth = (leftMonth.value + 1) % 12;
            const yearOffset = leftMonth.value + 1 >= 12 ? 1 : 0;
            return props2.unlinkPanels && new Date(leftYear.value + yearOffset, nextMonth) < new Date(rightYear.value, rightMonth.value);
          });
          const enableYearArrow = computed(() => {
            return props2.unlinkPanels && rightYear.value * 12 + rightMonth.value - (leftYear.value * 12 + leftMonth.value + 1) >= 12;
          });
          const btnDisabled = computed(() => {
            return !(minDate.value && maxDate.value && !rangeState.value.selecting && isValidRange([minDate.value, maxDate.value]));
          });
          const showTime = computed(() => props2.type === "datetime" || props2.type === "datetimerange");
          const formatEmit = (emitDayjs, index2) => {
            if (!emitDayjs)
              return;
            if (defaultTime) {
              const defaultTimeD = dayjs(defaultTime[index2] || defaultTime).locale(lang2.value);
              return defaultTimeD.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
            }
            return emitDayjs;
          };
          const handleRangePick = (val, close2 = true) => {
            const min_ = val.minDate;
            const max_ = val.maxDate;
            const minDate_ = formatEmit(min_, 0);
            const maxDate_ = formatEmit(max_, 1);
            if (maxDate.value === maxDate_ && minDate.value === minDate_) {
              return;
            }
            emit("calendar-change", [min_.toDate(), max_ && max_.toDate()]);
            maxDate.value = maxDate_;
            minDate.value = minDate_;
            if (!showTime.value && close2) {
              close2 = !minDate_ || !maxDate_;
            }
            shouldBeVisible = close2;
          };
          watch([maxDate, minDate], ([max2, min2]) => {
            if (max2 && min2) {
              handleRangeConfirm(shouldBeVisible);
              shouldBeVisible = true;
            }
          });
          const minTimePickerVisible = ref(false);
          const maxTimePickerVisible = ref(false);
          const handleMinTimeClose = () => {
            minTimePickerVisible.value = false;
          };
          const handleMaxTimeClose = () => {
            maxTimePickerVisible.value = false;
          };
          const handleDateInput = (value, type) => {
            dateUserInput.value[type] = value;
            const parsedValueD = dayjs(value, dateFormat.value).locale(lang2.value);
            if (parsedValueD.isValid()) {
              if (disabledDate && disabledDate(parsedValueD.toDate())) {
                return;
              }
              if (type === "min") {
                leftDate.value = parsedValueD;
                minDate.value = (minDate.value || leftDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
                if (!props2.unlinkPanels && (!maxDate.value || maxDate.value.isBefore(minDate.value))) {
                  rightDate.value = parsedValueD.add(1, "month");
                  maxDate.value = minDate.value.add(1, "month");
                }
              } else {
                rightDate.value = parsedValueD;
                maxDate.value = (maxDate.value || rightDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
                if (!props2.unlinkPanels && (!minDate.value || minDate.value.isAfter(maxDate.value))) {
                  leftDate.value = parsedValueD.subtract(1, "month");
                  minDate.value = maxDate.value.subtract(1, "month");
                }
              }
            }
          };
          const handleDateChange = (_2, type) => {
            dateUserInput.value[type] = null;
          };
          const handleTimeInput = (value, type) => {
            timeUserInput.value[type] = value;
            const parsedValueD = dayjs(value, timeFormat.value).locale(lang2.value);
            if (parsedValueD.isValid()) {
              if (type === "min") {
                minTimePickerVisible.value = true;
                minDate.value = (minDate.value || leftDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
              } else {
                maxTimePickerVisible.value = true;
                maxDate.value = (maxDate.value || rightDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
                rightDate.value = maxDate.value;
              }
            }
          };
          const handleTimeChange = (_value, type) => {
            timeUserInput.value[type] = null;
            if (type === "min") {
              leftDate.value = minDate.value;
              minTimePickerVisible.value = false;
              if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
                maxDate.value = minDate.value;
              }
            } else {
              rightDate.value = maxDate.value;
              maxTimePickerVisible.value = false;
              if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
                minDate.value = maxDate.value;
              }
            }
          };
          const handleMinTimePick = (value, visible, first) => {
            if (timeUserInput.value.min)
              return;
            if (value) {
              leftDate.value = value;
              minDate.value = (minDate.value || leftDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
            }
            if (!first) {
              minTimePickerVisible.value = visible;
            }
            if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
              maxDate.value = minDate.value;
              rightDate.value = value;
              nextTick(() => {
                onReset(props2.parsedValue);
              });
            }
          };
          const handleMaxTimePick = (value, visible, first) => {
            if (timeUserInput.value.max)
              return;
            if (value) {
              rightDate.value = value;
              maxDate.value = (maxDate.value || rightDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
            }
            if (!first) {
              maxTimePickerVisible.value = visible;
            }
            if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
              minDate.value = maxDate.value;
            }
          };
          const handleClear = () => {
            leftDate.value = getDefaultValue(unref(defaultValue), {
              lang: unref(lang2),
              unit: "month",
              unlinkPanels: props2.unlinkPanels
            })[0];
            rightDate.value = leftDate.value.add(1, "month");
            maxDate.value = void 0;
            minDate.value = void 0;
            emit("pick", null);
          };
          const formatToString = (value) => {
            return isArray$1(value) ? value.map((_2) => _2.format(format2.value)) : value.format(format2.value);
          };
          const parseUserInput = (value) => {
            return correctlyParseUserInput(value, format2.value, lang2.value, isDefaultFormat);
          };
          function onParsedValueChanged(minDate2, maxDate2) {
            if (props2.unlinkPanels && maxDate2) {
              const minDateYear = (minDate2 == null ? void 0 : minDate2.year()) || 0;
              const minDateMonth = (minDate2 == null ? void 0 : minDate2.month()) || 0;
              const maxDateYear = maxDate2.year();
              const maxDateMonth = maxDate2.month();
              rightDate.value = minDateYear === maxDateYear && minDateMonth === maxDateMonth ? maxDate2.add(1, unit$2) : maxDate2;
            } else {
              rightDate.value = leftDate.value.add(1, unit$2);
              if (maxDate2) {
                rightDate.value = rightDate.value.hour(maxDate2.hour()).minute(maxDate2.minute()).second(maxDate2.second());
              }
            }
          }
          emit("set-picker-option", ["isValidValue", isValidValue2]);
          emit("set-picker-option", ["parseUserInput", parseUserInput]);
          emit("set-picker-option", ["formatToString", formatToString]);
          emit("set-picker-option", ["handleClear", handleClear]);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ppNs).b(),
                unref(drpNs).b(),
                {
                  "has-sidebar": _ctx.$slots.sidebar || unref(hasShortcuts),
                  "has-time": unref(showTime)
                }
              ])
            }, [
              createElementVNode("div", {
                class: normalizeClass(unref(ppNs).e("body-wrapper"))
              }, [
                renderSlot(_ctx.$slots, "sidebar", {
                  class: normalizeClass(unref(ppNs).e("sidebar"))
                }),
                unref(hasShortcuts) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ppNs).e("sidebar"))
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(shortcuts), (shortcut, key) => {
                    return openBlock(), createElementBlock("button", {
                      key,
                      type: "button",
                      class: normalizeClass(unref(ppNs).e("shortcut")),
                      onClick: ($event) => unref(handleShortcutClick)(shortcut)
                    }, toDisplayString(shortcut.text), 11, ["onClick"]);
                  }), 128))
                ], 2)) : createCommentVNode("v-if", true),
                createElementVNode("div", {
                  class: normalizeClass(unref(ppNs).e("body"))
                }, [
                  unref(showTime) ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(unref(drpNs).e("time-header"))
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass(unref(drpNs).e("editors-wrap"))
                    }, [
                      createElementVNode("span", {
                        class: normalizeClass(unref(drpNs).e("time-picker-wrap"))
                      }, [
                        createVNode(unref(ElInput), {
                          size: "small",
                          disabled: unref(rangeState).selecting,
                          placeholder: unref(t)("el.datepicker.startDate"),
                          class: normalizeClass(unref(drpNs).e("editor")),
                          "model-value": unref(minVisibleDate),
                          "validate-event": false,
                          onInput: (val) => handleDateInput(val, "min"),
                          onChange: (val) => handleDateChange(val, "min")
                        }, null, 8, ["disabled", "placeholder", "class", "model-value", "onInput", "onChange"])
                      ], 2),
                      withDirectives((openBlock(), createElementBlock("span", {
                        class: normalizeClass(unref(drpNs).e("time-picker-wrap"))
                      }, [
                        createVNode(unref(ElInput), {
                          size: "small",
                          class: normalizeClass(unref(drpNs).e("editor")),
                          disabled: unref(rangeState).selecting,
                          placeholder: unref(t)("el.datepicker.startTime"),
                          "model-value": unref(minVisibleTime),
                          "validate-event": false,
                          onFocus: ($event) => minTimePickerVisible.value = true,
                          onInput: (val) => handleTimeInput(val, "min"),
                          onChange: (val) => handleTimeChange(val, "min")
                        }, null, 8, ["class", "disabled", "placeholder", "model-value", "onFocus", "onInput", "onChange"]),
                        createVNode(unref(TimePickPanel), {
                          visible: minTimePickerVisible.value,
                          format: unref(timeFormat),
                          "datetime-role": "start",
                          "parsed-value": leftDate.value,
                          onPick: handleMinTimePick
                        }, null, 8, ["visible", "format", "parsed-value"])
                      ], 2)), [
                        [unref(ClickOutside), handleMinTimeClose]
                      ])
                    ], 2),
                    createElementVNode("span", null, [
                      createVNode(unref(ElIcon), null, {
                        default: withCtx(() => [
                          createVNode(unref(arrow_right_default$1))
                        ]),
                        _: 1
                      })
                    ]),
                    createElementVNode("span", {
                      class: normalizeClass([unref(drpNs).e("editors-wrap"), "is-right"])
                    }, [
                      createElementVNode("span", {
                        class: normalizeClass(unref(drpNs).e("time-picker-wrap"))
                      }, [
                        createVNode(unref(ElInput), {
                          size: "small",
                          class: normalizeClass(unref(drpNs).e("editor")),
                          disabled: unref(rangeState).selecting,
                          placeholder: unref(t)("el.datepicker.endDate"),
                          "model-value": unref(maxVisibleDate),
                          readonly: !unref(minDate),
                          "validate-event": false,
                          onInput: (val) => handleDateInput(val, "max"),
                          onChange: (val) => handleDateChange(val, "max")
                        }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly", "onInput", "onChange"])
                      ], 2),
                      withDirectives((openBlock(), createElementBlock("span", {
                        class: normalizeClass(unref(drpNs).e("time-picker-wrap"))
                      }, [
                        createVNode(unref(ElInput), {
                          size: "small",
                          class: normalizeClass(unref(drpNs).e("editor")),
                          disabled: unref(rangeState).selecting,
                          placeholder: unref(t)("el.datepicker.endTime"),
                          "model-value": unref(maxVisibleTime),
                          readonly: !unref(minDate),
                          "validate-event": false,
                          onFocus: ($event) => unref(minDate) && (maxTimePickerVisible.value = true),
                          onInput: (val) => handleTimeInput(val, "max"),
                          onChange: (val) => handleTimeChange(val, "max")
                        }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly", "onFocus", "onInput", "onChange"]),
                        createVNode(unref(TimePickPanel), {
                          "datetime-role": "end",
                          visible: maxTimePickerVisible.value,
                          format: unref(timeFormat),
                          "parsed-value": rightDate.value,
                          onPick: handleMaxTimePick
                        }, null, 8, ["visible", "format", "parsed-value"])
                      ], 2)), [
                        [unref(ClickOutside), handleMaxTimeClose]
                      ])
                    ], 2)
                  ], 2)) : createCommentVNode("v-if", true),
                  createElementVNode("div", {
                    class: normalizeClass([[unref(ppNs).e("content"), unref(drpNs).e("content")], "is-left"])
                  }, [
                    createElementVNode("div", {
                      class: normalizeClass(unref(drpNs).e("header"))
                    }, [
                      createElementVNode("button", {
                        type: "button",
                        class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-left"]),
                        "aria-label": unref(t)(`el.datepicker.prevYear`),
                        onClick: leftPrevYear
                      }, [
                        renderSlot(_ctx.$slots, "prev-year", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(d_arrow_left_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["aria-label"]),
                      withDirectives(createElementVNode("button", {
                        type: "button",
                        class: normalizeClass([unref(ppNs).e("icon-btn"), "arrow-left"]),
                        "aria-label": unref(t)(`el.datepicker.prevMonth`),
                        onClick: leftPrevMonth
                      }, [
                        renderSlot(_ctx.$slots, "prev-month", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(arrow_left_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["aria-label"]), [
                        [vShow, unref(leftCurrentView) === "date"]
                      ]),
                      _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                        key: 0,
                        type: "button",
                        disabled: !unref(enableYearArrow),
                        class: normalizeClass([[unref(ppNs).e("icon-btn"), { "is-disabled": !unref(enableYearArrow) }], "d-arrow-right"]),
                        "aria-label": unref(t)(`el.datepicker.nextYear`),
                        onClick: leftNextYear
                      }, [
                        renderSlot(_ctx.$slots, "next-year", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(d_arrow_right_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["disabled", "aria-label"])) : createCommentVNode("v-if", true),
                      _ctx.unlinkPanels && unref(leftCurrentView) === "date" ? (openBlock(), createElementBlock("button", {
                        key: 1,
                        type: "button",
                        disabled: !unref(enableMonthArrow),
                        class: normalizeClass([[
                          unref(ppNs).e("icon-btn"),
                          { "is-disabled": !unref(enableMonthArrow) }
                        ], "arrow-right"]),
                        "aria-label": unref(t)(`el.datepicker.nextMonth`),
                        onClick: leftNextMonth
                      }, [
                        renderSlot(_ctx.$slots, "next-month", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(arrow_right_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["disabled", "aria-label"])) : createCommentVNode("v-if", true),
                      createElementVNode("div", null, [
                        createElementVNode("span", {
                          role: "button",
                          class: normalizeClass(unref(drpNs).e("header-label")),
                          "aria-live": "polite",
                          tabindex: "0",
                          onKeydown: withKeys(($event) => unref(showLeftPicker)("year"), ["enter"]),
                          onClick: ($event) => unref(showLeftPicker)("year")
                        }, toDisplayString(unref(leftYearLabel)), 43, ["onKeydown", "onClick"]),
                        withDirectives(createElementVNode("span", {
                          role: "button",
                          "aria-live": "polite",
                          tabindex: "0",
                          class: normalizeClass([
                            unref(drpNs).e("header-label"),
                            { active: unref(leftCurrentView) === "month" }
                          ]),
                          onKeydown: withKeys(($event) => unref(showLeftPicker)("month"), ["enter"]),
                          onClick: ($event) => unref(showLeftPicker)("month")
                        }, toDisplayString(unref(t)(`el.datepicker.month${leftDate.value.month() + 1}`)), 43, ["onKeydown", "onClick"]), [
                          [vShow, unref(leftCurrentView) === "date"]
                        ])
                      ])
                    ], 2),
                    unref(leftCurrentView) === "date" ? (openBlock(), createBlock(DateTable, {
                      key: 0,
                      ref_key: "leftCurrentViewRef",
                      ref: leftCurrentViewRef,
                      "selection-mode": "range",
                      date: leftDate.value,
                      "min-date": unref(minDate),
                      "max-date": unref(maxDate),
                      "range-state": unref(rangeState),
                      "disabled-date": unref(disabledDate),
                      "cell-class-name": unref(cellClassName),
                      "show-week-number": _ctx.showWeekNumber,
                      onChangerange: unref(handleChangeRange),
                      onPick: handleRangePick,
                      onSelect: unref(onSelect)
                    }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "show-week-number", "onChangerange", "onSelect"])) : createCommentVNode("v-if", true),
                    unref(leftCurrentView) === "year" ? (openBlock(), createBlock(YearTable, {
                      key: 1,
                      ref_key: "leftCurrentViewRef",
                      ref: leftCurrentViewRef,
                      "selection-mode": "year",
                      date: leftDate.value,
                      "disabled-date": unref(disabledDate),
                      "parsed-value": _ctx.parsedValue,
                      onPick: unref(handleLeftYearPick)
                    }, null, 8, ["date", "disabled-date", "parsed-value", "onPick"])) : createCommentVNode("v-if", true),
                    unref(leftCurrentView) === "month" ? (openBlock(), createBlock(MonthTable, {
                      key: 2,
                      ref_key: "leftCurrentViewRef",
                      ref: leftCurrentViewRef,
                      "selection-mode": "month",
                      date: leftDate.value,
                      "parsed-value": _ctx.parsedValue,
                      "disabled-date": unref(disabledDate),
                      onPick: unref(handleLeftMonthPick)
                    }, null, 8, ["date", "parsed-value", "disabled-date", "onPick"])) : createCommentVNode("v-if", true)
                  ], 2),
                  createElementVNode("div", {
                    class: normalizeClass([[unref(ppNs).e("content"), unref(drpNs).e("content")], "is-right"])
                  }, [
                    createElementVNode("div", {
                      class: normalizeClass(unref(drpNs).e("header"))
                    }, [
                      _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                        key: 0,
                        type: "button",
                        disabled: !unref(enableYearArrow),
                        class: normalizeClass([[unref(ppNs).e("icon-btn"), { "is-disabled": !unref(enableYearArrow) }], "d-arrow-left"]),
                        "aria-label": unref(t)(`el.datepicker.prevYear`),
                        onClick: rightPrevYear
                      }, [
                        renderSlot(_ctx.$slots, "prev-year", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(d_arrow_left_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["disabled", "aria-label"])) : createCommentVNode("v-if", true),
                      _ctx.unlinkPanels && unref(rightCurrentView) === "date" ? (openBlock(), createElementBlock("button", {
                        key: 1,
                        type: "button",
                        disabled: !unref(enableMonthArrow),
                        class: normalizeClass([[
                          unref(ppNs).e("icon-btn"),
                          { "is-disabled": !unref(enableMonthArrow) }
                        ], "arrow-left"]),
                        "aria-label": unref(t)(`el.datepicker.prevMonth`),
                        onClick: rightPrevMonth
                      }, [
                        renderSlot(_ctx.$slots, "prev-month", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(arrow_left_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["disabled", "aria-label"])) : createCommentVNode("v-if", true),
                      createElementVNode("button", {
                        type: "button",
                        "aria-label": unref(t)(`el.datepicker.nextYear`),
                        class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-right"]),
                        onClick: rightNextYear
                      }, [
                        renderSlot(_ctx.$slots, "next-year", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(d_arrow_right_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["aria-label"]),
                      withDirectives(createElementVNode("button", {
                        type: "button",
                        class: normalizeClass([unref(ppNs).e("icon-btn"), "arrow-right"]),
                        "aria-label": unref(t)(`el.datepicker.nextMonth`),
                        onClick: rightNextMonth
                      }, [
                        renderSlot(_ctx.$slots, "next-month", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(arrow_right_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["aria-label"]), [
                        [vShow, unref(rightCurrentView) === "date"]
                      ]),
                      createElementVNode("div", null, [
                        createElementVNode("span", {
                          role: "button",
                          class: normalizeClass(unref(drpNs).e("header-label")),
                          "aria-live": "polite",
                          tabindex: "0",
                          onKeydown: withKeys(($event) => unref(showRightPicker)("year"), ["enter"]),
                          onClick: ($event) => unref(showRightPicker)("year")
                        }, toDisplayString(unref(rightYearLabel)), 43, ["onKeydown", "onClick"]),
                        withDirectives(createElementVNode("span", {
                          role: "button",
                          "aria-live": "polite",
                          tabindex: "0",
                          class: normalizeClass([
                            unref(drpNs).e("header-label"),
                            { active: unref(rightCurrentView) === "month" }
                          ]),
                          onKeydown: withKeys(($event) => unref(showRightPicker)("month"), ["enter"]),
                          onClick: ($event) => unref(showRightPicker)("month")
                        }, toDisplayString(unref(t)(`el.datepicker.month${rightDate.value.month() + 1}`)), 43, ["onKeydown", "onClick"]), [
                          [vShow, unref(rightCurrentView) === "date"]
                        ])
                      ])
                    ], 2),
                    unref(rightCurrentView) === "date" ? (openBlock(), createBlock(DateTable, {
                      key: 0,
                      ref_key: "rightCurrentViewRef",
                      ref: rightCurrentViewRef,
                      "selection-mode": "range",
                      date: rightDate.value,
                      "min-date": unref(minDate),
                      "max-date": unref(maxDate),
                      "range-state": unref(rangeState),
                      "disabled-date": unref(disabledDate),
                      "cell-class-name": unref(cellClassName),
                      "show-week-number": _ctx.showWeekNumber,
                      onChangerange: unref(handleChangeRange),
                      onPick: handleRangePick,
                      onSelect: unref(onSelect)
                    }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "show-week-number", "onChangerange", "onSelect"])) : createCommentVNode("v-if", true),
                    unref(rightCurrentView) === "year" ? (openBlock(), createBlock(YearTable, {
                      key: 1,
                      ref_key: "rightCurrentViewRef",
                      ref: rightCurrentViewRef,
                      "selection-mode": "year",
                      date: rightDate.value,
                      "disabled-date": unref(disabledDate),
                      "parsed-value": _ctx.parsedValue,
                      onPick: unref(handleRightYearPick)
                    }, null, 8, ["date", "disabled-date", "parsed-value", "onPick"])) : createCommentVNode("v-if", true),
                    unref(rightCurrentView) === "month" ? (openBlock(), createBlock(MonthTable, {
                      key: 2,
                      ref_key: "rightCurrentViewRef",
                      ref: rightCurrentViewRef,
                      "selection-mode": "month",
                      date: rightDate.value,
                      "parsed-value": _ctx.parsedValue,
                      "disabled-date": unref(disabledDate),
                      onPick: unref(handleRightMonthPick)
                    }, null, 8, ["date", "parsed-value", "disabled-date", "onPick"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 2)
              ], 2),
              _ctx.showFooter && unref(showTime) ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ppNs).e("footer"))
              }, [
                unref(clearable) ? (openBlock(), createBlock(unref(ElButton), {
                  key: 0,
                  text: "",
                  size: "small",
                  class: normalizeClass(unref(ppNs).e("link-btn")),
                  onClick: handleClear
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(unref(t)("el.datepicker.clear")), 1)
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true),
                createVNode(unref(ElButton), {
                  plain: "",
                  size: "small",
                  class: normalizeClass(unref(ppNs).e("link-btn")),
                  disabled: unref(btnDisabled),
                  onClick: ($event) => unref(handleRangeConfirm)(false)
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(unref(t)("el.datepicker.confirm")), 1)
                  ]),
                  _: 1
                }, 8, ["class", "disabled", "onClick"])
              ], 2)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var DateRangePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1x, [["__file", "panel-date-range.vue"]]);
      const panelMonthRangeProps = buildProps({
        ...panelRangeSharedProps
      });
      const panelMonthRangeEmits = [
        "pick",
        "set-picker-option",
        "calendar-change"
      ];
      const useMonthRangeHeader = ({
        unlinkPanels,
        leftDate,
        rightDate
      }) => {
        const { t } = useLocale();
        const leftPrevYear = () => {
          leftDate.value = leftDate.value.subtract(1, "year");
          if (!unlinkPanels.value) {
            rightDate.value = rightDate.value.subtract(1, "year");
          }
        };
        const rightNextYear = () => {
          if (!unlinkPanels.value) {
            leftDate.value = leftDate.value.add(1, "year");
          }
          rightDate.value = rightDate.value.add(1, "year");
        };
        const leftNextYear = () => {
          leftDate.value = leftDate.value.add(1, "year");
        };
        const rightPrevYear = () => {
          rightDate.value = rightDate.value.subtract(1, "year");
        };
        const leftLabel = computed(() => {
          return `${leftDate.value.year()} ${t("el.datepicker.year")}`;
        });
        const rightLabel = computed(() => {
          return `${rightDate.value.year()} ${t("el.datepicker.year")}`;
        });
        const leftYear = computed(() => {
          return leftDate.value.year();
        });
        const rightYear = computed(() => {
          return rightDate.value.year() === leftDate.value.year() ? leftDate.value.year() + 1 : rightDate.value.year();
        });
        return {
          leftPrevYear,
          rightNextYear,
          leftNextYear,
          rightPrevYear,
          leftLabel,
          rightLabel,
          leftYear,
          rightYear
        };
      };
      const unit$1 = "year";
      const __default__$19 = defineComponent({
        name: "DatePickerMonthRange"
      });
      const _sfc_main$1w = /* @__PURE__ */ defineComponent({
        ...__default__$19,
        props: panelMonthRangeProps,
        emits: panelMonthRangeEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const { lang: lang2 } = useLocale();
          const pickerBase = inject(PICKER_BASE_INJECTION_KEY);
          const isDefaultFormat = inject(ROOT_PICKER_IS_DEFAULT_FORMAT_INJECTION_KEY);
          const { shortcuts, disabledDate } = pickerBase.props;
          const format2 = toRef(pickerBase.props, "format");
          const defaultValue = toRef(pickerBase.props, "defaultValue");
          const leftDate = ref(dayjs().locale(lang2.value));
          const rightDate = ref(dayjs().locale(lang2.value).add(1, unit$1));
          const {
            minDate,
            maxDate,
            rangeState,
            ppNs,
            drpNs,
            handleChangeRange,
            handleRangeConfirm,
            handleShortcutClick,
            onSelect,
            onReset
          } = useRangePicker(props2, {
            defaultValue,
            leftDate,
            rightDate,
            unit: unit$1,
            onParsedValueChanged
          });
          const hasShortcuts = computed(() => !!shortcuts.length);
          const {
            leftPrevYear,
            rightNextYear,
            leftNextYear,
            rightPrevYear,
            leftLabel,
            rightLabel,
            leftYear,
            rightYear
          } = useMonthRangeHeader({
            unlinkPanels: toRef(props2, "unlinkPanels"),
            leftDate,
            rightDate
          });
          const enableYearArrow = computed(() => {
            return props2.unlinkPanels && rightYear.value > leftYear.value + 1;
          });
          const handleRangePick = (val, close2 = true) => {
            const minDate_ = val.minDate;
            const maxDate_ = val.maxDate;
            if (maxDate.value === maxDate_ && minDate.value === minDate_) {
              return;
            }
            emit("calendar-change", [minDate_.toDate(), maxDate_ && maxDate_.toDate()]);
            maxDate.value = maxDate_;
            minDate.value = minDate_;
            if (!close2)
              return;
            handleRangeConfirm();
          };
          const handleClear = () => {
            leftDate.value = getDefaultValue(unref(defaultValue), {
              lang: unref(lang2),
              unit: "year",
              unlinkPanels: props2.unlinkPanels
            })[0];
            rightDate.value = leftDate.value.add(1, "year");
            emit("pick", null);
          };
          const formatToString = (value) => {
            return isArray$1(value) ? value.map((_2) => _2.format(format2.value)) : value.format(format2.value);
          };
          const parseUserInput = (value) => {
            return correctlyParseUserInput(value, format2.value, lang2.value, isDefaultFormat);
          };
          function onParsedValueChanged(minDate2, maxDate2) {
            if (props2.unlinkPanels && maxDate2) {
              const minDateYear = (minDate2 == null ? void 0 : minDate2.year()) || 0;
              const maxDateYear = maxDate2.year();
              rightDate.value = minDateYear === maxDateYear ? maxDate2.add(1, unit$1) : maxDate2;
            } else {
              rightDate.value = leftDate.value.add(1, unit$1);
            }
          }
          watch(() => props2.visible, (visible) => {
            if (!visible && rangeState.value.selecting) {
              onReset(props2.parsedValue);
              onSelect(false);
            }
          });
          emit("set-picker-option", ["isValidValue", isValidRange]);
          emit("set-picker-option", ["formatToString", formatToString]);
          emit("set-picker-option", ["parseUserInput", parseUserInput]);
          emit("set-picker-option", ["handleClear", handleClear]);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ppNs).b(),
                unref(drpNs).b(),
                {
                  "has-sidebar": Boolean(_ctx.$slots.sidebar) || unref(hasShortcuts)
                }
              ])
            }, [
              createElementVNode("div", {
                class: normalizeClass(unref(ppNs).e("body-wrapper"))
              }, [
                renderSlot(_ctx.$slots, "sidebar", {
                  class: normalizeClass(unref(ppNs).e("sidebar"))
                }),
                unref(hasShortcuts) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ppNs).e("sidebar"))
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(shortcuts), (shortcut, key) => {
                    return openBlock(), createElementBlock("button", {
                      key,
                      type: "button",
                      class: normalizeClass(unref(ppNs).e("shortcut")),
                      onClick: ($event) => unref(handleShortcutClick)(shortcut)
                    }, toDisplayString(shortcut.text), 11, ["onClick"]);
                  }), 128))
                ], 2)) : createCommentVNode("v-if", true),
                createElementVNode("div", {
                  class: normalizeClass(unref(ppNs).e("body"))
                }, [
                  createElementVNode("div", {
                    class: normalizeClass([[unref(ppNs).e("content"), unref(drpNs).e("content")], "is-left"])
                  }, [
                    createElementVNode("div", {
                      class: normalizeClass(unref(drpNs).e("header"))
                    }, [
                      createElementVNode("button", {
                        type: "button",
                        class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-left"]),
                        onClick: unref(leftPrevYear)
                      }, [
                        renderSlot(_ctx.$slots, "prev-year", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(d_arrow_left_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["onClick"]),
                      _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                        key: 0,
                        type: "button",
                        disabled: !unref(enableYearArrow),
                        class: normalizeClass([[
                          unref(ppNs).e("icon-btn"),
                          { [unref(ppNs).is("disabled")]: !unref(enableYearArrow) }
                        ], "d-arrow-right"]),
                        onClick: unref(leftNextYear)
                      }, [
                        renderSlot(_ctx.$slots, "next-year", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(d_arrow_right_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["disabled", "onClick"])) : createCommentVNode("v-if", true),
                      createElementVNode("div", null, toDisplayString(unref(leftLabel)), 1)
                    ], 2),
                    createVNode(MonthTable, {
                      "selection-mode": "range",
                      date: leftDate.value,
                      "min-date": unref(minDate),
                      "max-date": unref(maxDate),
                      "range-state": unref(rangeState),
                      "disabled-date": unref(disabledDate),
                      onChangerange: unref(handleChangeRange),
                      onPick: handleRangePick,
                      onSelect: unref(onSelect)
                    }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])
                  ], 2),
                  createElementVNode("div", {
                    class: normalizeClass([[unref(ppNs).e("content"), unref(drpNs).e("content")], "is-right"])
                  }, [
                    createElementVNode("div", {
                      class: normalizeClass(unref(drpNs).e("header"))
                    }, [
                      _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                        key: 0,
                        type: "button",
                        disabled: !unref(enableYearArrow),
                        class: normalizeClass([[unref(ppNs).e("icon-btn"), { "is-disabled": !unref(enableYearArrow) }], "d-arrow-left"]),
                        onClick: unref(rightPrevYear)
                      }, [
                        renderSlot(_ctx.$slots, "prev-year", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(d_arrow_left_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["disabled", "onClick"])) : createCommentVNode("v-if", true),
                      createElementVNode("button", {
                        type: "button",
                        class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-right"]),
                        onClick: unref(rightNextYear)
                      }, [
                        renderSlot(_ctx.$slots, "next-year", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(d_arrow_right_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["onClick"]),
                      createElementVNode("div", null, toDisplayString(unref(rightLabel)), 1)
                    ], 2),
                    createVNode(MonthTable, {
                      "selection-mode": "range",
                      date: rightDate.value,
                      "min-date": unref(minDate),
                      "max-date": unref(maxDate),
                      "range-state": unref(rangeState),
                      "disabled-date": unref(disabledDate),
                      onChangerange: unref(handleChangeRange),
                      onPick: handleRangePick,
                      onSelect: unref(onSelect)
                    }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])
                  ], 2)
                ], 2)
              ], 2)
            ], 2);
          };
        }
      });
      var MonthRangePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1w, [["__file", "panel-month-range.vue"]]);
      const panelYearRangeProps = buildProps({
        ...panelRangeSharedProps
      });
      const panelYearRangeEmits = [
        "pick",
        "set-picker-option",
        "calendar-change"
      ];
      const useYearRangeHeader = ({
        unlinkPanels,
        leftDate,
        rightDate
      }) => {
        const leftPrevYear = () => {
          leftDate.value = leftDate.value.subtract(10, "year");
          if (!unlinkPanels.value) {
            rightDate.value = rightDate.value.subtract(10, "year");
          }
        };
        const rightNextYear = () => {
          if (!unlinkPanels.value) {
            leftDate.value = leftDate.value.add(10, "year");
          }
          rightDate.value = rightDate.value.add(10, "year");
        };
        const leftNextYear = () => {
          leftDate.value = leftDate.value.add(10, "year");
        };
        const rightPrevYear = () => {
          rightDate.value = rightDate.value.subtract(10, "year");
        };
        const leftLabel = computed(() => {
          const leftStartDate = Math.floor(leftDate.value.year() / 10) * 10;
          return `${leftStartDate}-${leftStartDate + 9}`;
        });
        const rightLabel = computed(() => {
          const rightStartDate = Math.floor(rightDate.value.year() / 10) * 10;
          return `${rightStartDate}-${rightStartDate + 9}`;
        });
        const leftYear = computed(() => {
          const leftEndDate = Math.floor(leftDate.value.year() / 10) * 10 + 9;
          return leftEndDate;
        });
        const rightYear = computed(() => {
          const rightStartDate = Math.floor(rightDate.value.year() / 10) * 10;
          return rightStartDate;
        });
        return {
          leftPrevYear,
          rightNextYear,
          leftNextYear,
          rightPrevYear,
          leftLabel,
          rightLabel,
          leftYear,
          rightYear
        };
      };
      const step = 10;
      const unit = "year";
      const __default__$18 = defineComponent({
        name: "DatePickerYearRange"
      });
      const _sfc_main$1v = /* @__PURE__ */ defineComponent({
        ...__default__$18,
        props: panelYearRangeProps,
        emits: panelYearRangeEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const { lang: lang2 } = useLocale();
          const leftDate = ref(dayjs().locale(lang2.value));
          const rightDate = ref(dayjs().locale(lang2.value).add(step, unit));
          const isDefaultFormat = inject(ROOT_PICKER_IS_DEFAULT_FORMAT_INJECTION_KEY);
          const pickerBase = inject(PICKER_BASE_INJECTION_KEY);
          const { shortcuts, disabledDate } = pickerBase.props;
          const format2 = toRef(pickerBase.props, "format");
          const defaultValue = toRef(pickerBase.props, "defaultValue");
          const {
            minDate,
            maxDate,
            rangeState,
            ppNs,
            drpNs,
            handleChangeRange,
            handleRangeConfirm,
            handleShortcutClick,
            onSelect,
            onReset
          } = useRangePicker(props2, {
            defaultValue,
            leftDate,
            rightDate,
            step,
            unit,
            onParsedValueChanged
          });
          const {
            leftPrevYear,
            rightNextYear,
            leftNextYear,
            rightPrevYear,
            leftLabel,
            rightLabel,
            leftYear,
            rightYear
          } = useYearRangeHeader({
            unlinkPanels: toRef(props2, "unlinkPanels"),
            leftDate,
            rightDate
          });
          const hasShortcuts = computed(() => !!shortcuts.length);
          const panelKls = computed(() => [
            ppNs.b(),
            drpNs.b(),
            {
              "has-sidebar": Boolean(useSlots().sidebar) || hasShortcuts.value
            }
          ]);
          const leftPanelKls = computed(() => {
            return {
              content: [ppNs.e("content"), drpNs.e("content"), "is-left"],
              arrowLeftBtn: [ppNs.e("icon-btn"), "d-arrow-left"],
              arrowRightBtn: [
                ppNs.e("icon-btn"),
                { [ppNs.is("disabled")]: !enableYearArrow.value },
                "d-arrow-right"
              ]
            };
          });
          const rightPanelKls = computed(() => {
            return {
              content: [ppNs.e("content"), drpNs.e("content"), "is-right"],
              arrowLeftBtn: [
                ppNs.e("icon-btn"),
                { "is-disabled": !enableYearArrow.value },
                "d-arrow-left"
              ],
              arrowRightBtn: [ppNs.e("icon-btn"), "d-arrow-right"]
            };
          });
          const enableYearArrow = computed(() => {
            return props2.unlinkPanels && rightYear.value > leftYear.value + 1;
          });
          const handleRangePick = (val, close2 = true) => {
            const minDate_ = val.minDate;
            const maxDate_ = val.maxDate;
            if (maxDate.value === maxDate_ && minDate.value === minDate_) {
              return;
            }
            emit("calendar-change", [minDate_.toDate(), maxDate_ && maxDate_.toDate()]);
            maxDate.value = maxDate_;
            minDate.value = minDate_;
            if (!close2)
              return;
            handleRangeConfirm();
          };
          const parseUserInput = (value) => {
            return correctlyParseUserInput(value, format2.value, lang2.value, isDefaultFormat);
          };
          const formatToString = (value) => {
            return isArray$1(value) ? value.map((day) => day.format(format2.value)) : value.format(format2.value);
          };
          const isValidValue2 = (date3) => {
            return isValidRange(date3) && (disabledDate ? !disabledDate(date3[0].toDate()) && !disabledDate(date3[1].toDate()) : true);
          };
          const handleClear = () => {
            const defaultArr = getDefaultValue(unref(defaultValue), {
              lang: unref(lang2),
              step,
              unit,
              unlinkPanels: props2.unlinkPanels
            });
            leftDate.value = defaultArr[0];
            rightDate.value = defaultArr[1];
            emit("pick", null);
          };
          function onParsedValueChanged(minDate2, maxDate2) {
            if (props2.unlinkPanels && maxDate2) {
              const minDateYear = (minDate2 == null ? void 0 : minDate2.year()) || 0;
              const maxDateYear = maxDate2.year();
              rightDate.value = minDateYear + step > maxDateYear ? maxDate2.add(step, unit) : maxDate2;
            } else {
              rightDate.value = leftDate.value.add(step, unit);
            }
          }
          watch(() => props2.visible, (visible) => {
            if (!visible && rangeState.value.selecting) {
              onReset(props2.parsedValue);
              onSelect(false);
            }
          });
          emit("set-picker-option", ["isValidValue", isValidValue2]);
          emit("set-picker-option", ["parseUserInput", parseUserInput]);
          emit("set-picker-option", ["formatToString", formatToString]);
          emit("set-picker-option", ["handleClear", handleClear]);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(panelKls))
            }, [
              createElementVNode("div", {
                class: normalizeClass(unref(ppNs).e("body-wrapper"))
              }, [
                renderSlot(_ctx.$slots, "sidebar", {
                  class: normalizeClass(unref(ppNs).e("sidebar"))
                }),
                unref(hasShortcuts) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ppNs).e("sidebar"))
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(shortcuts), (shortcut, key) => {
                    return openBlock(), createElementBlock("button", {
                      key,
                      type: "button",
                      class: normalizeClass(unref(ppNs).e("shortcut")),
                      onClick: ($event) => unref(handleShortcutClick)(shortcut)
                    }, toDisplayString(shortcut.text), 11, ["onClick"]);
                  }), 128))
                ], 2)) : createCommentVNode("v-if", true),
                createElementVNode("div", {
                  class: normalizeClass(unref(ppNs).e("body"))
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(unref(leftPanelKls).content)
                  }, [
                    createElementVNode("div", {
                      class: normalizeClass(unref(drpNs).e("header"))
                    }, [
                      createElementVNode("button", {
                        type: "button",
                        class: normalizeClass(unref(leftPanelKls).arrowLeftBtn),
                        onClick: unref(leftPrevYear)
                      }, [
                        renderSlot(_ctx.$slots, "prev-year", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(d_arrow_left_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["onClick"]),
                      _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                        key: 0,
                        type: "button",
                        disabled: !unref(enableYearArrow),
                        class: normalizeClass(unref(leftPanelKls).arrowRightBtn),
                        onClick: unref(leftNextYear)
                      }, [
                        renderSlot(_ctx.$slots, "next-year", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(d_arrow_right_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["disabled", "onClick"])) : createCommentVNode("v-if", true),
                      createElementVNode("div", null, toDisplayString(unref(leftLabel)), 1)
                    ], 2),
                    createVNode(YearTable, {
                      "selection-mode": "range",
                      date: leftDate.value,
                      "min-date": unref(minDate),
                      "max-date": unref(maxDate),
                      "range-state": unref(rangeState),
                      "disabled-date": unref(disabledDate),
                      onChangerange: unref(handleChangeRange),
                      onPick: handleRangePick,
                      onSelect: unref(onSelect)
                    }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])
                  ], 2),
                  createElementVNode("div", {
                    class: normalizeClass(unref(rightPanelKls).content)
                  }, [
                    createElementVNode("div", {
                      class: normalizeClass(unref(drpNs).e("header"))
                    }, [
                      _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                        key: 0,
                        type: "button",
                        disabled: !unref(enableYearArrow),
                        class: normalizeClass(unref(rightPanelKls).arrowLeftBtn),
                        onClick: unref(rightPrevYear)
                      }, [
                        renderSlot(_ctx.$slots, "prev-year", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(d_arrow_left_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["disabled", "onClick"])) : createCommentVNode("v-if", true),
                      createElementVNode("button", {
                        type: "button",
                        class: normalizeClass(unref(rightPanelKls).arrowRightBtn),
                        onClick: unref(rightNextYear)
                      }, [
                        renderSlot(_ctx.$slots, "next-year", {}, () => [
                          createVNode(unref(ElIcon), null, {
                            default: withCtx(() => [
                              createVNode(unref(d_arrow_right_default$1))
                            ]),
                            _: 1
                          })
                        ])
                      ], 10, ["onClick"]),
                      createElementVNode("div", null, toDisplayString(unref(rightLabel)), 1)
                    ], 2),
                    createVNode(YearTable, {
                      "selection-mode": "range",
                      date: rightDate.value,
                      "min-date": unref(minDate),
                      "max-date": unref(maxDate),
                      "range-state": unref(rangeState),
                      "disabled-date": unref(disabledDate),
                      onChangerange: unref(handleChangeRange),
                      onPick: handleRangePick,
                      onSelect: unref(onSelect)
                    }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])
                  ], 2)
                ], 2)
              ], 2)
            ], 2);
          };
        }
      });
      var YearRangePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1v, [["__file", "panel-year-range.vue"]]);
      const getPanel = function(type) {
        switch (type) {
          case "daterange":
          case "datetimerange": {
            return DateRangePickPanel;
          }
          case "monthrange": {
            return MonthRangePickPanel;
          }
          case "yearrange": {
            return YearRangePickPanel;
          }
          default: {
            return DatePickPanel;
          }
        }
      };
      dayjs.extend(localeData);
      dayjs.extend(advancedFormat);
      dayjs.extend(customParseFormat);
      dayjs.extend(weekOfYear);
      dayjs.extend(weekYear);
      dayjs.extend(dayOfYear);
      dayjs.extend(isSameOrAfter);
      dayjs.extend(isSameOrBefore);
      var DatePicker = defineComponent({
        name: "ElDatePicker",
        install: null,
        props: datePickerProps,
        emits: [UPDATE_MODEL_EVENT],
        setup(props2, {
          expose,
          emit,
          slots
        }) {
          const ns = useNamespace("picker-panel");
          const isDefaultFormat = computed(() => {
            return !props2.format;
          });
          provide(ROOT_PICKER_IS_DEFAULT_FORMAT_INJECTION_KEY, isDefaultFormat);
          provide(PICKER_POPPER_OPTIONS_INJECTION_KEY, reactive(toRef(props2, "popperOptions")));
          provide(ROOT_PICKER_INJECTION_KEY, {
            slots,
            pickerNs: ns
          });
          const commonPicker = ref();
          const refProps = {
            focus: () => {
              var _a;
              (_a = commonPicker.value) == null ? void 0 : _a.focus();
            },
            blur: () => {
              var _a;
              (_a = commonPicker.value) == null ? void 0 : _a.blur();
            },
            handleOpen: () => {
              var _a;
              (_a = commonPicker.value) == null ? void 0 : _a.handleOpen();
            },
            handleClose: () => {
              var _a;
              (_a = commonPicker.value) == null ? void 0 : _a.handleClose();
            }
          };
          expose(refProps);
          const onModelValueUpdated = (val) => {
            emit(UPDATE_MODEL_EVENT, val);
          };
          return () => {
            var _a;
            const format2 = (_a = props2.format) != null ? _a : DEFAULT_FORMATS_DATEPICKER[props2.type] || DEFAULT_FORMATS_DATE;
            const Component = getPanel(props2.type);
            return createVNode(CommonPicker, mergeProps(props2, {
              "format": format2,
              "type": props2.type,
              "ref": commonPicker,
              "onUpdate:modelValue": onModelValueUpdated
            }), {
              default: (scopedProps) => createVNode(Component, scopedProps, {
                "prev-month": slots["prev-month"],
                "next-month": slots["next-month"],
                "prev-year": slots["prev-year"],
                "next-year": slots["next-year"]
              }),
              "range-separator": slots["range-separator"]
            });
          };
        }
      });
      const ElDatePicker = exports("ElDatePicker", withInstall(DatePicker));
      const descriptionsKey = Symbol("elDescriptions");
      var ElDescriptionsCell = defineComponent({
        name: "ElDescriptionsCell",
        props: {
          cell: {
            type: Object
          },
          tag: {
            type: String,
            default: "td"
          },
          type: {
            type: String
          }
        },
        setup() {
          const descriptions = inject(descriptionsKey, {});
          return {
            descriptions
          };
        },
        render() {
          var _a;
          const item = getNormalizedProps(this.cell);
          const directives = (((_a = this.cell) == null ? void 0 : _a.dirs) || []).map((dire) => {
            const { dir, arg, modifiers, value } = dire;
            return [dir, value, arg, modifiers];
          });
          const { border, direction: direction2 } = this.descriptions;
          const isVertical = direction2 === "vertical";
          const renderLabel = () => {
            var _a2, _b, _c;
            return ((_c = (_b = (_a2 = this.cell) == null ? void 0 : _a2.children) == null ? void 0 : _b.label) == null ? void 0 : _c.call(_b)) || item.label;
          };
          const renderContent = () => {
            var _a2, _b, _c;
            return (_c = (_b = (_a2 = this.cell) == null ? void 0 : _a2.children) == null ? void 0 : _b.default) == null ? void 0 : _c.call(_b);
          };
          const span = item.span;
          const rowspan = item.rowspan;
          const align = item.align ? `is-${item.align}` : "";
          const labelAlign = item.labelAlign ? `is-${item.labelAlign}` : align;
          const className = item.className;
          const labelClassName = item.labelClassName;
          const width = this.type === "label" ? item.labelWidth || this.descriptions.labelWidth || item.width : item.width;
          const style = {
            width: addUnit(width),
            minWidth: addUnit(item.minWidth)
          };
          const ns = useNamespace("descriptions");
          switch (this.type) {
            case "label":
              return withDirectives(h$1(this.tag, {
                style,
                class: [
                  ns.e("cell"),
                  ns.e("label"),
                  ns.is("bordered-label", border),
                  ns.is("vertical-label", isVertical),
                  labelAlign,
                  labelClassName
                ],
                colSpan: isVertical ? span : 1,
                rowspan: isVertical ? 1 : rowspan
              }, renderLabel()), directives);
            case "content":
              return withDirectives(h$1(this.tag, {
                style,
                class: [
                  ns.e("cell"),
                  ns.e("content"),
                  ns.is("bordered-content", border),
                  ns.is("vertical-content", isVertical),
                  align,
                  className
                ],
                colSpan: isVertical ? span : span * 2 - 1,
                rowspan: isVertical ? rowspan * 2 - 1 : rowspan
              }, renderContent()), directives);
            default: {
              const label = renderLabel();
              const labelStyle = {};
              const width2 = addUnit(item.labelWidth || this.descriptions.labelWidth);
              if (width2) {
                labelStyle.width = width2;
                labelStyle.display = "inline-block";
              }
              return withDirectives(h$1("td", {
                style,
                class: [ns.e("cell"), align],
                colSpan: span,
                rowspan
              }, [
                !isNil(label) ? h$1("span", {
                  style: labelStyle,
                  class: [ns.e("label"), labelClassName]
                }, label) : void 0,
                h$1("span", {
                  class: [ns.e("content"), className]
                }, renderContent())
              ]), directives);
            }
          }
        }
      });
      const descriptionsRowProps = buildProps({
        row: {
          type: definePropType(Array),
          default: () => []
        }
      });
      const __default__$17 = defineComponent({
        name: "ElDescriptionsRow"
      });
      const _sfc_main$1u = /* @__PURE__ */ defineComponent({
        ...__default__$17,
        props: descriptionsRowProps,
        setup(__props) {
          const descriptions = inject(descriptionsKey, {});
          return (_ctx, _cache) => {
            return unref(descriptions).direction === "vertical" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createElementVNode("tr", null, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.row, (cell, _index) => {
                  return openBlock(), createBlock(unref(ElDescriptionsCell), {
                    key: `tr1-${_index}`,
                    cell,
                    tag: "th",
                    type: "label"
                  }, null, 8, ["cell"]);
                }), 128))
              ]),
              createElementVNode("tr", null, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.row, (cell, _index) => {
                  return openBlock(), createBlock(unref(ElDescriptionsCell), {
                    key: `tr2-${_index}`,
                    cell,
                    tag: "td",
                    type: "content"
                  }, null, 8, ["cell"]);
                }), 128))
              ])
            ], 64)) : (openBlock(), createElementBlock("tr", { key: 1 }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.row, (cell, _index) => {
                return openBlock(), createElementBlock(Fragment, {
                  key: `tr3-${_index}`
                }, [
                  unref(descriptions).border ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createVNode(unref(ElDescriptionsCell), {
                      cell,
                      tag: "td",
                      type: "label"
                    }, null, 8, ["cell"]),
                    createVNode(unref(ElDescriptionsCell), {
                      cell,
                      tag: "td",
                      type: "content"
                    }, null, 8, ["cell"])
                  ], 64)) : (openBlock(), createBlock(unref(ElDescriptionsCell), {
                    key: 1,
                    cell,
                    tag: "td",
                    type: "both"
                  }, null, 8, ["cell"]))
                ], 64);
              }), 128))
            ]));
          };
        }
      });
      var ElDescriptionsRow = /* @__PURE__ */ _export_sfc(_sfc_main$1u, [["__file", "descriptions-row.vue"]]);
      const descriptionProps = exports("descriptionProps", buildProps({
        border: Boolean,
        column: {
          type: Number,
          default: 3
        },
        direction: {
          type: String,
          values: ["horizontal", "vertical"],
          default: "horizontal"
        },
        size: useSizeProp,
        title: {
          type: String,
          default: ""
        },
        extra: {
          type: String,
          default: ""
        },
        labelWidth: {
          type: [String, Number],
          default: ""
        }
      }));
      const COMPONENT_NAME$e = "ElDescriptionsItem";
      const __default__$16 = defineComponent({
        name: "ElDescriptions"
      });
      const _sfc_main$1t = /* @__PURE__ */ defineComponent({
        ...__default__$16,
        props: descriptionProps,
        setup(__props) {
          const props2 = __props;
          const ns = useNamespace("descriptions");
          const descriptionsSize = useFormSize();
          const slots = useSlots();
          provide(descriptionsKey, props2);
          const descriptionKls = computed(() => [ns.b(), ns.m(descriptionsSize.value)]);
          const filledNode = (node, span, count, isLast = false) => {
            if (!node.props) {
              node.props = {};
            }
            if (span > count) {
              node.props.span = count;
            }
            if (isLast) {
              node.props.span = span;
            }
            return node;
          };
          const getRows = () => {
            if (!slots.default)
              return [];
            const children = flattedChildren(slots.default()).filter((node) => {
              var _a;
              return ((_a = node == null ? void 0 : node.type) == null ? void 0 : _a.name) === COMPONENT_NAME$e;
            });
            const rows = [];
            let temp = [];
            let count = props2.column;
            let totalSpan = 0;
            const rowspanTemp = [];
            children.forEach((node, index2) => {
              var _a, _b, _c;
              const span = ((_a = node.props) == null ? void 0 : _a.span) || 1;
              const rowspan = ((_b = node.props) == null ? void 0 : _b.rowspan) || 1;
              const rowNo = rows.length;
              rowspanTemp[rowNo] || (rowspanTemp[rowNo] = 0);
              if (rowspan > 1) {
                for (let i = 1; i < rowspan; i++) {
                  rowspanTemp[_c = rowNo + i] || (rowspanTemp[_c] = 0);
                  rowspanTemp[rowNo + i]++;
                  totalSpan++;
                }
              }
              if (rowspanTemp[rowNo] > 0) {
                count -= rowspanTemp[rowNo];
                rowspanTemp[rowNo] = 0;
              }
              if (index2 < children.length - 1) {
                totalSpan += span > count ? count : span;
              }
              if (index2 === children.length - 1) {
                const lastSpan = props2.column - totalSpan % props2.column;
                temp.push(filledNode(node, lastSpan, count, true));
                rows.push(temp);
                return;
              }
              if (span < count) {
                count -= span;
                temp.push(node);
              } else {
                temp.push(filledNode(node, span, count));
                rows.push(temp);
                count = props2.column;
                temp = [];
              }
            });
            return rows;
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(descriptionKls))
            }, [
              _ctx.title || _ctx.extra || _ctx.$slots.title || _ctx.$slots.extra ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).e("header"))
              }, [
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).e("title"))
                }, [
                  renderSlot(_ctx.$slots, "title", {}, () => [
                    createTextVNode(toDisplayString(_ctx.title), 1)
                  ])
                ], 2),
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).e("extra"))
                }, [
                  renderSlot(_ctx.$slots, "extra", {}, () => [
                    createTextVNode(toDisplayString(_ctx.extra), 1)
                  ])
                ], 2)
              ], 2)) : createCommentVNode("v-if", true),
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("body"))
              }, [
                createElementVNode("table", {
                  class: normalizeClass([unref(ns).e("table"), unref(ns).is("bordered", _ctx.border)])
                }, [
                  createElementVNode("tbody", null, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(getRows(), (row, _index) => {
                      return openBlock(), createBlock(ElDescriptionsRow, {
                        key: _index,
                        row
                      }, null, 8, ["row"]);
                    }), 128))
                  ])
                ], 2)
              ], 2)
            ], 2);
          };
        }
      });
      var Descriptions = /* @__PURE__ */ _export_sfc(_sfc_main$1t, [["__file", "description.vue"]]);
      const descriptionItemProps = exports("descriptionItemProps", buildProps({
        label: {
          type: String,
          default: ""
        },
        span: {
          type: Number,
          default: 1
        },
        rowspan: {
          type: Number,
          default: 1
        },
        width: {
          type: [String, Number],
          default: ""
        },
        minWidth: {
          type: [String, Number],
          default: ""
        },
        labelWidth: {
          type: [String, Number],
          default: ""
        },
        align: {
          type: String,
          values: columnAlignment,
          default: "left"
        },
        labelAlign: {
          type: String,
          values: columnAlignment
        },
        className: {
          type: String,
          default: ""
        },
        labelClassName: {
          type: String,
          default: ""
        }
      }));
      const DescriptionItem = defineComponent({
        name: COMPONENT_NAME$e,
        props: descriptionItemProps
      });
      const ElDescriptions = exports("ElDescriptions", withInstall(Descriptions, {
        DescriptionsItem: DescriptionItem
      }));
      const ElDescriptionsItem = exports("ElDescriptionsItem", withNoopInstall(DescriptionItem));
      const overlayProps = exports("overlayProps", buildProps({
        mask: {
          type: Boolean,
          default: true
        },
        customMaskEvent: Boolean,
        overlayClass: {
          type: definePropType([
            String,
            Array,
            Object
          ])
        },
        zIndex: {
          type: definePropType([String, Number])
        }
      }));
      const overlayEmits = exports("overlayEmits", {
        click: (evt) => evt instanceof MouseEvent
      });
      const BLOCK = "overlay";
      var Overlay$1 = defineComponent({
        name: "ElOverlay",
        props: overlayProps,
        emits: overlayEmits,
        setup(props2, { slots, emit }) {
          const ns = useNamespace(BLOCK);
          const onMaskClick = (e) => {
            emit("click", e);
          };
          const { onClick, onMousedown, onMouseup } = useSameTarget(props2.customMaskEvent ? void 0 : onMaskClick);
          return () => {
            return props2.mask ? createVNode("div", {
              class: [ns.b(), props2.overlayClass],
              style: {
                zIndex: props2.zIndex
              },
              onClick,
              onMousedown,
              onMouseup
            }, [renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : h$1("div", {
              class: props2.overlayClass,
              style: {
                zIndex: props2.zIndex,
                position: "fixed",
                top: "0px",
                right: "0px",
                bottom: "0px",
                left: "0px"
              }
            }, [renderSlot(slots, "default")]);
          };
        }
      });
      const ElOverlay = exports("ElOverlay", Overlay$1);
      const dialogInjectionKey = exports("dialogInjectionKey", Symbol("dialogInjectionKey"));
      const DEFAULT_DIALOG_TRANSITION = exports("DEFAULT_DIALOG_TRANSITION", "dialog-fade");
      const dialogContentProps = buildProps({
        center: Boolean,
        alignCenter: {
          type: Boolean,
          default: void 0
        },
        closeIcon: {
          type: iconPropType
        },
        draggable: {
          type: Boolean,
          default: void 0
        },
        overflow: {
          type: Boolean,
          default: void 0
        },
        fullscreen: Boolean,
        headerClass: String,
        bodyClass: String,
        footerClass: String,
        showClose: {
          type: Boolean,
          default: true
        },
        title: {
          type: String,
          default: ""
        },
        ariaLevel: {
          type: String,
          default: "2"
        }
      });
      const dialogContentEmits = {
        close: () => true
      };
      const __default__$15 = defineComponent({ name: "ElDialogContent" });
      const _sfc_main$1s = /* @__PURE__ */ defineComponent({
        ...__default__$15,
        props: dialogContentProps,
        emits: dialogContentEmits,
        setup(__props, { expose }) {
          const props2 = __props;
          const { t } = useLocale();
          const { Close } = CloseComponents;
          const { dialogRef, headerRef, bodyId, ns, style } = inject(dialogInjectionKey);
          const { focusTrapRef } = inject(FOCUS_TRAP_INJECTION_KEY);
          const dialogKls = computed(() => [
            ns.b(),
            ns.is("fullscreen", props2.fullscreen),
            ns.is("draggable", !!props2.draggable),
            ns.is("align-center", !!props2.alignCenter),
            { [ns.m("center")]: props2.center }
          ]);
          const composedDialogRef = composeRefs(focusTrapRef, dialogRef);
          const draggable2 = computed(() => !!props2.draggable);
          const overflow = computed(() => !!props2.overflow);
          const { resetPosition, updatePosition } = useDraggable(dialogRef, headerRef, draggable2, overflow);
          expose({
            resetPosition,
            updatePosition
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref: unref(composedDialogRef),
              class: normalizeClass(unref(dialogKls)),
              style: normalizeStyle(unref(style)),
              tabindex: "-1"
            }, [
              createElementVNode("header", {
                ref_key: "headerRef",
                ref: headerRef,
                class: normalizeClass([unref(ns).e("header"), _ctx.headerClass, { "show-close": _ctx.showClose }])
              }, [
                renderSlot(_ctx.$slots, "header", {}, () => [
                  createElementVNode("span", {
                    role: "heading",
                    "aria-level": _ctx.ariaLevel,
                    class: normalizeClass(unref(ns).e("title"))
                  }, toDisplayString(_ctx.title), 11, ["aria-level"])
                ]),
                _ctx.showClose ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  "aria-label": unref(t)("el.dialog.close"),
                  class: normalizeClass(unref(ns).e("headerbtn")),
                  type: "button",
                  onClick: ($event) => _ctx.$emit("close")
                }, [
                  createVNode(unref(ElIcon), {
                    class: normalizeClass(unref(ns).e("close"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon || unref(Close))))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ], 10, ["aria-label", "onClick"])) : createCommentVNode("v-if", true)
              ], 2),
              createElementVNode("div", {
                id: unref(bodyId),
                class: normalizeClass([unref(ns).e("body"), _ctx.bodyClass])
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 10, ["id"]),
              _ctx.$slots.footer ? (openBlock(), createElementBlock("footer", {
                key: 0,
                class: normalizeClass([unref(ns).e("footer"), _ctx.footerClass])
              }, [
                renderSlot(_ctx.$slots, "footer")
              ], 2)) : createCommentVNode("v-if", true)
            ], 6);
          };
        }
      });
      var ElDialogContent = /* @__PURE__ */ _export_sfc(_sfc_main$1s, [["__file", "dialog-content.vue"]]);
      const dialogProps = exports("dialogProps", buildProps({
        ...dialogContentProps,
        appendToBody: Boolean,
        appendTo: {
          type: teleportProps.to.type,
          default: "body"
        },
        beforeClose: {
          type: definePropType(Function)
        },
        destroyOnClose: Boolean,
        closeOnClickModal: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        lockScroll: {
          type: Boolean,
          default: true
        },
        modal: {
          type: Boolean,
          default: true
        },
        modalPenetrable: Boolean,
        openDelay: {
          type: Number,
          default: 0
        },
        closeDelay: {
          type: Number,
          default: 0
        },
        top: {
          type: String
        },
        modelValue: Boolean,
        modalClass: String,
        headerClass: String,
        bodyClass: String,
        footerClass: String,
        width: {
          type: [String, Number]
        },
        zIndex: {
          type: Number
        },
        trapFocus: Boolean,
        headerAriaLevel: {
          type: String,
          default: "2"
        },
        transition: {
          type: definePropType([String, Object]),
          default: void 0
        }
      }));
      const dialogEmits = exports("dialogEmits", {
        open: () => true,
        opened: () => true,
        close: () => true,
        closed: () => true,
        [UPDATE_MODEL_EVENT]: (value) => isBoolean(value),
        openAutoFocus: () => true,
        closeAutoFocus: () => true
      });
      const dialogContextKey = exports("dialogContextKey", Symbol("dialogContextKey"));
      const useDialog = exports("useDialog", (props2, targetRef) => {
        var _a;
        const instance = getCurrentInstance();
        const emit = instance.emit;
        const { nextZIndex } = useZIndex();
        let lastPosition = "";
        const titleId = useId();
        const bodyId = useId();
        const visible = ref(false);
        const closed = ref(false);
        const rendered = ref(false);
        const zIndex2 = ref((_a = props2.zIndex) != null ? _a : nextZIndex());
        let openTimer = void 0;
        let closeTimer = void 0;
        const config = useGlobalConfig();
        const namespace = computed(() => {
          var _a2, _b;
          return (_b = (_a2 = config.value) == null ? void 0 : _a2.namespace) != null ? _b : defaultNamespace;
        });
        const globalConfig2 = computed(() => {
          var _a2;
          return (_a2 = config.value) == null ? void 0 : _a2.dialog;
        });
        const style = computed(() => {
          const style2 = {};
          const varPrefix = `--${namespace.value}-dialog`;
          if (!props2.fullscreen) {
            if (props2.top) {
              style2[`${varPrefix}-margin-top`] = props2.top;
            }
            if (props2.width) {
              style2[`${varPrefix}-width`] = addUnit(props2.width);
            }
          }
          return style2;
        });
        const _draggable = computed(() => {
          var _a2, _b, _c;
          return ((_c = (_b = props2.draggable) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.draggable) != null ? _c : false) && !props2.fullscreen;
        });
        const _alignCenter = computed(() => {
          var _a2, _b, _c;
          return (_c = (_b = props2.alignCenter) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.alignCenter) != null ? _c : false;
        });
        const _overflow = computed(() => {
          var _a2, _b, _c;
          return (_c = (_b = props2.overflow) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.overflow) != null ? _c : false;
        });
        const overlayDialogStyle = computed(() => {
          if (_alignCenter.value) {
            return { display: "flex" };
          }
          return {};
        });
        const transitionConfig = computed(() => {
          var _a2, _b, _c;
          const transition = (_c = (_b = props2.transition) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.transition) != null ? _c : DEFAULT_DIALOG_TRANSITION;
          const baseConfig = {
            name: transition,
            onAfterEnter: afterEnter,
            onBeforeLeave: beforeLeave,
            onAfterLeave: afterLeave
          };
          if (isObject$1(transition)) {
            const config2 = { ...transition };
            const _mergeHook = (userHook, defaultHook) => {
              return (el) => {
                if (isArray$1(userHook)) {
                  userHook.forEach((fn2) => {
                    if (isFunction$1(fn2))
                      fn2(el);
                  });
                } else if (isFunction$1(userHook)) {
                  userHook(el);
                }
                defaultHook();
              };
            };
            config2.onAfterEnter = _mergeHook(config2.onAfterEnter, afterEnter);
            config2.onBeforeLeave = _mergeHook(config2.onBeforeLeave, beforeLeave);
            config2.onAfterLeave = _mergeHook(config2.onAfterLeave, afterLeave);
            if (!config2.name) {
              config2.name = DEFAULT_DIALOG_TRANSITION;
            }
            return config2;
          }
          return baseConfig;
        });
        function afterEnter() {
          emit("opened");
        }
        function afterLeave() {
          emit("closed");
          emit(UPDATE_MODEL_EVENT, false);
          if (props2.destroyOnClose) {
            rendered.value = false;
          }
        }
        function beforeLeave() {
          emit("close");
        }
        function open() {
          closeTimer == null ? void 0 : closeTimer();
          openTimer == null ? void 0 : openTimer();
          if (props2.openDelay && props2.openDelay > 0) {
            ({ stop: openTimer } = useTimeoutFn(() => doOpen(), props2.openDelay));
          } else {
            doOpen();
          }
        }
        function close2() {
          openTimer == null ? void 0 : openTimer();
          closeTimer == null ? void 0 : closeTimer();
          if (props2.closeDelay && props2.closeDelay > 0) {
            ({ stop: closeTimer } = useTimeoutFn(() => doClose(), props2.closeDelay));
          } else {
            doClose();
          }
        }
        function handleClose() {
          function hide(shouldCancel) {
            if (shouldCancel)
              return;
            closed.value = true;
            visible.value = false;
          }
          if (props2.beforeClose) {
            props2.beforeClose(hide);
          } else {
            close2();
          }
        }
        function onModalClick() {
          if (props2.closeOnClickModal) {
            handleClose();
          }
        }
        function doOpen() {
          if (!isClient)
            return;
          visible.value = true;
        }
        function doClose() {
          visible.value = false;
        }
        function onOpenAutoFocus() {
          emit("openAutoFocus");
        }
        function onCloseAutoFocus() {
          emit("closeAutoFocus");
        }
        function onFocusoutPrevented(event) {
          var _a2;
          if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) === "pointer") {
            event.preventDefault();
          }
        }
        if (props2.lockScroll) {
          useLockscreen(visible);
        }
        function onCloseRequested() {
          if (props2.closeOnPressEscape) {
            handleClose();
          }
        }
        watch(() => props2.zIndex, () => {
          var _a2;
          zIndex2.value = (_a2 = props2.zIndex) != null ? _a2 : nextZIndex();
        });
        watch(() => props2.modelValue, (val) => {
          var _a2;
          if (val) {
            closed.value = false;
            open();
            rendered.value = true;
            zIndex2.value = (_a2 = props2.zIndex) != null ? _a2 : nextZIndex();
            nextTick(() => {
              emit("open");
              if (targetRef.value) {
                targetRef.value.parentElement.scrollTop = 0;
                targetRef.value.parentElement.scrollLeft = 0;
                targetRef.value.scrollTop = 0;
              }
            });
          } else {
            if (visible.value) {
              close2();
            }
          }
        });
        watch(() => props2.fullscreen, (val) => {
          if (!targetRef.value)
            return;
          if (val) {
            lastPosition = targetRef.value.style.transform;
            targetRef.value.style.transform = "";
          } else {
            targetRef.value.style.transform = lastPosition;
          }
        });
        onMounted(() => {
          if (props2.modelValue) {
            visible.value = true;
            rendered.value = true;
            open();
          }
        });
        return {
          afterEnter,
          afterLeave,
          beforeLeave,
          handleClose,
          onModalClick,
          close: close2,
          doClose,
          onOpenAutoFocus,
          onCloseAutoFocus,
          onCloseRequested,
          onFocusoutPrevented,
          titleId,
          bodyId,
          closed,
          style,
          overlayDialogStyle,
          rendered,
          visible,
          zIndex: zIndex2,
          transitionConfig,
          _draggable,
          _alignCenter,
          _overflow
        };
      });
      const __default__$14 = defineComponent({
        name: "ElDialog",
        inheritAttrs: false
      });
      const _sfc_main$1r = /* @__PURE__ */ defineComponent({
        ...__default__$14,
        props: dialogProps,
        emits: dialogEmits,
        setup(__props, { expose }) {
          const props2 = __props;
          const slots = useSlots();
          useDeprecated({
            scope: "el-dialog",
            from: "the title slot",
            replacement: "the header slot",
            version: "3.0.0",
            ref: "https://element-plus.org/en-US/component/dialog.html#slots"
          }, computed(() => !!slots.title));
          const ns = useNamespace("dialog");
          const dialogRef = ref();
          const headerRef = ref();
          const dialogContentRef = ref();
          const {
            visible,
            titleId,
            bodyId,
            style,
            overlayDialogStyle,
            rendered,
            transitionConfig,
            zIndex: zIndex2,
            _draggable,
            _alignCenter,
            _overflow,
            handleClose,
            onModalClick,
            onOpenAutoFocus,
            onCloseAutoFocus,
            onCloseRequested,
            onFocusoutPrevented
          } = useDialog(props2, dialogRef);
          provide(dialogInjectionKey, {
            dialogRef,
            headerRef,
            bodyId,
            ns,
            rendered,
            style
          });
          const overlayEvent = useSameTarget(onModalClick);
          const penetrable = computed(() => props2.modalPenetrable && !props2.modal && !props2.fullscreen);
          const resetPosition = () => {
            var _a;
            (_a = dialogContentRef.value) == null ? void 0 : _a.resetPosition();
          };
          expose({
            visible,
            dialogContentRef,
            resetPosition,
            handleClose
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTeleport$1), {
              to: _ctx.appendTo,
              disabled: _ctx.appendTo !== "body" ? false : !_ctx.appendToBody
            }, {
              default: withCtx(() => [
                createVNode(Transition, mergeProps(unref(transitionConfig), { persisted: "" }), {
                  default: withCtx(() => {
                    var _a;
                    return [
                      withDirectives(createVNode(unref(ElOverlay), {
                        "custom-mask-event": "",
                        mask: _ctx.modal,
                        "overlay-class": [
                          (_a = _ctx.modalClass) != null ? _a : "",
                          `${unref(ns).namespace.value}-modal-dialog`,
                          unref(ns).is("penetrable", unref(penetrable))
                        ],
                        "z-index": unref(zIndex2)
                      }, {
                        default: withCtx(() => [
                          createElementVNode("div", {
                            role: "dialog",
                            "aria-modal": "true",
                            "aria-label": _ctx.title || void 0,
                            "aria-labelledby": !_ctx.title ? unref(titleId) : void 0,
                            "aria-describedby": unref(bodyId),
                            class: normalizeClass(`${unref(ns).namespace.value}-overlay-dialog`),
                            style: normalizeStyle(unref(overlayDialogStyle)),
                            onClick: unref(overlayEvent).onClick,
                            onMousedown: unref(overlayEvent).onMousedown,
                            onMouseup: unref(overlayEvent).onMouseup
                          }, [
                            createVNode(unref(ElFocusTrap), {
                              loop: "",
                              trapped: unref(visible),
                              "focus-start-el": "container",
                              onFocusAfterTrapped: unref(onOpenAutoFocus),
                              onFocusAfterReleased: unref(onCloseAutoFocus),
                              onFocusoutPrevented: unref(onFocusoutPrevented),
                              onReleaseRequested: unref(onCloseRequested)
                            }, {
                              default: withCtx(() => [
                                unref(rendered) ? (openBlock(), createBlock(ElDialogContent, mergeProps({
                                  key: 0,
                                  ref_key: "dialogContentRef",
                                  ref: dialogContentRef
                                }, _ctx.$attrs, {
                                  center: _ctx.center,
                                  "align-center": unref(_alignCenter),
                                  "close-icon": _ctx.closeIcon,
                                  draggable: unref(_draggable),
                                  overflow: unref(_overflow),
                                  fullscreen: _ctx.fullscreen,
                                  "header-class": _ctx.headerClass,
                                  "body-class": _ctx.bodyClass,
                                  "footer-class": _ctx.footerClass,
                                  "show-close": _ctx.showClose,
                                  title: _ctx.title,
                                  "aria-level": _ctx.headerAriaLevel,
                                  onClose: unref(handleClose)
                                }), createSlots({
                                  header: withCtx(() => [
                                    !_ctx.$slots.title ? renderSlot(_ctx.$slots, "header", {
                                      key: 0,
                                      close: unref(handleClose),
                                      titleId: unref(titleId),
                                      titleClass: unref(ns).e("title")
                                    }) : renderSlot(_ctx.$slots, "title", { key: 1 })
                                  ]),
                                  default: withCtx(() => [
                                    renderSlot(_ctx.$slots, "default")
                                  ]),
                                  _: 2
                                }, [
                                  _ctx.$slots.footer ? {
                                    name: "footer",
                                    fn: withCtx(() => [
                                      renderSlot(_ctx.$slots, "footer")
                                    ])
                                  } : void 0
                                ]), 1040, ["center", "align-center", "close-icon", "draggable", "overflow", "fullscreen", "header-class", "body-class", "footer-class", "show-close", "title", "aria-level", "onClose"])) : createCommentVNode("v-if", true)
                              ]),
                              _: 3
                            }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                          ], 46, ["aria-label", "aria-labelledby", "aria-describedby", "onClick", "onMousedown", "onMouseup"])
                        ]),
                        _: 3
                      }, 8, ["mask", "overlay-class", "z-index"]), [
                        [vShow, unref(visible)]
                      ])
                    ];
                  }),
                  _: 3
                }, 16)
              ]),
              _: 3
            }, 8, ["to", "disabled"]);
          };
        }
      });
      var Dialog = /* @__PURE__ */ _export_sfc(_sfc_main$1r, [["__file", "dialog.vue"]]);
      const ElDialog = exports("ElDialog", withInstall(Dialog));
      const dividerProps = exports("dividerProps", buildProps({
        direction: {
          type: String,
          values: ["horizontal", "vertical"],
          default: "horizontal"
        },
        contentPosition: {
          type: String,
          values: ["left", "center", "right"],
          default: "center"
        },
        borderStyle: {
          type: definePropType(String),
          default: "solid"
        }
      }));
      const __default__$13 = defineComponent({
        name: "ElDivider"
      });
      const _sfc_main$1q = /* @__PURE__ */ defineComponent({
        ...__default__$13,
        props: dividerProps,
        setup(__props) {
          const props2 = __props;
          const ns = useNamespace("divider");
          const dividerStyle = computed(() => {
            return ns.cssVar({
              "border-style": props2.borderStyle
            });
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b(), unref(ns).m(_ctx.direction)]),
              style: normalizeStyle(unref(dividerStyle)),
              role: "separator"
            }, [
              _ctx.$slots.default && _ctx.direction !== "vertical" ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass([unref(ns).e("text"), unref(ns).is(_ctx.contentPosition)])
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2)) : createCommentVNode("v-if", true)
            ], 6);
          };
        }
      });
      var Divider = /* @__PURE__ */ _export_sfc(_sfc_main$1q, [["__file", "divider.vue"]]);
      const ElDivider = exports("ElDivider", withInstall(Divider));
      const drawerProps = exports("drawerProps", buildProps({
        ...dialogProps,
        direction: {
          type: String,
          default: "rtl",
          values: ["ltr", "rtl", "ttb", "btt"]
        },
        size: {
          type: [String, Number],
          default: "30%"
        },
        withHeader: {
          type: Boolean,
          default: true
        },
        modalFade: {
          type: Boolean,
          default: true
        },
        headerAriaLevel: {
          type: String,
          default: "2"
        }
      }));
      const drawerEmits = exports("drawerEmits", dialogEmits);
      const __default__$12 = defineComponent({
        name: "ElDrawer",
        inheritAttrs: false
      });
      const _sfc_main$1p = /* @__PURE__ */ defineComponent({
        ...__default__$12,
        props: drawerProps,
        emits: drawerEmits,
        setup(__props, { expose }) {
          const props2 = __props;
          const slots = useSlots();
          useDeprecated({
            scope: "el-drawer",
            from: "the title slot",
            replacement: "the header slot",
            version: "3.0.0",
            ref: "https://element-plus.org/en-US/component/drawer.html#slots"
          }, computed(() => !!slots.title));
          const drawerRef = ref();
          const focusStartRef = ref();
          const ns = useNamespace("drawer");
          const { t } = useLocale();
          const {
            afterEnter,
            afterLeave,
            beforeLeave,
            visible,
            rendered,
            titleId,
            bodyId,
            zIndex: zIndex2,
            onModalClick,
            onOpenAutoFocus,
            onCloseAutoFocus,
            onFocusoutPrevented,
            onCloseRequested,
            handleClose
          } = useDialog(props2, drawerRef);
          const isHorizontal2 = computed(() => props2.direction === "rtl" || props2.direction === "ltr");
          const drawerSize = computed(() => addUnit(props2.size));
          expose({
            handleClose,
            afterEnter,
            afterLeave
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTeleport$1), {
              to: _ctx.appendTo,
              disabled: _ctx.appendTo !== "body" ? false : !_ctx.appendToBody
            }, {
              default: withCtx(() => [
                createVNode(Transition, {
                  name: unref(ns).b("fade"),
                  onAfterEnter: unref(afterEnter),
                  onAfterLeave: unref(afterLeave),
                  onBeforeLeave: unref(beforeLeave),
                  persisted: ""
                }, {
                  default: withCtx(() => [
                    withDirectives(createVNode(unref(ElOverlay), {
                      mask: _ctx.modal,
                      "overlay-class": _ctx.modalClass,
                      "z-index": unref(zIndex2),
                      onClick: unref(onModalClick)
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(ElFocusTrap), {
                          loop: "",
                          trapped: unref(visible),
                          "focus-trap-el": drawerRef.value,
                          "focus-start-el": focusStartRef.value,
                          onFocusAfterTrapped: unref(onOpenAutoFocus),
                          onFocusAfterReleased: unref(onCloseAutoFocus),
                          onFocusoutPrevented: unref(onFocusoutPrevented),
                          onReleaseRequested: unref(onCloseRequested)
                        }, {
                          default: withCtx(() => [
                            createElementVNode("div", mergeProps({
                              ref_key: "drawerRef",
                              ref: drawerRef,
                              "aria-modal": "true",
                              "aria-label": _ctx.title || void 0,
                              "aria-labelledby": !_ctx.title ? unref(titleId) : void 0,
                              "aria-describedby": unref(bodyId)
                            }, _ctx.$attrs, {
                              class: [unref(ns).b(), _ctx.direction, unref(visible) && "open"],
                              style: unref(isHorizontal2) ? "width: " + unref(drawerSize) : "height: " + unref(drawerSize),
                              role: "dialog",
                              onClick: withModifiers(() => {
                              }, ["stop"])
                            }), [
                              createElementVNode("span", {
                                ref_key: "focusStartRef",
                                ref: focusStartRef,
                                class: normalizeClass(unref(ns).e("sr-focus")),
                                tabindex: "-1"
                              }, null, 2),
                              _ctx.withHeader ? (openBlock(), createElementBlock("header", {
                                key: 0,
                                class: normalizeClass([unref(ns).e("header"), _ctx.headerClass])
                              }, [
                                !_ctx.$slots.title ? renderSlot(_ctx.$slots, "header", {
                                  key: 0,
                                  close: unref(handleClose),
                                  titleId: unref(titleId),
                                  titleClass: unref(ns).e("title")
                                }, () => [
                                  !_ctx.$slots.title ? (openBlock(), createElementBlock("span", {
                                    key: 0,
                                    id: unref(titleId),
                                    role: "heading",
                                    "aria-level": _ctx.headerAriaLevel,
                                    class: normalizeClass(unref(ns).e("title"))
                                  }, toDisplayString(_ctx.title), 11, ["id", "aria-level"])) : createCommentVNode("v-if", true)
                                ]) : renderSlot(_ctx.$slots, "title", { key: 1 }, () => [
                                  createCommentVNode(" DEPRECATED SLOT ")
                                ]),
                                _ctx.showClose ? (openBlock(), createElementBlock("button", {
                                  key: 2,
                                  "aria-label": unref(t)("el.drawer.close"),
                                  class: normalizeClass(unref(ns).e("close-btn")),
                                  type: "button",
                                  onClick: unref(handleClose)
                                }, [
                                  createVNode(unref(ElIcon), {
                                    class: normalizeClass(unref(ns).e("close"))
                                  }, {
                                    default: withCtx(() => [
                                      createVNode(unref(close_default$1))
                                    ]),
                                    _: 1
                                  }, 8, ["class"])
                                ], 10, ["aria-label", "onClick"])) : createCommentVNode("v-if", true)
                              ], 2)) : createCommentVNode("v-if", true),
                              unref(rendered) ? (openBlock(), createElementBlock("div", {
                                key: 1,
                                id: unref(bodyId),
                                class: normalizeClass([unref(ns).e("body"), _ctx.bodyClass])
                              }, [
                                renderSlot(_ctx.$slots, "default")
                              ], 10, ["id"])) : createCommentVNode("v-if", true),
                              _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
                                key: 2,
                                class: normalizeClass([unref(ns).e("footer"), _ctx.footerClass])
                              }, [
                                renderSlot(_ctx.$slots, "footer")
                              ], 2)) : createCommentVNode("v-if", true)
                            ], 16, ["aria-label", "aria-labelledby", "aria-describedby", "onClick"])
                          ]),
                          _: 3
                        }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                      ]),
                      _: 3
                    }, 8, ["mask", "overlay-class", "z-index", "onClick"]), [
                      [vShow, unref(visible)]
                    ])
                  ]),
                  _: 3
                }, 8, ["name", "onAfterEnter", "onAfterLeave", "onBeforeLeave"])
              ]),
              _: 3
            }, 8, ["to", "disabled"]);
          };
        }
      });
      var Drawer = /* @__PURE__ */ _export_sfc(_sfc_main$1p, [["__file", "drawer.vue"]]);
      const ElDrawer = exports("ElDrawer", withInstall(Drawer));
      const _sfc_main$1o = /* @__PURE__ */ defineComponent({
        inheritAttrs: false
      });
      function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default");
      }
      var Collection = /* @__PURE__ */ _export_sfc(_sfc_main$1o, [["render", _sfc_render$k], ["__file", "collection.vue"]]);
      const _sfc_main$1n = /* @__PURE__ */ defineComponent({
        name: "ElCollectionItem",
        inheritAttrs: false
      });
      function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default");
      }
      var CollectionItem = /* @__PURE__ */ _export_sfc(_sfc_main$1n, [["render", _sfc_render$j], ["__file", "collection-item.vue"]]);
      const COLLECTION_ITEM_SIGN = `data-el-collection-item`;
      const createCollectionWithScope = (name) => {
        const COLLECTION_NAME = `El${name}Collection`;
        const COLLECTION_ITEM_NAME = `${COLLECTION_NAME}Item`;
        const COLLECTION_INJECTION_KEY2 = Symbol(COLLECTION_NAME);
        const COLLECTION_ITEM_INJECTION_KEY2 = Symbol(COLLECTION_ITEM_NAME);
        const ElCollection2 = {
          ...Collection,
          name: COLLECTION_NAME,
          setup() {
            const collectionRef = ref();
            const itemMap = /* @__PURE__ */ new Map();
            const getItems = () => {
              const collectionEl = unref(collectionRef);
              if (!collectionEl)
                return [];
              const orderedNodes = Array.from(collectionEl.querySelectorAll(`[${COLLECTION_ITEM_SIGN}]`));
              const items = [...itemMap.values()];
              return items.sort((a2, b2) => orderedNodes.indexOf(a2.ref) - orderedNodes.indexOf(b2.ref));
            };
            provide(COLLECTION_INJECTION_KEY2, {
              itemMap,
              getItems,
              collectionRef
            });
          }
        };
        const ElCollectionItem2 = {
          ...CollectionItem,
          name: COLLECTION_ITEM_NAME,
          setup(_2, { attrs }) {
            const collectionItemRef = ref();
            const collectionInjection = inject(COLLECTION_INJECTION_KEY2, void 0);
            provide(COLLECTION_ITEM_INJECTION_KEY2, {
              collectionItemRef
            });
            onMounted(() => {
              const collectionItemEl = unref(collectionItemRef);
              if (collectionItemEl) {
                collectionInjection.itemMap.set(collectionItemEl, {
                  ref: collectionItemEl,
                  ...attrs
                });
              }
            });
            onBeforeUnmount(() => {
              const collectionItemEl = unref(collectionItemRef);
              collectionInjection.itemMap.delete(collectionItemEl);
            });
          }
        };
        return {
          COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY2,
          COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY2,
          ElCollection: ElCollection2,
          ElCollectionItem: ElCollectionItem2
        };
      };
      const rovingFocusGroupProps = buildProps({
        style: { type: definePropType([String, Array, Object]) },
        currentTabId: {
          type: definePropType(String)
        },
        defaultCurrentTabId: String,
        loop: Boolean,
        dir: {
          type: String,
          values: ["ltr", "rtl"],
          default: "ltr"
        },
        orientation: {
          type: definePropType(String)
        },
        onBlur: Function,
        onFocus: Function,
        onMousedown: Function
      });
      const {
        ElCollection: ElCollection$1,
        ElCollectionItem: ElCollectionItem$1,
        COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY$1,
        COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY$1
      } = createCollectionWithScope("RovingFocusGroup");
      const ROVING_FOCUS_GROUP_INJECTION_KEY = Symbol("elRovingFocusGroup");
      const ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY = Symbol("elRovingFocusGroupItem");
      const MAP_KEY_TO_FOCUS_INTENT = {
        ArrowLeft: "prev",
        ArrowUp: "prev",
        ArrowRight: "next",
        ArrowDown: "next",
        PageUp: "first",
        Home: "first",
        PageDown: "last",
        End: "last"
      };
      const getDirectionAwareKey = (key, dir) => {
        if (dir !== "rtl")
          return key;
        switch (key) {
          case EVENT_CODE.right:
            return EVENT_CODE.left;
          case EVENT_CODE.left:
            return EVENT_CODE.right;
          default:
            return key;
        }
      };
      const getFocusIntent = (event, orientation, dir) => {
        const key = getDirectionAwareKey(event.code, dir);
        if (orientation === "vertical" && [EVENT_CODE.left, EVENT_CODE.right].includes(key))
          return void 0;
        if (orientation === "horizontal" && [EVENT_CODE.up, EVENT_CODE.down].includes(key))
          return void 0;
        return MAP_KEY_TO_FOCUS_INTENT[key];
      };
      const reorderArray = (array3, atIdx) => {
        return array3.map((_2, idx) => array3[(idx + atIdx) % array3.length]);
      };
      const focusFirst = (elements) => {
        const { activeElement: prevActive } = document;
        for (const element of elements) {
          if (element === prevActive)
            return;
          element.focus();
          if (prevActive !== document.activeElement)
            return;
        }
      };
      const CURRENT_TAB_ID_CHANGE_EVT = "currentTabIdChange";
      const ENTRY_FOCUS_EVT = "rovingFocusGroup.entryFocus";
      const EVT_OPTS = { bubbles: false, cancelable: true };
      const _sfc_main$1m = defineComponent({
        name: "ElRovingFocusGroupImpl",
        inheritAttrs: false,
        props: rovingFocusGroupProps,
        emits: [CURRENT_TAB_ID_CHANGE_EVT, "entryFocus"],
        setup(props2, { emit }) {
          var _a;
          const currentTabbedId = ref((_a = props2.currentTabId || props2.defaultCurrentTabId) != null ? _a : null);
          const isBackingOut = ref(false);
          const isClickFocus = ref(false);
          const rovingFocusGroupRef = ref();
          const { getItems } = inject(COLLECTION_INJECTION_KEY$1, void 0);
          const rovingFocusGroupRootStyle = computed(() => {
            return [
              {
                outline: "none"
              },
              props2.style
            ];
          });
          const onItemFocus = (tabbedId) => {
            emit(CURRENT_TAB_ID_CHANGE_EVT, tabbedId);
          };
          const onItemShiftTab = () => {
            isBackingOut.value = true;
          };
          const onMousedown = composeEventHandlers((e) => {
            var _a2;
            (_a2 = props2.onMousedown) == null ? void 0 : _a2.call(props2, e);
          }, () => {
            isClickFocus.value = true;
          });
          const onFocus = composeEventHandlers((e) => {
            var _a2;
            (_a2 = props2.onFocus) == null ? void 0 : _a2.call(props2, e);
          }, (e) => {
            const isKeyboardFocus = !unref(isClickFocus);
            const { target: target2, currentTarget } = e;
            if (target2 === currentTarget && isKeyboardFocus && !unref(isBackingOut)) {
              const entryFocusEvt = new Event(ENTRY_FOCUS_EVT, EVT_OPTS);
              currentTarget == null ? void 0 : currentTarget.dispatchEvent(entryFocusEvt);
              if (!entryFocusEvt.defaultPrevented) {
                const items = getItems().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === unref(currentTabbedId));
                const candidates = [activeItem, currentItem, ...items].filter(Boolean);
                const candidateNodes = candidates.map((item) => item.ref);
                focusFirst(candidateNodes);
              }
            }
            isClickFocus.value = false;
          });
          const onBlur = composeEventHandlers((e) => {
            var _a2;
            (_a2 = props2.onBlur) == null ? void 0 : _a2.call(props2, e);
          }, () => {
            isBackingOut.value = false;
          });
          const handleEntryFocus = (...args) => {
            emit("entryFocus", ...args);
          };
          provide(ROVING_FOCUS_GROUP_INJECTION_KEY, {
            currentTabbedId: readonly(currentTabbedId),
            loop: toRef(props2, "loop"),
            tabIndex: computed(() => {
              return unref(isBackingOut) ? -1 : 0;
            }),
            rovingFocusGroupRef,
            rovingFocusGroupRootStyle,
            orientation: toRef(props2, "orientation"),
            dir: toRef(props2, "dir"),
            onItemFocus,
            onItemShiftTab,
            onBlur,
            onFocus,
            onMousedown
          });
          watch(() => props2.currentTabId, (val) => {
            currentTabbedId.value = val != null ? val : null;
          });
          useEventListener(rovingFocusGroupRef, ENTRY_FOCUS_EVT, handleEntryFocus);
        }
      });
      function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
        return renderSlot(_ctx.$slots, "default");
      }
      var ElRovingFocusGroupImpl = /* @__PURE__ */ _export_sfc(_sfc_main$1m, [["render", _sfc_render$i], ["__file", "roving-focus-group-impl.vue"]]);
      const _sfc_main$1l = defineComponent({
        name: "ElRovingFocusGroup",
        components: {
          ElFocusGroupCollection: ElCollection$1,
          ElRovingFocusGroupImpl
        }
      });
      function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_roving_focus_group_impl = resolveComponent("el-roving-focus-group-impl");
        const _component_el_focus_group_collection = resolveComponent("el-focus-group-collection");
        return openBlock(), createBlock(_component_el_focus_group_collection, null, {
          default: withCtx(() => [
            createVNode(_component_el_roving_focus_group_impl, normalizeProps(guardReactiveProps(_ctx.$attrs)), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16)
          ]),
          _: 3
        });
      }
      var ElRovingFocusGroup = /* @__PURE__ */ _export_sfc(_sfc_main$1l, [["render", _sfc_render$h], ["__file", "roving-focus-group.vue"]]);
      const _sfc_main$1k = defineComponent({
        components: {
          ElRovingFocusCollectionItem: ElCollectionItem$1
        },
        props: {
          focusable: {
            type: Boolean,
            default: true
          },
          active: Boolean
        },
        emits: ["mousedown", "focus", "keydown"],
        setup(props2, { emit }) {
          const { currentTabbedId, loop, onItemFocus, onItemShiftTab } = inject(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
          const { getItems } = inject(COLLECTION_INJECTION_KEY$1, void 0);
          const id = useId();
          const rovingFocusGroupItemRef = ref();
          const handleMousedown = composeEventHandlers((e) => {
            emit("mousedown", e);
          }, (e) => {
            if (!props2.focusable) {
              e.preventDefault();
            } else {
              onItemFocus(unref(id));
            }
          });
          const handleFocus = composeEventHandlers((e) => {
            emit("focus", e);
          }, () => {
            onItemFocus(unref(id));
          });
          const handleKeydown = composeEventHandlers((e) => {
            emit("keydown", e);
          }, (e) => {
            const { code, shiftKey, target: target2, currentTarget } = e;
            if (code === EVENT_CODE.tab && shiftKey) {
              onItemShiftTab();
              return;
            }
            if (target2 !== currentTarget)
              return;
            const focusIntent = getFocusIntent(e);
            if (focusIntent) {
              e.preventDefault();
              const items = getItems().filter((item) => item.focusable);
              let elements = items.map((item) => item.ref);
              switch (focusIntent) {
                case "last": {
                  elements.reverse();
                  break;
                }
                case "prev":
                case "next": {
                  if (focusIntent === "prev") {
                    elements.reverse();
                  }
                  const currentIdx = elements.indexOf(currentTarget);
                  elements = loop.value ? reorderArray(elements, currentIdx + 1) : elements.slice(currentIdx + 1);
                  break;
                }
              }
              nextTick(() => {
                focusFirst(elements);
              });
            }
          });
          const isCurrentTab = computed(() => currentTabbedId.value === unref(id));
          provide(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, {
            rovingFocusGroupItemRef,
            tabIndex: computed(() => unref(isCurrentTab) ? 0 : -1),
            handleMousedown,
            handleFocus,
            handleKeydown
          });
          return {
            id,
            handleKeydown,
            handleFocus,
            handleMousedown
          };
        }
      });
      function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_roving_focus_collection_item = resolveComponent("el-roving-focus-collection-item");
        return openBlock(), createBlock(_component_el_roving_focus_collection_item, {
          id: _ctx.id,
          focusable: _ctx.focusable,
          active: _ctx.active
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "focusable", "active"]);
      }
      var ElRovingFocusItem = /* @__PURE__ */ _export_sfc(_sfc_main$1k, [["render", _sfc_render$g], ["__file", "roving-focus-item.vue"]]);
      const dropdownProps = exports("dropdownProps", buildProps({
        trigger: useTooltipTriggerProps.trigger,
        triggerKeys: {
          type: definePropType(Array),
          default: () => [
            EVENT_CODE.enter,
            EVENT_CODE.numpadEnter,
            EVENT_CODE.space,
            EVENT_CODE.down
          ]
        },
        effect: {
          ...useTooltipContentProps.effect,
          default: "light"
        },
        type: {
          type: definePropType(String)
        },
        placement: {
          type: definePropType(String),
          default: "bottom"
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        id: String,
        size: {
          type: String,
          default: ""
        },
        splitButton: Boolean,
        hideOnClick: {
          type: Boolean,
          default: true
        },
        loop: {
          type: Boolean,
          default: true
        },
        showTimeout: {
          type: Number,
          default: 150
        },
        hideTimeout: {
          type: Number,
          default: 150
        },
        tabindex: {
          type: definePropType([Number, String]),
          default: 0
        },
        maxHeight: {
          type: definePropType([Number, String]),
          default: ""
        },
        popperClass: {
          type: String,
          default: ""
        },
        disabled: Boolean,
        role: {
          type: String,
          values: roleTypes,
          default: "menu"
        },
        buttonProps: {
          type: definePropType(Object)
        },
        teleported: useTooltipContentProps.teleported,
        persistent: {
          type: Boolean,
          default: true
        }
      }));
      const dropdownItemProps = exports("dropdownItemProps", buildProps({
        command: {
          type: [Object, String, Number],
          default: () => ({})
        },
        disabled: Boolean,
        divided: Boolean,
        textValue: String,
        icon: {
          type: iconPropType
        }
      }));
      const dropdownMenuProps = exports("dropdownMenuProps", buildProps({
        onKeydown: { type: definePropType(Function) }
      }));
      const FIRST_KEYS = exports("FIRST_KEYS", [
        EVENT_CODE.down,
        EVENT_CODE.pageDown,
        EVENT_CODE.home
      ]);
      const LAST_KEYS = exports("LAST_KEYS", [EVENT_CODE.up, EVENT_CODE.pageUp, EVENT_CODE.end]);
      const FIRST_LAST_KEYS = exports("FIRST_LAST_KEYS", [...FIRST_KEYS, ...LAST_KEYS]);
      const {
        ElCollection,
        ElCollectionItem,
        COLLECTION_INJECTION_KEY,
        COLLECTION_ITEM_INJECTION_KEY
      } = createCollectionWithScope("Dropdown");
      exports({ ElCollection, ElCollectionItem, DROPDOWN_COLLECTION_INJECTION_KEY: COLLECTION_INJECTION_KEY, DROPDOWN_COLLECTION_ITEM_INJECTION_KEY: COLLECTION_ITEM_INJECTION_KEY });
      const DROPDOWN_INJECTION_KEY = exports("DROPDOWN_INJECTION_KEY", Symbol("elDropdown"));
      const DROPDOWN_INSTANCE_INJECTION_KEY = exports("DROPDOWN_INSTANCE_INJECTION_KEY", "elDropdown");
      const { ButtonGroup: ElButtonGroup } = ElButton;
      const _sfc_main$1j = defineComponent({
        name: "ElDropdown",
        components: {
          ElButton,
          ElButtonGroup,
          ElScrollbar,
          ElDropdownCollection: ElCollection,
          ElTooltip,
          ElRovingFocusGroup,
          ElOnlyChild: OnlyChild,
          ElIcon,
          ArrowDown: arrow_down_default$1
        },
        props: dropdownProps,
        emits: ["visible-change", "click", "command"],
        setup(props2, { emit }) {
          const _instance = getCurrentInstance();
          const ns = useNamespace("dropdown");
          const { t } = useLocale();
          const triggeringElementRef = ref();
          const referenceElementRef = ref();
          const popperRef = ref();
          const contentRef = ref();
          const scrollbar = ref(null);
          const currentTabId = ref(null);
          const isUsingKeyboard = ref(false);
          const wrapStyle = computed(() => ({
            maxHeight: addUnit(props2.maxHeight)
          }));
          const dropdownTriggerKls = computed(() => [ns.m(dropdownSize.value)]);
          const trigger = computed(() => castArray$1(props2.trigger));
          const defaultTriggerId = useId().value;
          const triggerId = computed(() => props2.id || defaultTriggerId);
          watch([triggeringElementRef, trigger], ([triggeringElement, trigger2], [prevTriggeringElement]) => {
            var _a, _b, _c;
            if ((_a = prevTriggeringElement == null ? void 0 : prevTriggeringElement.$el) == null ? void 0 : _a.removeEventListener) {
              prevTriggeringElement.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
            }
            if ((_b = triggeringElement == null ? void 0 : triggeringElement.$el) == null ? void 0 : _b.removeEventListener) {
              triggeringElement.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
            }
            if (((_c = triggeringElement == null ? void 0 : triggeringElement.$el) == null ? void 0 : _c.addEventListener) && trigger2.includes("hover")) {
              triggeringElement.$el.addEventListener("pointerenter", onAutofocusTriggerEnter);
            }
          }, { immediate: true });
          onBeforeUnmount(() => {
            var _a, _b;
            if ((_b = (_a = triggeringElementRef.value) == null ? void 0 : _a.$el) == null ? void 0 : _b.removeEventListener) {
              triggeringElementRef.value.$el.removeEventListener("pointerenter", onAutofocusTriggerEnter);
            }
          });
          function handleClick() {
            handleClose();
          }
          function handleClose() {
            var _a;
            (_a = popperRef.value) == null ? void 0 : _a.onClose();
          }
          function handleOpen() {
            var _a;
            (_a = popperRef.value) == null ? void 0 : _a.onOpen();
          }
          const dropdownSize = useFormSize();
          function commandHandler(...args) {
            emit("command", ...args);
          }
          function onAutofocusTriggerEnter() {
            var _a, _b;
            (_b = (_a = triggeringElementRef.value) == null ? void 0 : _a.$el) == null ? void 0 : _b.focus({
              preventScroll: true
            });
          }
          function onItemEnter() {
          }
          function onItemLeave() {
            const contentEl = unref(contentRef);
            trigger.value.includes("hover") && (contentEl == null ? void 0 : contentEl.focus({
              preventScroll: true
            }));
            currentTabId.value = null;
          }
          function handleCurrentTabIdChange(id) {
            currentTabId.value = id;
          }
          function handleEntryFocus(e) {
            if (!isUsingKeyboard.value) {
              e.preventDefault();
              e.stopImmediatePropagation();
            }
          }
          function handleBeforeShowTooltip() {
            emit("visible-change", true);
          }
          function handleShowTooltip(event) {
            var _a;
            if ((event == null ? void 0 : event.type) === "keydown") {
              (_a = contentRef.value) == null ? void 0 : _a.focus();
            }
          }
          function handleBeforeHideTooltip() {
            emit("visible-change", false);
          }
          provide(DROPDOWN_INJECTION_KEY, {
            contentRef,
            role: computed(() => props2.role),
            triggerId,
            isUsingKeyboard,
            onItemEnter,
            onItemLeave
          });
          provide(DROPDOWN_INSTANCE_INJECTION_KEY, {
            instance: _instance,
            dropdownSize,
            handleClick,
            commandHandler,
            trigger: toRef(props2, "trigger"),
            hideOnClick: toRef(props2, "hideOnClick")
          });
          const onFocusAfterTrapped = (e) => {
            var _a, _b;
            e.preventDefault();
            (_b = (_a = contentRef.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a, {
              preventScroll: true
            });
          };
          const handlerMainButtonClick = (event) => {
            emit("click", event);
          };
          return {
            t,
            ns,
            scrollbar,
            wrapStyle,
            dropdownTriggerKls,
            dropdownSize,
            triggerId,
            currentTabId,
            handleCurrentTabIdChange,
            handlerMainButtonClick,
            handleEntryFocus,
            handleClose,
            handleOpen,
            handleBeforeShowTooltip,
            handleShowTooltip,
            handleBeforeHideTooltip,
            onFocusAfterTrapped,
            popperRef,
            contentRef,
            triggeringElementRef,
            referenceElementRef
          };
        }
      });
      function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
        var _a;
        const _component_el_dropdown_collection = resolveComponent("el-dropdown-collection");
        const _component_el_roving_focus_group = resolveComponent("el-roving-focus-group");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _component_el_only_child = resolveComponent("el-only-child");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _component_el_button = resolveComponent("el-button");
        const _component_arrow_down = resolveComponent("arrow-down");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_button_group = resolveComponent("el-button-group");
        return openBlock(), createElementBlock("div", {
          class: normalizeClass([_ctx.ns.b(), _ctx.ns.is("disabled", _ctx.disabled)])
        }, [
          createVNode(_component_el_tooltip, {
            ref: "popperRef",
            role: _ctx.role,
            effect: _ctx.effect,
            "fallback-placements": ["bottom", "top"],
            "popper-options": _ctx.popperOptions,
            "gpu-acceleration": false,
            "hide-after": _ctx.trigger === "hover" ? _ctx.hideTimeout : 0,
            "manual-mode": true,
            placement: _ctx.placement,
            "popper-class": [_ctx.ns.e("popper"), _ctx.popperClass],
            "reference-element": (_a = _ctx.referenceElementRef) == null ? void 0 : _a.$el,
            trigger: _ctx.trigger,
            "trigger-keys": _ctx.triggerKeys,
            "trigger-target-el": _ctx.contentRef,
            "show-after": _ctx.trigger === "hover" ? _ctx.showTimeout : 0,
            "stop-popper-mouse-event": false,
            "virtual-ref": _ctx.triggeringElementRef,
            "virtual-triggering": _ctx.splitButton,
            disabled: _ctx.disabled,
            transition: `${_ctx.ns.namespace.value}-zoom-in-top`,
            teleported: _ctx.teleported,
            pure: "",
            persistent: _ctx.persistent,
            onBeforeShow: _ctx.handleBeforeShowTooltip,
            onShow: _ctx.handleShowTooltip,
            onBeforeHide: _ctx.handleBeforeHideTooltip
          }, createSlots({
            content: withCtx(() => [
              createVNode(_component_el_scrollbar, {
                ref: "scrollbar",
                "wrap-style": _ctx.wrapStyle,
                tag: "div",
                "view-class": _ctx.ns.e("list")
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_roving_focus_group, {
                    loop: _ctx.loop,
                    "current-tab-id": _ctx.currentTabId,
                    orientation: "horizontal",
                    onCurrentTabIdChange: _ctx.handleCurrentTabIdChange,
                    onEntryFocus: _ctx.handleEntryFocus
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_el_dropdown_collection, null, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "dropdown")
                        ]),
                        _: 3
                      })
                    ]),
                    _: 3
                  }, 8, ["loop", "current-tab-id", "onCurrentTabIdChange", "onEntryFocus"])
                ]),
                _: 3
              }, 8, ["wrap-style", "view-class"])
            ]),
            _: 2
          }, [
            !_ctx.splitButton ? {
              name: "default",
              fn: withCtx(() => [
                createVNode(_component_el_only_child, {
                  id: _ctx.triggerId,
                  ref: "triggeringElementRef",
                  role: "button",
                  tabindex: _ctx.tabindex
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["id", "tabindex"])
              ])
            } : void 0
          ]), 1032, ["role", "effect", "popper-options", "hide-after", "placement", "popper-class", "reference-element", "trigger", "trigger-keys", "trigger-target-el", "show-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "teleported", "persistent", "onBeforeShow", "onShow", "onBeforeHide"]),
          _ctx.splitButton ? (openBlock(), createBlock(_component_el_button_group, { key: 0 }, {
            default: withCtx(() => [
              createVNode(_component_el_button, mergeProps({ ref: "referenceElementRef" }, _ctx.buttonProps, {
                size: _ctx.dropdownSize,
                type: _ctx.type,
                disabled: _ctx.disabled,
                tabindex: _ctx.tabindex,
                onClick: _ctx.handlerMainButtonClick
              }), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 16, ["size", "type", "disabled", "tabindex", "onClick"]),
              createVNode(_component_el_button, mergeProps({
                id: _ctx.triggerId,
                ref: "triggeringElementRef"
              }, _ctx.buttonProps, {
                role: "button",
                size: _ctx.dropdownSize,
                type: _ctx.type,
                class: _ctx.ns.e("caret-button"),
                disabled: _ctx.disabled,
                tabindex: _ctx.tabindex,
                "aria-label": _ctx.t("el.dropdown.toggleDropdown")
              }), {
                default: withCtx(() => [
                  createVNode(_component_el_icon, {
                    class: normalizeClass(_ctx.ns.e("icon"))
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_arrow_down)
                    ]),
                    _: 1
                  }, 8, ["class"])
                ]),
                _: 1
              }, 16, ["id", "size", "type", "class", "disabled", "tabindex", "aria-label"])
            ]),
            _: 3
          })) : createCommentVNode("v-if", true)
        ], 2);
      }
      var Dropdown = /* @__PURE__ */ _export_sfc(_sfc_main$1j, [["render", _sfc_render$f], ["__file", "dropdown.vue"]]);
      const _sfc_main$1i = defineComponent({
        name: "DropdownItemImpl",
        components: {
          ElIcon
        },
        props: dropdownItemProps,
        emits: ["pointermove", "pointerleave", "click", "clickimpl"],
        setup(_2, { emit }) {
          const ns = useNamespace("dropdown");
          const { role: menuRole } = inject(DROPDOWN_INJECTION_KEY, void 0);
          const { collectionItemRef: dropdownCollectionItemRef } = inject(COLLECTION_ITEM_INJECTION_KEY, void 0);
          const { collectionItemRef: rovingFocusCollectionItemRef } = inject(COLLECTION_ITEM_INJECTION_KEY$1, void 0);
          const {
            rovingFocusGroupItemRef,
            tabIndex,
            handleFocus,
            handleKeydown: handleItemKeydown,
            handleMousedown
          } = inject(ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, void 0);
          const itemRef = composeRefs(dropdownCollectionItemRef, rovingFocusCollectionItemRef, rovingFocusGroupItemRef);
          const role = computed(() => {
            if (menuRole.value === "menu") {
              return "menuitem";
            } else if (menuRole.value === "navigation") {
              return "link";
            }
            return "button";
          });
          const handleKeydown = composeEventHandlers((e) => {
            if ([EVENT_CODE.enter, EVENT_CODE.numpadEnter, EVENT_CODE.space].includes(e.code)) {
              e.preventDefault();
              e.stopImmediatePropagation();
              emit("clickimpl", e);
              return true;
            }
          }, handleItemKeydown);
          return {
            ns,
            itemRef,
            dataset: {
              [COLLECTION_ITEM_SIGN]: ""
            },
            role,
            tabIndex,
            handleFocus,
            handleKeydown,
            handleMousedown
          };
        }
      });
      function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_icon = resolveComponent("el-icon");
        return openBlock(), createElementBlock(Fragment, null, [
          _ctx.divided ? (openBlock(), createElementBlock("li", {
            key: 0,
            role: "separator",
            class: normalizeClass(_ctx.ns.bem("menu", "item", "divided"))
          }, null, 2)) : createCommentVNode("v-if", true),
          createElementVNode("li", mergeProps({ ref: _ctx.itemRef }, { ..._ctx.dataset, ..._ctx.$attrs }, {
            "aria-disabled": _ctx.disabled,
            class: [_ctx.ns.be("menu", "item"), _ctx.ns.is("disabled", _ctx.disabled)],
            tabindex: _ctx.tabIndex,
            role: _ctx.role,
            onClick: (e) => _ctx.$emit("clickimpl", e),
            onFocus: _ctx.handleFocus,
            onKeydown: withModifiers(_ctx.handleKeydown, ["self"]),
            onMousedown: _ctx.handleMousedown,
            onPointermove: (e) => _ctx.$emit("pointermove", e),
            onPointerleave: (e) => _ctx.$emit("pointerleave", e)
          }), [
            _ctx.icon ? (openBlock(), createBlock(_component_el_icon, { key: 0 }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
              ]),
              _: 1
            })) : createCommentVNode("v-if", true),
            renderSlot(_ctx.$slots, "default")
          ], 16, ["aria-disabled", "tabindex", "role", "onClick", "onFocus", "onKeydown", "onMousedown", "onPointermove", "onPointerleave"])
        ], 64);
      }
      var ElDropdownItemImpl = /* @__PURE__ */ _export_sfc(_sfc_main$1i, [["render", _sfc_render$e], ["__file", "dropdown-item-impl.vue"]]);
      const useDropdown = () => {
        const elDropdown = inject(DROPDOWN_INSTANCE_INJECTION_KEY, {});
        const _elDropdownSize = computed(() => elDropdown == null ? void 0 : elDropdown.dropdownSize);
        return {
          elDropdown,
          _elDropdownSize
        };
      };
      const _sfc_main$1h = defineComponent({
        name: "ElDropdownItem",
        components: {
          ElDropdownCollectionItem: ElCollectionItem,
          ElRovingFocusItem,
          ElDropdownItemImpl
        },
        inheritAttrs: false,
        props: dropdownItemProps,
        emits: ["pointermove", "pointerleave", "click"],
        setup(props2, { emit, attrs }) {
          const { elDropdown } = useDropdown();
          const _instance = getCurrentInstance();
          const itemRef = ref(null);
          const textContent = computed(() => {
            var _a, _b;
            return (_b = (_a = unref(itemRef)) == null ? void 0 : _a.textContent) != null ? _b : "";
          });
          const { onItemEnter, onItemLeave } = inject(DROPDOWN_INJECTION_KEY, void 0);
          const handlePointerMove = composeEventHandlers((e) => {
            emit("pointermove", e);
            return e.defaultPrevented;
          }, whenMouse((e) => {
            if (props2.disabled) {
              onItemLeave(e);
              return;
            }
            const target2 = e.currentTarget;
            if (target2 === document.activeElement || target2.contains(document.activeElement)) {
              return;
            }
            onItemEnter(e);
            if (!e.defaultPrevented) {
              target2 == null ? void 0 : target2.focus({
                preventScroll: true
              });
            }
          }));
          const handlePointerLeave = composeEventHandlers((e) => {
            emit("pointerleave", e);
            return e.defaultPrevented;
          }, whenMouse(onItemLeave));
          const handleClick = composeEventHandlers((e) => {
            if (props2.disabled) {
              return;
            }
            emit("click", e);
            return e.type !== "keydown" && e.defaultPrevented;
          }, (e) => {
            var _a, _b, _c;
            if (props2.disabled) {
              e.stopImmediatePropagation();
              return;
            }
            if ((_a = elDropdown == null ? void 0 : elDropdown.hideOnClick) == null ? void 0 : _a.value) {
              (_b = elDropdown.handleClick) == null ? void 0 : _b.call(elDropdown);
            }
            (_c = elDropdown.commandHandler) == null ? void 0 : _c.call(elDropdown, props2.command, _instance, e);
          });
          const propsAndAttrs = computed(() => ({ ...props2, ...attrs }));
          return {
            handleClick,
            handlePointerMove,
            handlePointerLeave,
            textContent,
            propsAndAttrs
          };
        }
      });
      function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
        var _a;
        const _component_el_dropdown_item_impl = resolveComponent("el-dropdown-item-impl");
        const _component_el_roving_focus_item = resolveComponent("el-roving-focus-item");
        const _component_el_dropdown_collection_item = resolveComponent("el-dropdown-collection-item");
        return openBlock(), createBlock(_component_el_dropdown_collection_item, {
          disabled: _ctx.disabled,
          "text-value": (_a = _ctx.textValue) != null ? _a : _ctx.textContent
        }, {
          default: withCtx(() => [
            createVNode(_component_el_roving_focus_item, {
              focusable: !_ctx.disabled
            }, {
              default: withCtx(() => [
                createVNode(_component_el_dropdown_item_impl, mergeProps(_ctx.propsAndAttrs, {
                  onPointerleave: _ctx.handlePointerLeave,
                  onPointermove: _ctx.handlePointerMove,
                  onClickimpl: _ctx.handleClick
                }), {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  _: 3
                }, 16, ["onPointerleave", "onPointermove", "onClickimpl"])
              ]),
              _: 3
            }, 8, ["focusable"])
          ]),
          _: 3
        }, 8, ["disabled", "text-value"]);
      }
      var DropdownItem = /* @__PURE__ */ _export_sfc(_sfc_main$1h, [["render", _sfc_render$d], ["__file", "dropdown-item.vue"]]);
      const _sfc_main$1g = defineComponent({
        name: "ElDropdownMenu",
        props: dropdownMenuProps,
        setup(props2) {
          const ns = useNamespace("dropdown");
          const { _elDropdownSize } = useDropdown();
          const size = _elDropdownSize.value;
          const { focusTrapRef, onKeydown } = inject(FOCUS_TRAP_INJECTION_KEY, void 0);
          const { contentRef, role, triggerId } = inject(DROPDOWN_INJECTION_KEY, void 0);
          const { collectionRef: dropdownCollectionRef, getItems } = inject(COLLECTION_INJECTION_KEY, void 0);
          const {
            rovingFocusGroupRef,
            rovingFocusGroupRootStyle,
            tabIndex,
            onBlur,
            onFocus,
            onMousedown
          } = inject(ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
          const { collectionRef: rovingFocusGroupCollectionRef } = inject(COLLECTION_INJECTION_KEY$1, void 0);
          const dropdownKls = computed(() => {
            return [ns.b("menu"), ns.bm("menu", size == null ? void 0 : size.value)];
          });
          const dropdownListWrapperRef = composeRefs(contentRef, dropdownCollectionRef, focusTrapRef, rovingFocusGroupRef, rovingFocusGroupCollectionRef);
          const composedKeydown = composeEventHandlers((e) => {
            var _a;
            (_a = props2.onKeydown) == null ? void 0 : _a.call(props2, e);
          }, (e) => {
            const { currentTarget, code, target: target2 } = e;
            currentTarget.contains(target2);
            if (EVENT_CODE.tab === code) {
              e.stopImmediatePropagation();
            }
            e.preventDefault();
            if (target2 !== unref(contentRef) || !FIRST_LAST_KEYS.includes(code))
              return;
            const items = getItems().filter((item) => !item.disabled);
            const targets = items.map((item) => item.ref);
            if (LAST_KEYS.includes(code)) {
              targets.reverse();
            }
            focusFirst(targets);
          });
          const handleKeydown = (e) => {
            composedKeydown(e);
            onKeydown(e);
          };
          return {
            size,
            rovingFocusGroupRootStyle,
            tabIndex,
            dropdownKls,
            role,
            triggerId,
            dropdownListWrapperRef,
            handleKeydown,
            onBlur,
            onFocus,
            onMousedown
          };
        }
      });
      function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("ul", {
          ref: _ctx.dropdownListWrapperRef,
          class: normalizeClass(_ctx.dropdownKls),
          style: normalizeStyle(_ctx.rovingFocusGroupRootStyle),
          tabindex: -1,
          role: _ctx.role,
          "aria-labelledby": _ctx.triggerId,
          onBlur: _ctx.onBlur,
          onFocus: _ctx.onFocus,
          onKeydown: withModifiers(_ctx.handleKeydown, ["self"]),
          onMousedown: withModifiers(_ctx.onMousedown, ["self"])
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 46, ["role", "aria-labelledby", "onBlur", "onFocus", "onKeydown", "onMousedown"]);
      }
      var DropdownMenu = /* @__PURE__ */ _export_sfc(_sfc_main$1g, [["render", _sfc_render$c], ["__file", "dropdown-menu.vue"]]);
      const ElDropdown = exports("ElDropdown", withInstall(Dropdown, {
        DropdownItem,
        DropdownMenu
      }));
      const ElDropdownItem = exports("ElDropdownItem", withNoopInstall(DropdownItem));
      const ElDropdownMenu = exports("ElDropdownMenu", withNoopInstall(DropdownMenu));
      const __default__$11 = defineComponent({
        name: "ImgEmpty"
      });
      const _sfc_main$1f = /* @__PURE__ */ defineComponent({
        ...__default__$11,
        setup(__props) {
          const ns = useNamespace("empty");
          const id = useId();
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("svg", {
              viewBox: "0 0 79 86",
              version: "1.1",
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink"
            }, [
              createElementVNode("defs", null, [
                createElementVNode("linearGradient", {
                  id: `linearGradient-1-${unref(id)}`,
                  x1: "38.8503086%",
                  y1: "0%",
                  x2: "61.1496914%",
                  y2: "100%"
                }, [
                  createElementVNode("stop", {
                    "stop-color": `var(${unref(ns).cssVarBlockName("fill-color-1")})`,
                    offset: "0%"
                  }, null, 8, ["stop-color"]),
                  createElementVNode("stop", {
                    "stop-color": `var(${unref(ns).cssVarBlockName("fill-color-4")})`,
                    offset: "100%"
                  }, null, 8, ["stop-color"])
                ], 8, ["id"]),
                createElementVNode("linearGradient", {
                  id: `linearGradient-2-${unref(id)}`,
                  x1: "0%",
                  y1: "9.5%",
                  x2: "100%",
                  y2: "90.5%"
                }, [
                  createElementVNode("stop", {
                    "stop-color": `var(${unref(ns).cssVarBlockName("fill-color-1")})`,
                    offset: "0%"
                  }, null, 8, ["stop-color"]),
                  createElementVNode("stop", {
                    "stop-color": `var(${unref(ns).cssVarBlockName("fill-color-6")})`,
                    offset: "100%"
                  }, null, 8, ["stop-color"])
                ], 8, ["id"]),
                createElementVNode("rect", {
                  id: `path-3-${unref(id)}`,
                  x: "0",
                  y: "0",
                  width: "17",
                  height: "36"
                }, null, 8, ["id"])
              ]),
              createElementVNode("g", {
                stroke: "none",
                "stroke-width": "1",
                fill: "none",
                "fill-rule": "evenodd"
              }, [
                createElementVNode("g", { transform: "translate(-1268.000000, -535.000000)" }, [
                  createElementVNode("g", { transform: "translate(1268.000000, 535.000000)" }, [
                    createElementVNode("path", {
                      d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z",
                      fill: `var(${unref(ns).cssVarBlockName("fill-color-3")})`
                    }, null, 8, ["fill"]),
                    createElementVNode("polygon", {
                      fill: `var(${unref(ns).cssVarBlockName("fill-color-7")})`,
                      transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ",
                      points: "13 58 53 58 42 45 2 45"
                    }, null, 8, ["fill"]),
                    createElementVNode("g", { transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)" }, [
                      createElementVNode("polygon", {
                        fill: `var(${unref(ns).cssVarBlockName("fill-color-7")})`,
                        transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ",
                        points: "2.84078316e-14 3 18 3 23 7 5 7"
                      }, null, 8, ["fill"]),
                      createElementVNode("polygon", {
                        fill: `var(${unref(ns).cssVarBlockName("fill-color-5")})`,
                        points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43"
                      }, null, 8, ["fill"]),
                      createElementVNode("rect", {
                        fill: `url(#linearGradient-1-${unref(id)})`,
                        transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ",
                        x: "38",
                        y: "7",
                        width: "17",
                        height: "36"
                      }, null, 8, ["fill"]),
                      createElementVNode("polygon", {
                        fill: `var(${unref(ns).cssVarBlockName("fill-color-2")})`,
                        transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ",
                        points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12"
                      }, null, 8, ["fill"])
                    ]),
                    createElementVNode("rect", {
                      fill: `url(#linearGradient-2-${unref(id)})`,
                      x: "13",
                      y: "45",
                      width: "40",
                      height: "36"
                    }, null, 8, ["fill"]),
                    createElementVNode("g", { transform: "translate(53.000000, 45.000000)" }, [
                      createElementVNode("use", {
                        fill: `var(${unref(ns).cssVarBlockName("fill-color-8")})`,
                        transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ",
                        "xlink:href": `#path-3-${unref(id)}`
                      }, null, 8, ["fill", "xlink:href"]),
                      createElementVNode("polygon", {
                        fill: `var(${unref(ns).cssVarBlockName("fill-color-9")})`,
                        mask: `url(#mask-4-${unref(id)})`,
                        transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ",
                        points: "7 0 24 0 20 18 7 16.5"
                      }, null, 8, ["fill", "mask"])
                    ]),
                    createElementVNode("polygon", {
                      fill: `var(${unref(ns).cssVarBlockName("fill-color-2")})`,
                      transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ",
                      points: "62 45 79 45 70 58 53 58"
                    }, null, 8, ["fill"])
                  ])
                ])
              ])
            ]);
          };
        }
      });
      var ImgEmpty = /* @__PURE__ */ _export_sfc(_sfc_main$1f, [["__file", "img-empty.vue"]]);
      const emptyProps = exports("emptyProps", buildProps({
        image: {
          type: String,
          default: ""
        },
        imageSize: Number,
        description: {
          type: String,
          default: ""
        }
      }));
      const __default__$10 = defineComponent({
        name: "ElEmpty"
      });
      const _sfc_main$1e = /* @__PURE__ */ defineComponent({
        ...__default__$10,
        props: emptyProps,
        setup(__props) {
          const props2 = __props;
          const { t } = useLocale();
          const ns = useNamespace("empty");
          const emptyDescription = computed(() => props2.description || t("el.table.emptyText"));
          const imageStyle = computed(() => ({
            width: addUnit(props2.imageSize)
          }));
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b())
            }, [
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("image")),
                style: normalizeStyle(unref(imageStyle))
              }, [
                _ctx.image ? (openBlock(), createElementBlock("img", {
                  key: 0,
                  src: _ctx.image,
                  ondragstart: "return false"
                }, null, 8, ["src"])) : renderSlot(_ctx.$slots, "image", { key: 1 }, () => [
                  createVNode(ImgEmpty)
                ])
              ], 6),
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("description"))
              }, [
                _ctx.$slots.description ? renderSlot(_ctx.$slots, "description", { key: 0 }) : (openBlock(), createElementBlock("p", { key: 1 }, toDisplayString(unref(emptyDescription)), 1))
              ], 2),
              _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).e("bottom"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Empty = /* @__PURE__ */ _export_sfc(_sfc_main$1e, [["__file", "empty.vue"]]);
      const ElEmpty = exports("ElEmpty", withInstall(Empty));
      const imageViewerProps = exports("imageViewerProps", buildProps({
        urlList: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        zIndex: {
          type: Number
        },
        initialIndex: {
          type: Number,
          default: 0
        },
        infinite: {
          type: Boolean,
          default: true
        },
        hideOnClickModal: Boolean,
        teleported: Boolean,
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        zoomRate: {
          type: Number,
          default: 1.2
        },
        minScale: {
          type: Number,
          default: 0.2
        },
        maxScale: {
          type: Number,
          default: 7
        },
        showProgress: Boolean,
        crossorigin: {
          type: definePropType(String)
        }
      }));
      const imageViewerEmits = exports("imageViewerEmits", {
        close: () => true,
        switch: (index2) => isNumber(index2),
        rotate: (deg) => isNumber(deg)
      });
      const __default__$$ = defineComponent({
        name: "ElImageViewer"
      });
      const _sfc_main$1d = /* @__PURE__ */ defineComponent({
        ...__default__$$,
        props: imageViewerProps,
        emits: imageViewerEmits,
        setup(__props, { expose, emit }) {
          var _a;
          const props2 = __props;
          const modes = {
            CONTAIN: {
              name: "contain",
              icon: markRaw(full_screen_default$1)
            },
            ORIGINAL: {
              name: "original",
              icon: markRaw(scale_to_original_default$1)
            }
          };
          let stopWheelListener;
          let prevOverflow = "";
          const { t } = useLocale();
          const ns = useNamespace("image-viewer");
          const { nextZIndex } = useZIndex();
          const wrapper = ref();
          const imgRefs = ref([]);
          const scopeEventListener = effectScope();
          const loading = ref(true);
          const activeIndex = ref(props2.initialIndex);
          const mode = shallowRef(modes.CONTAIN);
          const transform2 = ref({
            scale: 1,
            deg: 0,
            offsetX: 0,
            offsetY: 0,
            enableTransition: false
          });
          const zIndex2 = ref((_a = props2.zIndex) != null ? _a : nextZIndex());
          const isSingle = computed(() => {
            const { urlList } = props2;
            return urlList.length <= 1;
          });
          const isFirst = computed(() => activeIndex.value === 0);
          const isLast = computed(() => activeIndex.value === props2.urlList.length - 1);
          const currentImg = computed(() => props2.urlList[activeIndex.value]);
          const arrowPrevKls = computed(() => [
            ns.e("btn"),
            ns.e("prev"),
            ns.is("disabled", !props2.infinite && isFirst.value)
          ]);
          const arrowNextKls = computed(() => [
            ns.e("btn"),
            ns.e("next"),
            ns.is("disabled", !props2.infinite && isLast.value)
          ]);
          const imgStyle = computed(() => {
            const { scale, deg, offsetX, offsetY, enableTransition } = transform2.value;
            let translateX = offsetX / scale;
            let translateY = offsetY / scale;
            const radian = deg * Math.PI / 180;
            const cosRadian = Math.cos(radian);
            const sinRadian = Math.sin(radian);
            translateX = translateX * cosRadian + translateY * sinRadian;
            translateY = translateY * cosRadian - offsetX / scale * sinRadian;
            const style = {
              transform: `scale(${scale}) rotate(${deg}deg) translate(${translateX}px, ${translateY}px)`,
              transition: enableTransition ? "transform .3s" : ""
            };
            if (mode.value.name === modes.CONTAIN.name) {
              style.maxWidth = style.maxHeight = "100%";
            }
            return style;
          });
          const progress = computed(() => `${activeIndex.value + 1} / ${props2.urlList.length}`);
          function hide() {
            unregisterEventListener();
            stopWheelListener == null ? void 0 : stopWheelListener();
            document.body.style.overflow = prevOverflow;
            emit("close");
          }
          function registerEventListener() {
            const keydownHandler = throttle((e) => {
              switch (e.code) {
                case EVENT_CODE.esc:
                  props2.closeOnPressEscape && hide();
                  break;
                case EVENT_CODE.space:
                  toggleMode();
                  break;
                case EVENT_CODE.left:
                  prev();
                  break;
                case EVENT_CODE.up:
                  handleActions("zoomIn");
                  break;
                case EVENT_CODE.right:
                  next();
                  break;
                case EVENT_CODE.down:
                  handleActions("zoomOut");
                  break;
              }
            });
            const mousewheelHandler = throttle((e) => {
              const delta = e.deltaY || e.deltaX;
              handleActions(delta < 0 ? "zoomIn" : "zoomOut", {
                zoomRate: props2.zoomRate,
                enableTransition: false
              });
            });
            scopeEventListener.run(() => {
              useEventListener(document, "keydown", keydownHandler);
              useEventListener(document, "wheel", mousewheelHandler);
            });
          }
          function unregisterEventListener() {
            scopeEventListener.stop();
          }
          function handleImgLoad() {
            loading.value = false;
          }
          function handleImgError(e) {
            loading.value = false;
            e.target.alt = t("el.image.error");
          }
          function handleMouseDown(e) {
            if (loading.value || e.button !== 0 || !wrapper.value)
              return;
            transform2.value.enableTransition = false;
            const { offsetX, offsetY } = transform2.value;
            const startX = e.pageX;
            const startY = e.pageY;
            const dragHandler = throttle((ev) => {
              transform2.value = {
                ...transform2.value,
                offsetX: offsetX + ev.pageX - startX,
                offsetY: offsetY + ev.pageY - startY
              };
            });
            const removeMousemove = useEventListener(document, "mousemove", dragHandler);
            useEventListener(document, "mouseup", () => {
              removeMousemove();
            });
            e.preventDefault();
          }
          function reset() {
            transform2.value = {
              scale: 1,
              deg: 0,
              offsetX: 0,
              offsetY: 0,
              enableTransition: false
            };
          }
          function toggleMode() {
            if (loading.value)
              return;
            const modeNames = keysOf(modes);
            const modeValues = Object.values(modes);
            const currentMode = mode.value.name;
            const index2 = modeValues.findIndex((i) => i.name === currentMode);
            const nextIndex = (index2 + 1) % modeNames.length;
            mode.value = modes[modeNames[nextIndex]];
            reset();
          }
          function setActiveItem(index2) {
            const len = props2.urlList.length;
            activeIndex.value = (index2 + len) % len;
          }
          function prev() {
            if (isFirst.value && !props2.infinite)
              return;
            setActiveItem(activeIndex.value - 1);
          }
          function next() {
            if (isLast.value && !props2.infinite)
              return;
            setActiveItem(activeIndex.value + 1);
          }
          function handleActions(action, options = {}) {
            if (loading.value)
              return;
            const { minScale, maxScale } = props2;
            const { zoomRate, rotateDeg, enableTransition } = {
              zoomRate: props2.zoomRate,
              rotateDeg: 90,
              enableTransition: true,
              ...options
            };
            switch (action) {
              case "zoomOut":
                if (transform2.value.scale > minScale) {
                  transform2.value.scale = Number.parseFloat((transform2.value.scale / zoomRate).toFixed(3));
                }
                break;
              case "zoomIn":
                if (transform2.value.scale < maxScale) {
                  transform2.value.scale = Number.parseFloat((transform2.value.scale * zoomRate).toFixed(3));
                }
                break;
              case "clockwise":
                transform2.value.deg += rotateDeg;
                emit("rotate", transform2.value.deg);
                break;
              case "anticlockwise":
                transform2.value.deg -= rotateDeg;
                emit("rotate", transform2.value.deg);
                break;
            }
            transform2.value.enableTransition = enableTransition;
          }
          function onFocusoutPrevented(event) {
            var _a2;
            if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) === "pointer") {
              event.preventDefault();
            }
          }
          function onCloseRequested() {
            if (props2.closeOnPressEscape) {
              hide();
            }
          }
          function wheelHandler(e) {
            if (!e.ctrlKey)
              return;
            if (e.deltaY < 0) {
              e.preventDefault();
              return false;
            } else if (e.deltaY > 0) {
              e.preventDefault();
              return false;
            }
          }
          watch(currentImg, () => {
            nextTick(() => {
              const $img = imgRefs.value[0];
              if (!($img == null ? void 0 : $img.complete)) {
                loading.value = true;
              }
            });
          });
          watch(activeIndex, (val) => {
            reset();
            emit("switch", val);
          });
          onMounted(() => {
            registerEventListener();
            stopWheelListener = useEventListener("wheel", wheelHandler, {
              passive: false
            });
            prevOverflow = document.body.style.overflow;
            document.body.style.overflow = "hidden";
          });
          expose({
            setActiveItem
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTeleport$1), {
              to: "body",
              disabled: !_ctx.teleported
            }, {
              default: withCtx(() => [
                createVNode(Transition, {
                  name: "viewer-fade",
                  appear: ""
                }, {
                  default: withCtx(() => [
                    createElementVNode("div", {
                      ref_key: "wrapper",
                      ref: wrapper,
                      tabindex: -1,
                      class: normalizeClass(unref(ns).e("wrapper")),
                      style: normalizeStyle({ zIndex: zIndex2.value })
                    }, [
                      createVNode(unref(ElFocusTrap), {
                        loop: "",
                        trapped: "",
                        "focus-trap-el": wrapper.value,
                        "focus-start-el": "container",
                        onFocusoutPrevented,
                        onReleaseRequested: onCloseRequested
                      }, {
                        default: withCtx(() => [
                          createElementVNode("div", {
                            class: normalizeClass(unref(ns).e("mask")),
                            onClick: withModifiers(($event) => _ctx.hideOnClickModal && hide(), ["self"])
                          }, null, 10, ["onClick"]),
                          createCommentVNode(" CLOSE "),
                          createElementVNode("span", {
                            class: normalizeClass([unref(ns).e("btn"), unref(ns).e("close")]),
                            onClick: hide
                          }, [
                            createVNode(unref(ElIcon), null, {
                              default: withCtx(() => [
                                createVNode(unref(close_default$1))
                              ]),
                              _: 1
                            })
                          ], 2),
                          createCommentVNode(" ARROW "),
                          !unref(isSingle) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                            createElementVNode("span", {
                              class: normalizeClass(unref(arrowPrevKls)),
                              onClick: prev
                            }, [
                              createVNode(unref(ElIcon), null, {
                                default: withCtx(() => [
                                  createVNode(unref(arrow_left_default$1))
                                ]),
                                _: 1
                              })
                            ], 2),
                            createElementVNode("span", {
                              class: normalizeClass(unref(arrowNextKls)),
                              onClick: next
                            }, [
                              createVNode(unref(ElIcon), null, {
                                default: withCtx(() => [
                                  createVNode(unref(arrow_right_default$1))
                                ]),
                                _: 1
                              })
                            ], 2)
                          ], 64)) : createCommentVNode("v-if", true),
                          _ctx.$slots.progress || _ctx.showProgress ? (openBlock(), createElementBlock("div", {
                            key: 1,
                            class: normalizeClass([unref(ns).e("btn"), unref(ns).e("progress")])
                          }, [
                            renderSlot(_ctx.$slots, "progress", {
                              activeIndex: activeIndex.value,
                              total: _ctx.urlList.length
                            }, () => [
                              createTextVNode(toDisplayString(unref(progress)), 1)
                            ])
                          ], 2)) : createCommentVNode("v-if", true),
                          createCommentVNode(" ACTIONS "),
                          createElementVNode("div", {
                            class: normalizeClass([unref(ns).e("btn"), unref(ns).e("actions")])
                          }, [
                            createElementVNode("div", {
                              class: normalizeClass(unref(ns).e("actions__inner"))
                            }, [
                              renderSlot(_ctx.$slots, "toolbar", {
                                actions: handleActions,
                                prev,
                                next,
                                reset: toggleMode,
                                activeIndex: activeIndex.value,
                                setActiveItem
                              }, () => [
                                createVNode(unref(ElIcon), {
                                  onClick: ($event) => handleActions("zoomOut")
                                }, {
                                  default: withCtx(() => [
                                    createVNode(unref(zoom_out_default$1))
                                  ]),
                                  _: 1
                                }, 8, ["onClick"]),
                                createVNode(unref(ElIcon), {
                                  onClick: ($event) => handleActions("zoomIn")
                                }, {
                                  default: withCtx(() => [
                                    createVNode(unref(zoom_in_default$1))
                                  ]),
                                  _: 1
                                }, 8, ["onClick"]),
                                createElementVNode("i", {
                                  class: normalizeClass(unref(ns).e("actions__divider"))
                                }, null, 2),
                                createVNode(unref(ElIcon), { onClick: toggleMode }, {
                                  default: withCtx(() => [
                                    (openBlock(), createBlock(resolveDynamicComponent(unref(mode).icon)))
                                  ]),
                                  _: 1
                                }),
                                createElementVNode("i", {
                                  class: normalizeClass(unref(ns).e("actions__divider"))
                                }, null, 2),
                                createVNode(unref(ElIcon), {
                                  onClick: ($event) => handleActions("anticlockwise")
                                }, {
                                  default: withCtx(() => [
                                    createVNode(unref(refresh_left_default$1))
                                  ]),
                                  _: 1
                                }, 8, ["onClick"]),
                                createVNode(unref(ElIcon), {
                                  onClick: ($event) => handleActions("clockwise")
                                }, {
                                  default: withCtx(() => [
                                    createVNode(unref(refresh_right_default$1))
                                  ]),
                                  _: 1
                                }, 8, ["onClick"])
                              ])
                            ], 2)
                          ], 2),
                          createCommentVNode(" CANVAS "),
                          createElementVNode("div", {
                            class: normalizeClass(unref(ns).e("canvas"))
                          }, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.urlList, (url, i) => {
                              return openBlock(), createElementBlock(Fragment, { key: i }, [
                                i === activeIndex.value ? (openBlock(), createElementBlock("img", {
                                  key: 0,
                                  ref_for: true,
                                  ref: (el) => imgRefs.value[i] = el,
                                  src: url,
                                  style: normalizeStyle(unref(imgStyle)),
                                  class: normalizeClass(unref(ns).e("img")),
                                  crossorigin: _ctx.crossorigin,
                                  onLoad: handleImgLoad,
                                  onError: handleImgError,
                                  onMousedown: handleMouseDown
                                }, null, 46, ["src", "crossorigin"])) : createCommentVNode("v-if", true)
                              ], 64);
                            }), 128))
                          ], 2),
                          renderSlot(_ctx.$slots, "default")
                        ]),
                        _: 3
                      }, 8, ["focus-trap-el"])
                    ], 6)
                  ]),
                  _: 3
                })
              ]),
              _: 3
            }, 8, ["disabled"]);
          };
        }
      });
      var ImageViewer = /* @__PURE__ */ _export_sfc(_sfc_main$1d, [["__file", "image-viewer.vue"]]);
      const ElImageViewer = exports("ElImageViewer", withInstall(ImageViewer));
      const imageProps = exports("imageProps", buildProps({
        hideOnClickModal: Boolean,
        src: {
          type: String,
          default: ""
        },
        fit: {
          type: String,
          values: ["", "contain", "cover", "fill", "none", "scale-down"],
          default: ""
        },
        loading: {
          type: String,
          values: ["eager", "lazy"]
        },
        lazy: Boolean,
        scrollContainer: {
          type: definePropType([String, Object])
        },
        previewSrcList: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        previewTeleported: Boolean,
        zIndex: {
          type: Number
        },
        initialIndex: {
          type: Number,
          default: 0
        },
        infinite: {
          type: Boolean,
          default: true
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        zoomRate: {
          type: Number,
          default: 1.2
        },
        minScale: {
          type: Number,
          default: 0.2
        },
        maxScale: {
          type: Number,
          default: 7
        },
        showProgress: Boolean,
        crossorigin: {
          type: definePropType(String)
        }
      }));
      const imageEmits = exports("imageEmits", {
        load: (evt) => evt instanceof Event,
        error: (evt) => evt instanceof Event,
        switch: (val) => isNumber(val),
        close: () => true,
        show: () => true
      });
      const __default__$_ = defineComponent({
        name: "ElImage",
        inheritAttrs: false
      });
      const _sfc_main$1c = /* @__PURE__ */ defineComponent({
        ...__default__$_,
        props: imageProps,
        emits: imageEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const { t } = useLocale();
          const ns = useNamespace("image");
          const rawAttrs = useAttrs$1();
          const containerAttrs = computed(() => {
            return fromPairs(Object.entries(rawAttrs).filter(([key]) => /^(data-|on[A-Z])/i.test(key) || ["id", "style"].includes(key)));
          });
          const imgAttrs = useAttrs({
            excludeListeners: true,
            excludeKeys: computed(() => {
              return Object.keys(containerAttrs.value);
            })
          });
          const imageSrc = ref();
          const hasLoadError = ref(false);
          const isLoading = ref(true);
          const showViewer = ref(false);
          const container = ref();
          const _scrollContainer = ref();
          const supportLoading = isClient && "loading" in HTMLImageElement.prototype;
          let stopScrollListener;
          const imageKls = computed(() => [
            ns.e("inner"),
            preview.value && ns.e("preview"),
            isLoading.value && ns.is("loading")
          ]);
          const imageStyle = computed(() => {
            const { fit } = props2;
            if (isClient && fit) {
              return { objectFit: fit };
            }
            return {};
          });
          const preview = computed(() => {
            const { previewSrcList } = props2;
            return isArray$1(previewSrcList) && previewSrcList.length > 0;
          });
          const imageIndex = computed(() => {
            const { previewSrcList, initialIndex } = props2;
            let previewIndex = initialIndex;
            if (initialIndex > previewSrcList.length - 1) {
              previewIndex = 0;
            }
            return previewIndex;
          });
          const isManual = computed(() => {
            if (props2.loading === "eager")
              return false;
            return !supportLoading && props2.loading === "lazy" || props2.lazy;
          });
          const loadImage = () => {
            if (!isClient)
              return;
            isLoading.value = true;
            hasLoadError.value = false;
            imageSrc.value = props2.src;
          };
          function handleLoad(event) {
            isLoading.value = false;
            hasLoadError.value = false;
            emit("load", event);
          }
          function handleError(event) {
            isLoading.value = false;
            hasLoadError.value = true;
            emit("error", event);
          }
          function handleLazyLoad(isIntersecting) {
            if (isIntersecting) {
              loadImage();
              removeLazyLoadListener();
            }
          }
          const lazyLoadHandler = useThrottleFn(handleLazyLoad, 200, true);
          async function addLazyLoadListener() {
            var _a;
            if (!isClient)
              return;
            await nextTick();
            const { scrollContainer } = props2;
            if (isElement$2(scrollContainer)) {
              _scrollContainer.value = scrollContainer;
            } else if (isString$1(scrollContainer) && scrollContainer !== "") {
              _scrollContainer.value = (_a = document.querySelector(scrollContainer)) != null ? _a : void 0;
            } else if (container.value) {
              const scrollContainer2 = getScrollContainer(container.value);
              _scrollContainer.value = isWindow$1(scrollContainer2) ? void 0 : scrollContainer2;
            }
            const { stop } = useIntersectionObserver(container, ([entry]) => {
              lazyLoadHandler(entry.isIntersecting);
            }, { root: _scrollContainer });
            stopScrollListener = stop;
          }
          function removeLazyLoadListener() {
            if (!isClient || !lazyLoadHandler)
              return;
            stopScrollListener == null ? void 0 : stopScrollListener();
            _scrollContainer.value = void 0;
            stopScrollListener = void 0;
          }
          function clickHandler() {
            if (!preview.value)
              return;
            showViewer.value = true;
            emit("show");
          }
          function closeViewer() {
            showViewer.value = false;
            emit("close");
          }
          function switchViewer(val) {
            emit("switch", val);
          }
          watch(() => props2.src, () => {
            if (isManual.value) {
              isLoading.value = true;
              hasLoadError.value = false;
              removeLazyLoadListener();
              addLazyLoadListener();
            } else {
              loadImage();
            }
          });
          onMounted(() => {
            if (isManual.value) {
              addLazyLoadListener();
            } else {
              loadImage();
            }
          });
          expose({
            showPreview: clickHandler
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", mergeProps({
              ref_key: "container",
              ref: container
            }, unref(containerAttrs), {
              class: [unref(ns).b(), _ctx.$attrs.class]
            }), [
              hasLoadError.value ? renderSlot(_ctx.$slots, "error", { key: 0 }, () => [
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).e("error"))
                }, toDisplayString(unref(t)("el.image.error")), 3)
              ]) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                imageSrc.value !== void 0 ? (openBlock(), createElementBlock("img", mergeProps({ key: 0 }, unref(imgAttrs), {
                  src: imageSrc.value,
                  loading: _ctx.loading,
                  style: unref(imageStyle),
                  class: unref(imageKls),
                  crossorigin: _ctx.crossorigin,
                  onClick: clickHandler,
                  onLoad: handleLoad,
                  onError: handleError
                }), null, 16, ["src", "loading", "crossorigin"])) : createCommentVNode("v-if", true),
                isLoading.value ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(ns).e("wrapper"))
                }, [
                  renderSlot(_ctx.$slots, "placeholder", {}, () => [
                    createElementVNode("div", {
                      class: normalizeClass(unref(ns).e("placeholder"))
                    }, null, 2)
                  ])
                ], 2)) : createCommentVNode("v-if", true)
              ], 64)),
              unref(preview) ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                showViewer.value ? (openBlock(), createBlock(unref(ElImageViewer), {
                  key: 0,
                  "z-index": _ctx.zIndex,
                  "initial-index": unref(imageIndex),
                  infinite: _ctx.infinite,
                  "zoom-rate": _ctx.zoomRate,
                  "min-scale": _ctx.minScale,
                  "max-scale": _ctx.maxScale,
                  "show-progress": _ctx.showProgress,
                  "url-list": _ctx.previewSrcList,
                  crossorigin: _ctx.crossorigin,
                  "hide-on-click-modal": _ctx.hideOnClickModal,
                  teleported: _ctx.previewTeleported,
                  "close-on-press-escape": _ctx.closeOnPressEscape,
                  onClose: closeViewer,
                  onSwitch: switchViewer
                }, createSlots({
                  toolbar: withCtx((toolbar) => [
                    renderSlot(_ctx.$slots, "toolbar", normalizeProps(guardReactiveProps(toolbar)))
                  ]),
                  default: withCtx(() => [
                    _ctx.$slots.viewer ? (openBlock(), createElementBlock("div", { key: 0 }, [
                      renderSlot(_ctx.$slots, "viewer")
                    ])) : createCommentVNode("v-if", true)
                  ]),
                  _: 2
                }, [
                  _ctx.$slots.progress ? {
                    name: "progress",
                    fn: withCtx((progress) => [
                      renderSlot(_ctx.$slots, "progress", normalizeProps(guardReactiveProps(progress)))
                    ])
                  } : void 0
                ]), 1032, ["z-index", "initial-index", "infinite", "zoom-rate", "min-scale", "max-scale", "show-progress", "url-list", "crossorigin", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : createCommentVNode("v-if", true)
              ], 64)) : createCommentVNode("v-if", true)
            ], 16);
          };
        }
      });
      var Image$1 = /* @__PURE__ */ _export_sfc(_sfc_main$1c, [["__file", "image.vue"]]);
      const ElImage = exports("ElImage", withInstall(Image$1));
      const inputNumberProps = exports("inputNumberProps", buildProps({
        id: {
          type: String,
          default: void 0
        },
        step: {
          type: Number,
          default: 1
        },
        stepStrictly: Boolean,
        max: {
          type: Number,
          default: Number.MAX_SAFE_INTEGER
        },
        min: {
          type: Number,
          default: Number.MIN_SAFE_INTEGER
        },
        modelValue: {
          type: [Number, null]
        },
        readonly: Boolean,
        disabled: Boolean,
        size: useSizeProp,
        controls: {
          type: Boolean,
          default: true
        },
        controlsPosition: {
          type: String,
          default: "",
          values: ["", "right"]
        },
        valueOnClear: {
          type: [String, Number, null],
          validator: (val) => val === null || isNumber(val) || ["min", "max"].includes(val),
          default: null
        },
        name: String,
        placeholder: String,
        precision: {
          type: Number,
          validator: (val) => val >= 0 && val === Number.parseInt(`${val}`, 10)
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        ...useAriaProps(["ariaLabel"]),
        inputmode: {
          type: definePropType(String),
          default: void 0
        },
        align: {
          type: definePropType(String),
          default: "center"
        },
        disabledScientific: Boolean
      }));
      const inputNumberEmits = exports("inputNumberEmits", {
        [CHANGE_EVENT]: (cur, prev) => prev !== cur,
        blur: (e) => e instanceof FocusEvent,
        focus: (e) => e instanceof FocusEvent,
        [INPUT_EVENT]: (val) => isNumber(val) || isNil(val),
        [UPDATE_MODEL_EVENT]: (val) => isNumber(val) || isNil(val)
      });
      const __default__$Z = defineComponent({
        name: "ElInputNumber"
      });
      const _sfc_main$1b = /* @__PURE__ */ defineComponent({
        ...__default__$Z,
        props: inputNumberProps,
        emits: inputNumberEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const { t } = useLocale();
          const ns = useNamespace("input-number");
          const input = ref();
          const data = reactive({
            currentValue: props2.modelValue,
            userInput: null
          });
          const { formItem } = useFormItem();
          const minDisabled = computed(() => isNumber(props2.modelValue) && props2.modelValue <= props2.min);
          const maxDisabled = computed(() => isNumber(props2.modelValue) && props2.modelValue >= props2.max);
          const numPrecision = computed(() => {
            const stepPrecision = getPrecision(props2.step);
            if (!isUndefined(props2.precision)) {
              if (stepPrecision > props2.precision)
                ;
              return props2.precision;
            } else {
              return Math.max(getPrecision(props2.modelValue), stepPrecision);
            }
          });
          const controlsAtRight = computed(() => {
            return props2.controls && props2.controlsPosition === "right";
          });
          const inputNumberSize = useFormSize();
          const inputNumberDisabled = useFormDisabled();
          const displayValue = computed(() => {
            if (data.userInput !== null) {
              return data.userInput;
            }
            let currentValue = data.currentValue;
            if (isNil(currentValue))
              return "";
            if (isNumber(currentValue)) {
              if (Number.isNaN(currentValue))
                return "";
              if (!isUndefined(props2.precision)) {
                currentValue = currentValue.toFixed(props2.precision);
              }
            }
            return currentValue;
          });
          const toPrecision = (num, pre) => {
            if (isUndefined(pre))
              pre = numPrecision.value;
            if (pre === 0)
              return Math.round(num);
            let snum = String(num);
            const pointPos = snum.indexOf(".");
            if (pointPos === -1)
              return num;
            const nums = snum.replace(".", "").split("");
            const datum = nums[pointPos + pre];
            if (!datum)
              return num;
            const length = snum.length;
            if (snum.charAt(length - 1) === "5") {
              snum = `${snum.slice(0, Math.max(0, length - 1))}6`;
            }
            return Number.parseFloat(Number(snum).toFixed(pre));
          };
          const getPrecision = (value) => {
            if (isNil(value))
              return 0;
            const valueString = value.toString();
            const dotPosition = valueString.indexOf(".");
            let precision = 0;
            if (dotPosition !== -1) {
              precision = valueString.length - dotPosition - 1;
            }
            return precision;
          };
          const ensurePrecision = (val, coefficient = 1) => {
            if (!isNumber(val))
              return data.currentValue;
            if (val >= Number.MAX_SAFE_INTEGER && coefficient === 1) {
              return val;
            } else if (val <= Number.MIN_SAFE_INTEGER && coefficient === -1) {
              return val;
            }
            return toPrecision(val + props2.step * coefficient);
          };
          const handleKeydown = (event) => {
            var _a;
            const e = event;
            if (props2.disabledScientific && ["e", "E"].includes(e.key)) {
              e.preventDefault();
              return;
            }
            const keyHandlers = {
              [EVENT_CODE.up]: () => {
                e.preventDefault();
                increase();
              },
              [EVENT_CODE.down]: () => {
                e.preventDefault();
                decrease();
              }
            };
            (_a = keyHandlers[e.key]) == null ? void 0 : _a.call(keyHandlers);
          };
          const increase = () => {
            if (props2.readonly || inputNumberDisabled.value || maxDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value);
            setCurrentValue(newVal);
            emit(INPUT_EVENT, data.currentValue);
            setCurrentValueToModelValue();
          };
          const decrease = () => {
            if (props2.readonly || inputNumberDisabled.value || minDisabled.value)
              return;
            const value = Number(displayValue.value) || 0;
            const newVal = ensurePrecision(value, -1);
            setCurrentValue(newVal);
            emit(INPUT_EVENT, data.currentValue);
            setCurrentValueToModelValue();
          };
          const verifyValue = (value, update2) => {
            const { max: max2, min: min2, step: step2, precision, stepStrictly, valueOnClear } = props2;
            if (max2 < min2) {
              throwError("InputNumber", "min should not be greater than max.");
            }
            let newVal = Number(value);
            if (isNil(value) || Number.isNaN(newVal)) {
              return null;
            }
            if (value === "") {
              if (valueOnClear === null) {
                return null;
              }
              newVal = isString$1(valueOnClear) ? { min: min2, max: max2 }[valueOnClear] : valueOnClear;
            }
            if (stepStrictly) {
              newVal = toPrecision(Math.round(newVal / step2) * step2, precision);
              if (newVal !== value) {
                update2 && emit(UPDATE_MODEL_EVENT, newVal);
              }
            }
            if (!isUndefined(precision)) {
              newVal = toPrecision(newVal, precision);
            }
            if (newVal > max2 || newVal < min2) {
              newVal = newVal > max2 ? max2 : min2;
              update2 && emit(UPDATE_MODEL_EVENT, newVal);
            }
            return newVal;
          };
          const setCurrentValue = (value, emitChange = true) => {
            var _a;
            const oldVal = data.currentValue;
            const newVal = verifyValue(value);
            if (!emitChange) {
              emit(UPDATE_MODEL_EVENT, newVal);
              return;
            }
            if (oldVal === newVal && value)
              return;
            data.userInput = null;
            emit(UPDATE_MODEL_EVENT, newVal);
            if (oldVal !== newVal) {
              emit(CHANGE_EVENT, newVal, oldVal);
            }
            if (props2.validateEvent) {
              (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change").catch((err) => debugWarn());
            }
            data.currentValue = newVal;
          };
          const handleInput = (value) => {
            data.userInput = value;
            const newVal = value === "" ? null : Number(value);
            emit(INPUT_EVENT, newVal);
            setCurrentValue(newVal, false);
          };
          const handleInputChange = (value) => {
            const newVal = value !== "" ? Number(value) : "";
            if (isNumber(newVal) && !Number.isNaN(newVal) || value === "") {
              setCurrentValue(newVal);
            }
            setCurrentValueToModelValue();
            data.userInput = null;
          };
          const focus = () => {
            var _a, _b;
            (_b = (_a = input.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
          };
          const blur = () => {
            var _a, _b;
            (_b = (_a = input.value) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);
          };
          const handleFocus = (event) => {
            emit("focus", event);
          };
          const handleBlur = (event) => {
            var _a, _b;
            data.userInput = null;
            if (data.currentValue === null && ((_a = input.value) == null ? void 0 : _a.input)) {
              input.value.input.value = "";
            }
            emit("blur", event);
            if (props2.validateEvent) {
              (_b = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _b.call(formItem, "blur").catch((err) => debugWarn());
            }
          };
          const setCurrentValueToModelValue = () => {
            if (data.currentValue !== props2.modelValue) {
              data.currentValue = props2.modelValue;
            }
          };
          const handleWheel = (e) => {
            if (document.activeElement === e.target)
              e.preventDefault();
          };
          watch(() => props2.modelValue, (value, oldValue) => {
            const newValue = verifyValue(value, true);
            if (data.userInput === null && newValue !== oldValue) {
              data.currentValue = newValue;
            }
          }, { immediate: true });
          watch(() => props2.precision, () => {
            data.currentValue = verifyValue(props2.modelValue);
          });
          onMounted(() => {
            var _a;
            const { min: min2, max: max2, modelValue } = props2;
            const innerInput = (_a = input.value) == null ? void 0 : _a.input;
            innerInput.setAttribute("role", "spinbutton");
            if (Number.isFinite(max2)) {
              innerInput.setAttribute("aria-valuemax", String(max2));
            } else {
              innerInput.removeAttribute("aria-valuemax");
            }
            if (Number.isFinite(min2)) {
              innerInput.setAttribute("aria-valuemin", String(min2));
            } else {
              innerInput.removeAttribute("aria-valuemin");
            }
            innerInput.setAttribute("aria-valuenow", data.currentValue || data.currentValue === 0 ? String(data.currentValue) : "");
            innerInput.setAttribute("aria-disabled", String(inputNumberDisabled.value));
            if (!isNumber(modelValue) && modelValue != null) {
              let val = Number(modelValue);
              if (Number.isNaN(val)) {
                val = null;
              }
              emit(UPDATE_MODEL_EVENT, val);
            }
            innerInput.addEventListener("wheel", handleWheel, { passive: false });
          });
          onUpdated(() => {
            var _a, _b;
            const innerInput = (_a = input.value) == null ? void 0 : _a.input;
            innerInput == null ? void 0 : innerInput.setAttribute("aria-valuenow", `${(_b = data.currentValue) != null ? _b : ""}`);
          });
          expose({
            focus,
            blur
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).m(unref(inputNumberSize)),
                unref(ns).is("disabled", unref(inputNumberDisabled)),
                unref(ns).is("without-controls", !_ctx.controls),
                unref(ns).is("controls-right", unref(controlsAtRight)),
                unref(ns).is(_ctx.align, !!_ctx.align)
              ]),
              onDragstart: withModifiers(() => {
              }, ["prevent"])
            }, [
              _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                key: 0,
                role: "button",
                "aria-label": unref(t)("el.inputNumber.decrease"),
                class: normalizeClass([unref(ns).e("decrease"), unref(ns).is("disabled", unref(minDisabled))]),
                onKeydown: withKeys(decrease, ["enter"])
              }, [
                renderSlot(_ctx.$slots, "decrease-icon", {}, () => [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_down_default$1), { key: 0 })) : (openBlock(), createBlock(unref(minus_default$1), { key: 1 }))
                    ]),
                    _: 1
                  })
                ])
              ], 42, ["aria-label", "onKeydown"])), [
                [unref(vRepeatClick), decrease]
              ]) : createCommentVNode("v-if", true),
              _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
                key: 1,
                role: "button",
                "aria-label": unref(t)("el.inputNumber.increase"),
                class: normalizeClass([unref(ns).e("increase"), unref(ns).is("disabled", unref(maxDisabled))]),
                onKeydown: withKeys(increase, ["enter"])
              }, [
                renderSlot(_ctx.$slots, "increase-icon", {}, () => [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      unref(controlsAtRight) ? (openBlock(), createBlock(unref(arrow_up_default$1), { key: 0 })) : (openBlock(), createBlock(unref(plus_default$1), { key: 1 }))
                    ]),
                    _: 1
                  })
                ])
              ], 42, ["aria-label", "onKeydown"])), [
                [unref(vRepeatClick), increase]
              ]) : createCommentVNode("v-if", true),
              createVNode(unref(ElInput), {
                id: _ctx.id,
                ref_key: "input",
                ref: input,
                type: "number",
                step: _ctx.step,
                "model-value": unref(displayValue),
                placeholder: _ctx.placeholder,
                readonly: _ctx.readonly,
                disabled: unref(inputNumberDisabled),
                size: unref(inputNumberSize),
                max: _ctx.max,
                min: _ctx.min,
                name: _ctx.name,
                "aria-label": _ctx.ariaLabel,
                "validate-event": false,
                inputmode: _ctx.inputmode,
                onKeydown: handleKeydown,
                onBlur: handleBlur,
                onFocus: handleFocus,
                onInput: handleInput,
                onChange: handleInputChange
              }, createSlots({
                _: 2
              }, [
                _ctx.$slots.prefix ? {
                  name: "prefix",
                  fn: withCtx(() => [
                    renderSlot(_ctx.$slots, "prefix")
                  ])
                } : void 0,
                _ctx.$slots.suffix ? {
                  name: "suffix",
                  fn: withCtx(() => [
                    renderSlot(_ctx.$slots, "suffix")
                  ])
                } : void 0
              ]), 1032, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "aria-label", "inputmode"])
            ], 42, ["onDragstart"]);
          };
        }
      });
      var InputNumber = /* @__PURE__ */ _export_sfc(_sfc_main$1b, [["__file", "input-number.vue"]]);
      const ElInputNumber = exports("ElInputNumber", withInstall(InputNumber));
      const inputTagProps = exports("inputTagProps", buildProps({
        modelValue: {
          type: definePropType(Array)
        },
        max: Number,
        tagType: { ...tagProps.type, default: "info" },
        tagEffect: tagProps.effect,
        trigger: {
          type: definePropType(String),
          default: EVENT_CODE.enter
        },
        draggable: Boolean,
        delimiter: {
          type: [String, RegExp],
          default: ""
        },
        size: useSizeProp,
        clearable: Boolean,
        disabled: {
          type: Boolean,
          default: void 0
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        readonly: Boolean,
        autofocus: Boolean,
        id: {
          type: String,
          default: void 0
        },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        maxlength: {
          type: [String, Number]
        },
        minlength: {
          type: [String, Number]
        },
        placeholder: String,
        autocomplete: {
          type: String,
          default: "off"
        },
        saveOnBlur: {
          type: Boolean,
          default: true
        },
        ariaLabel: String
      }));
      const inputTagEmits = exports("inputTagEmits", {
        [UPDATE_MODEL_EVENT]: (value) => isArray$1(value) || isUndefined(value),
        [CHANGE_EVENT]: (value) => isArray$1(value) || isUndefined(value),
        [INPUT_EVENT]: (value) => isString$1(value),
        "add-tag": (value) => isString$1(value) || isArray$1(value),
        "remove-tag": (value) => isString$1(value),
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent,
        clear: () => true
      });
      function useDragTag({
        wrapperRef,
        handleDragged,
        afterDragged
      }) {
        const ns = useNamespace("input-tag");
        const dropIndicatorRef = shallowRef();
        const showDropIndicator = ref(false);
        let draggingIndex;
        let draggingTag;
        let dropIndex;
        let dropType;
        function getTagClassName(index2) {
          return `.${ns.e("inner")} .${ns.namespace.value}-tag:nth-child(${index2 + 1})`;
        }
        function handleDragStart(event, index2) {
          draggingIndex = index2;
          draggingTag = wrapperRef.value.querySelector(getTagClassName(index2));
          if (draggingTag) {
            draggingTag.style.opacity = "0.5";
          }
          event.dataTransfer.effectAllowed = "move";
        }
        function handleDragOver(event, index2) {
          dropIndex = index2;
          event.preventDefault();
          event.dataTransfer.dropEffect = "move";
          if (isUndefined(draggingIndex) || draggingIndex === index2) {
            showDropIndicator.value = false;
            return;
          }
          const dropPosition = wrapperRef.value.querySelector(getTagClassName(index2)).getBoundingClientRect();
          const dropPrev = !(draggingIndex + 1 === index2);
          const dropNext = !(draggingIndex - 1 === index2);
          const distance = event.clientX - dropPosition.left;
          const prevPercent = dropPrev ? dropNext ? 0.5 : 1 : -1;
          const nextPercent = dropNext ? dropPrev ? 0.5 : 0 : 1;
          if (distance <= dropPosition.width * prevPercent) {
            dropType = "before";
          } else if (distance > dropPosition.width * nextPercent) {
            dropType = "after";
          } else {
            dropType = void 0;
          }
          const innerEl = wrapperRef.value.querySelector(`.${ns.e("inner")}`);
          const innerPosition = innerEl.getBoundingClientRect();
          const gap = Number.parseFloat(getStyle(innerEl, "gap")) / 2;
          const indicatorTop = dropPosition.top - innerPosition.top;
          let indicatorLeft = -9999;
          if (dropType === "before") {
            indicatorLeft = Math.max(dropPosition.left - innerPosition.left - gap, Math.floor(-gap / 2));
          } else if (dropType === "after") {
            const left = dropPosition.right - innerPosition.left;
            indicatorLeft = left + (innerPosition.width === left ? Math.floor(gap / 2) : gap);
          }
          setStyle(dropIndicatorRef.value, {
            top: `${indicatorTop}px`,
            left: `${indicatorLeft}px`
          });
          showDropIndicator.value = !!dropType;
        }
        function handleDragEnd(event) {
          event.preventDefault();
          if (draggingTag) {
            draggingTag.style.opacity = "";
          }
          if (dropType && !isUndefined(draggingIndex) && !isUndefined(dropIndex) && draggingIndex !== dropIndex) {
            handleDragged(draggingIndex, dropIndex, dropType);
          }
          showDropIndicator.value = false;
          draggingIndex = void 0;
          draggingTag = null;
          dropIndex = void 0;
          dropType = void 0;
          afterDragged == null ? void 0 : afterDragged();
        }
        return {
          dropIndicatorRef,
          showDropIndicator,
          handleDragStart,
          handleDragOver,
          handleDragEnd
        };
      }
      function useHovering() {
        const hovering = ref(false);
        const handleMouseEnter = () => {
          hovering.value = true;
        };
        const handleMouseLeave = () => {
          hovering.value = false;
        };
        return {
          hovering,
          handleMouseEnter,
          handleMouseLeave
        };
      }
      function useInputTag({ props: props2, emit, formItem }) {
        const disabled = useFormDisabled();
        const size = useFormSize();
        const inputRef = shallowRef();
        const inputValue = ref();
        const tagSize = computed(() => {
          return ["small"].includes(size.value) ? "small" : "default";
        });
        const placeholder = computed(() => {
          var _a;
          return ((_a = props2.modelValue) == null ? void 0 : _a.length) ? void 0 : props2.placeholder;
        });
        const closable = computed(() => !(props2.readonly || disabled.value));
        const inputLimit = computed(() => {
          var _a, _b;
          return isUndefined(props2.max) ? false : ((_b = (_a = props2.modelValue) == null ? void 0 : _a.length) != null ? _b : 0) >= props2.max;
        });
        const addTagsEmit = (value) => {
          var _a;
          const list = [...(_a = props2.modelValue) != null ? _a : [], ...castArray$1(value)];
          emit(UPDATE_MODEL_EVENT, list);
          emit(CHANGE_EVENT, list);
          emit("add-tag", value);
          inputValue.value = void 0;
        };
        const getDelimitedTags = (input) => {
          var _a, _b;
          const tags = input.split(props2.delimiter).filter((val) => val && val !== input);
          if (props2.max) {
            const maxInsert = props2.max - ((_b = (_a = props2.modelValue) == null ? void 0 : _a.length) != null ? _b : 0);
            tags.splice(maxInsert);
          }
          return tags.length === 1 ? tags[0] : tags;
        };
        const handleInput = (event) => {
          if (inputLimit.value) {
            inputValue.value = void 0;
            return;
          }
          if (isComposing.value)
            return;
          if (props2.delimiter && inputValue.value) {
            const tags = getDelimitedTags(inputValue.value);
            if (tags.length) {
              addTagsEmit(tags);
            }
          }
          emit(INPUT_EVENT, event.target.value);
        };
        const handleKeydown = (event) => {
          var _a;
          if (isComposing.value)
            return;
          switch (event.code) {
            case props2.trigger:
              event.preventDefault();
              event.stopPropagation();
              handleAddTag();
              break;
            case EVENT_CODE.numpadEnter:
              if (props2.trigger === EVENT_CODE.enter) {
                event.preventDefault();
                event.stopPropagation();
                handleAddTag();
              }
              break;
            case EVENT_CODE.backspace:
              if (!inputValue.value && ((_a = props2.modelValue) == null ? void 0 : _a.length)) {
                event.preventDefault();
                event.stopPropagation();
                handleRemoveTag(props2.modelValue.length - 1);
              }
              break;
          }
        };
        const handleAddTag = () => {
          var _a;
          const value = (_a = inputValue.value) == null ? void 0 : _a.trim();
          if (!value || inputLimit.value)
            return;
          addTagsEmit(value);
        };
        const handleRemoveTag = (index2) => {
          var _a;
          const value = ((_a = props2.modelValue) != null ? _a : []).slice();
          const [item] = value.splice(index2, 1);
          emit(UPDATE_MODEL_EVENT, value);
          emit(CHANGE_EVENT, value);
          emit("remove-tag", item);
        };
        const handleClear = () => {
          inputValue.value = void 0;
          emit(UPDATE_MODEL_EVENT, void 0);
          emit(CHANGE_EVENT, void 0);
          emit("clear");
        };
        const handleDragged = (draggingIndex, dropIndex, type) => {
          var _a;
          const value = ((_a = props2.modelValue) != null ? _a : []).slice();
          const [draggedItem] = value.splice(draggingIndex, 1);
          const step2 = dropIndex > draggingIndex && type === "before" ? -1 : dropIndex < draggingIndex && type === "after" ? 1 : 0;
          value.splice(dropIndex + step2, 0, draggedItem);
          emit(UPDATE_MODEL_EVENT, value);
          emit(CHANGE_EVENT, value);
        };
        const focus = () => {
          var _a;
          (_a = inputRef.value) == null ? void 0 : _a.focus();
        };
        const blur = () => {
          var _a;
          (_a = inputRef.value) == null ? void 0 : _a.blur();
        };
        const { wrapperRef, isFocused } = useFocusController(inputRef, {
          disabled,
          afterBlur() {
            var _a;
            if (props2.saveOnBlur) {
              handleAddTag();
            } else {
              inputValue.value = void 0;
            }
            if (props2.validateEvent) {
              (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "blur").catch((err) => debugWarn());
            }
          }
        });
        const {
          isComposing,
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        } = useComposition({ afterComposition: handleInput });
        watch(() => props2.modelValue, () => {
          var _a;
          if (props2.validateEvent) {
            (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, CHANGE_EVENT).catch((err) => debugWarn());
          }
        });
        return {
          inputRef,
          wrapperRef,
          isFocused,
          isComposing,
          inputValue,
          size,
          tagSize,
          placeholder,
          closable,
          disabled,
          inputLimit,
          handleDragged,
          handleInput,
          handleKeydown,
          handleAddTag,
          handleRemoveTag,
          handleClear,
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd,
          focus,
          blur
        };
      }
      function useInputTagDom({
        props: props2,
        isFocused,
        hovering,
        disabled,
        inputValue,
        size,
        validateState,
        validateIcon,
        needStatusIcon
      }) {
        const attrs = useAttrs$1();
        const slots = useSlots();
        const ns = useNamespace("input-tag");
        const nsInput = useNamespace("input");
        const containerKls = computed(() => [
          ns.b(),
          ns.is("focused", isFocused.value),
          ns.is("hovering", hovering.value),
          ns.is("disabled", disabled.value),
          ns.m(size.value),
          ns.e("wrapper"),
          attrs.class
        ]);
        const containerStyle = computed(() => [attrs.style]);
        const innerKls = computed(() => {
          var _a, _b;
          return [
            ns.e("inner"),
            ns.is("draggable", props2.draggable),
            ns.is("left-space", !((_a = props2.modelValue) == null ? void 0 : _a.length) && !slots.prefix),
            ns.is("right-space", !((_b = props2.modelValue) == null ? void 0 : _b.length) && !showSuffix.value)
          ];
        });
        const showClear = computed(() => {
          var _a;
          return props2.clearable && !disabled.value && !props2.readonly && (((_a = props2.modelValue) == null ? void 0 : _a.length) || inputValue.value) && (isFocused.value || hovering.value);
        });
        const showSuffix = computed(() => {
          return slots.suffix || showClear.value || validateState.value && validateIcon.value && needStatusIcon.value;
        });
        return {
          ns,
          nsInput,
          containerKls,
          containerStyle,
          innerKls,
          showClear,
          showSuffix
        };
      }
      const __default__$Y = defineComponent({
        name: "ElInputTag",
        inheritAttrs: false
      });
      const _sfc_main$1a = /* @__PURE__ */ defineComponent({
        ...__default__$Y,
        props: inputTagProps,
        emits: inputTagEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const attrs = useAttrs();
          const slots = useSlots();
          const { form, formItem } = useFormItem();
          const { inputId } = useFormItemInputId(props2, { formItemContext: formItem });
          const needStatusIcon = computed(() => {
            var _a;
            return (_a = form == null ? void 0 : form.statusIcon) != null ? _a : false;
          });
          const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
          const validateIcon = computed(() => {
            return validateState.value && ValidateComponentsMap[validateState.value];
          });
          const {
            inputRef,
            wrapperRef,
            isFocused,
            inputValue,
            size,
            tagSize,
            placeholder,
            closable,
            disabled,
            handleDragged,
            handleInput,
            handleKeydown,
            handleRemoveTag,
            handleClear,
            handleCompositionStart,
            handleCompositionUpdate,
            handleCompositionEnd,
            focus,
            blur
          } = useInputTag({ props: props2, emit, formItem });
          const { hovering, handleMouseEnter, handleMouseLeave } = useHovering();
          const { calculatorRef, inputStyle } = useCalcInputWidth();
          const {
            dropIndicatorRef,
            showDropIndicator,
            handleDragStart,
            handleDragOver,
            handleDragEnd
          } = useDragTag({ wrapperRef, handleDragged, afterDragged: focus });
          const {
            ns,
            nsInput,
            containerKls,
            containerStyle,
            innerKls,
            showClear,
            showSuffix
          } = useInputTagDom({
            props: props2,
            hovering,
            isFocused,
            inputValue,
            disabled,
            size,
            validateState,
            validateIcon,
            needStatusIcon
          });
          expose({
            focus,
            blur
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "wrapperRef",
              ref: wrapperRef,
              class: normalizeClass(unref(containerKls)),
              style: normalizeStyle(unref(containerStyle)),
              onMouseenter: unref(handleMouseEnter),
              onMouseleave: unref(handleMouseLeave)
            }, [
              unref(slots).prefix ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).e("prefix"))
              }, [
                renderSlot(_ctx.$slots, "prefix")
              ], 2)) : createCommentVNode("v-if", true),
              createElementVNode("div", {
                class: normalizeClass(unref(innerKls))
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.modelValue, (item, index2) => {
                  return openBlock(), createBlock(unref(ElTag), {
                    key: index2,
                    size: unref(tagSize),
                    closable: unref(closable),
                    type: _ctx.tagType,
                    effect: _ctx.tagEffect,
                    draggable: unref(closable) && _ctx.draggable,
                    "disable-transitions": "",
                    onClose: ($event) => unref(handleRemoveTag)(index2),
                    onDragstart: (event) => unref(handleDragStart)(event, index2),
                    onDragover: (event) => unref(handleDragOver)(event, index2),
                    onDragend: unref(handleDragEnd),
                    onDrop: withModifiers(() => {
                    }, ["stop"])
                  }, {
                    default: withCtx(() => [
                      renderSlot(_ctx.$slots, "tag", {
                        value: item,
                        index: index2
                      }, () => [
                        createTextVNode(toDisplayString(item), 1)
                      ])
                    ]),
                    _: 2
                  }, 1032, ["size", "closable", "type", "effect", "draggable", "onClose", "onDragstart", "onDragover", "onDragend", "onDrop"]);
                }), 128)),
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).e("input-wrapper"))
                }, [
                  withDirectives(createElementVNode("input", mergeProps({
                    id: unref(inputId),
                    ref_key: "inputRef",
                    ref: inputRef,
                    "onUpdate:modelValue": ($event) => isRef(inputValue) ? inputValue.value = $event : null
                  }, unref(attrs), {
                    type: "text",
                    minlength: _ctx.minlength,
                    maxlength: _ctx.maxlength,
                    disabled: unref(disabled),
                    readonly: _ctx.readonly,
                    autocomplete: _ctx.autocomplete,
                    tabindex: _ctx.tabindex,
                    placeholder: unref(placeholder),
                    autofocus: _ctx.autofocus,
                    ariaLabel: _ctx.ariaLabel,
                    class: unref(ns).e("input"),
                    style: unref(inputStyle),
                    onCompositionstart: unref(handleCompositionStart),
                    onCompositionupdate: unref(handleCompositionUpdate),
                    onCompositionend: unref(handleCompositionEnd),
                    onInput: unref(handleInput),
                    onKeydown: unref(handleKeydown)
                  }), null, 16, ["id", "onUpdate:modelValue", "minlength", "maxlength", "disabled", "readonly", "autocomplete", "tabindex", "placeholder", "autofocus", "ariaLabel", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onInput", "onKeydown"]), [
                    [vModelText, unref(inputValue)]
                  ]),
                  createElementVNode("span", {
                    ref_key: "calculatorRef",
                    ref: calculatorRef,
                    "aria-hidden": "true",
                    class: normalizeClass(unref(ns).e("input-calculator")),
                    textContent: toDisplayString(unref(inputValue))
                  }, null, 10, ["textContent"])
                ], 2),
                withDirectives(createElementVNode("div", {
                  ref_key: "dropIndicatorRef",
                  ref: dropIndicatorRef,
                  class: normalizeClass(unref(ns).e("drop-indicator"))
                }, null, 2), [
                  [vShow, unref(showDropIndicator)]
                ])
              ], 2),
              unref(showSuffix) ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(ns).e("suffix"))
              }, [
                renderSlot(_ctx.$slots, "suffix"),
                unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass([unref(ns).e("icon"), unref(ns).e("clear")]),
                  onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                  onClick: unref(handleClear)
                }, {
                  default: withCtx(() => [
                    createVNode(unref(circle_close_default$1))
                  ]),
                  _: 1
                }, 8, ["class", "onMousedown", "onClick"])) : createCommentVNode("v-if", true),
                unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 1,
                  class: normalizeClass([
                    unref(nsInput).e("icon"),
                    unref(nsInput).e("validateIcon"),
                    unref(nsInput).is("loading", unref(validateState) === "validating")
                  ])
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true)
              ], 2)) : createCommentVNode("v-if", true)
            ], 46, ["onMouseenter", "onMouseleave"]);
          };
        }
      });
      var InputTag = /* @__PURE__ */ _export_sfc(_sfc_main$1a, [["__file", "input-tag.vue"]]);
      const ElInputTag = exports("ElInputTag", withInstall(InputTag));
      const linkProps = exports("linkProps", buildProps({
        type: {
          type: String,
          values: ["primary", "success", "warning", "info", "danger", "default"],
          default: void 0
        },
        underline: {
          type: [Boolean, String],
          values: [true, false, "always", "never", "hover"],
          default: void 0
        },
        disabled: Boolean,
        href: { type: String, default: "" },
        target: {
          type: String,
          default: "_self"
        },
        icon: {
          type: iconPropType
        }
      }));
      const linkEmits = exports("linkEmits", {
        click: (evt) => evt instanceof MouseEvent
      });
      const __default__$X = defineComponent({
        name: "ElLink"
      });
      const _sfc_main$19 = /* @__PURE__ */ defineComponent({
        ...__default__$X,
        props: linkProps,
        emits: linkEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const globalConfig2 = useGlobalConfig("link");
          useDeprecated({
            scope: "el-link",
            from: "The underline option (boolean)",
            replacement: "'always' | 'hover' | 'never'",
            version: "3.0.0",
            ref: "https://element-plus.org/en-US/component/link.html#underline"
          }, computed(() => isBoolean(props2.underline)));
          const ns = useNamespace("link");
          const linkKls = computed(() => {
            var _a, _b, _c;
            return [
              ns.b(),
              ns.m((_c = (_b = props2.type) != null ? _b : (_a = globalConfig2.value) == null ? void 0 : _a.type) != null ? _c : "default"),
              ns.is("disabled", props2.disabled),
              ns.is("underline", underline.value === "always"),
              ns.is("hover-underline", underline.value === "hover" && !props2.disabled)
            ];
          });
          const underline = computed(() => {
            var _a, _b, _c;
            if (isBoolean(props2.underline)) {
              return props2.underline ? "hover" : "never";
            } else
              return (_c = (_b = props2.underline) != null ? _b : (_a = globalConfig2.value) == null ? void 0 : _a.underline) != null ? _c : "hover";
          });
          function handleClick(event) {
            if (!props2.disabled)
              emit("click", event);
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("a", {
              class: normalizeClass(unref(linkKls)),
              href: _ctx.disabled || !_ctx.href ? void 0 : _ctx.href,
              target: _ctx.disabled || !_ctx.href ? void 0 : _ctx.target,
              onClick: handleClick
            }, [
              _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                ]),
                _: 1
              })) : createCommentVNode("v-if", true),
              _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                key: 1,
                class: normalizeClass(unref(ns).e("inner"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2)) : createCommentVNode("v-if", true),
              _ctx.$slots.icon ? renderSlot(_ctx.$slots, "icon", { key: 2 }) : createCommentVNode("v-if", true)
            ], 10, ["href", "target"]);
          };
        }
      });
      var Link = /* @__PURE__ */ _export_sfc(_sfc_main$19, [["__file", "link.vue"]]);
      const ElLink = exports("ElLink", withInstall(Link));
      class SubMenu$1 {
        constructor(parent2, domNode) {
          this.parent = parent2;
          this.domNode = domNode;
          this.subIndex = 0;
          this.subIndex = 0;
          this.init();
        }
        init() {
          this.subMenuItems = this.domNode.querySelectorAll("li");
          this.addListeners();
        }
        gotoSubIndex(idx) {
          if (idx === this.subMenuItems.length) {
            idx = 0;
          } else if (idx < 0) {
            idx = this.subMenuItems.length - 1;
          }
          this.subMenuItems[idx].focus();
          this.subIndex = idx;
        }
        addListeners() {
          const parentNode = this.parent.domNode;
          Array.prototype.forEach.call(this.subMenuItems, (el) => {
            el.addEventListener("keydown", (event) => {
              let prevDef = false;
              switch (event.code) {
                case EVENT_CODE.down: {
                  this.gotoSubIndex(this.subIndex + 1);
                  prevDef = true;
                  break;
                }
                case EVENT_CODE.up: {
                  this.gotoSubIndex(this.subIndex - 1);
                  prevDef = true;
                  break;
                }
                case EVENT_CODE.tab: {
                  triggerEvent(parentNode, "mouseleave");
                  break;
                }
                case EVENT_CODE.enter:
                case EVENT_CODE.numpadEnter:
                case EVENT_CODE.space: {
                  prevDef = true;
                  event.currentTarget.click();
                  break;
                }
              }
              if (prevDef) {
                event.preventDefault();
                event.stopPropagation();
              }
              return false;
            });
          });
        }
      }
      var SubMenu$2 = SubMenu$1;
      class MenuItem$1 {
        constructor(domNode, namespace) {
          this.domNode = domNode;
          this.submenu = null;
          this.submenu = null;
          this.init(namespace);
        }
        init(namespace) {
          this.domNode.setAttribute("tabindex", "0");
          const menuChild = this.domNode.querySelector(`.${namespace}-menu`);
          if (menuChild) {
            this.submenu = new SubMenu$2(this, menuChild);
          }
          this.addListeners();
        }
        addListeners() {
          this.domNode.addEventListener("keydown", (event) => {
            let prevDef = false;
            switch (event.code) {
              case EVENT_CODE.down: {
                triggerEvent(event.currentTarget, "mouseenter");
                this.submenu && this.submenu.gotoSubIndex(0);
                prevDef = true;
                break;
              }
              case EVENT_CODE.up: {
                triggerEvent(event.currentTarget, "mouseenter");
                this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1);
                prevDef = true;
                break;
              }
              case EVENT_CODE.tab: {
                triggerEvent(event.currentTarget, "mouseleave");
                break;
              }
              case EVENT_CODE.enter:
              case EVENT_CODE.numpadEnter:
              case EVENT_CODE.space: {
                prevDef = true;
                event.currentTarget.click();
                break;
              }
            }
            if (prevDef) {
              event.preventDefault();
            }
          });
        }
      }
      var MenuItem$2 = MenuItem$1;
      class Menu$1 {
        constructor(domNode, namespace) {
          this.domNode = domNode;
          this.init(namespace);
        }
        init(namespace) {
          const menuChildren = this.domNode.childNodes;
          Array.from(menuChildren).forEach((child) => {
            if (child.nodeType === 1) {
              new MenuItem$2(child, namespace);
            }
          });
        }
      }
      var Menubar = Menu$1;
      const __default__$W = defineComponent({
        name: "ElMenuCollapseTransition"
      });
      const _sfc_main$18 = /* @__PURE__ */ defineComponent({
        ...__default__$W,
        setup(__props) {
          const ns = useNamespace("menu");
          const listeners = {
            onBeforeEnter: (el) => el.style.opacity = "0.2",
            onEnter(el, done) {
              addClass(el, `${ns.namespace.value}-opacity-transition`);
              el.style.opacity = "1";
              done();
            },
            onAfterEnter(el) {
              removeClass(el, `${ns.namespace.value}-opacity-transition`);
              el.style.opacity = "";
            },
            onBeforeLeave(el) {
              if (!el.dataset)
                el.dataset = {};
              if (hasClass(el, ns.m("collapse"))) {
                removeClass(el, ns.m("collapse"));
                el.dataset.oldOverflow = el.style.overflow;
                el.dataset.scrollWidth = el.clientWidth.toString();
                addClass(el, ns.m("collapse"));
              } else {
                addClass(el, ns.m("collapse"));
                el.dataset.oldOverflow = el.style.overflow;
                el.dataset.scrollWidth = el.clientWidth.toString();
                removeClass(el, ns.m("collapse"));
              }
              el.style.width = `${el.scrollWidth}px`;
              el.style.overflow = "hidden";
            },
            onLeave(el) {
              addClass(el, "horizontal-collapse-transition");
              el.style.width = `${el.dataset.scrollWidth}px`;
            }
          };
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, mergeProps({ mode: "out-in" }, unref(listeners)), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16);
          };
        }
      });
      var ElMenuCollapseTransition = /* @__PURE__ */ _export_sfc(_sfc_main$18, [["__file", "menu-collapse-transition.vue"]]);
      function useMenu(instance, currentIndex) {
        const indexPath = computed(() => {
          let parent2 = instance.parent;
          const path = [currentIndex.value];
          while (parent2.type.name !== "ElMenu") {
            if (parent2.props.index) {
              path.unshift(parent2.props.index);
            }
            parent2 = parent2.parent;
          }
          return path;
        });
        const parentMenu = computed(() => {
          let parent2 = instance.parent;
          while (parent2 && !["ElMenu", "ElSubMenu"].includes(parent2.type.name)) {
            parent2 = parent2.parent;
          }
          return parent2;
        });
        return {
          parentMenu,
          indexPath
        };
      }
      function useMenuColor(props2) {
        const menuBarColor = computed(() => {
          const color = props2.backgroundColor;
          return color ? new TinyColor(color).shade(20).toString() : "";
        });
        return menuBarColor;
      }
      const useMenuCssVar = (props2, level) => {
        const ns = useNamespace("menu");
        return computed(() => ns.cssVarBlock({
          "text-color": props2.textColor || "",
          "hover-text-color": props2.textColor || "",
          "bg-color": props2.backgroundColor || "",
          "hover-bg-color": useMenuColor(props2).value || "",
          "active-color": props2.activeTextColor || "",
          level: `${level}`
        }));
      };
      const MENU_INJECTION_KEY = exports("MENU_INJECTION_KEY", "rootMenu");
      const SUB_MENU_INJECTION_KEY = exports("SUB_MENU_INJECTION_KEY", "subMenu:");
      const subMenuProps = exports("subMenuProps", buildProps({
        index: {
          type: String,
          required: true
        },
        showTimeout: Number,
        hideTimeout: Number,
        popperClass: String,
        disabled: Boolean,
        teleported: {
          type: Boolean,
          default: void 0
        },
        popperOffset: Number,
        expandCloseIcon: {
          type: iconPropType
        },
        expandOpenIcon: {
          type: iconPropType
        },
        collapseCloseIcon: {
          type: iconPropType
        },
        collapseOpenIcon: {
          type: iconPropType
        }
      }));
      const COMPONENT_NAME$d = "ElSubMenu";
      var SubMenu = defineComponent({
        name: COMPONENT_NAME$d,
        props: subMenuProps,
        setup(props2, { slots, expose }) {
          const instance = getCurrentInstance();
          const { indexPath, parentMenu } = useMenu(instance, computed(() => props2.index));
          const nsMenu = useNamespace("menu");
          const nsSubMenu = useNamespace("sub-menu");
          const rootMenu = inject(MENU_INJECTION_KEY);
          if (!rootMenu)
            throwError(COMPONENT_NAME$d, "can not inject root menu");
          const subMenu = inject(`${SUB_MENU_INJECTION_KEY}${parentMenu.value.uid}`);
          if (!subMenu)
            throwError(COMPONENT_NAME$d, "can not inject sub menu");
          const items = ref({});
          const subMenus = ref({});
          let timeout;
          const mouseInChild = ref(false);
          const verticalTitleRef = ref();
          const vPopper = ref();
          const currentPlacement = computed(() => mode.value === "horizontal" && isFirstLevel.value ? "bottom-start" : "right-start");
          const subMenuTitleIcon = computed(() => {
            return mode.value === "horizontal" && isFirstLevel.value || mode.value === "vertical" && !rootMenu.props.collapse ? props2.expandCloseIcon && props2.expandOpenIcon ? opened.value ? props2.expandOpenIcon : props2.expandCloseIcon : arrow_down_default$1 : props2.collapseCloseIcon && props2.collapseOpenIcon ? opened.value ? props2.collapseOpenIcon : props2.collapseCloseIcon : arrow_right_default$1;
          });
          const isFirstLevel = computed(() => subMenu.level === 0);
          const appendToBody = computed(() => {
            const value = props2.teleported;
            return isUndefined(value) ? isFirstLevel.value : value;
          });
          const menuTransitionName = computed(() => rootMenu.props.collapse ? `${nsMenu.namespace.value}-zoom-in-left` : `${nsMenu.namespace.value}-zoom-in-top`);
          const fallbackPlacements = computed(() => mode.value === "horizontal" && isFirstLevel.value ? [
            "bottom-start",
            "bottom-end",
            "top-start",
            "top-end",
            "right-start",
            "left-start"
          ] : [
            "right-start",
            "right",
            "right-end",
            "left-start",
            "bottom-start",
            "bottom-end",
            "top-start",
            "top-end"
          ]);
          const opened = computed(() => rootMenu.openedMenus.includes(props2.index));
          const active = computed(() => [...Object.values(items.value), ...Object.values(subMenus.value)].some(({ active: active2 }) => active2));
          const mode = computed(() => rootMenu.props.mode);
          const persistent = computed(() => rootMenu.props.persistent);
          const item = reactive({
            index: props2.index,
            indexPath,
            active
          });
          const ulStyle = useMenuCssVar(rootMenu.props, subMenu.level + 1);
          const subMenuPopperOffset = computed(() => {
            var _a;
            return (_a = props2.popperOffset) != null ? _a : rootMenu.props.popperOffset;
          });
          const subMenuPopperClass = computed(() => {
            var _a;
            return (_a = props2.popperClass) != null ? _a : rootMenu.props.popperClass;
          });
          const subMenuShowTimeout = computed(() => {
            var _a;
            return (_a = props2.showTimeout) != null ? _a : rootMenu.props.showTimeout;
          });
          const subMenuHideTimeout = computed(() => {
            var _a;
            return (_a = props2.hideTimeout) != null ? _a : rootMenu.props.hideTimeout;
          });
          const doDestroy = () => {
            var _a, _b, _c;
            return (_c = (_b = (_a = vPopper.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.popperInstanceRef) == null ? void 0 : _c.destroy();
          };
          const handleCollapseToggle = (value) => {
            if (!value) {
              doDestroy();
            }
          };
          const handleClick = () => {
            if (rootMenu.props.menuTrigger === "hover" && rootMenu.props.mode === "horizontal" || rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props2.disabled)
              return;
            rootMenu.handleSubMenuClick({
              index: props2.index,
              indexPath: indexPath.value,
              active: active.value
            });
          };
          const handleMouseenter = (event, showTimeout = subMenuShowTimeout.value) => {
            var _a;
            if (event.type === "focus")
              return;
            if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props2.disabled) {
              subMenu.mouseInChild.value = true;
              return;
            }
            subMenu.mouseInChild.value = true;
            timeout == null ? void 0 : timeout();
            ({ stop: timeout } = useTimeoutFn(() => {
              rootMenu.openMenu(props2.index, indexPath.value);
            }, showTimeout));
            if (appendToBody.value) {
              (_a = parentMenu.value.vnode.el) == null ? void 0 : _a.dispatchEvent(new MouseEvent("mouseenter"));
            }
          };
          const handleMouseleave = (deepDispatch = false) => {
            var _a;
            if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical") {
              subMenu.mouseInChild.value = false;
              return;
            }
            timeout == null ? void 0 : timeout();
            subMenu.mouseInChild.value = false;
            ({ stop: timeout } = useTimeoutFn(() => !mouseInChild.value && rootMenu.closeMenu(props2.index, indexPath.value), subMenuHideTimeout.value));
            if (appendToBody.value && deepDispatch) {
              (_a = subMenu.handleMouseleave) == null ? void 0 : _a.call(subMenu, true);
            }
          };
          watch(() => rootMenu.props.collapse, (value) => handleCollapseToggle(Boolean(value)));
          {
            const addSubMenu = (item2) => {
              subMenus.value[item2.index] = item2;
            };
            const removeSubMenu = (item2) => {
              delete subMenus.value[item2.index];
            };
            provide(`${SUB_MENU_INJECTION_KEY}${instance.uid}`, {
              addSubMenu,
              removeSubMenu,
              handleMouseleave,
              mouseInChild,
              level: subMenu.level + 1
            });
          }
          expose({
            opened
          });
          onMounted(() => {
            rootMenu.addSubMenu(item);
            subMenu.addSubMenu(item);
          });
          onBeforeUnmount(() => {
            subMenu.removeSubMenu(item);
            rootMenu.removeSubMenu(item);
          });
          return () => {
            var _a;
            const titleTag = [
              (_a = slots.title) == null ? void 0 : _a.call(slots),
              h$1(ElIcon, {
                class: nsSubMenu.e("icon-arrow"),
                style: {
                  transform: opened.value ? props2.expandCloseIcon && props2.expandOpenIcon || props2.collapseCloseIcon && props2.collapseOpenIcon && rootMenu.props.collapse ? "none" : "rotateZ(180deg)" : "none"
                }
              }, {
                default: () => isString$1(subMenuTitleIcon.value) ? h$1(instance.appContext.components[subMenuTitleIcon.value]) : h$1(subMenuTitleIcon.value)
              })
            ];
            const child = rootMenu.isMenuPopup ? h$1(ElTooltip, {
              ref: vPopper,
              visible: opened.value,
              effect: "light",
              pure: true,
              offset: subMenuPopperOffset.value,
              showArrow: false,
              persistent: persistent.value,
              popperClass: subMenuPopperClass.value,
              placement: currentPlacement.value,
              teleported: appendToBody.value,
              fallbackPlacements: fallbackPlacements.value,
              transition: menuTransitionName.value,
              gpuAcceleration: false
            }, {
              content: () => {
                var _a2;
                return h$1("div", {
                  class: [
                    nsMenu.m(mode.value),
                    nsMenu.m("popup-container"),
                    subMenuPopperClass.value
                  ],
                  onMouseenter: (evt) => handleMouseenter(evt, 100),
                  onMouseleave: () => handleMouseleave(true),
                  onFocus: (evt) => handleMouseenter(evt, 100)
                }, [
                  h$1("ul", {
                    class: [
                      nsMenu.b(),
                      nsMenu.m("popup"),
                      nsMenu.m(`popup-${currentPlacement.value}`)
                    ],
                    style: ulStyle.value
                  }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)])
                ]);
              },
              default: () => h$1("div", {
                class: nsSubMenu.e("title"),
                onClick: handleClick
              }, titleTag)
            }) : h$1(Fragment, {}, [
              h$1("div", {
                class: nsSubMenu.e("title"),
                ref: verticalTitleRef,
                onClick: handleClick
              }, titleTag),
              h$1(ElCollapseTransition, {}, {
                default: () => {
                  var _a2;
                  return withDirectives(h$1("ul", {
                    role: "menu",
                    class: [nsMenu.b(), nsMenu.m("inline")],
                    style: ulStyle.value
                  }, [(_a2 = slots.default) == null ? void 0 : _a2.call(slots)]), [[vShow, opened.value]]);
                }
              })
            ]);
            return h$1("li", {
              class: [
                nsSubMenu.b(),
                nsSubMenu.is("active", active.value),
                nsSubMenu.is("opened", opened.value),
                nsSubMenu.is("disabled", props2.disabled)
              ],
              role: "menuitem",
              ariaHaspopup: true,
              ariaExpanded: opened.value,
              onMouseenter: handleMouseenter,
              onMouseleave: () => handleMouseleave(),
              onFocus: handleMouseenter
            }, [child]);
          };
        }
      });
      const menuProps = exports("menuProps", buildProps({
        mode: {
          type: String,
          values: ["horizontal", "vertical"],
          default: "vertical"
        },
        defaultActive: {
          type: String,
          default: ""
        },
        defaultOpeneds: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        uniqueOpened: Boolean,
        router: Boolean,
        menuTrigger: {
          type: String,
          values: ["hover", "click"],
          default: "hover"
        },
        collapse: Boolean,
        backgroundColor: String,
        textColor: String,
        activeTextColor: String,
        closeOnClickOutside: Boolean,
        collapseTransition: {
          type: Boolean,
          default: true
        },
        ellipsis: {
          type: Boolean,
          default: true
        },
        popperOffset: {
          type: Number,
          default: 6
        },
        ellipsisIcon: {
          type: iconPropType,
          default: () => more_default$1
        },
        popperEffect: {
          type: definePropType(String),
          default: "dark"
        },
        popperClass: String,
        showTimeout: {
          type: Number,
          default: 300
        },
        hideTimeout: {
          type: Number,
          default: 300
        },
        persistent: {
          type: Boolean,
          default: true
        }
      }));
      const checkIndexPath = (indexPath) => isArray$1(indexPath) && indexPath.every((path) => isString$1(path));
      const menuEmits = exports("menuEmits", {
        close: (index2, indexPath) => isString$1(index2) && checkIndexPath(indexPath),
        open: (index2, indexPath) => isString$1(index2) && checkIndexPath(indexPath),
        select: (index2, indexPath, item, routerResult) => isString$1(index2) && checkIndexPath(indexPath) && isObject$1(item) && (isUndefined(routerResult) || routerResult instanceof Promise)
      });
      var Menu = defineComponent({
        name: "ElMenu",
        props: menuProps,
        emits: menuEmits,
        setup(props2, { emit, slots, expose }) {
          const instance = getCurrentInstance();
          const router = instance.appContext.config.globalProperties.$router;
          const menu = ref();
          const subMenu = ref();
          const nsMenu = useNamespace("menu");
          const nsSubMenu = useNamespace("sub-menu");
          let moreItemWidth = 64;
          const sliceIndex = ref(-1);
          const openedMenus = ref(props2.defaultOpeneds && !props2.collapse ? props2.defaultOpeneds.slice(0) : []);
          const activeIndex = ref(props2.defaultActive);
          const items = ref({});
          const subMenus = ref({});
          const isMenuPopup = computed(() => props2.mode === "horizontal" || props2.mode === "vertical" && props2.collapse);
          const initMenu = () => {
            const activeItem = activeIndex.value && items.value[activeIndex.value];
            if (!activeItem || props2.mode === "horizontal" || props2.collapse)
              return;
            const indexPath = activeItem.indexPath;
            indexPath.forEach((index2) => {
              const subMenu2 = subMenus.value[index2];
              subMenu2 && openMenu(index2, subMenu2.indexPath);
            });
          };
          const openMenu = (index2, indexPath) => {
            if (openedMenus.value.includes(index2))
              return;
            if (props2.uniqueOpened) {
              openedMenus.value = openedMenus.value.filter((index22) => indexPath.includes(index22));
            }
            openedMenus.value.push(index2);
            emit("open", index2, indexPath);
          };
          const close2 = (index2) => {
            const i = openedMenus.value.indexOf(index2);
            if (i !== -1) {
              openedMenus.value.splice(i, 1);
            }
          };
          const closeMenu = (index2, indexPath) => {
            close2(index2);
            emit("close", index2, indexPath);
          };
          const handleSubMenuClick = ({
            index: index2,
            indexPath
          }) => {
            const isOpened = openedMenus.value.includes(index2);
            isOpened ? closeMenu(index2, indexPath) : openMenu(index2, indexPath);
          };
          const handleMenuItemClick = (menuItem) => {
            if (props2.mode === "horizontal" || props2.collapse) {
              openedMenus.value = [];
            }
            const { index: index2, indexPath } = menuItem;
            if (isNil(index2) || isNil(indexPath))
              return;
            if (props2.router && router) {
              const route = menuItem.route || index2;
              const routerResult = router.push(route).then((res) => {
                if (!res)
                  activeIndex.value = index2;
                return res;
              });
              emit("select", index2, indexPath, { index: index2, indexPath, route }, routerResult);
            } else {
              activeIndex.value = index2;
              emit("select", index2, indexPath, { index: index2, indexPath });
            }
          };
          const updateActiveIndex = (val) => {
            var _a;
            const itemsInData = items.value;
            const item = itemsInData[val] || activeIndex.value && itemsInData[activeIndex.value] || itemsInData[props2.defaultActive];
            activeIndex.value = (_a = item == null ? void 0 : item.index) != null ? _a : val;
          };
          const calcMenuItemWidth = (menuItem) => {
            const computedStyle = getComputedStyle(menuItem);
            const marginLeft = Number.parseInt(computedStyle.marginLeft, 10);
            const marginRight = Number.parseInt(computedStyle.marginRight, 10);
            return menuItem.offsetWidth + marginLeft + marginRight || 0;
          };
          const calcSliceIndex = () => {
            var _a, _b;
            if (!menu.value)
              return -1;
            const items2 = Array.from((_b = (_a = menu.value) == null ? void 0 : _a.childNodes) != null ? _b : []).filter((item) => item.nodeName !== "#text" || item.nodeValue);
            const computedMenuStyle = getComputedStyle(menu.value);
            const paddingLeft = Number.parseInt(computedMenuStyle.paddingLeft, 10);
            const paddingRight = Number.parseInt(computedMenuStyle.paddingRight, 10);
            const menuWidth = menu.value.clientWidth - paddingLeft - paddingRight;
            let calcWidth = 0;
            let sliceIndex2 = 0;
            items2.forEach((item, index2) => {
              if (item.nodeName === "#comment")
                return;
              calcWidth += calcMenuItemWidth(item);
              if (calcWidth <= menuWidth - moreItemWidth) {
                sliceIndex2 = index2 + 1;
              }
            });
            return sliceIndex2 === items2.length ? -1 : sliceIndex2;
          };
          const getIndexPath = (index2) => subMenus.value[index2].indexPath;
          const debounce2 = (fn2, wait = 33.34) => {
            let timer;
            return () => {
              timer && clearTimeout(timer);
              timer = setTimeout(() => {
                fn2();
              }, wait);
            };
          };
          let isFirstTimeRender = true;
          const handleResize = () => {
            const el = unrefElement(subMenu);
            if (el)
              moreItemWidth = calcMenuItemWidth(el) || 64;
            if (sliceIndex.value === calcSliceIndex())
              return;
            const callback = () => {
              sliceIndex.value = -1;
              nextTick(() => {
                sliceIndex.value = calcSliceIndex();
              });
            };
            isFirstTimeRender ? callback() : debounce2(callback)();
            isFirstTimeRender = false;
          };
          watch(() => props2.defaultActive, (currentActive) => {
            if (!items.value[currentActive]) {
              activeIndex.value = "";
            }
            updateActiveIndex(currentActive);
          });
          watch(() => props2.collapse, (value) => {
            if (value)
              openedMenus.value = [];
          });
          watch(items.value, initMenu);
          let resizeStopper;
          watchEffect(() => {
            if (props2.mode === "horizontal" && props2.ellipsis)
              resizeStopper = useResizeObserver(menu, handleResize).stop;
            else
              resizeStopper == null ? void 0 : resizeStopper();
          });
          const mouseInChild = ref(false);
          {
            const addSubMenu = (item) => {
              subMenus.value[item.index] = item;
            };
            const removeSubMenu = (item) => {
              delete subMenus.value[item.index];
            };
            const addMenuItem = (item) => {
              items.value[item.index] = item;
            };
            const removeMenuItem = (item) => {
              delete items.value[item.index];
            };
            provide(MENU_INJECTION_KEY, reactive({
              props: props2,
              openedMenus,
              items,
              subMenus,
              activeIndex,
              isMenuPopup,
              addMenuItem,
              removeMenuItem,
              addSubMenu,
              removeSubMenu,
              openMenu,
              closeMenu,
              handleMenuItemClick,
              handleSubMenuClick
            }));
            provide(`${SUB_MENU_INJECTION_KEY}${instance.uid}`, {
              addSubMenu,
              removeSubMenu,
              mouseInChild,
              level: 0
            });
          }
          onMounted(() => {
            if (props2.mode === "horizontal") {
              new Menubar(instance.vnode.el, nsMenu.namespace.value);
            }
          });
          {
            const open = (index2) => {
              const { indexPath } = subMenus.value[index2];
              indexPath.forEach((i) => openMenu(i, indexPath));
            };
            expose({
              open,
              close: close2,
              updateActiveIndex,
              handleResize
            });
          }
          const ulStyle = useMenuCssVar(props2, 0);
          return () => {
            var _a, _b;
            let slot = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : [];
            const vShowMore = [];
            if (props2.mode === "horizontal" && menu.value) {
              const originalSlot = flattedChildren(slot);
              const slotDefault = sliceIndex.value === -1 ? originalSlot : originalSlot.slice(0, sliceIndex.value);
              const slotMore = sliceIndex.value === -1 ? [] : originalSlot.slice(sliceIndex.value);
              if ((slotMore == null ? void 0 : slotMore.length) && props2.ellipsis) {
                slot = slotDefault;
                vShowMore.push(h$1(SubMenu, {
                  ref: subMenu,
                  index: "sub-menu-more",
                  class: nsSubMenu.e("hide-arrow"),
                  popperOffset: props2.popperOffset
                }, {
                  title: () => h$1(ElIcon, {
                    class: nsSubMenu.e("icon-more")
                  }, {
                    default: () => h$1(props2.ellipsisIcon)
                  }),
                  default: () => slotMore
                }));
              }
            }
            const directives = props2.closeOnClickOutside ? [
              [
                ClickOutside,
                () => {
                  if (!openedMenus.value.length)
                    return;
                  if (!mouseInChild.value) {
                    openedMenus.value.forEach((openedMenu) => emit("close", openedMenu, getIndexPath(openedMenu)));
                    openedMenus.value = [];
                  }
                }
              ]
            ] : [];
            const vMenu = withDirectives(h$1("ul", {
              key: String(props2.collapse),
              role: "menubar",
              ref: menu,
              style: ulStyle.value,
              class: {
                [nsMenu.b()]: true,
                [nsMenu.m(props2.mode)]: true,
                [nsMenu.m("collapse")]: props2.collapse
              }
            }, [...slot, ...vShowMore]), directives);
            if (props2.collapseTransition && props2.mode === "vertical") {
              return h$1(ElMenuCollapseTransition, () => vMenu);
            }
            return vMenu;
          };
        }
      });
      const menuItemProps = exports("menuItemProps", buildProps({
        index: {
          type: definePropType([String, null]),
          default: null
        },
        route: {
          type: definePropType([String, Object])
        },
        disabled: Boolean
      }));
      const menuItemEmits = exports("menuItemEmits", {
        click: (item) => isString$1(item.index) && isArray$1(item.indexPath)
      });
      const COMPONENT_NAME$c = "ElMenuItem";
      const __default__$V = defineComponent({
        name: COMPONENT_NAME$c
      });
      const _sfc_main$17 = /* @__PURE__ */ defineComponent({
        ...__default__$V,
        props: menuItemProps,
        emits: menuItemEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          isPropAbsent(props2.index) && debugWarn();
          const instance = getCurrentInstance();
          const rootMenu = inject(MENU_INJECTION_KEY);
          const nsMenu = useNamespace("menu");
          const nsMenuItem = useNamespace("menu-item");
          if (!rootMenu)
            throwError(COMPONENT_NAME$c, "can not inject root menu");
          const { parentMenu, indexPath } = useMenu(instance, toRef(props2, "index"));
          const subMenu = inject(`${SUB_MENU_INJECTION_KEY}${parentMenu.value.uid}`);
          if (!subMenu)
            throwError(COMPONENT_NAME$c, "can not inject sub menu");
          const active = computed(() => props2.index === rootMenu.activeIndex);
          const item = reactive({
            index: props2.index,
            indexPath,
            active
          });
          const handleClick = () => {
            if (!props2.disabled) {
              rootMenu.handleMenuItemClick({
                index: props2.index,
                indexPath: indexPath.value,
                route: props2.route
              });
              emit("click", item);
            }
          };
          onMounted(() => {
            subMenu.addSubMenu(item);
            rootMenu.addMenuItem(item);
          });
          onBeforeUnmount(() => {
            subMenu.removeSubMenu(item);
            rootMenu.removeMenuItem(item);
          });
          expose({
            parentMenu,
            rootMenu,
            active,
            nsMenu,
            nsMenuItem,
            handleClick
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("li", {
              class: normalizeClass([
                unref(nsMenuItem).b(),
                unref(nsMenuItem).is("active", unref(active)),
                unref(nsMenuItem).is("disabled", _ctx.disabled)
              ]),
              role: "menuitem",
              tabindex: "-1",
              onClick: handleClick
            }, [
              unref(parentMenu).type.name === "ElMenu" && unref(rootMenu).props.collapse && _ctx.$slots.title ? (openBlock(), createBlock(unref(ElTooltip), {
                key: 0,
                effect: unref(rootMenu).props.popperEffect,
                placement: "right",
                "fallback-placements": ["left"],
                persistent: unref(rootMenu).props.persistent
              }, {
                content: withCtx(() => [
                  renderSlot(_ctx.$slots, "title")
                ]),
                default: withCtx(() => [
                  createElementVNode("div", {
                    class: normalizeClass(unref(nsMenu).be("tooltip", "trigger"))
                  }, [
                    renderSlot(_ctx.$slots, "default")
                  ], 2)
                ]),
                _: 3
              }, 8, ["effect", "persistent"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                renderSlot(_ctx.$slots, "default"),
                renderSlot(_ctx.$slots, "title")
              ], 64))
            ], 2);
          };
        }
      });
      var MenuItem = /* @__PURE__ */ _export_sfc(_sfc_main$17, [["__file", "menu-item.vue"]]);
      const menuItemGroupProps = exports("menuItemGroupProps", {
        title: String
      });
      const __default__$U = defineComponent({
        name: "ElMenuItemGroup"
      });
      const _sfc_main$16 = /* @__PURE__ */ defineComponent({
        ...__default__$U,
        props: menuItemGroupProps,
        setup(__props) {
          const ns = useNamespace("menu-item-group");
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("li", {
              class: normalizeClass(unref(ns).b())
            }, [
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("title"))
              }, [
                !_ctx.$slots.title ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createTextVNode(toDisplayString(_ctx.title), 1)
                ], 64)) : renderSlot(_ctx.$slots, "title", { key: 1 })
              ], 2),
              createElementVNode("ul", null, [
                renderSlot(_ctx.$slots, "default")
              ])
            ], 2);
          };
        }
      });
      var MenuItemGroup = /* @__PURE__ */ _export_sfc(_sfc_main$16, [["__file", "menu-item-group.vue"]]);
      const ElMenu = exports("ElMenu", withInstall(Menu, {
        MenuItem,
        MenuItemGroup,
        SubMenu
      }));
      const ElMenuItem = exports("ElMenuItem", withNoopInstall(MenuItem));
      const ElMenuItemGroup = exports("ElMenuItemGroup", withNoopInstall(MenuItemGroup));
      const ElSubMenu = exports("ElSubMenu", withNoopInstall(SubMenu));
      const pageHeaderProps = exports("pageHeaderProps", buildProps({
        icon: {
          type: iconPropType,
          default: () => back_default$1
        },
        title: String,
        content: {
          type: String,
          default: ""
        }
      }));
      const pageHeaderEmits = exports("pageHeaderEmits", {
        back: () => true
      });
      const __default__$T = defineComponent({
        name: "ElPageHeader"
      });
      const _sfc_main$15 = /* @__PURE__ */ defineComponent({
        ...__default__$T,
        props: pageHeaderProps,
        emits: pageHeaderEmits,
        setup(__props, { emit }) {
          const { t } = useLocale();
          const ns = useNamespace("page-header");
          function handleClick() {
            emit("back");
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ns).b(),
                {
                  [unref(ns).m("has-breadcrumb")]: !!_ctx.$slots.breadcrumb,
                  [unref(ns).m("has-extra")]: !!_ctx.$slots.extra,
                  [unref(ns).is("contentful")]: !!_ctx.$slots.default
                }
              ])
            }, [
              _ctx.$slots.breadcrumb ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).e("breadcrumb"))
              }, [
                renderSlot(_ctx.$slots, "breadcrumb")
              ], 2)) : createCommentVNode("v-if", true),
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("header"))
              }, [
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).e("left"))
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).e("back")),
                    role: "button",
                    tabindex: "0",
                    onClick: handleClick
                  }, [
                    _ctx.icon || _ctx.$slots.icon ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      "aria-label": _ctx.title || unref(t)("el.pageHeader.title"),
                      class: normalizeClass(unref(ns).e("icon"))
                    }, [
                      renderSlot(_ctx.$slots, "icon", {}, () => [
                        _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                          ]),
                          _: 1
                        })) : createCommentVNode("v-if", true)
                      ])
                    ], 10, ["aria-label"])) : createCommentVNode("v-if", true),
                    createElementVNode("div", {
                      class: normalizeClass(unref(ns).e("title"))
                    }, [
                      renderSlot(_ctx.$slots, "title", {}, () => [
                        createTextVNode(toDisplayString(_ctx.title || unref(t)("el.pageHeader.title")), 1)
                      ])
                    ], 2)
                  ], 2),
                  createVNode(unref(ElDivider), { direction: "vertical" }),
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).e("content"))
                  }, [
                    renderSlot(_ctx.$slots, "content", {}, () => [
                      createTextVNode(toDisplayString(_ctx.content), 1)
                    ])
                  ], 2)
                ], 2),
                _ctx.$slots.extra ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).e("extra"))
                }, [
                  renderSlot(_ctx.$slots, "extra")
                ], 2)) : createCommentVNode("v-if", true)
              ], 2),
              _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(ns).e("main"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var PageHeader = /* @__PURE__ */ _export_sfc(_sfc_main$15, [["__file", "page-header.vue"]]);
      const ElPageHeader = exports("ElPageHeader", withInstall(PageHeader));
      const elPaginationKey = exports("elPaginationKey", Symbol("elPaginationKey"));
      const paginationPrevProps = buildProps({
        disabled: Boolean,
        currentPage: {
          type: Number,
          default: 1
        },
        prevText: {
          type: String
        },
        prevIcon: {
          type: iconPropType
        }
      });
      const paginationPrevEmits = {
        click: (evt) => evt instanceof MouseEvent
      };
      const __default__$S = defineComponent({
        name: "ElPaginationPrev"
      });
      const _sfc_main$14 = /* @__PURE__ */ defineComponent({
        ...__default__$S,
        props: paginationPrevProps,
        emits: paginationPrevEmits,
        setup(__props) {
          const props2 = __props;
          const { t } = useLocale();
          const internalDisabled = computed(() => props2.disabled || props2.currentPage <= 1);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("button", {
              type: "button",
              class: "btn-prev",
              disabled: unref(internalDisabled),
              "aria-label": _ctx.prevText || unref(t)("el.pagination.prev"),
              "aria-disabled": unref(internalDisabled),
              onClick: ($event) => _ctx.$emit("click", $event)
            }, [
              _ctx.prevText ? (openBlock(), createElementBlock("span", { key: 0 }, toDisplayString(_ctx.prevText), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.prevIcon)))
                ]),
                _: 1
              }))
            ], 8, ["disabled", "aria-label", "aria-disabled", "onClick"]);
          };
        }
      });
      var Prev = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["__file", "prev.vue"]]);
      const paginationNextProps = buildProps({
        disabled: Boolean,
        currentPage: {
          type: Number,
          default: 1
        },
        pageCount: {
          type: Number,
          default: 50
        },
        nextText: {
          type: String
        },
        nextIcon: {
          type: iconPropType
        }
      });
      const __default__$R = defineComponent({
        name: "ElPaginationNext"
      });
      const _sfc_main$13 = /* @__PURE__ */ defineComponent({
        ...__default__$R,
        props: paginationNextProps,
        emits: ["click"],
        setup(__props) {
          const props2 = __props;
          const { t } = useLocale();
          const internalDisabled = computed(() => props2.disabled || props2.currentPage === props2.pageCount || props2.pageCount === 0);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("button", {
              type: "button",
              class: "btn-next",
              disabled: unref(internalDisabled),
              "aria-label": _ctx.nextText || unref(t)("el.pagination.next"),
              "aria-disabled": unref(internalDisabled),
              onClick: ($event) => _ctx.$emit("click", $event)
            }, [
              _ctx.nextText ? (openBlock(), createElementBlock("span", { key: 0 }, toDisplayString(_ctx.nextText), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.nextIcon)))
                ]),
                _: 1
              }))
            ], 8, ["disabled", "aria-label", "aria-disabled", "onClick"]);
          };
        }
      });
      var Next = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["__file", "next.vue"]]);
      const selectGroupKey = exports("selectGroupKey", Symbol("ElSelectGroup"));
      const selectKey = exports("selectKey", Symbol("ElSelect"));
      const COMPONENT_NAME$b = "ElOption";
      const optionProps = buildProps({
        value: {
          type: [String, Number, Boolean, Object],
          required: true
        },
        label: {
          type: [String, Number]
        },
        created: Boolean,
        disabled: Boolean
      });
      function useOption$1(props2, states) {
        const select = inject(selectKey);
        if (!select) {
          throwError(COMPONENT_NAME$b, "usage: <el-select><el-option /></el-select/>");
        }
        const selectGroup = inject(selectGroupKey, { disabled: false });
        const itemSelected = computed(() => {
          return contains2(castArray$1(select.props.modelValue), props2.value);
        });
        const limitReached = computed(() => {
          var _a;
          if (select.props.multiple) {
            const modelValue = castArray$1((_a = select.props.modelValue) != null ? _a : []);
            return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
          } else {
            return false;
          }
        });
        const currentLabel = computed(() => {
          var _a;
          return (_a = props2.label) != null ? _a : isObject$1(props2.value) ? "" : props2.value;
        });
        const currentValue = computed(() => {
          return props2.value || props2.label || "";
        });
        const isDisabled = computed(() => {
          return props2.disabled || states.groupDisabled || limitReached.value;
        });
        const instance = getCurrentInstance();
        const contains2 = (arr = [], target2) => {
          if (!isObject$1(props2.value)) {
            return arr && arr.includes(target2);
          } else {
            const valueKey = select.props.valueKey;
            return arr && arr.some((item) => {
              return toRaw(get(item, valueKey)) === get(target2, valueKey);
            });
          }
        };
        const hoverItem = () => {
          if (!props2.disabled && !selectGroup.disabled) {
            select.states.hoveringIndex = select.optionsArray.indexOf(instance.proxy);
          }
        };
        const updateOption = (query) => {
          const regexp = new RegExp(escapeStringRegexp(query), "i");
          states.visible = regexp.test(String(currentLabel.value)) || props2.created;
        };
        watch(() => currentLabel.value, () => {
          if (!props2.created && !select.props.remote)
            select.setSelected();
        });
        watch(() => props2.value, (val, oldVal) => {
          const { remote, valueKey } = select.props;
          const shouldUpdate = remote ? val !== oldVal : !isEqual$1(val, oldVal);
          if (shouldUpdate) {
            select.onOptionDestroy(oldVal, instance.proxy);
            select.onOptionCreate(instance.proxy);
          }
          if (!props2.created && !remote) {
            if (valueKey && isObject$1(val) && isObject$1(oldVal) && val[valueKey] === oldVal[valueKey]) {
              return;
            }
            select.setSelected();
          }
        });
        watch(() => selectGroup.disabled, () => {
          states.groupDisabled = selectGroup.disabled;
        }, { immediate: true });
        return {
          select,
          currentLabel,
          currentValue,
          itemSelected,
          isDisabled,
          hoverItem,
          updateOption
        };
      }
      const _sfc_main$12 = defineComponent({
        name: COMPONENT_NAME$b,
        componentName: COMPONENT_NAME$b,
        props: optionProps,
        setup(props2) {
          const ns = useNamespace("select");
          const id = useId();
          const containerKls = computed(() => [
            ns.be("dropdown", "item"),
            ns.is("disabled", unref(isDisabled)),
            ns.is("selected", unref(itemSelected)),
            ns.is("hovering", unref(hover))
          ]);
          const states = reactive({
            index: -1,
            groupDisabled: false,
            visible: true,
            hover: false
          });
          const {
            currentLabel,
            itemSelected,
            isDisabled,
            select,
            hoverItem,
            updateOption
          } = useOption$1(props2, states);
          const { visible, hover } = toRefs(states);
          const vm = getCurrentInstance().proxy;
          select.onOptionCreate(vm);
          onBeforeUnmount(() => {
            const key = vm.value;
            nextTick(() => {
              const { selected: selectedOptions } = select.states;
              const doesSelected = selectedOptions.some((item) => {
                return item.value === vm.value;
              });
              if (select.states.cachedOptions.get(key) === vm && !doesSelected) {
                select.states.cachedOptions.delete(key);
              }
            });
            select.onOptionDestroy(key, vm);
          });
          function selectOptionClick() {
            if (!isDisabled.value) {
              select.handleOptionSelect(vm);
            }
          }
          return {
            ns,
            id,
            containerKls,
            currentLabel,
            itemSelected,
            isDisabled,
            select,
            visible,
            hover,
            states,
            hoverItem,
            updateOption,
            selectOptionClick
          };
        }
      });
      function _sfc_render$b(_ctx, _cache) {
        return withDirectives((openBlock(), createElementBlock("li", {
          id: _ctx.id,
          class: normalizeClass(_ctx.containerKls),
          role: "option",
          "aria-disabled": _ctx.isDisabled || void 0,
          "aria-selected": _ctx.itemSelected,
          onMousemove: _ctx.hoverItem,
          onClick: withModifiers(_ctx.selectOptionClick, ["stop"])
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createElementVNode("span", null, toDisplayString(_ctx.currentLabel), 1)
          ])
        ], 42, ["id", "aria-disabled", "aria-selected", "onMousemove", "onClick"])), [
          [vShow, _ctx.visible]
        ]);
      }
      var Option = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["render", _sfc_render$b], ["__file", "option.vue"]]);
      const _sfc_main$11 = defineComponent({
        name: "ElSelectDropdown",
        componentName: "ElSelectDropdown",
        setup() {
          const select = inject(selectKey);
          const ns = useNamespace("select");
          const popperClass = computed(() => select.props.popperClass);
          const isMultiple = computed(() => select.props.multiple);
          const isFitInputWidth = computed(() => select.props.fitInputWidth);
          const minWidth = ref("");
          function updateMinWidth() {
            var _a;
            minWidth.value = `${(_a = select.selectRef) == null ? void 0 : _a.offsetWidth}px`;
          }
          onMounted(() => {
            updateMinWidth();
            useResizeObserver(select.selectRef, updateMinWidth);
          });
          return {
            ns,
            minWidth,
            popperClass,
            isMultiple,
            isFitInputWidth
          };
        }
      });
      function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass([_ctx.ns.b("dropdown"), _ctx.ns.is("multiple", _ctx.isMultiple), _ctx.popperClass]),
          style: normalizeStyle({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
        }, [
          _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.ns.be("dropdown", "header"))
          }, [
            renderSlot(_ctx.$slots, "header")
          ], 2)) : createCommentVNode("v-if", true),
          renderSlot(_ctx.$slots, "default"),
          _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(_ctx.ns.be("dropdown", "footer"))
          }, [
            renderSlot(_ctx.$slots, "footer")
          ], 2)) : createCommentVNode("v-if", true)
        ], 6);
      }
      var ElSelectMenu$1 = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["render", _sfc_render$a], ["__file", "select-dropdown.vue"]]);
      const useSelect$3 = (props2, emit) => {
        const { t } = useLocale();
        const contentId = useId();
        const nsSelect = useNamespace("select");
        const nsInput = useNamespace("input");
        const states = reactive({
          inputValue: "",
          options: /* @__PURE__ */ new Map(),
          cachedOptions: /* @__PURE__ */ new Map(),
          optionValues: [],
          selected: [],
          selectionWidth: 0,
          collapseItemWidth: 0,
          selectedLabel: "",
          hoveringIndex: -1,
          previousQuery: null,
          inputHovering: false,
          menuVisibleOnFocus: false,
          isBeforeHide: false
        });
        const selectRef = ref();
        const selectionRef = ref();
        const tooltipRef = ref();
        const tagTooltipRef = ref();
        const inputRef = ref();
        const prefixRef = ref();
        const suffixRef = ref();
        const menuRef = ref();
        const tagMenuRef = ref();
        const collapseItemRef = ref();
        const scrollbarRef = ref();
        const expanded = ref(false);
        const hoverOption = ref();
        const { form, formItem } = useFormItem();
        const { inputId } = useFormItemInputId(props2, {
          formItemContext: formItem
        });
        const { valueOnClear, isEmptyValue: isEmptyValue2 } = useEmptyValues(props2);
        const {
          isComposing,
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd
        } = useComposition({
          afterComposition: (e) => onInput(e)
        });
        const selectDisabled = computed(() => props2.disabled || !!(form == null ? void 0 : form.disabled));
        const { wrapperRef, isFocused, handleBlur } = useFocusController(inputRef, {
          disabled: selectDisabled,
          afterFocus() {
            if (props2.automaticDropdown && !expanded.value) {
              expanded.value = true;
              states.menuVisibleOnFocus = true;
            }
          },
          beforeBlur(event) {
            var _a, _b;
            return ((_a = tooltipRef.value) == null ? void 0 : _a.isFocusInsideContent(event)) || ((_b = tagTooltipRef.value) == null ? void 0 : _b.isFocusInsideContent(event));
          },
          afterBlur() {
            var _a;
            expanded.value = false;
            states.menuVisibleOnFocus = false;
            if (props2.validateEvent) {
              (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "blur").catch((err) => debugWarn());
            }
          }
        });
        const hasModelValue = computed(() => {
          return isArray$1(props2.modelValue) ? props2.modelValue.length > 0 : !isEmptyValue2(props2.modelValue);
        });
        const needStatusIcon = computed(() => {
          var _a;
          return (_a = form == null ? void 0 : form.statusIcon) != null ? _a : false;
        });
        const showClose = computed(() => {
          return props2.clearable && !selectDisabled.value && states.inputHovering && hasModelValue.value;
        });
        const iconComponent = computed(() => props2.remote && props2.filterable && !props2.remoteShowSuffix ? "" : props2.suffixIcon);
        const iconReverse = computed(() => nsSelect.is("reverse", !!(iconComponent.value && expanded.value)));
        const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
        const validateIcon = computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
        const debounce$1 = computed(() => props2.remote ? 300 : 0);
        const isRemoteSearchEmpty = computed(() => props2.remote && !states.inputValue && states.options.size === 0);
        const emptyText = computed(() => {
          if (props2.loading) {
            return props2.loadingText || t("el.select.loading");
          } else {
            if (props2.filterable && states.inputValue && states.options.size > 0 && filteredOptionsCount.value === 0) {
              return props2.noMatchText || t("el.select.noMatch");
            }
            if (states.options.size === 0) {
              return props2.noDataText || t("el.select.noData");
            }
          }
          return null;
        });
        const filteredOptionsCount = computed(() => optionsArray.value.filter((option) => option.visible).length);
        const optionsArray = computed(() => {
          const list = Array.from(states.options.values());
          const newList = [];
          states.optionValues.forEach((item) => {
            const index2 = list.findIndex((i) => i.value === item);
            if (index2 > -1) {
              newList.push(list[index2]);
            }
          });
          return newList.length >= list.length ? newList : list;
        });
        const cachedOptionsArray = computed(() => Array.from(states.cachedOptions.values()));
        const showNewOption = computed(() => {
          const hasExistingOption = optionsArray.value.filter((option) => {
            return !option.created;
          }).some((option) => {
            return option.currentLabel === states.inputValue;
          });
          return props2.filterable && props2.allowCreate && states.inputValue !== "" && !hasExistingOption;
        });
        const updateOptions2 = () => {
          if (props2.filterable && isFunction$1(props2.filterMethod))
            return;
          if (props2.filterable && props2.remote && isFunction$1(props2.remoteMethod))
            return;
          optionsArray.value.forEach((option) => {
            var _a;
            (_a = option.updateOption) == null ? void 0 : _a.call(option, states.inputValue);
          });
        };
        const selectSize = useFormSize();
        const collapseTagSize = computed(() => ["small"].includes(selectSize.value) ? "small" : "default");
        const dropdownMenuVisible = computed({
          get() {
            return expanded.value && !isRemoteSearchEmpty.value;
          },
          set(val) {
            expanded.value = val;
          }
        });
        const shouldShowPlaceholder = computed(() => {
          if (props2.multiple && !isUndefined(props2.modelValue)) {
            return castArray$1(props2.modelValue).length === 0 && !states.inputValue;
          }
          const value = isArray$1(props2.modelValue) ? props2.modelValue[0] : props2.modelValue;
          return props2.filterable || isUndefined(value) ? !states.inputValue : true;
        });
        const currentPlaceholder = computed(() => {
          var _a;
          const _placeholder = (_a = props2.placeholder) != null ? _a : t("el.select.placeholder");
          return props2.multiple || !hasModelValue.value ? _placeholder : states.selectedLabel;
        });
        const mouseEnterEventName = computed(() => isIOS ? null : "mouseenter");
        watch(() => props2.modelValue, (val, oldVal) => {
          if (props2.multiple) {
            if (props2.filterable && !props2.reserveKeyword) {
              states.inputValue = "";
              handleQueryChange("");
            }
          }
          setSelected();
          if (!isEqual$1(val, oldVal) && props2.validateEvent) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
          }
        }, {
          flush: "post",
          deep: true
        });
        watch(() => expanded.value, (val) => {
          if (val) {
            handleQueryChange(states.inputValue);
          } else {
            states.inputValue = "";
            states.previousQuery = null;
            states.isBeforeHide = true;
          }
          emit("visible-change", val);
        });
        watch(() => states.options.entries(), () => {
          if (!isClient)
            return;
          setSelected();
          if (props2.defaultFirstOption && (props2.filterable || props2.remote) && filteredOptionsCount.value) {
            checkDefaultFirstOption();
          }
        }, {
          flush: "post"
        });
        watch([() => states.hoveringIndex, optionsArray], ([val]) => {
          if (isNumber(val) && val > -1) {
            hoverOption.value = optionsArray.value[val] || {};
          } else {
            hoverOption.value = {};
          }
          optionsArray.value.forEach((option) => {
            option.hover = hoverOption.value === option;
          });
        });
        watchEffect(() => {
          if (states.isBeforeHide)
            return;
          updateOptions2();
        });
        const handleQueryChange = (val) => {
          if (states.previousQuery === val || isComposing.value) {
            return;
          }
          states.previousQuery = val;
          if (props2.filterable && isFunction$1(props2.filterMethod)) {
            props2.filterMethod(val);
          } else if (props2.filterable && props2.remote && isFunction$1(props2.remoteMethod)) {
            props2.remoteMethod(val);
          }
          if (props2.defaultFirstOption && (props2.filterable || props2.remote) && filteredOptionsCount.value) {
            nextTick(checkDefaultFirstOption);
          } else {
            nextTick(updateHoveringIndex);
          }
        };
        const checkDefaultFirstOption = () => {
          const optionsInDropdown = optionsArray.value.filter((n) => n.visible && !n.disabled && !n.states.groupDisabled);
          const userCreatedOption = optionsInDropdown.find((n) => n.created);
          const firstOriginOption = optionsInDropdown[0];
          const valueList = optionsArray.value.map((item) => item.value);
          states.hoveringIndex = getValueIndex(valueList, userCreatedOption || firstOriginOption);
        };
        const setSelected = () => {
          if (!props2.multiple) {
            const value = isArray$1(props2.modelValue) ? props2.modelValue[0] : props2.modelValue;
            const option = getOption(value);
            states.selectedLabel = option.currentLabel;
            states.selected = [option];
            return;
          } else {
            states.selectedLabel = "";
          }
          const result2 = [];
          if (!isUndefined(props2.modelValue)) {
            castArray$1(props2.modelValue).forEach((value) => {
              result2.push(getOption(value));
            });
          }
          states.selected = result2;
        };
        const getOption = (value) => {
          let option;
          const isObjectValue = isPlainObject$1(value);
          for (let i = states.cachedOptions.size - 1; i >= 0; i--) {
            const cachedOption = cachedOptionsArray.value[i];
            const isEqualValue = isObjectValue ? get(cachedOption.value, props2.valueKey) === get(value, props2.valueKey) : cachedOption.value === value;
            if (isEqualValue) {
              option = {
                value,
                currentLabel: cachedOption.currentLabel,
                get isDisabled() {
                  return cachedOption.isDisabled;
                }
              };
              break;
            }
          }
          if (option)
            return option;
          const label = isObjectValue ? value.label : value != null ? value : "";
          const newOption = {
            value,
            currentLabel: label
          };
          return newOption;
        };
        const updateHoveringIndex = () => {
          states.hoveringIndex = optionsArray.value.findIndex((item) => states.selected.some((selected) => getValueKey(selected) === getValueKey(item)));
        };
        const resetSelectionWidth = () => {
          states.selectionWidth = Number.parseFloat(window.getComputedStyle(selectionRef.value).width);
        };
        const resetCollapseItemWidth = () => {
          states.collapseItemWidth = collapseItemRef.value.getBoundingClientRect().width;
        };
        const updateTooltip = () => {
          var _a, _b;
          (_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
        };
        const updateTagTooltip = () => {
          var _a, _b;
          (_b = (_a = tagTooltipRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
        };
        const onInputChange = () => {
          if (states.inputValue.length > 0 && !expanded.value) {
            expanded.value = true;
          }
          handleQueryChange(states.inputValue);
        };
        const onInput = (event) => {
          states.inputValue = event.target.value;
          if (props2.remote) {
            debouncedOnInputChange();
          } else {
            return onInputChange();
          }
        };
        const debouncedOnInputChange = debounce(() => {
          onInputChange();
        }, debounce$1.value);
        const emitChange = (val) => {
          if (!isEqual$1(props2.modelValue, val)) {
            emit(CHANGE_EVENT, val);
          }
        };
        const getLastNotDisabledIndex = (value) => findLastIndex(value, (it2) => {
          const option = states.cachedOptions.get(it2);
          return option && !option.disabled && !option.states.groupDisabled;
        });
        const deletePrevTag = (e) => {
          if (!props2.multiple)
            return;
          if (e.code === EVENT_CODE.delete)
            return;
          if (e.target.value.length <= 0) {
            const value = castArray$1(props2.modelValue).slice();
            const lastNotDisabledIndex = getLastNotDisabledIndex(value);
            if (lastNotDisabledIndex < 0)
              return;
            const removeTagValue = value[lastNotDisabledIndex];
            value.splice(lastNotDisabledIndex, 1);
            emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            emit("remove-tag", removeTagValue);
          }
        };
        const deleteTag = (event, tag) => {
          const index2 = states.selected.indexOf(tag);
          if (index2 > -1 && !selectDisabled.value) {
            const value = castArray$1(props2.modelValue).slice();
            value.splice(index2, 1);
            emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            emit("remove-tag", tag.value);
          }
          event.stopPropagation();
          focus();
        };
        const deleteSelected = (event) => {
          event.stopPropagation();
          const value = props2.multiple ? [] : valueOnClear.value;
          if (props2.multiple) {
            for (const item of states.selected) {
              if (item.isDisabled)
                value.push(item.value);
            }
          }
          emit(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          states.hoveringIndex = -1;
          expanded.value = false;
          emit("clear");
          focus();
        };
        const handleOptionSelect = (option) => {
          var _a;
          if (props2.multiple) {
            const value = castArray$1((_a = props2.modelValue) != null ? _a : []).slice();
            const optionIndex = getValueIndex(value, option);
            if (optionIndex > -1) {
              value.splice(optionIndex, 1);
            } else if (props2.multipleLimit <= 0 || value.length < props2.multipleLimit) {
              value.push(option.value);
            }
            emit(UPDATE_MODEL_EVENT, value);
            emitChange(value);
            if (option.created) {
              handleQueryChange("");
            }
            if (props2.filterable && !props2.reserveKeyword) {
              states.inputValue = "";
            }
          } else {
            emit(UPDATE_MODEL_EVENT, option.value);
            emitChange(option.value);
            expanded.value = false;
          }
          focus();
          if (expanded.value)
            return;
          nextTick(() => {
            scrollToOption(option);
          });
        };
        const getValueIndex = (arr, option) => {
          if (isUndefined(option))
            return -1;
          if (!isObject$1(option.value))
            return arr.indexOf(option.value);
          return arr.findIndex((item) => {
            return isEqual$1(get(item, props2.valueKey), getValueKey(option));
          });
        };
        const scrollToOption = (option) => {
          var _a, _b, _c, _d, _e;
          const targetOption = isArray$1(option) ? option[0] : option;
          let target2 = null;
          if (targetOption == null ? void 0 : targetOption.value) {
            const options = optionsArray.value.filter((item) => item.value === targetOption.value);
            if (options.length > 0) {
              target2 = options[0].$el;
            }
          }
          if (tooltipRef.value && target2) {
            const menu = (_d = (_c = (_b = (_a = tooltipRef.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, `.${nsSelect.be("dropdown", "wrap")}`);
            if (menu) {
              scrollIntoView(menu, target2);
            }
          }
          (_e = scrollbarRef.value) == null ? void 0 : _e.handleScroll();
        };
        const onOptionCreate = (vm) => {
          states.options.set(vm.value, vm);
          states.cachedOptions.set(vm.value, vm);
        };
        const onOptionDestroy = (key, vm) => {
          if (states.options.get(key) === vm) {
            states.options.delete(key);
          }
        };
        const popperRef = computed(() => {
          var _a, _b;
          return (_b = (_a = tooltipRef.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
        });
        const handleMenuEnter = () => {
          states.isBeforeHide = false;
          nextTick(() => {
            var _a;
            (_a = scrollbarRef.value) == null ? void 0 : _a.update();
            scrollToOption(states.selected);
          });
        };
        const focus = () => {
          var _a;
          (_a = inputRef.value) == null ? void 0 : _a.focus();
        };
        const blur = () => {
          var _a;
          if (expanded.value) {
            expanded.value = false;
            nextTick(() => {
              var _a2;
              return (_a2 = inputRef.value) == null ? void 0 : _a2.blur();
            });
            return;
          }
          (_a = inputRef.value) == null ? void 0 : _a.blur();
        };
        const handleClearClick = (event) => {
          deleteSelected(event);
        };
        const handleClickOutside = (event) => {
          expanded.value = false;
          if (isFocused.value) {
            const _event2 = new FocusEvent("blur", event);
            nextTick(() => handleBlur(_event2));
          }
        };
        const handleEsc = () => {
          if (states.inputValue.length > 0) {
            states.inputValue = "";
          } else {
            expanded.value = false;
          }
        };
        const toggleMenu = () => {
          if (selectDisabled.value)
            return;
          if (isIOS)
            states.inputHovering = true;
          if (states.menuVisibleOnFocus) {
            states.menuVisibleOnFocus = false;
          } else {
            expanded.value = !expanded.value;
          }
        };
        const selectOption = () => {
          if (!expanded.value) {
            toggleMenu();
          } else {
            const option = optionsArray.value[states.hoveringIndex];
            if (option && !option.isDisabled) {
              handleOptionSelect(option);
            }
          }
        };
        const getValueKey = (item) => {
          return isObject$1(item.value) ? get(item.value, props2.valueKey) : item.value;
        };
        const optionsAllDisabled = computed(() => optionsArray.value.filter((option) => option.visible).every((option) => option.isDisabled));
        const showTagList = computed(() => {
          if (!props2.multiple) {
            return [];
          }
          return props2.collapseTags ? states.selected.slice(0, props2.maxCollapseTags) : states.selected;
        });
        const collapseTagList = computed(() => {
          if (!props2.multiple) {
            return [];
          }
          return props2.collapseTags ? states.selected.slice(props2.maxCollapseTags) : [];
        });
        const navigateOptions = (direction2) => {
          if (!expanded.value) {
            expanded.value = true;
            return;
          }
          if (states.options.size === 0 || filteredOptionsCount.value === 0 || isComposing.value)
            return;
          if (!optionsAllDisabled.value) {
            if (direction2 === "next") {
              states.hoveringIndex++;
              if (states.hoveringIndex === states.options.size) {
                states.hoveringIndex = 0;
              }
            } else if (direction2 === "prev") {
              states.hoveringIndex--;
              if (states.hoveringIndex < 0) {
                states.hoveringIndex = states.options.size - 1;
              }
            }
            const option = optionsArray.value[states.hoveringIndex];
            if (option.isDisabled || !option.visible) {
              navigateOptions(direction2);
            }
            nextTick(() => scrollToOption(hoverOption.value));
          }
        };
        const getGapWidth = () => {
          if (!selectionRef.value)
            return 0;
          const style = window.getComputedStyle(selectionRef.value);
          return Number.parseFloat(style.gap || "6px");
        };
        const tagStyle = computed(() => {
          const gapWidth = getGapWidth();
          const maxWidth = collapseItemRef.value && props2.maxCollapseTags === 1 ? states.selectionWidth - states.collapseItemWidth - gapWidth : states.selectionWidth;
          return { maxWidth: `${maxWidth}px` };
        });
        const collapseTagStyle = computed(() => {
          return { maxWidth: `${states.selectionWidth}px` };
        });
        const popupScroll = (data) => {
          emit("popup-scroll", data);
        };
        useResizeObserver(selectionRef, resetSelectionWidth);
        useResizeObserver(wrapperRef, updateTooltip);
        useResizeObserver(tagMenuRef, updateTagTooltip);
        useResizeObserver(collapseItemRef, resetCollapseItemWidth);
        let stop;
        watch(() => dropdownMenuVisible.value, (newVal) => {
          if (newVal) {
            stop = useResizeObserver(menuRef, updateTooltip).stop;
          } else {
            stop == null ? void 0 : stop();
            stop = void 0;
          }
        });
        onMounted(() => {
          setSelected();
        });
        return {
          inputId,
          contentId,
          nsSelect,
          nsInput,
          states,
          isFocused,
          expanded,
          optionsArray,
          hoverOption,
          selectSize,
          filteredOptionsCount,
          updateTooltip,
          updateTagTooltip,
          debouncedOnInputChange,
          onInput,
          deletePrevTag,
          deleteTag,
          deleteSelected,
          handleOptionSelect,
          scrollToOption,
          hasModelValue,
          shouldShowPlaceholder,
          currentPlaceholder,
          mouseEnterEventName,
          needStatusIcon,
          showClose,
          iconComponent,
          iconReverse,
          validateState,
          validateIcon,
          showNewOption,
          updateOptions: updateOptions2,
          collapseTagSize,
          setSelected,
          selectDisabled,
          emptyText,
          handleCompositionStart,
          handleCompositionUpdate,
          handleCompositionEnd,
          onOptionCreate,
          onOptionDestroy,
          handleMenuEnter,
          focus,
          blur,
          handleClearClick,
          handleClickOutside,
          handleEsc,
          toggleMenu,
          selectOption,
          getValueKey,
          navigateOptions,
          dropdownMenuVisible,
          showTagList,
          collapseTagList,
          popupScroll,
          tagStyle,
          collapseTagStyle,
          popperRef,
          inputRef,
          tooltipRef,
          tagTooltipRef,
          prefixRef,
          suffixRef,
          selectRef,
          wrapperRef,
          selectionRef,
          scrollbarRef,
          menuRef,
          tagMenuRef,
          collapseItemRef
        };
      };
      var ElOptions = defineComponent({
        name: "ElOptions",
        setup(_2, { slots }) {
          const select = inject(selectKey);
          let cachedValueList = [];
          return () => {
            var _a, _b;
            const children = (_a = slots.default) == null ? void 0 : _a.call(slots);
            const valueList = [];
            function filterOptions(children2) {
              if (!isArray$1(children2))
                return;
              children2.forEach((item) => {
                var _a2, _b2, _c, _d;
                const name = (_a2 = (item == null ? void 0 : item.type) || {}) == null ? void 0 : _a2.name;
                if (name === "ElOptionGroup") {
                  filterOptions(!isString$1(item.children) && !isArray$1(item.children) && isFunction$1((_b2 = item.children) == null ? void 0 : _b2.default) ? (_c = item.children) == null ? void 0 : _c.default() : item.children);
                } else if (name === "ElOption") {
                  valueList.push((_d = item.props) == null ? void 0 : _d.value);
                } else if (isArray$1(item.children)) {
                  filterOptions(item.children);
                }
              });
            }
            if (children.length) {
              filterOptions((_b = children[0]) == null ? void 0 : _b.children);
            }
            if (!isEqual$1(valueList, cachedValueList)) {
              cachedValueList = valueList;
              if (select) {
                select.states.optionValues = valueList;
              }
            }
            return children;
          };
        }
      });
      const selectProps = exports("selectProps", buildProps({
        name: String,
        id: String,
        modelValue: {
          type: definePropType([
            Array,
            String,
            Number,
            Boolean,
            Object
          ]),
          default: void 0
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        automaticDropdown: Boolean,
        size: useSizeProp,
        effect: {
          type: definePropType(String),
          default: "light"
        },
        disabled: Boolean,
        clearable: Boolean,
        filterable: Boolean,
        allowCreate: Boolean,
        loading: Boolean,
        popperClass: {
          type: String,
          default: ""
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        remote: Boolean,
        loadingText: String,
        noMatchText: String,
        noDataText: String,
        remoteMethod: {
          type: definePropType(Function)
        },
        filterMethod: {
          type: definePropType(Function)
        },
        multiple: Boolean,
        multipleLimit: {
          type: Number,
          default: 0
        },
        placeholder: {
          type: String
        },
        defaultFirstOption: Boolean,
        reserveKeyword: {
          type: Boolean,
          default: true
        },
        valueKey: {
          type: String,
          default: "value"
        },
        collapseTags: Boolean,
        collapseTagsTooltip: Boolean,
        maxCollapseTags: {
          type: Number,
          default: 1
        },
        teleported: useTooltipContentProps.teleported,
        persistent: {
          type: Boolean,
          default: true
        },
        clearIcon: {
          type: iconPropType,
          default: circle_close_default$1
        },
        fitInputWidth: Boolean,
        suffixIcon: {
          type: iconPropType,
          default: arrow_down_default$1
        },
        tagType: { ...tagProps.type, default: "info" },
        tagEffect: { ...tagProps.effect, default: "light" },
        validateEvent: {
          type: Boolean,
          default: true
        },
        remoteShowSuffix: Boolean,
        showArrow: {
          type: Boolean,
          default: true
        },
        offset: {
          type: Number,
          default: 12
        },
        placement: {
          type: definePropType(String),
          values: Ee,
          default: "bottom-start"
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: ["bottom-start", "top-start", "right", "left"]
        },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        appendTo: useTooltipContentProps.appendTo,
        options: {
          type: definePropType(Array)
        },
        props: {
          type: definePropType(Object)
        },
        ...useEmptyValuesProps,
        ...useAriaProps(["ariaLabel"])
      }));
      const selectEmits = exports("selectEmits", {
        [UPDATE_MODEL_EVENT]: (val) => true,
        [CHANGE_EVENT]: (val) => true,
        "popup-scroll": scrollbarEmits.scroll,
        "remove-tag": (val) => true,
        "visible-change": (visible) => true,
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent,
        clear: () => true
      });
      const COMPONENT_NAME$a = "ElSelect";
      const _sfc_main$10 = defineComponent({
        name: COMPONENT_NAME$a,
        componentName: COMPONENT_NAME$a,
        components: {
          ElSelectMenu: ElSelectMenu$1,
          ElOption: Option,
          ElOptions,
          ElTag,
          ElScrollbar,
          ElTooltip,
          ElIcon
        },
        directives: { ClickOutside },
        props: selectProps,
        emits: [
          UPDATE_MODEL_EVENT,
          CHANGE_EVENT,
          "remove-tag",
          "clear",
          "visible-change",
          "focus",
          "blur",
          "popup-scroll"
        ],
        setup(props2, { emit, slots }) {
          const instance = getCurrentInstance();
          instance.appContext.config.warnHandler = (...args) => {
            if (!args[0] || args[0].includes('Slot "default" invoked outside of the render function')) {
              return;
            }
            console.warn(...args);
          };
          const modelValue = computed(() => {
            const { modelValue: rawModelValue, multiple } = props2;
            const fallback = multiple ? [] : void 0;
            if (isArray$1(rawModelValue)) {
              return multiple ? rawModelValue : fallback;
            }
            return multiple ? fallback : rawModelValue;
          });
          const _props = reactive({
            ...toRefs(props2),
            modelValue
          });
          const API = useSelect$3(_props, emit);
          const { calculatorRef, inputStyle } = useCalcInputWidth();
          const flatTreeSelectData = (data) => {
            return data.reduce((acc, item) => {
              acc.push(item);
              if (item.children && item.children.length > 0) {
                acc.push(...flatTreeSelectData(item.children));
              }
              return acc;
            }, []);
          };
          const manuallyRenderSlots = (vnodes) => {
            const children = flattedChildren(vnodes || []);
            children.forEach((item) => {
              var _a;
              if (isObject$1(item) && (item.type.name === "ElOption" || item.type.name === "ElTree")) {
                const _name = item.type.name;
                if (_name === "ElTree") {
                  const treeData = ((_a = item.props) == null ? void 0 : _a.data) || [];
                  const flatData = flatTreeSelectData(treeData);
                  flatData.forEach((treeItem) => {
                    treeItem.currentLabel = treeItem.label || (isObject$1(treeItem.value) ? "" : treeItem.value);
                    API.onOptionCreate(treeItem);
                  });
                } else if (_name === "ElOption") {
                  const obj = { ...item.props };
                  obj.currentLabel = obj.label || (isObject$1(obj.value) ? "" : obj.value);
                  API.onOptionCreate(obj);
                }
              }
            });
          };
          watch(() => {
            var _a;
            const slotsContent = (_a = slots.default) == null ? void 0 : _a.call(slots);
            return slotsContent;
          }, (newSlot) => {
            if (props2.persistent) {
              return;
            }
            manuallyRenderSlots(newSlot);
          }, {
            immediate: true
          });
          provide(selectKey, reactive({
            props: _props,
            states: API.states,
            selectRef: API.selectRef,
            optionsArray: API.optionsArray,
            setSelected: API.setSelected,
            handleOptionSelect: API.handleOptionSelect,
            onOptionCreate: API.onOptionCreate,
            onOptionDestroy: API.onOptionDestroy
          }));
          const selectedLabel = computed(() => {
            if (!props2.multiple) {
              return API.states.selectedLabel;
            }
            return API.states.selected.map((i) => i.currentLabel);
          });
          onBeforeUnmount(() => {
            instance.appContext.config.warnHandler = void 0;
          });
          return {
            ...API,
            modelValue,
            selectedLabel,
            calculatorRef,
            inputStyle
          };
        }
      });
      function _sfc_render$9(_ctx, _cache) {
        const _component_el_tag = resolveComponent("el-tag");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_option = resolveComponent("el-option");
        const _component_el_options = resolveComponent("el-options");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _component_el_select_menu = resolveComponent("el-select-menu");
        const _directive_click_outside = resolveDirective("click-outside");
        return withDirectives((openBlock(), createElementBlock("div", {
          ref: "selectRef",
          class: normalizeClass([_ctx.nsSelect.b(), _ctx.nsSelect.m(_ctx.selectSize)]),
          [toHandlerKey(_ctx.mouseEnterEventName)]: ($event) => _ctx.states.inputHovering = true,
          onMouseleave: ($event) => _ctx.states.inputHovering = false
        }, [
          createVNode(_component_el_tooltip, {
            ref: "tooltipRef",
            visible: _ctx.dropdownMenuVisible,
            placement: _ctx.placement,
            teleported: _ctx.teleported,
            "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
            "popper-options": _ctx.popperOptions,
            "fallback-placements": _ctx.fallbackPlacements,
            effect: _ctx.effect,
            pure: "",
            trigger: "click",
            transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
            "stop-popper-mouse-event": false,
            "gpu-acceleration": false,
            persistent: _ctx.persistent,
            "append-to": _ctx.appendTo,
            "show-arrow": _ctx.showArrow,
            offset: _ctx.offset,
            onBeforeShow: _ctx.handleMenuEnter,
            onHide: ($event) => _ctx.states.isBeforeHide = false
          }, {
            default: withCtx(() => {
              var _a;
              return [
                createElementVNode("div", {
                  ref: "wrapperRef",
                  class: normalizeClass([
                    _ctx.nsSelect.e("wrapper"),
                    _ctx.nsSelect.is("focused", _ctx.isFocused),
                    _ctx.nsSelect.is("hovering", _ctx.states.inputHovering),
                    _ctx.nsSelect.is("filterable", _ctx.filterable),
                    _ctx.nsSelect.is("disabled", _ctx.selectDisabled)
                  ]),
                  onClick: withModifiers(_ctx.toggleMenu, ["prevent"])
                }, [
                  _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    ref: "prefixRef",
                    class: normalizeClass(_ctx.nsSelect.e("prefix"))
                  }, [
                    renderSlot(_ctx.$slots, "prefix")
                  ], 2)) : createCommentVNode("v-if", true),
                  createElementVNode("div", {
                    ref: "selectionRef",
                    class: normalizeClass([
                      _ctx.nsSelect.e("selection"),
                      _ctx.nsSelect.is("near", _ctx.multiple && !_ctx.$slots.prefix && !!_ctx.states.selected.length)
                    ])
                  }, [
                    _ctx.multiple ? renderSlot(_ctx.$slots, "tag", {
                      key: 0,
                      data: _ctx.states.selected,
                      deleteTag: _ctx.deleteTag,
                      selectDisabled: _ctx.selectDisabled
                    }, () => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.showTagList, (item) => {
                        return openBlock(), createElementBlock("div", {
                          key: _ctx.getValueKey(item),
                          class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                        }, [
                          createVNode(_component_el_tag, {
                            closable: !_ctx.selectDisabled && !item.isDisabled,
                            size: _ctx.collapseTagSize,
                            type: _ctx.tagType,
                            effect: _ctx.tagEffect,
                            "disable-transitions": "",
                            style: normalizeStyle(_ctx.tagStyle),
                            onClose: ($event) => _ctx.deleteTag($event, item)
                          }, {
                            default: withCtx(() => [
                              createElementVNode("span", {
                                class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                              }, [
                                renderSlot(_ctx.$slots, "label", {
                                  label: item.currentLabel,
                                  value: item.value
                                }, () => [
                                  createTextVNode(toDisplayString(item.currentLabel), 1)
                                ])
                              ], 2)
                            ]),
                            _: 2
                          }, 1032, ["closable", "size", "type", "effect", "style", "onClose"])
                        ], 2);
                      }), 128)),
                      _ctx.collapseTags && _ctx.states.selected.length > _ctx.maxCollapseTags ? (openBlock(), createBlock(_component_el_tooltip, {
                        key: 0,
                        ref: "tagTooltipRef",
                        disabled: _ctx.dropdownMenuVisible || !_ctx.collapseTagsTooltip,
                        "fallback-placements": ["bottom", "top", "right", "left"],
                        effect: _ctx.effect,
                        placement: "bottom",
                        "popper-class": _ctx.popperClass,
                        teleported: _ctx.teleported
                      }, {
                        default: withCtx(() => [
                          createElementVNode("div", {
                            ref: "collapseItemRef",
                            class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                          }, [
                            createVNode(_component_el_tag, {
                              closable: false,
                              size: _ctx.collapseTagSize,
                              type: _ctx.tagType,
                              effect: _ctx.tagEffect,
                              "disable-transitions": "",
                              style: normalizeStyle(_ctx.collapseTagStyle)
                            }, {
                              default: withCtx(() => [
                                createElementVNode("span", {
                                  class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                                }, " + " + toDisplayString(_ctx.states.selected.length - _ctx.maxCollapseTags), 3)
                              ]),
                              _: 1
                            }, 8, ["size", "type", "effect", "style"])
                          ], 2)
                        ]),
                        content: withCtx(() => [
                          createElementVNode("div", {
                            ref: "tagMenuRef",
                            class: normalizeClass(_ctx.nsSelect.e("selection"))
                          }, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.collapseTagList, (item) => {
                              return openBlock(), createElementBlock("div", {
                                key: _ctx.getValueKey(item),
                                class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                              }, [
                                createVNode(_component_el_tag, {
                                  class: "in-tooltip",
                                  closable: !_ctx.selectDisabled && !item.isDisabled,
                                  size: _ctx.collapseTagSize,
                                  type: _ctx.tagType,
                                  effect: _ctx.tagEffect,
                                  "disable-transitions": "",
                                  onClose: ($event) => _ctx.deleteTag($event, item)
                                }, {
                                  default: withCtx(() => [
                                    createElementVNode("span", {
                                      class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                                    }, [
                                      renderSlot(_ctx.$slots, "label", {
                                        label: item.currentLabel,
                                        value: item.value
                                      }, () => [
                                        createTextVNode(toDisplayString(item.currentLabel), 1)
                                      ])
                                    ], 2)
                                  ]),
                                  _: 2
                                }, 1032, ["closable", "size", "type", "effect", "onClose"])
                              ], 2);
                            }), 128))
                          ], 2)
                        ]),
                        _: 3
                      }, 8, ["disabled", "effect", "popper-class", "teleported"])) : createCommentVNode("v-if", true)
                    ]) : createCommentVNode("v-if", true),
                    createElementVNode("div", {
                      class: normalizeClass([
                        _ctx.nsSelect.e("selected-item"),
                        _ctx.nsSelect.e("input-wrapper"),
                        _ctx.nsSelect.is("hidden", !_ctx.filterable)
                      ])
                    }, [
                      withDirectives(createElementVNode("input", {
                        id: _ctx.inputId,
                        ref: "inputRef",
                        "onUpdate:modelValue": ($event) => _ctx.states.inputValue = $event,
                        type: "text",
                        name: _ctx.name,
                        class: normalizeClass([_ctx.nsSelect.e("input"), _ctx.nsSelect.is(_ctx.selectSize)]),
                        disabled: _ctx.selectDisabled,
                        autocomplete: _ctx.autocomplete,
                        style: normalizeStyle(_ctx.inputStyle),
                        tabindex: _ctx.tabindex,
                        role: "combobox",
                        readonly: !_ctx.filterable,
                        spellcheck: "false",
                        "aria-activedescendant": ((_a = _ctx.hoverOption) == null ? void 0 : _a.id) || "",
                        "aria-controls": _ctx.contentId,
                        "aria-expanded": _ctx.dropdownMenuVisible,
                        "aria-label": _ctx.ariaLabel,
                        "aria-autocomplete": "none",
                        "aria-haspopup": "listbox",
                        onKeydown: [
                          withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"]),
                          withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"]),
                          withKeys(withModifiers(_ctx.handleEsc, ["stop", "prevent"]), ["esc"]),
                          withKeys(withModifiers(_ctx.selectOption, ["stop", "prevent"]), ["enter"]),
                          withKeys(withModifiers(_ctx.deletePrevTag, ["stop"]), ["delete"])
                        ],
                        onCompositionstart: _ctx.handleCompositionStart,
                        onCompositionupdate: _ctx.handleCompositionUpdate,
                        onCompositionend: _ctx.handleCompositionEnd,
                        onInput: _ctx.onInput,
                        onClick: withModifiers(_ctx.toggleMenu, ["stop"])
                      }, null, 46, ["id", "onUpdate:modelValue", "name", "disabled", "autocomplete", "tabindex", "readonly", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label", "onKeydown", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onInput", "onClick"]), [
                        [vModelText, _ctx.states.inputValue]
                      ]),
                      _ctx.filterable ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        ref: "calculatorRef",
                        "aria-hidden": "true",
                        class: normalizeClass(_ctx.nsSelect.e("input-calculator")),
                        textContent: toDisplayString(_ctx.states.inputValue)
                      }, null, 10, ["textContent"])) : createCommentVNode("v-if", true)
                    ], 2),
                    _ctx.shouldShowPlaceholder ? (openBlock(), createElementBlock("div", {
                      key: 1,
                      class: normalizeClass([
                        _ctx.nsSelect.e("selected-item"),
                        _ctx.nsSelect.e("placeholder"),
                        _ctx.nsSelect.is("transparent", !_ctx.hasModelValue || _ctx.expanded && !_ctx.states.inputValue)
                      ])
                    }, [
                      _ctx.hasModelValue ? renderSlot(_ctx.$slots, "label", {
                        key: 0,
                        label: _ctx.currentPlaceholder,
                        value: _ctx.modelValue
                      }, () => [
                        createElementVNode("span", null, toDisplayString(_ctx.currentPlaceholder), 1)
                      ]) : (openBlock(), createElementBlock("span", { key: 1 }, toDisplayString(_ctx.currentPlaceholder), 1))
                    ], 2)) : createCommentVNode("v-if", true)
                  ], 2),
                  createElementVNode("div", {
                    ref: "suffixRef",
                    class: normalizeClass(_ctx.nsSelect.e("suffix"))
                  }, [
                    _ctx.iconComponent && !_ctx.showClose ? (openBlock(), createBlock(_component_el_icon, {
                      key: 0,
                      class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon"), _ctx.iconReverse])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true),
                    _ctx.showClose && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                      key: 1,
                      class: normalizeClass([
                        _ctx.nsSelect.e("caret"),
                        _ctx.nsSelect.e("icon"),
                        _ctx.nsSelect.e("clear")
                      ]),
                      onClick: _ctx.handleClearClick
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
                    _ctx.validateState && _ctx.validateIcon && _ctx.needStatusIcon ? (openBlock(), createBlock(_component_el_icon, {
                      key: 2,
                      class: normalizeClass([
                        _ctx.nsInput.e("icon"),
                        _ctx.nsInput.e("validateIcon"),
                        _ctx.nsInput.is("loading", _ctx.validateState === "validating")
                      ])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.validateIcon)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 10, ["onClick"])
              ];
            }),
            content: withCtx(() => [
              createVNode(_component_el_select_menu, { ref: "menuRef" }, {
                default: withCtx(() => [
                  _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(_ctx.nsSelect.be("dropdown", "header")),
                    onClick: withModifiers(() => {
                    }, ["stop"])
                  }, [
                    renderSlot(_ctx.$slots, "header")
                  ], 10, ["onClick"])) : createCommentVNode("v-if", true),
                  withDirectives(createVNode(_component_el_scrollbar, {
                    id: _ctx.contentId,
                    ref: "scrollbarRef",
                    tag: "ul",
                    "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
                    "view-class": _ctx.nsSelect.be("dropdown", "list"),
                    class: normalizeClass([_ctx.nsSelect.is("empty", _ctx.filteredOptionsCount === 0)]),
                    role: "listbox",
                    "aria-label": _ctx.ariaLabel,
                    "aria-orientation": "vertical",
                    onScroll: _ctx.popupScroll
                  }, {
                    default: withCtx(() => [
                      _ctx.showNewOption ? (openBlock(), createBlock(_component_el_option, {
                        key: 0,
                        value: _ctx.states.inputValue,
                        created: true
                      }, null, 8, ["value"])) : createCommentVNode("v-if", true),
                      createVNode(_component_el_options, null, {
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "default", {}, () => [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (item, index2) => {
                              var _a, _b, _c, _d, _e, _f;
                              return openBlock(), createBlock(_component_el_option, {
                                key: index2,
                                label: item[(_b = (_a = _ctx.props) == null ? void 0 : _a.label) != null ? _b : "label"],
                                value: item[(_d = (_c = _ctx.props) == null ? void 0 : _c.value) != null ? _d : "value"],
                                disabled: item[(_f = (_e = _ctx.props) == null ? void 0 : _e.disabled) != null ? _f : "disabled"]
                              }, null, 8, ["label", "value", "disabled"]);
                            }), 128))
                          ])
                        ]),
                        _: 3
                      })
                    ]),
                    _: 3
                  }, 8, ["id", "wrap-class", "view-class", "class", "aria-label", "onScroll"]), [
                    [vShow, _ctx.states.options.size > 0 && !_ctx.loading]
                  ]),
                  _ctx.$slots.loading && _ctx.loading ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass(_ctx.nsSelect.be("dropdown", "loading"))
                  }, [
                    renderSlot(_ctx.$slots, "loading")
                  ], 2)) : _ctx.loading || _ctx.filteredOptionsCount === 0 ? (openBlock(), createElementBlock("div", {
                    key: 2,
                    class: normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
                  }, [
                    renderSlot(_ctx.$slots, "empty", {}, () => [
                      createElementVNode("span", null, toDisplayString(_ctx.emptyText), 1)
                    ])
                  ], 2)) : createCommentVNode("v-if", true),
                  _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
                    key: 3,
                    class: normalizeClass(_ctx.nsSelect.be("dropdown", "footer")),
                    onClick: withModifiers(() => {
                    }, ["stop"])
                  }, [
                    renderSlot(_ctx.$slots, "footer")
                  ], 10, ["onClick"])) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 512)
            ]),
            _: 3
          }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "fallback-placements", "effect", "transition", "persistent", "append-to", "show-arrow", "offset", "onBeforeShow", "onHide"])
        ], 16, ["onMouseleave"])), [
          [_directive_click_outside, _ctx.handleClickOutside, _ctx.popperRef]
        ]);
      }
      var Select$1 = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["render", _sfc_render$9], ["__file", "select.vue"]]);
      const _sfc_main$$ = defineComponent({
        name: "ElOptionGroup",
        componentName: "ElOptionGroup",
        props: {
          label: String,
          disabled: Boolean
        },
        setup(props2) {
          const ns = useNamespace("select");
          const groupRef = ref();
          const instance = getCurrentInstance();
          const children = ref([]);
          provide(selectGroupKey, reactive({
            ...toRefs(props2)
          }));
          const visible = computed(() => children.value.some((option) => option.visible === true));
          const isOption = (node) => {
            var _a;
            return node.type.name === "ElOption" && !!((_a = node.component) == null ? void 0 : _a.proxy);
          };
          const flattedChildren2 = (node) => {
            const nodes = castArray$1(node);
            const children2 = [];
            nodes.forEach((child) => {
              var _a;
              if (!isVNode(child))
                return;
              if (isOption(child)) {
                children2.push(child.component.proxy);
              } else if (isArray$1(child.children) && child.children.length) {
                children2.push(...flattedChildren2(child.children));
              } else if ((_a = child.component) == null ? void 0 : _a.subTree) {
                children2.push(...flattedChildren2(child.component.subTree));
              }
            });
            return children2;
          };
          const updateChildren = () => {
            children.value = flattedChildren2(instance.subTree);
          };
          onMounted(() => {
            updateChildren();
          });
          useMutationObserver(groupRef, updateChildren, {
            attributes: true,
            subtree: true,
            childList: true
          });
          return {
            groupRef,
            visible,
            ns
          };
        }
      });
      function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
        return withDirectives((openBlock(), createElementBlock("ul", {
          ref: "groupRef",
          class: normalizeClass(_ctx.ns.be("group", "wrap"))
        }, [
          createElementVNode("li", {
            class: normalizeClass(_ctx.ns.be("group", "title"))
          }, toDisplayString(_ctx.label), 3),
          createElementVNode("li", null, [
            createElementVNode("ul", {
              class: normalizeClass(_ctx.ns.b("group"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2)
          ])
        ], 2)), [
          [vShow, _ctx.visible]
        ]);
      }
      var OptionGroup = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["render", _sfc_render$8], ["__file", "option-group.vue"]]);
      const ElSelect = exports("ElSelect", withInstall(Select$1, {
        Option,
        OptionGroup
      }));
      const ElOption = exports("ElOption", withNoopInstall(Option));
      const ElOptionGroup = exports("ElOptionGroup", withNoopInstall(OptionGroup));
      const usePagination = () => inject(elPaginationKey, {});
      const paginationSizesProps = buildProps({
        pageSize: {
          type: Number,
          required: true
        },
        pageSizes: {
          type: definePropType(Array),
          default: () => mutable([10, 20, 30, 40, 50, 100])
        },
        popperClass: {
          type: String
        },
        disabled: Boolean,
        teleported: Boolean,
        size: {
          type: String,
          values: componentSizes
        },
        appendSizeTo: String
      });
      const __default__$Q = defineComponent({
        name: "ElPaginationSizes"
      });
      const _sfc_main$_ = /* @__PURE__ */ defineComponent({
        ...__default__$Q,
        props: paginationSizesProps,
        emits: ["page-size-change"],
        setup(__props, { emit }) {
          const props2 = __props;
          const { t } = useLocale();
          const ns = useNamespace("pagination");
          const pagination = usePagination();
          const innerPageSize = ref(props2.pageSize);
          watch(() => props2.pageSizes, (newVal, oldVal) => {
            if (isEqual$1(newVal, oldVal))
              return;
            if (isArray$1(newVal)) {
              const pageSize = newVal.includes(props2.pageSize) ? props2.pageSize : props2.pageSizes[0];
              emit("page-size-change", pageSize);
            }
          });
          watch(() => props2.pageSize, (newVal) => {
            innerPageSize.value = newVal;
          });
          const innerPageSizes = computed(() => props2.pageSizes);
          function handleChange(val) {
            var _a;
            if (val !== innerPageSize.value) {
              innerPageSize.value = val;
              (_a = pagination.handleSizeChange) == null ? void 0 : _a.call(pagination, Number(val));
            }
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              class: normalizeClass(unref(ns).e("sizes"))
            }, [
              createVNode(unref(ElSelect), {
                "model-value": innerPageSize.value,
                disabled: _ctx.disabled,
                "popper-class": _ctx.popperClass,
                size: _ctx.size,
                teleported: _ctx.teleported,
                "validate-event": false,
                "append-to": _ctx.appendSizeTo,
                onChange: handleChange
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(innerPageSizes), (item) => {
                    return openBlock(), createBlock(unref(ElOption), {
                      key: item,
                      value: item,
                      label: item + unref(t)("el.pagination.pagesize")
                    }, null, 8, ["value", "label"]);
                  }), 128))
                ]),
                _: 1
              }, 8, ["model-value", "disabled", "popper-class", "size", "teleported", "append-to"])
            ], 2);
          };
        }
      });
      var Sizes = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["__file", "sizes.vue"]]);
      const paginationJumperProps = buildProps({
        size: {
          type: String,
          values: componentSizes
        }
      });
      const __default__$P = defineComponent({
        name: "ElPaginationJumper"
      });
      const _sfc_main$Z = /* @__PURE__ */ defineComponent({
        ...__default__$P,
        props: paginationJumperProps,
        setup(__props) {
          const { t } = useLocale();
          const ns = useNamespace("pagination");
          const { pageCount, disabled, currentPage, changeEvent } = usePagination();
          const userInput = ref();
          const innerValue = computed(() => {
            var _a;
            return (_a = userInput.value) != null ? _a : currentPage == null ? void 0 : currentPage.value;
          });
          function handleInput(val) {
            userInput.value = val ? +val : "";
          }
          function handleChange(val) {
            val = Math.trunc(+val);
            changeEvent == null ? void 0 : changeEvent(val);
            userInput.value = void 0;
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              class: normalizeClass(unref(ns).e("jump")),
              disabled: unref(disabled)
            }, [
              createElementVNode("span", {
                class: normalizeClass([unref(ns).e("goto")])
              }, toDisplayString(unref(t)("el.pagination.goto")), 3),
              createVNode(unref(ElInput), {
                size: _ctx.size,
                class: normalizeClass([unref(ns).e("editor"), unref(ns).is("in-pagination")]),
                min: 1,
                max: unref(pageCount),
                disabled: unref(disabled),
                "model-value": unref(innerValue),
                "validate-event": false,
                "aria-label": unref(t)("el.pagination.page"),
                type: "number",
                "onUpdate:modelValue": handleInput,
                onChange: handleChange
              }, null, 8, ["size", "class", "max", "disabled", "model-value", "aria-label"]),
              createElementVNode("span", {
                class: normalizeClass([unref(ns).e("classifier")])
              }, toDisplayString(unref(t)("el.pagination.pageClassifier")), 3)
            ], 10, ["disabled"]);
          };
        }
      });
      var Jumper = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["__file", "jumper.vue"]]);
      const paginationTotalProps = buildProps({
        total: {
          type: Number,
          default: 1e3
        }
      });
      const __default__$O = defineComponent({
        name: "ElPaginationTotal"
      });
      const _sfc_main$Y = /* @__PURE__ */ defineComponent({
        ...__default__$O,
        props: paginationTotalProps,
        setup(__props) {
          const { t } = useLocale();
          const ns = useNamespace("pagination");
          const { disabled } = usePagination();
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              class: normalizeClass(unref(ns).e("total")),
              disabled: unref(disabled)
            }, toDisplayString(unref(t)("el.pagination.total", {
              total: _ctx.total
            })), 11, ["disabled"]);
          };
        }
      });
      var Total = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["__file", "total.vue"]]);
      const paginationPagerProps = buildProps({
        currentPage: {
          type: Number,
          default: 1
        },
        pageCount: {
          type: Number,
          required: true
        },
        pagerCount: {
          type: Number,
          default: 7
        },
        disabled: Boolean
      });
      const __default__$N = defineComponent({
        name: "ElPaginationPager"
      });
      const _sfc_main$X = /* @__PURE__ */ defineComponent({
        ...__default__$N,
        props: paginationPagerProps,
        emits: [CHANGE_EVENT],
        setup(__props, { emit }) {
          const props2 = __props;
          const nsPager = useNamespace("pager");
          const nsIcon = useNamespace("icon");
          const { t } = useLocale();
          const showPrevMore = ref(false);
          const showNextMore = ref(false);
          const quickPrevHover = ref(false);
          const quickNextHover = ref(false);
          const quickPrevFocus = ref(false);
          const quickNextFocus = ref(false);
          const pagers = computed(() => {
            const pagerCount = props2.pagerCount;
            const halfPagerCount = (pagerCount - 1) / 2;
            const currentPage = Number(props2.currentPage);
            const pageCount = Number(props2.pageCount);
            let showPrevMore2 = false;
            let showNextMore2 = false;
            if (pageCount > pagerCount) {
              if (currentPage > pagerCount - halfPagerCount) {
                showPrevMore2 = true;
              }
              if (currentPage < pageCount - halfPagerCount) {
                showNextMore2 = true;
              }
            }
            const array3 = [];
            if (showPrevMore2 && !showNextMore2) {
              const startPage = pageCount - (pagerCount - 2);
              for (let i = startPage; i < pageCount; i++) {
                array3.push(i);
              }
            } else if (!showPrevMore2 && showNextMore2) {
              for (let i = 2; i < pagerCount; i++) {
                array3.push(i);
              }
            } else if (showPrevMore2 && showNextMore2) {
              const offset2 = Math.floor(pagerCount / 2) - 1;
              for (let i = currentPage - offset2; i <= currentPage + offset2; i++) {
                array3.push(i);
              }
            } else {
              for (let i = 2; i < pageCount; i++) {
                array3.push(i);
              }
            }
            return array3;
          });
          const prevMoreKls = computed(() => [
            "more",
            "btn-quickprev",
            nsIcon.b(),
            nsPager.is("disabled", props2.disabled)
          ]);
          const nextMoreKls = computed(() => [
            "more",
            "btn-quicknext",
            nsIcon.b(),
            nsPager.is("disabled", props2.disabled)
          ]);
          const tabindex = computed(() => props2.disabled ? -1 : 0);
          watch(() => [props2.pageCount, props2.pagerCount, props2.currentPage], ([pageCount, pagerCount, currentPage]) => {
            const halfPagerCount = (pagerCount - 1) / 2;
            let showPrev = false;
            let showNext = false;
            if (pageCount > pagerCount) {
              showPrev = currentPage > pagerCount - halfPagerCount;
              showNext = currentPage < pageCount - halfPagerCount;
            }
            quickPrevHover.value && (quickPrevHover.value = showPrev);
            quickNextHover.value && (quickNextHover.value = showNext);
            showPrevMore.value = showPrev;
            showNextMore.value = showNext;
          }, { immediate: true });
          function onMouseEnter(forward = false) {
            if (props2.disabled)
              return;
            if (forward) {
              quickPrevHover.value = true;
            } else {
              quickNextHover.value = true;
            }
          }
          function onFocus(forward = false) {
            if (forward) {
              quickPrevFocus.value = true;
            } else {
              quickNextFocus.value = true;
            }
          }
          function onEnter(e) {
            const target2 = e.target;
            if (target2.tagName.toLowerCase() === "li" && Array.from(target2.classList).includes("number")) {
              const newPage = Number(target2.textContent);
              if (newPage !== props2.currentPage) {
                emit(CHANGE_EVENT, newPage);
              }
            } else if (target2.tagName.toLowerCase() === "li" && Array.from(target2.classList).includes("more")) {
              onPagerClick(e);
            }
          }
          function onPagerClick(event) {
            const target2 = event.target;
            if (target2.tagName.toLowerCase() === "ul" || props2.disabled) {
              return;
            }
            let newPage = Number(target2.textContent);
            const pageCount = props2.pageCount;
            const currentPage = props2.currentPage;
            const pagerCountOffset = props2.pagerCount - 2;
            if (target2.className.includes("more")) {
              if (target2.className.includes("quickprev")) {
                newPage = currentPage - pagerCountOffset;
              } else if (target2.className.includes("quicknext")) {
                newPage = currentPage + pagerCountOffset;
              }
            }
            if (!Number.isNaN(+newPage)) {
              if (newPage < 1) {
                newPage = 1;
              }
              if (newPage > pageCount) {
                newPage = pageCount;
              }
            }
            if (newPage !== currentPage) {
              emit(CHANGE_EVENT, newPage);
            }
          }
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("ul", {
              class: normalizeClass(unref(nsPager).b()),
              onClick: onPagerClick,
              onKeyup: withKeys(onEnter, ["enter"])
            }, [
              _ctx.pageCount > 0 ? (openBlock(), createElementBlock("li", {
                key: 0,
                class: normalizeClass([[
                  unref(nsPager).is("active", _ctx.currentPage === 1),
                  unref(nsPager).is("disabled", _ctx.disabled)
                ], "number"]),
                "aria-current": _ctx.currentPage === 1,
                "aria-label": unref(t)("el.pagination.currentPage", { pager: 1 }),
                tabindex: unref(tabindex)
              }, " 1 ", 10, ["aria-current", "aria-label", "tabindex"])) : createCommentVNode("v-if", true),
              showPrevMore.value ? (openBlock(), createElementBlock("li", {
                key: 1,
                class: normalizeClass(unref(prevMoreKls)),
                tabindex: unref(tabindex),
                "aria-label": unref(t)("el.pagination.prevPages", { pager: _ctx.pagerCount - 2 }),
                onMouseenter: ($event) => onMouseEnter(true),
                onMouseleave: ($event) => quickPrevHover.value = false,
                onFocus: ($event) => onFocus(true),
                onBlur: ($event) => quickPrevFocus.value = false
              }, [
                (quickPrevHover.value || quickPrevFocus.value) && !_ctx.disabled ? (openBlock(), createBlock(unref(d_arrow_left_default$1), { key: 0 })) : (openBlock(), createBlock(unref(more_filled_default$1), { key: 1 }))
              ], 42, ["tabindex", "aria-label", "onMouseenter", "onMouseleave", "onFocus", "onBlur"])) : createCommentVNode("v-if", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(pagers), (pager) => {
                return openBlock(), createElementBlock("li", {
                  key: pager,
                  class: normalizeClass([[
                    unref(nsPager).is("active", _ctx.currentPage === pager),
                    unref(nsPager).is("disabled", _ctx.disabled)
                  ], "number"]),
                  "aria-current": _ctx.currentPage === pager,
                  "aria-label": unref(t)("el.pagination.currentPage", { pager }),
                  tabindex: unref(tabindex)
                }, toDisplayString(pager), 11, ["aria-current", "aria-label", "tabindex"]);
              }), 128)),
              showNextMore.value ? (openBlock(), createElementBlock("li", {
                key: 2,
                class: normalizeClass(unref(nextMoreKls)),
                tabindex: unref(tabindex),
                "aria-label": unref(t)("el.pagination.nextPages", { pager: _ctx.pagerCount - 2 }),
                onMouseenter: ($event) => onMouseEnter(),
                onMouseleave: ($event) => quickNextHover.value = false,
                onFocus: ($event) => onFocus(),
                onBlur: ($event) => quickNextFocus.value = false
              }, [
                (quickNextHover.value || quickNextFocus.value) && !_ctx.disabled ? (openBlock(), createBlock(unref(d_arrow_right_default$1), { key: 0 })) : (openBlock(), createBlock(unref(more_filled_default$1), { key: 1 }))
              ], 42, ["tabindex", "aria-label", "onMouseenter", "onMouseleave", "onFocus", "onBlur"])) : createCommentVNode("v-if", true),
              _ctx.pageCount > 1 ? (openBlock(), createElementBlock("li", {
                key: 3,
                class: normalizeClass([[
                  unref(nsPager).is("active", _ctx.currentPage === _ctx.pageCount),
                  unref(nsPager).is("disabled", _ctx.disabled)
                ], "number"]),
                "aria-current": _ctx.currentPage === _ctx.pageCount,
                "aria-label": unref(t)("el.pagination.currentPage", { pager: _ctx.pageCount }),
                tabindex: unref(tabindex)
              }, toDisplayString(_ctx.pageCount), 11, ["aria-current", "aria-label", "tabindex"])) : createCommentVNode("v-if", true)
            ], 42, ["onKeyup"]);
          };
        }
      });
      var Pager = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["__file", "pager.vue"]]);
      const isAbsent = (v2) => typeof v2 !== "number";
      const paginationProps = exports("paginationProps", buildProps({
        pageSize: Number,
        defaultPageSize: Number,
        total: Number,
        pageCount: Number,
        pagerCount: {
          type: Number,
          validator: (value) => {
            return isNumber(value) && Math.trunc(value) === value && value > 4 && value < 22 && value % 2 === 1;
          },
          default: 7
        },
        currentPage: Number,
        defaultCurrentPage: Number,
        layout: {
          type: String,
          default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
        },
        pageSizes: {
          type: definePropType(Array),
          default: () => mutable([10, 20, 30, 40, 50, 100])
        },
        popperClass: {
          type: String,
          default: ""
        },
        prevText: {
          type: String,
          default: ""
        },
        prevIcon: {
          type: iconPropType,
          default: () => arrow_left_default$1
        },
        nextText: {
          type: String,
          default: ""
        },
        nextIcon: {
          type: iconPropType,
          default: () => arrow_right_default$1
        },
        teleported: {
          type: Boolean,
          default: true
        },
        small: Boolean,
        size: useSizeProp,
        background: Boolean,
        disabled: Boolean,
        hideOnSinglePage: Boolean,
        appendSizeTo: String
      }));
      const paginationEmits = exports("paginationEmits", {
        "update:current-page": (val) => isNumber(val),
        "update:page-size": (val) => isNumber(val),
        "size-change": (val) => isNumber(val),
        change: (currentPage, pageSize) => isNumber(currentPage) && isNumber(pageSize),
        "current-change": (val) => isNumber(val),
        "prev-click": (val) => isNumber(val),
        "next-click": (val) => isNumber(val)
      });
      const componentName = "ElPagination";
      var Pagination = defineComponent({
        name: componentName,
        props: paginationProps,
        emits: paginationEmits,
        setup(props2, { emit, slots }) {
          const { t } = useLocale();
          const ns = useNamespace("pagination");
          const vnodeProps = getCurrentInstance().vnode.props || {};
          const _globalSize = useGlobalSize();
          const _size = computed(() => {
            var _a;
            return props2.small ? "small" : (_a = props2.size) != null ? _a : _globalSize.value;
          });
          useDeprecated({
            from: "small",
            replacement: "size",
            version: "3.0.0",
            scope: "el-pagination",
            ref: "https://element-plus.org/zh-CN/component/pagination.html"
          }, computed(() => !!props2.small));
          const hasCurrentPageListener = "onUpdate:currentPage" in vnodeProps || "onUpdate:current-page" in vnodeProps || "onCurrentChange" in vnodeProps;
          const hasPageSizeListener = "onUpdate:pageSize" in vnodeProps || "onUpdate:page-size" in vnodeProps || "onSizeChange" in vnodeProps;
          const assertValidUsage = computed(() => {
            if (isAbsent(props2.total) && isAbsent(props2.pageCount))
              return false;
            if (!isAbsent(props2.currentPage) && !hasCurrentPageListener)
              return false;
            if (props2.layout.includes("sizes")) {
              if (!isAbsent(props2.pageCount)) {
                if (!hasPageSizeListener)
                  return false;
              } else if (!isAbsent(props2.total)) {
                if (!isAbsent(props2.pageSize)) {
                  if (!hasPageSizeListener) {
                    return false;
                  }
                }
              }
            }
            return true;
          });
          const innerPageSize = ref(isAbsent(props2.defaultPageSize) ? 10 : props2.defaultPageSize);
          const innerCurrentPage = ref(isAbsent(props2.defaultCurrentPage) ? 1 : props2.defaultCurrentPage);
          const pageSizeBridge = computed({
            get() {
              return isAbsent(props2.pageSize) ? innerPageSize.value : props2.pageSize;
            },
            set(v2) {
              if (isAbsent(props2.pageSize)) {
                innerPageSize.value = v2;
              }
              if (hasPageSizeListener) {
                emit("update:page-size", v2);
                emit("size-change", v2);
              }
            }
          });
          const pageCountBridge = computed(() => {
            let pageCount = 0;
            if (!isAbsent(props2.pageCount)) {
              pageCount = props2.pageCount;
            } else if (!isAbsent(props2.total)) {
              pageCount = Math.max(1, Math.ceil(props2.total / pageSizeBridge.value));
            }
            return pageCount;
          });
          const currentPageBridge = computed({
            get() {
              return isAbsent(props2.currentPage) ? innerCurrentPage.value : props2.currentPage;
            },
            set(v2) {
              let newCurrentPage = v2;
              if (v2 < 1) {
                newCurrentPage = 1;
              } else if (v2 > pageCountBridge.value) {
                newCurrentPage = pageCountBridge.value;
              }
              if (isAbsent(props2.currentPage)) {
                innerCurrentPage.value = newCurrentPage;
              }
              if (hasCurrentPageListener) {
                emit("update:current-page", newCurrentPage);
                emit("current-change", newCurrentPage);
              }
            }
          });
          watch(pageCountBridge, (val) => {
            if (currentPageBridge.value > val)
              currentPageBridge.value = val;
          });
          watch([currentPageBridge, pageSizeBridge], (value) => {
            emit(CHANGE_EVENT, ...value);
          }, { flush: "post" });
          function handleCurrentChange2(val) {
            currentPageBridge.value = val;
          }
          function handleSizeChange(val) {
            pageSizeBridge.value = val;
            const newPageCount = pageCountBridge.value;
            if (currentPageBridge.value > newPageCount) {
              currentPageBridge.value = newPageCount;
            }
          }
          function prev() {
            if (props2.disabled)
              return;
            currentPageBridge.value -= 1;
            emit("prev-click", currentPageBridge.value);
          }
          function next() {
            if (props2.disabled)
              return;
            currentPageBridge.value += 1;
            emit("next-click", currentPageBridge.value);
          }
          function addClass2(element, cls) {
            if (element) {
              if (!element.props) {
                element.props = {};
              }
              element.props.class = [element.props.class, cls].join(" ");
            }
          }
          provide(elPaginationKey, {
            pageCount: pageCountBridge,
            disabled: computed(() => props2.disabled),
            currentPage: currentPageBridge,
            changeEvent: handleCurrentChange2,
            handleSizeChange
          });
          return () => {
            var _a, _b;
            if (!assertValidUsage.value) {
              debugWarn(componentName, t("el.pagination.deprecationWarning"));
              return null;
            }
            if (!props2.layout)
              return null;
            if (props2.hideOnSinglePage && pageCountBridge.value <= 1)
              return null;
            const rootChildren = [];
            const rightWrapperChildren = [];
            const rightWrapperRoot = h$1("div", { class: ns.e("rightwrapper") }, rightWrapperChildren);
            const TEMPLATE_MAP = {
              prev: h$1(Prev, {
                disabled: props2.disabled,
                currentPage: currentPageBridge.value,
                prevText: props2.prevText,
                prevIcon: props2.prevIcon,
                onClick: prev
              }),
              jumper: h$1(Jumper, {
                size: _size.value
              }),
              pager: h$1(Pager, {
                currentPage: currentPageBridge.value,
                pageCount: pageCountBridge.value,
                pagerCount: props2.pagerCount,
                onChange: handleCurrentChange2,
                disabled: props2.disabled
              }),
              next: h$1(Next, {
                disabled: props2.disabled,
                currentPage: currentPageBridge.value,
                pageCount: pageCountBridge.value,
                nextText: props2.nextText,
                nextIcon: props2.nextIcon,
                onClick: next
              }),
              sizes: h$1(Sizes, {
                pageSize: pageSizeBridge.value,
                pageSizes: props2.pageSizes,
                popperClass: props2.popperClass,
                disabled: props2.disabled,
                teleported: props2.teleported,
                size: _size.value,
                appendSizeTo: props2.appendSizeTo
              }),
              slot: (_b = (_a = slots == null ? void 0 : slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : null,
              total: h$1(Total, { total: isAbsent(props2.total) ? 0 : props2.total })
            };
            const components = props2.layout.split(",").map((item) => item.trim());
            let haveRightWrapper = false;
            components.forEach((c2) => {
              if (c2 === "->") {
                haveRightWrapper = true;
                return;
              }
              if (!haveRightWrapper) {
                rootChildren.push(TEMPLATE_MAP[c2]);
              } else {
                rightWrapperChildren.push(TEMPLATE_MAP[c2]);
              }
            });
            addClass2(rootChildren[0], ns.is("first"));
            addClass2(rootChildren[rootChildren.length - 1], ns.is("last"));
            if (haveRightWrapper && rightWrapperChildren.length > 0) {
              addClass2(rightWrapperChildren[0], ns.is("first"));
              addClass2(rightWrapperChildren[rightWrapperChildren.length - 1], ns.is("last"));
              rootChildren.push(rightWrapperRoot);
            }
            return h$1("div", {
              class: [
                ns.b(),
                ns.is("background", props2.background),
                ns.m(_size.value)
              ]
            }, rootChildren);
          };
        }
      });
      const ElPagination = exports("ElPagination", withInstall(Pagination));
      const popconfirmProps = exports("popconfirmProps", buildProps({
        title: String,
        confirmButtonText: String,
        cancelButtonText: String,
        confirmButtonType: {
          type: String,
          values: buttonTypes,
          default: "primary"
        },
        cancelButtonType: {
          type: String,
          values: buttonTypes,
          default: "text"
        },
        icon: {
          type: iconPropType,
          default: () => question_filled_default$1
        },
        iconColor: {
          type: String,
          default: "#f90"
        },
        hideIcon: Boolean,
        hideAfter: {
          type: Number,
          default: 200
        },
        teleported: useTooltipContentProps.teleported,
        persistent: useTooltipContentProps.persistent,
        width: {
          type: [String, Number],
          default: 150
        }
      }));
      const popconfirmEmits = exports("popconfirmEmits", {
        confirm: (e) => e instanceof MouseEvent,
        cancel: (e) => e instanceof MouseEvent
      });
      const __default__$M = defineComponent({
        name: "ElPopconfirm"
      });
      const _sfc_main$W = /* @__PURE__ */ defineComponent({
        ...__default__$M,
        props: popconfirmProps,
        emits: popconfirmEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const { t } = useLocale();
          const ns = useNamespace("popconfirm");
          const tooltipRef = ref();
          const popperRef = computed(() => {
            var _a;
            return (_a = unref(tooltipRef)) == null ? void 0 : _a.popperRef;
          });
          const hidePopper = () => {
            var _a, _b;
            (_b = (_a = tooltipRef.value) == null ? void 0 : _a.onClose) == null ? void 0 : _b.call(_a);
          };
          const style = computed(() => {
            return {
              width: addUnit(props2.width)
            };
          });
          const confirm = (e) => {
            emit("confirm", e);
            hidePopper();
          };
          const cancel = (e) => {
            emit("cancel", e);
            hidePopper();
          };
          const finalConfirmButtonText = computed(() => props2.confirmButtonText || t("el.popconfirm.confirmButtonText"));
          const finalCancelButtonText = computed(() => props2.cancelButtonText || t("el.popconfirm.cancelButtonText"));
          expose({
            popperRef,
            hide: hidePopper
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTooltip), mergeProps({
              ref_key: "tooltipRef",
              ref: tooltipRef,
              trigger: "click",
              effect: "light"
            }, _ctx.$attrs, {
              "popper-class": `${unref(ns).namespace.value}-popover`,
              "popper-style": unref(style),
              teleported: _ctx.teleported,
              "fallback-placements": ["bottom", "top", "right", "left"],
              "hide-after": _ctx.hideAfter,
              persistent: _ctx.persistent
            }), {
              content: withCtx(() => [
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).b())
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).e("main"))
                  }, [
                    !_ctx.hideIcon && _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(unref(ns).e("icon")),
                      style: normalizeStyle({ color: _ctx.iconColor })
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                      ]),
                      _: 1
                    }, 8, ["class", "style"])) : createCommentVNode("v-if", true),
                    createTextVNode(" " + toDisplayString(_ctx.title), 1)
                  ], 2),
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).e("action"))
                  }, [
                    renderSlot(_ctx.$slots, "actions", {
                      confirm,
                      cancel
                    }, () => [
                      createVNode(unref(ElButton), {
                        size: "small",
                        type: _ctx.cancelButtonType === "text" ? "" : _ctx.cancelButtonType,
                        text: _ctx.cancelButtonType === "text",
                        onClick: cancel
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(unref(finalCancelButtonText)), 1)
                        ]),
                        _: 1
                      }, 8, ["type", "text"]),
                      createVNode(unref(ElButton), {
                        size: "small",
                        type: _ctx.confirmButtonType === "text" ? "" : _ctx.confirmButtonType,
                        text: _ctx.confirmButtonType === "text",
                        onClick: confirm
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(unref(finalConfirmButtonText)), 1)
                        ]),
                        _: 1
                      }, 8, ["type", "text"])
                    ])
                  ], 2)
                ], 2)
              ]),
              default: withCtx(() => [
                _ctx.$slots.reference ? renderSlot(_ctx.$slots, "reference", { key: 0 }) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16, ["popper-class", "popper-style", "teleported", "hide-after", "persistent"]);
          };
        }
      });
      var Popconfirm = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["__file", "popconfirm.vue"]]);
      const ElPopconfirm = exports("ElPopconfirm", withInstall(Popconfirm));
      const popoverProps = exports("popoverProps", buildProps({
        trigger: useTooltipTriggerProps.trigger,
        triggerKeys: useTooltipTriggerProps.triggerKeys,
        placement: dropdownProps.placement,
        disabled: useTooltipTriggerProps.disabled,
        visible: useTooltipContentProps.visible,
        transition: useTooltipContentProps.transition,
        popperOptions: dropdownProps.popperOptions,
        tabindex: dropdownProps.tabindex,
        content: useTooltipContentProps.content,
        popperStyle: useTooltipContentProps.popperStyle,
        popperClass: useTooltipContentProps.popperClass,
        enterable: {
          ...useTooltipContentProps.enterable,
          default: true
        },
        effect: {
          ...useTooltipContentProps.effect,
          default: "light"
        },
        teleported: useTooltipContentProps.teleported,
        appendTo: useTooltipContentProps.appendTo,
        title: String,
        width: {
          type: [String, Number],
          default: 150
        },
        offset: {
          type: Number,
          default: void 0
        },
        showAfter: {
          type: Number,
          default: 0
        },
        hideAfter: {
          type: Number,
          default: 200
        },
        autoClose: {
          type: Number,
          default: 0
        },
        showArrow: {
          type: Boolean,
          default: true
        },
        persistent: {
          type: Boolean,
          default: true
        },
        "onUpdate:visible": {
          type: Function
        }
      }));
      const popoverEmits = exports("popoverEmits", {
        "update:visible": (value) => isBoolean(value),
        "before-enter": () => true,
        "before-leave": () => true,
        "after-enter": () => true,
        "after-leave": () => true
      });
      const updateEventKeyRaw = `onUpdate:visible`;
      const __default__$L = defineComponent({
        name: "ElPopover"
      });
      const _sfc_main$V = /* @__PURE__ */ defineComponent({
        ...__default__$L,
        props: popoverProps,
        emits: popoverEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const onUpdateVisible = computed(() => {
            return props2[updateEventKeyRaw];
          });
          const ns = useNamespace("popover");
          const tooltipRef = ref();
          const popperRef = computed(() => {
            var _a;
            return (_a = unref(tooltipRef)) == null ? void 0 : _a.popperRef;
          });
          const style = computed(() => {
            return [
              {
                width: addUnit(props2.width)
              },
              props2.popperStyle
            ];
          });
          const kls = computed(() => {
            return [ns.b(), props2.popperClass, { [ns.m("plain")]: !!props2.content }];
          });
          const gpuAcceleration = computed(() => {
            return props2.transition === `${ns.namespace.value}-fade-in-linear`;
          });
          const hide = () => {
            var _a;
            (_a = tooltipRef.value) == null ? void 0 : _a.hide();
          };
          const beforeEnter = () => {
            emit("before-enter");
          };
          const beforeLeave = () => {
            emit("before-leave");
          };
          const afterEnter = () => {
            emit("after-enter");
          };
          const afterLeave = () => {
            emit("update:visible", false);
            emit("after-leave");
          };
          expose({
            popperRef,
            hide
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElTooltip), mergeProps({
              ref_key: "tooltipRef",
              ref: tooltipRef
            }, _ctx.$attrs, {
              trigger: _ctx.trigger,
              "trigger-keys": _ctx.triggerKeys,
              placement: _ctx.placement,
              disabled: _ctx.disabled,
              visible: _ctx.visible,
              transition: _ctx.transition,
              "popper-options": _ctx.popperOptions,
              tabindex: _ctx.tabindex,
              content: _ctx.content,
              offset: _ctx.offset,
              "show-after": _ctx.showAfter,
              "hide-after": _ctx.hideAfter,
              "auto-close": _ctx.autoClose,
              "show-arrow": _ctx.showArrow,
              "aria-label": _ctx.title,
              effect: _ctx.effect,
              enterable: _ctx.enterable,
              "popper-class": unref(kls),
              "popper-style": unref(style),
              teleported: _ctx.teleported,
              "append-to": _ctx.appendTo,
              persistent: _ctx.persistent,
              "gpu-acceleration": unref(gpuAcceleration),
              "onUpdate:visible": unref(onUpdateVisible),
              onBeforeShow: beforeEnter,
              onBeforeHide: beforeLeave,
              onShow: afterEnter,
              onHide: afterLeave
            }), {
              content: withCtx(() => [
                _ctx.title ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).e("title")),
                  role: "title"
                }, toDisplayString(_ctx.title), 3)) : createCommentVNode("v-if", true),
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.content), 1)
                ])
              ]),
              default: withCtx(() => [
                _ctx.$slots.reference ? renderSlot(_ctx.$slots, "reference", { key: 0 }) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16, ["trigger", "trigger-keys", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "append-to", "persistent", "gpu-acceleration", "onUpdate:visible"]);
          };
        }
      });
      var Popover = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["__file", "popover.vue"]]);
      const attachEvents = (el, binding) => {
        const popperComponent = binding.arg || binding.value;
        const popover = popperComponent == null ? void 0 : popperComponent.popperRef;
        if (popover) {
          popover.triggerRef = el;
        }
      };
      var PopoverDirective = {
        mounted(el, binding) {
          attachEvents(el, binding);
        },
        updated(el, binding) {
          attachEvents(el, binding);
        }
      };
      const VPopover = "popover";
      const ElPopoverDirective = exports("ElPopoverDirective", withInstallDirective(PopoverDirective, VPopover));
      const ElPopover = exports("ElPopover", withInstall(Popover, {
        directive: ElPopoverDirective
      }));
      const progressProps = exports("progressProps", buildProps({
        type: {
          type: String,
          default: "line",
          values: ["line", "circle", "dashboard"]
        },
        percentage: {
          type: Number,
          default: 0,
          validator: (val) => val >= 0 && val <= 100
        },
        status: {
          type: String,
          default: "",
          values: ["", "success", "exception", "warning"]
        },
        indeterminate: Boolean,
        duration: {
          type: Number,
          default: 3
        },
        strokeWidth: {
          type: Number,
          default: 6
        },
        strokeLinecap: {
          type: definePropType(String),
          default: "round"
        },
        textInside: Boolean,
        width: {
          type: Number,
          default: 126
        },
        showText: {
          type: Boolean,
          default: true
        },
        color: {
          type: definePropType([
            String,
            Array,
            Function
          ]),
          default: ""
        },
        striped: Boolean,
        stripedFlow: Boolean,
        format: {
          type: definePropType(Function),
          default: (percentage) => `${percentage}%`
        }
      }));
      const __default__$K = defineComponent({
        name: "ElProgress"
      });
      const _sfc_main$U = /* @__PURE__ */ defineComponent({
        ...__default__$K,
        props: progressProps,
        setup(__props) {
          const props2 = __props;
          const STATUS_COLOR_MAP = {
            success: "#13ce66",
            exception: "#ff4949",
            warning: "#e6a23c",
            default: "#20a0ff"
          };
          const ns = useNamespace("progress");
          const barStyle = computed(() => {
            const barStyle2 = {
              width: `${props2.percentage}%`,
              animationDuration: `${props2.duration}s`
            };
            const color = getCurrentColor(props2.percentage);
            if (color.includes("gradient")) {
              barStyle2.background = color;
            } else {
              barStyle2.backgroundColor = color;
            }
            return barStyle2;
          });
          const relativeStrokeWidth = computed(() => (props2.strokeWidth / props2.width * 100).toFixed(1));
          const radius = computed(() => {
            if (["circle", "dashboard"].includes(props2.type)) {
              return Number.parseInt(`${50 - Number.parseFloat(relativeStrokeWidth.value) / 2}`, 10);
            }
            return 0;
          });
          const trackPath = computed(() => {
            const r = radius.value;
            const isDashboard = props2.type === "dashboard";
            return `
          M 50 50
          m 0 ${isDashboard ? "" : "-"}${r}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "-" : ""}${r * 2}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "" : "-"}${r * 2}
          `;
          });
          const perimeter = computed(() => 2 * Math.PI * radius.value);
          const rate = computed(() => props2.type === "dashboard" ? 0.75 : 1);
          const strokeDashoffset = computed(() => {
            const offset2 = -1 * perimeter.value * (1 - rate.value) / 2;
            return `${offset2}px`;
          });
          const trailPathStyle = computed(() => ({
            strokeDasharray: `${perimeter.value * rate.value}px, ${perimeter.value}px`,
            strokeDashoffset: strokeDashoffset.value
          }));
          const circlePathStyle = computed(() => ({
            strokeDasharray: `${perimeter.value * rate.value * (props2.percentage / 100)}px, ${perimeter.value}px`,
            strokeDashoffset: strokeDashoffset.value,
            transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
          }));
          const stroke = computed(() => {
            let ret;
            if (props2.color) {
              ret = getCurrentColor(props2.percentage);
            } else {
              ret = STATUS_COLOR_MAP[props2.status] || STATUS_COLOR_MAP.default;
            }
            return ret;
          });
          const statusIcon = computed(() => {
            if (props2.status === "warning") {
              return warning_filled_default$1;
            }
            if (props2.type === "line") {
              return props2.status === "success" ? circle_check_default$1 : circle_close_default$1;
            } else {
              return props2.status === "success" ? check_default$1 : close_default$1;
            }
          });
          const progressTextSize = computed(() => {
            return props2.type === "line" ? 12 + props2.strokeWidth * 0.4 : props2.width * 0.111111 + 2;
          });
          const content = computed(() => props2.format(props2.percentage));
          function getColors(color) {
            const span = 100 / color.length;
            const seriesColors = color.map((seriesColor, index2) => {
              if (isString$1(seriesColor)) {
                return {
                  color: seriesColor,
                  percentage: (index2 + 1) * span
                };
              }
              return seriesColor;
            });
            return seriesColors.sort((a2, b2) => a2.percentage - b2.percentage);
          }
          const getCurrentColor = (percentage) => {
            var _a;
            const { color } = props2;
            if (isFunction$1(color)) {
              return color(percentage);
            } else if (isString$1(color)) {
              return color;
            } else {
              const colors = getColors(color);
              for (const color2 of colors) {
                if (color2.percentage > percentage)
                  return color2.color;
              }
              return (_a = colors[colors.length - 1]) == null ? void 0 : _a.color;
            }
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).m(_ctx.type),
                unref(ns).is(_ctx.status),
                {
                  [unref(ns).m("without-text")]: !_ctx.showText,
                  [unref(ns).m("text-inside")]: _ctx.textInside
                }
              ]),
              role: "progressbar",
              "aria-valuenow": _ctx.percentage,
              "aria-valuemin": "0",
              "aria-valuemax": "100"
            }, [
              _ctx.type === "line" ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).b("bar"))
              }, [
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).be("bar", "outer")),
                  style: normalizeStyle({ height: `${_ctx.strokeWidth}px` })
                }, [
                  createElementVNode("div", {
                    class: normalizeClass([
                      unref(ns).be("bar", "inner"),
                      { [unref(ns).bem("bar", "inner", "indeterminate")]: _ctx.indeterminate },
                      { [unref(ns).bem("bar", "inner", "striped")]: _ctx.striped },
                      { [unref(ns).bem("bar", "inner", "striped-flow")]: _ctx.stripedFlow }
                    ]),
                    style: normalizeStyle(unref(barStyle))
                  }, [
                    (_ctx.showText || _ctx.$slots.default) && _ctx.textInside ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: normalizeClass(unref(ns).be("bar", "innerText"))
                    }, [
                      renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                        createElementVNode("span", null, toDisplayString(unref(content)), 1)
                      ])
                    ], 2)) : createCommentVNode("v-if", true)
                  ], 6)
                ], 6)
              ], 2)) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(ns).b("circle")),
                style: normalizeStyle({ height: `${_ctx.width}px`, width: `${_ctx.width}px` })
              }, [
                (openBlock(), createElementBlock("svg", { viewBox: "0 0 100 100" }, [
                  createElementVNode("path", {
                    class: normalizeClass(unref(ns).be("circle", "track")),
                    d: unref(trackPath),
                    stroke: `var(${unref(ns).cssVarName("fill-color-light")}, #e5e9f2)`,
                    "stroke-linecap": _ctx.strokeLinecap,
                    "stroke-width": unref(relativeStrokeWidth),
                    fill: "none",
                    style: normalizeStyle(unref(trailPathStyle))
                  }, null, 14, ["d", "stroke", "stroke-linecap", "stroke-width"]),
                  createElementVNode("path", {
                    class: normalizeClass(unref(ns).be("circle", "path")),
                    d: unref(trackPath),
                    stroke: unref(stroke),
                    fill: "none",
                    opacity: _ctx.percentage ? 1 : 0,
                    "stroke-linecap": _ctx.strokeLinecap,
                    "stroke-width": unref(relativeStrokeWidth),
                    style: normalizeStyle(unref(circlePathStyle))
                  }, null, 14, ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"])
                ]))
              ], 6)),
              (_ctx.showText || _ctx.$slots.default) && !_ctx.textInside ? (openBlock(), createElementBlock("div", {
                key: 2,
                class: normalizeClass(unref(ns).e("text")),
                style: normalizeStyle({ fontSize: `${unref(progressTextSize)}px` })
              }, [
                renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                  !_ctx.status ? (openBlock(), createElementBlock("span", { key: 0 }, toDisplayString(unref(content)), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(statusIcon))))
                    ]),
                    _: 1
                  }))
                ])
              ], 6)) : createCommentVNode("v-if", true)
            ], 10, ["aria-valuenow"]);
          };
        }
      });
      var Progress = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["__file", "progress.vue"]]);
      const ElProgress = exports("ElProgress", withInstall(Progress));
      const rateProps = exports("rateProps", buildProps({
        modelValue: {
          type: Number,
          default: 0
        },
        id: {
          type: String,
          default: void 0
        },
        lowThreshold: {
          type: Number,
          default: 2
        },
        highThreshold: {
          type: Number,
          default: 4
        },
        max: {
          type: Number,
          default: 5
        },
        colors: {
          type: definePropType([Array, Object]),
          default: () => mutable(["", "", ""])
        },
        voidColor: {
          type: String,
          default: ""
        },
        disabledVoidColor: {
          type: String,
          default: ""
        },
        icons: {
          type: definePropType([Array, Object]),
          default: () => [star_filled_default$1, star_filled_default$1, star_filled_default$1]
        },
        voidIcon: {
          type: iconPropType,
          default: () => star_default$1
        },
        disabledVoidIcon: {
          type: iconPropType,
          default: () => star_filled_default$1
        },
        disabled: Boolean,
        allowHalf: Boolean,
        showText: Boolean,
        showScore: Boolean,
        textColor: {
          type: String,
          default: ""
        },
        texts: {
          type: definePropType(Array),
          default: () => mutable([
            "Extremely bad",
            "Disappointed",
            "Fair",
            "Satisfied",
            "Surprise"
          ])
        },
        scoreTemplate: {
          type: String,
          default: "{value}"
        },
        size: useSizeProp,
        clearable: Boolean,
        ...useAriaProps(["ariaLabel"])
      }));
      const rateEmits = exports("rateEmits", {
        [CHANGE_EVENT]: (value) => isNumber(value),
        [UPDATE_MODEL_EVENT]: (value) => isNumber(value)
      });
      const __default__$J = defineComponent({
        name: "ElRate"
      });
      const _sfc_main$T = /* @__PURE__ */ defineComponent({
        ...__default__$J,
        props: rateProps,
        emits: rateEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          function getValueFromMap(value, map2) {
            const isExcludedObject = (val) => isObject$1(val);
            const matchedKeys = Object.keys(map2).map((key) => +key).filter((key) => {
              const val = map2[key];
              const excluded = isExcludedObject(val) ? val.excluded : false;
              return excluded ? value < key : value <= key;
            }).sort((a2, b2) => a2 - b2);
            const matchedValue = map2[matchedKeys[0]];
            return isExcludedObject(matchedValue) && matchedValue.value || matchedValue;
          }
          const formContext = inject(formContextKey, void 0);
          const formItemContext = inject(formItemContextKey, void 0);
          const rateSize = useFormSize();
          const ns = useNamespace("rate");
          const { inputId, isLabeledByFormItem } = useFormItemInputId(props2, {
            formItemContext
          });
          const currentValue = ref(props2.modelValue);
          const hoverIndex = ref(-1);
          const pointerAtLeftHalf = ref(true);
          const rateClasses = computed(() => [ns.b(), ns.m(rateSize.value)]);
          const rateDisabled = computed(() => props2.disabled || (formContext == null ? void 0 : formContext.disabled));
          const rateStyles = computed(() => {
            return ns.cssVarBlock({
              "void-color": props2.voidColor,
              "disabled-void-color": props2.disabledVoidColor,
              "fill-color": activeColor.value
            });
          });
          const text = computed(() => {
            let result2 = "";
            if (props2.showScore) {
              result2 = props2.scoreTemplate.replace(/\{\s*value\s*\}/, rateDisabled.value ? `${props2.modelValue}` : `${currentValue.value}`);
            } else if (props2.showText) {
              result2 = props2.texts[Math.ceil(currentValue.value) - 1];
            }
            return result2;
          });
          const valueDecimal = computed(() => props2.modelValue * 100 - Math.floor(props2.modelValue) * 100);
          const colorMap = computed(() => isArray$1(props2.colors) ? {
            [props2.lowThreshold]: props2.colors[0],
            [props2.highThreshold]: { value: props2.colors[1], excluded: true },
            [props2.max]: props2.colors[2]
          } : props2.colors);
          const activeColor = computed(() => {
            const color = getValueFromMap(currentValue.value, colorMap.value);
            return isObject$1(color) ? "" : color;
          });
          const decimalStyle = computed(() => {
            let width = "";
            if (rateDisabled.value) {
              width = `${valueDecimal.value}%`;
            } else if (props2.allowHalf) {
              width = "50%";
            }
            return {
              color: activeColor.value,
              width
            };
          });
          const componentMap = computed(() => {
            let icons = isArray$1(props2.icons) ? [...props2.icons] : { ...props2.icons };
            icons = markRaw(icons);
            return isArray$1(icons) ? {
              [props2.lowThreshold]: icons[0],
              [props2.highThreshold]: {
                value: icons[1],
                excluded: true
              },
              [props2.max]: icons[2]
            } : icons;
          });
          const decimalIconComponent = computed(() => getValueFromMap(props2.modelValue, componentMap.value));
          const voidComponent = computed(() => rateDisabled.value ? isString$1(props2.disabledVoidIcon) ? props2.disabledVoidIcon : markRaw(props2.disabledVoidIcon) : isString$1(props2.voidIcon) ? props2.voidIcon : markRaw(props2.voidIcon));
          const activeComponent = computed(() => getValueFromMap(currentValue.value, componentMap.value));
          function showDecimalIcon(item) {
            const showWhenDisabled = rateDisabled.value && valueDecimal.value > 0 && item - 1 < props2.modelValue && item > props2.modelValue;
            const showWhenAllowHalf = props2.allowHalf && pointerAtLeftHalf.value && item - 0.5 <= currentValue.value && item > currentValue.value;
            return showWhenDisabled || showWhenAllowHalf;
          }
          function emitValue(value) {
            if (props2.clearable && value === props2.modelValue) {
              value = 0;
            }
            emit(UPDATE_MODEL_EVENT, value);
            if (props2.modelValue !== value) {
              emit(CHANGE_EVENT, value);
            }
          }
          function selectValue(value) {
            if (rateDisabled.value) {
              return;
            }
            if (props2.allowHalf && pointerAtLeftHalf.value) {
              emitValue(currentValue.value);
            } else {
              emitValue(value);
            }
          }
          function handleKey(e) {
            if (rateDisabled.value) {
              return;
            }
            let _currentValue = currentValue.value;
            const code = e.code;
            if (code === EVENT_CODE.up || code === EVENT_CODE.right) {
              if (props2.allowHalf) {
                _currentValue += 0.5;
              } else {
                _currentValue += 1;
              }
              e.stopPropagation();
              e.preventDefault();
            } else if (code === EVENT_CODE.left || code === EVENT_CODE.down) {
              if (props2.allowHalf) {
                _currentValue -= 0.5;
              } else {
                _currentValue -= 1;
              }
              e.stopPropagation();
              e.preventDefault();
            }
            _currentValue = _currentValue < 0 ? 0 : _currentValue;
            _currentValue = _currentValue > props2.max ? props2.max : _currentValue;
            emit(UPDATE_MODEL_EVENT, _currentValue);
            emit(CHANGE_EVENT, _currentValue);
            return _currentValue;
          }
          function setCurrentValue(value, event) {
            if (rateDisabled.value) {
              return;
            }
            if (props2.allowHalf && event) {
              let target2 = event.target;
              if (hasClass(target2, ns.e("item"))) {
                target2 = target2.querySelector(`.${ns.e("icon")}`);
              }
              if (target2.clientWidth === 0 || hasClass(target2, ns.e("decimal"))) {
                target2 = target2.parentNode;
              }
              pointerAtLeftHalf.value = event.offsetX * 2 <= target2.clientWidth;
              currentValue.value = pointerAtLeftHalf.value ? value - 0.5 : value;
            } else {
              currentValue.value = value;
            }
            hoverIndex.value = value;
          }
          function resetCurrentValue() {
            if (rateDisabled.value) {
              return;
            }
            if (props2.allowHalf) {
              pointerAtLeftHalf.value = props2.modelValue !== Math.floor(props2.modelValue);
            }
            currentValue.value = props2.modelValue;
            hoverIndex.value = -1;
          }
          watch(() => props2.modelValue, (val) => {
            currentValue.value = val;
            pointerAtLeftHalf.value = props2.modelValue !== Math.floor(props2.modelValue);
          });
          if (!props2.modelValue) {
            emit(UPDATE_MODEL_EVENT, 0);
          }
          expose({
            setCurrentValue,
            resetCurrentValue
          });
          return (_ctx, _cache) => {
            var _a;
            return openBlock(), createElementBlock("div", {
              id: unref(inputId),
              class: normalizeClass([unref(rateClasses), unref(ns).is("disabled", unref(rateDisabled))]),
              role: "slider",
              "aria-label": !unref(isLabeledByFormItem) ? _ctx.ariaLabel || "rating" : void 0,
              "aria-labelledby": unref(isLabeledByFormItem) ? (_a = unref(formItemContext)) == null ? void 0 : _a.labelId : void 0,
              "aria-valuenow": currentValue.value,
              "aria-valuetext": unref(text) || void 0,
              "aria-valuemin": "0",
              "aria-valuemax": _ctx.max,
              tabindex: "0",
              style: normalizeStyle(unref(rateStyles)),
              onKeydown: handleKey
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.max, (item, key) => {
                return openBlock(), createElementBlock("span", {
                  key,
                  class: normalizeClass(unref(ns).e("item")),
                  onMousemove: ($event) => setCurrentValue(item, $event),
                  onMouseleave: resetCurrentValue,
                  onClick: ($event) => selectValue(item)
                }, [
                  createVNode(unref(ElIcon), {
                    class: normalizeClass([
                      unref(ns).e("icon"),
                      { hover: hoverIndex.value === item },
                      unref(ns).is("active", item <= currentValue.value)
                    ])
                  }, {
                    default: withCtx(() => [
                      !showDecimalIcon(item) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        withDirectives((openBlock(), createBlock(resolveDynamicComponent(unref(activeComponent)), null, null, 512)), [
                          [vShow, item <= currentValue.value]
                        ]),
                        withDirectives((openBlock(), createBlock(resolveDynamicComponent(unref(voidComponent)), null, null, 512)), [
                          [vShow, !(item <= currentValue.value)]
                        ])
                      ], 64)) : createCommentVNode("v-if", true),
                      showDecimalIcon(item) ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(voidComponent)), {
                          class: normalizeClass([unref(ns).em("decimal", "box")])
                        }, null, 8, ["class"])),
                        createVNode(unref(ElIcon), {
                          style: normalizeStyle(unref(decimalStyle)),
                          class: normalizeClass([unref(ns).e("icon"), unref(ns).e("decimal")])
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(unref(decimalIconComponent))))
                          ]),
                          _: 1
                        }, 8, ["style", "class"])
                      ], 64)) : createCommentVNode("v-if", true)
                    ]),
                    _: 2
                  }, 1032, ["class"])
                ], 42, ["onMousemove", "onClick"]);
              }), 128)),
              _ctx.showText || _ctx.showScore ? (openBlock(), createElementBlock("span", {
                key: 0,
                class: normalizeClass(unref(ns).e("text")),
                style: normalizeStyle({ color: _ctx.textColor })
              }, toDisplayString(unref(text)), 7)) : createCommentVNode("v-if", true)
            ], 46, ["id", "aria-label", "aria-labelledby", "aria-valuenow", "aria-valuetext", "aria-valuemax"]);
          };
        }
      });
      var Rate = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["__file", "rate.vue"]]);
      const ElRate = exports("ElRate", withInstall(Rate));
      const IconMap = exports("IconMap", {
        primary: "icon-primary",
        success: "icon-success",
        warning: "icon-warning",
        error: "icon-error",
        info: "icon-info"
      });
      const IconComponentMap = exports("IconComponentMap", {
        [IconMap.primary]: info_filled_default$1,
        [IconMap.success]: circle_check_filled_default$1,
        [IconMap.warning]: warning_filled_default$1,
        [IconMap.error]: circle_close_filled_default$1,
        [IconMap.info]: info_filled_default$1
      });
      const resultProps = exports("resultProps", buildProps({
        title: {
          type: String,
          default: ""
        },
        subTitle: {
          type: String,
          default: ""
        },
        icon: {
          type: String,
          values: ["primary", "success", "warning", "info", "error"],
          default: "info"
        }
      }));
      const __default__$I = defineComponent({
        name: "ElResult"
      });
      const _sfc_main$S = /* @__PURE__ */ defineComponent({
        ...__default__$I,
        props: resultProps,
        setup(__props) {
          const props2 = __props;
          const ns = useNamespace("result");
          const resultIcon = computed(() => {
            const icon = props2.icon;
            const iconClass = icon && IconMap[icon] ? IconMap[icon] : "icon-info";
            const iconComponent = IconComponentMap[iconClass] || IconComponentMap["icon-info"];
            return {
              class: iconClass,
              component: iconComponent
            };
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b())
            }, [
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("icon"))
              }, [
                renderSlot(_ctx.$slots, "icon", {}, () => [
                  unref(resultIcon).component ? (openBlock(), createBlock(resolveDynamicComponent(unref(resultIcon).component), {
                    key: 0,
                    class: normalizeClass(unref(resultIcon).class)
                  }, null, 8, ["class"])) : createCommentVNode("v-if", true)
                ])
              ], 2),
              _ctx.title || _ctx.$slots.title ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).e("title"))
              }, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createElementVNode("p", null, toDisplayString(_ctx.title), 1)
                ])
              ], 2)) : createCommentVNode("v-if", true),
              _ctx.subTitle || _ctx.$slots["sub-title"] ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(ns).e("subtitle"))
              }, [
                renderSlot(_ctx.$slots, "sub-title", {}, () => [
                  createElementVNode("p", null, toDisplayString(_ctx.subTitle), 1)
                ])
              ], 2)) : createCommentVNode("v-if", true),
              _ctx.$slots.extra ? (openBlock(), createElementBlock("div", {
                key: 2,
                class: normalizeClass(unref(ns).e("extra"))
              }, [
                renderSlot(_ctx.$slots, "extra")
              ], 2)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Result = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["__file", "result.vue"]]);
      const ElResult = exports("ElResult", withInstall(Result));
      var safeIsNaN = Number.isNaN || function ponyfill(value) {
        return typeof value === "number" && value !== value;
      };
      function isEqual(first, second) {
        if (first === second) {
          return true;
        }
        if (safeIsNaN(first) && safeIsNaN(second)) {
          return true;
        }
        return false;
      }
      function areInputsEqual(newInputs, lastInputs) {
        if (newInputs.length !== lastInputs.length) {
          return false;
        }
        for (var i = 0; i < newInputs.length; i++) {
          if (!isEqual(newInputs[i], lastInputs[i])) {
            return false;
          }
        }
        return true;
      }
      function memoizeOne(resultFn, isEqual2) {
        if (isEqual2 === void 0) {
          isEqual2 = areInputsEqual;
        }
        var cache2 = null;
        function memoized() {
          var newArgs = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
          }
          if (cache2 && cache2.lastThis === this && isEqual2(newArgs, cache2.lastArgs)) {
            return cache2.lastResult;
          }
          var lastResult = resultFn.apply(this, newArgs);
          cache2 = {
            lastResult,
            lastArgs: newArgs,
            lastThis: this
          };
          return lastResult;
        }
        memoized.clear = function clear() {
          cache2 = null;
        };
        return memoized;
      }
      const useCache = () => {
        const vm = getCurrentInstance();
        const props2 = vm.proxy.$props;
        return computed(() => {
          const _getItemStyleCache = (_2, __, ___) => ({});
          return props2.perfMode ? memoize(_getItemStyleCache) : memoizeOne(_getItemStyleCache);
        });
      };
      const DEFAULT_DYNAMIC_LIST_ITEM_SIZE = 50;
      const ITEM_RENDER_EVT = "itemRendered";
      const SCROLL_EVT = "scroll";
      const FORWARD = "forward";
      const BACKWARD = "backward";
      const AUTO_ALIGNMENT = "auto";
      const SMART_ALIGNMENT = "smart";
      const START_ALIGNMENT = "start";
      const CENTERED_ALIGNMENT = "center";
      const END_ALIGNMENT = "end";
      const HORIZONTAL = "horizontal";
      const VERTICAL = "vertical";
      const LTR = "ltr";
      const RTL = "rtl";
      const RTL_OFFSET_NAG = "negative";
      const RTL_OFFSET_POS_ASC = "positive-ascending";
      const RTL_OFFSET_POS_DESC = "positive-descending";
      const ScrollbarDirKey = {
        [HORIZONTAL]: "left",
        [VERTICAL]: "top"
      };
      const SCROLLBAR_MIN_SIZE = 20;
      const LayoutKeys = {
        [HORIZONTAL]: "deltaX",
        [VERTICAL]: "deltaY"
      };
      const useWheel = ({ atEndEdge, atStartEdge, layout: layout2 }, onWheelDelta) => {
        let frameHandle;
        let offset2 = 0;
        const hasReachedEdge = (offset22) => {
          const edgeReached = offset22 < 0 && atStartEdge.value || offset22 > 0 && atEndEdge.value;
          return edgeReached;
        };
        const onWheel = (e) => {
          cAF(frameHandle);
          const newOffset = e[LayoutKeys[layout2.value]];
          if (hasReachedEdge(offset2) && hasReachedEdge(offset2 + newOffset))
            return;
          offset2 += newOffset;
          if (!isFirefox()) {
            e.preventDefault();
          }
          frameHandle = rAF(() => {
            onWheelDelta(offset2);
            offset2 = 0;
          });
        };
        return {
          hasReachedEdge,
          onWheel
        };
      };
      var useWheel$1 = useWheel;
      const itemSize$1 = buildProp({
        type: definePropType([Number, Function]),
        required: true
      });
      const estimatedItemSize = buildProp({
        type: Number
      });
      const cache = buildProp({
        type: Number,
        default: 2
      });
      const direction = buildProp({
        type: String,
        values: ["ltr", "rtl"],
        default: "ltr"
      });
      const initScrollOffset = buildProp({
        type: Number,
        default: 0
      });
      const total = buildProp({
        type: Number,
        required: true
      });
      const layout = buildProp({
        type: String,
        values: ["horizontal", "vertical"],
        default: VERTICAL
      });
      const virtualizedProps = exports("virtualizedProps", buildProps({
        className: {
          type: String,
          default: ""
        },
        containerElement: {
          type: definePropType([String, Object]),
          default: "div"
        },
        data: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        direction,
        height: {
          type: [String, Number],
          required: true
        },
        innerElement: {
          type: [String, Object],
          default: "div"
        },
        style: {
          type: definePropType([Object, String, Array])
        },
        useIsScrolling: Boolean,
        width: {
          type: [Number, String],
          required: false
        },
        perfMode: {
          type: Boolean,
          default: true
        },
        scrollbarAlwaysOn: Boolean
      }));
      const virtualizedListProps = exports("virtualizedListProps", buildProps({
        cache,
        estimatedItemSize,
        layout,
        initScrollOffset,
        total,
        itemSize: itemSize$1,
        ...virtualizedProps
      }));
      const scrollbarSize = {
        type: Number,
        default: 6
      };
      const startGap = { type: Number, default: 0 };
      const endGap = { type: Number, default: 2 };
      const virtualizedGridProps = exports("virtualizedGridProps", buildProps({
        columnCache: cache,
        columnWidth: itemSize$1,
        estimatedColumnWidth: estimatedItemSize,
        estimatedRowHeight: estimatedItemSize,
        initScrollLeft: initScrollOffset,
        initScrollTop: initScrollOffset,
        itemKey: {
          type: definePropType(Function),
          default: ({
            columnIndex,
            rowIndex
          }) => `${rowIndex}:${columnIndex}`
        },
        rowCache: cache,
        rowHeight: itemSize$1,
        totalColumn: total,
        totalRow: total,
        hScrollbarSize: scrollbarSize,
        vScrollbarSize: scrollbarSize,
        scrollbarStartGap: startGap,
        scrollbarEndGap: endGap,
        role: String,
        ...virtualizedProps
      }));
      const virtualizedScrollbarProps = exports("virtualizedScrollbarProps", buildProps({
        alwaysOn: Boolean,
        class: String,
        layout,
        total,
        ratio: {
          type: Number,
          required: true
        },
        clientSize: {
          type: Number,
          required: true
        },
        scrollFrom: {
          type: Number,
          required: true
        },
        scrollbarSize,
        startGap,
        endGap,
        visible: Boolean
      }));
      const getScrollDir = (prev, cur) => prev < cur ? FORWARD : BACKWARD;
      const isHorizontal = (dir) => dir === LTR || dir === RTL || dir === HORIZONTAL;
      const isRTL = (dir) => dir === RTL;
      let cachedRTLResult = null;
      function getRTLOffsetType(recalculate = false) {
        if (cachedRTLResult === null || recalculate) {
          const outerDiv = document.createElement("div");
          const outerStyle = outerDiv.style;
          outerStyle.width = "50px";
          outerStyle.height = "50px";
          outerStyle.overflow = "scroll";
          outerStyle.direction = "rtl";
          const innerDiv = document.createElement("div");
          const innerStyle = innerDiv.style;
          innerStyle.width = "100px";
          innerStyle.height = "100px";
          outerDiv.appendChild(innerDiv);
          document.body.appendChild(outerDiv);
          if (outerDiv.scrollLeft > 0) {
            cachedRTLResult = RTL_OFFSET_POS_DESC;
          } else {
            outerDiv.scrollLeft = 1;
            if (outerDiv.scrollLeft === 0) {
              cachedRTLResult = RTL_OFFSET_NAG;
            } else {
              cachedRTLResult = RTL_OFFSET_POS_ASC;
            }
          }
          document.body.removeChild(outerDiv);
          return cachedRTLResult;
        }
        return cachedRTLResult;
      }
      function renderThumbStyle({ move, size, bar }, layout2) {
        const style = {};
        const translate2 = `translate${bar.axis}(${move}px)`;
        style[bar.size] = size;
        style.transform = translate2;
        if (layout2 === "horizontal") {
          style.height = "100%";
        } else {
          style.width = "100%";
        }
        return style;
      }
      const ScrollBar = defineComponent({
        name: "ElVirtualScrollBar",
        props: virtualizedScrollbarProps,
        emits: ["scroll", "start-move", "stop-move"],
        setup(props2, { emit }) {
          const GAP2 = computed(() => props2.startGap + props2.endGap);
          const nsVirtualScrollbar = useNamespace("virtual-scrollbar");
          const nsScrollbar = useNamespace("scrollbar");
          const trackRef = ref();
          const thumbRef = ref();
          let frameHandle = null;
          let onselectstartStore = null;
          const state = reactive({
            isDragging: false,
            traveled: 0
          });
          const bar = computed(() => BAR_MAP[props2.layout]);
          const trackSize = computed(() => props2.clientSize - unref(GAP2));
          const trackStyle = computed(() => ({
            position: "absolute",
            width: `${HORIZONTAL === props2.layout ? trackSize.value : props2.scrollbarSize}px`,
            height: `${HORIZONTAL === props2.layout ? props2.scrollbarSize : trackSize.value}px`,
            [ScrollbarDirKey[props2.layout]]: "2px",
            right: "2px",
            bottom: "2px",
            borderRadius: "4px"
          }));
          const thumbSize = computed(() => {
            const ratio = props2.ratio;
            if (ratio >= 100) {
              return Number.POSITIVE_INFINITY;
            }
            if (ratio >= 50) {
              return ratio * trackSize.value / 100;
            }
            const SCROLLBAR_MAX_SIZE = trackSize.value / 3;
            return Math.floor(Math.min(Math.max(ratio * trackSize.value, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));
          });
          const thumbStyle = computed(() => {
            if (!Number.isFinite(thumbSize.value)) {
              return {
                display: "none"
              };
            }
            const thumb = `${thumbSize.value}px`;
            const style = renderThumbStyle({
              bar: bar.value,
              size: thumb,
              move: state.traveled
            }, props2.layout);
            return style;
          });
          const totalSteps = computed(() => Math.ceil(props2.clientSize - thumbSize.value - unref(GAP2)));
          const attachEvents2 = () => {
            window.addEventListener("mousemove", onMouseMove);
            window.addEventListener("mouseup", onMouseUp);
            const thumbEl = unref(thumbRef);
            if (!thumbEl)
              return;
            onselectstartStore = document.onselectstart;
            document.onselectstart = () => false;
            thumbEl.addEventListener("touchmove", onMouseMove, { passive: true });
            thumbEl.addEventListener("touchend", onMouseUp);
          };
          const detachEvents = () => {
            window.removeEventListener("mousemove", onMouseMove);
            window.removeEventListener("mouseup", onMouseUp);
            document.onselectstart = onselectstartStore;
            onselectstartStore = null;
            const thumbEl = unref(thumbRef);
            if (!thumbEl)
              return;
            thumbEl.removeEventListener("touchmove", onMouseMove);
            thumbEl.removeEventListener("touchend", onMouseUp);
          };
          const onThumbMouseDown = (e) => {
            e.stopImmediatePropagation();
            if (e.ctrlKey || [1, 2].includes(e.button)) {
              return;
            }
            state.isDragging = true;
            state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);
            emit("start-move");
            attachEvents2();
          };
          const onMouseUp = () => {
            state.isDragging = false;
            state[bar.value.axis] = 0;
            emit("stop-move");
            detachEvents();
          };
          const onMouseMove = (e) => {
            const { isDragging: isDragging2 } = state;
            if (!isDragging2)
              return;
            if (!thumbRef.value || !trackRef.value)
              return;
            const prevPage = state[bar.value.axis];
            if (!prevPage)
              return;
            cAF(frameHandle);
            const offset2 = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
            const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;
            const distance = offset2 - thumbClickPosition;
            frameHandle = rAF(() => {
              state.traveled = Math.max(0, Math.min(distance, totalSteps.value));
              emit("scroll", distance, totalSteps.value);
            });
          };
          const clickTrackHandler = (e) => {
            const offset2 = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
            const thumbHalf = thumbRef.value[bar.value.offset] / 2;
            const distance = offset2 - thumbHalf;
            state.traveled = Math.max(0, Math.min(distance, totalSteps.value));
            emit("scroll", distance, totalSteps.value);
          };
          watch(() => props2.scrollFrom, (v2) => {
            if (state.isDragging)
              return;
            state.traveled = Math.ceil(v2 * totalSteps.value);
          });
          onBeforeUnmount(() => {
            detachEvents();
          });
          return () => {
            return h$1("div", {
              role: "presentation",
              ref: trackRef,
              class: [
                nsVirtualScrollbar.b(),
                props2.class,
                (props2.alwaysOn || state.isDragging) && "always-on"
              ],
              style: trackStyle.value,
              onMousedown: withModifiers(clickTrackHandler, ["stop", "prevent"]),
              onTouchstartPrevent: onThumbMouseDown
            }, h$1("div", {
              ref: thumbRef,
              class: nsScrollbar.e("thumb"),
              style: thumbStyle.value,
              onMousedown: onThumbMouseDown
            }, []));
          };
        }
      });
      var Scrollbar = ScrollBar;
      const createList = ({
        name,
        getOffset: getOffset2,
        getItemSize,
        getItemOffset,
        getEstimatedTotalSize: getEstimatedTotalSize2,
        getStartIndexForOffset,
        getStopIndexForStartIndex,
        initCache,
        clearCache,
        validateProps
      }) => {
        return defineComponent({
          name: name != null ? name : "ElVirtualList",
          props: virtualizedListProps,
          emits: [ITEM_RENDER_EVT, SCROLL_EVT],
          setup(props2, { emit, expose }) {
            validateProps(props2);
            const instance = getCurrentInstance();
            const ns = useNamespace("vl");
            const dynamicSizeCache = ref(initCache(props2, instance));
            const getItemStyleCache = useCache();
            const windowRef = ref();
            const innerRef = ref();
            const scrollbarRef = ref();
            const states = ref({
              isScrolling: false,
              scrollDir: "forward",
              scrollOffset: isNumber(props2.initScrollOffset) ? props2.initScrollOffset : 0,
              updateRequested: false,
              isScrollbarDragging: false,
              scrollbarAlwaysOn: props2.scrollbarAlwaysOn
            });
            const itemsToRender = computed(() => {
              const { total: total2, cache: cache2 } = props2;
              const { isScrolling, scrollDir, scrollOffset } = unref(states);
              if (total2 === 0) {
                return [0, 0, 0, 0];
              }
              const startIndex = getStartIndexForOffset(props2, scrollOffset, unref(dynamicSizeCache));
              const stopIndex = getStopIndexForStartIndex(props2, startIndex, scrollOffset, unref(dynamicSizeCache));
              const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache2) : 1;
              const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache2) : 1;
              return [
                Math.max(0, startIndex - cacheBackward),
                Math.max(0, Math.min(total2 - 1, stopIndex + cacheForward)),
                startIndex,
                stopIndex
              ];
            });
            const estimatedTotalSize = computed(() => getEstimatedTotalSize2(props2, unref(dynamicSizeCache)));
            const _isHorizontal = computed(() => isHorizontal(props2.layout));
            const windowStyle = computed(() => [
              {
                position: "relative",
                [`overflow-${_isHorizontal.value ? "x" : "y"}`]: "scroll",
                WebkitOverflowScrolling: "touch",
                willChange: "transform"
              },
              {
                direction: props2.direction,
                height: isNumber(props2.height) ? `${props2.height}px` : props2.height,
                width: isNumber(props2.width) ? `${props2.width}px` : props2.width
              },
              props2.style
            ]);
            const innerStyle = computed(() => {
              const size = unref(estimatedTotalSize);
              const horizontal = unref(_isHorizontal);
              return {
                height: horizontal ? "100%" : `${size}px`,
                pointerEvents: unref(states).isScrolling ? "none" : void 0,
                width: horizontal ? `${size}px` : "100%"
              };
            });
            const clientSize = computed(() => _isHorizontal.value ? props2.width : props2.height);
            const { onWheel } = useWheel$1({
              atStartEdge: computed(() => states.value.scrollOffset <= 0),
              atEndEdge: computed(() => states.value.scrollOffset >= estimatedTotalSize.value),
              layout: computed(() => props2.layout)
            }, (offset2) => {
              var _a, _b;
              (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);
              scrollTo(Math.min(states.value.scrollOffset + offset2, estimatedTotalSize.value - clientSize.value));
            });
            useEventListener(windowRef, "wheel", onWheel, {
              passive: false
            });
            const emitEvents = () => {
              const { total: total2 } = props2;
              if (total2 > 0) {
                const [cacheStart, cacheEnd, visibleStart, visibleEnd] = unref(itemsToRender);
                emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);
              }
              const { scrollDir, scrollOffset, updateRequested } = unref(states);
              emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);
            };
            const scrollVertically = (e) => {
              const { clientHeight, scrollHeight, scrollTop } = e.currentTarget;
              const _states = unref(states);
              if (_states.scrollOffset === scrollTop) {
                return;
              }
              const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));
              states.value = {
                ..._states,
                isScrolling: true,
                scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),
                scrollOffset,
                updateRequested: false
              };
              nextTick(resetIsScrolling);
            };
            const scrollHorizontally = (e) => {
              const { clientWidth, scrollLeft, scrollWidth } = e.currentTarget;
              const _states = unref(states);
              if (_states.scrollOffset === scrollLeft) {
                return;
              }
              const { direction: direction2 } = props2;
              let scrollOffset = scrollLeft;
              if (direction2 === RTL) {
                switch (getRTLOffsetType()) {
                  case RTL_OFFSET_NAG: {
                    scrollOffset = -scrollLeft;
                    break;
                  }
                  case RTL_OFFSET_POS_DESC: {
                    scrollOffset = scrollWidth - clientWidth - scrollLeft;
                    break;
                  }
                }
              }
              scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));
              states.value = {
                ..._states,
                isScrolling: true,
                scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),
                scrollOffset,
                updateRequested: false
              };
              nextTick(resetIsScrolling);
            };
            const onScroll = (e) => {
              unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);
              emitEvents();
            };
            const onScrollbarScroll = (distanceToGo, totalSteps) => {
              const offset2 = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;
              scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset2));
            };
            const scrollTo = (offset2) => {
              offset2 = Math.max(offset2, 0);
              if (offset2 === unref(states).scrollOffset) {
                return;
              }
              states.value = {
                ...unref(states),
                scrollOffset: offset2,
                scrollDir: getScrollDir(unref(states).scrollOffset, offset2),
                updateRequested: true
              };
              nextTick(resetIsScrolling);
            };
            const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {
              const { scrollOffset } = unref(states);
              idx = Math.max(0, Math.min(idx, props2.total - 1));
              scrollTo(getOffset2(props2, idx, alignment, scrollOffset, unref(dynamicSizeCache)));
            };
            const getItemStyle = (idx) => {
              const { direction: direction2, itemSize: itemSize2, layout: layout2 } = props2;
              const itemStyleCache = getItemStyleCache.value(clearCache && itemSize2, clearCache && layout2, clearCache && direction2);
              let style;
              if (hasOwn(itemStyleCache, String(idx))) {
                style = itemStyleCache[idx];
              } else {
                const offset2 = getItemOffset(props2, idx, unref(dynamicSizeCache));
                const size = getItemSize(props2, idx, unref(dynamicSizeCache));
                const horizontal = unref(_isHorizontal);
                const isRtl = direction2 === RTL;
                const offsetHorizontal = horizontal ? offset2 : 0;
                itemStyleCache[idx] = style = {
                  position: "absolute",
                  left: isRtl ? void 0 : `${offsetHorizontal}px`,
                  right: isRtl ? `${offsetHorizontal}px` : void 0,
                  top: !horizontal ? `${offset2}px` : 0,
                  height: !horizontal ? `${size}px` : "100%",
                  width: horizontal ? `${size}px` : "100%"
                };
              }
              return style;
            };
            const resetIsScrolling = () => {
              states.value.isScrolling = false;
              nextTick(() => {
                getItemStyleCache.value(-1, null, null);
              });
            };
            const resetScrollTop = () => {
              const window2 = windowRef.value;
              if (window2) {
                window2.scrollTop = 0;
              }
            };
            onMounted(() => {
              if (!isClient)
                return;
              const { initScrollOffset: initScrollOffset2 } = props2;
              const windowElement = unref(windowRef);
              if (isNumber(initScrollOffset2) && windowElement) {
                if (unref(_isHorizontal)) {
                  windowElement.scrollLeft = initScrollOffset2;
                } else {
                  windowElement.scrollTop = initScrollOffset2;
                }
              }
              emitEvents();
            });
            onUpdated(() => {
              const { direction: direction2, layout: layout2 } = props2;
              const { scrollOffset, updateRequested } = unref(states);
              const windowElement = unref(windowRef);
              if (updateRequested && windowElement) {
                if (layout2 === HORIZONTAL) {
                  if (direction2 === RTL) {
                    switch (getRTLOffsetType()) {
                      case RTL_OFFSET_NAG: {
                        windowElement.scrollLeft = -scrollOffset;
                        break;
                      }
                      case RTL_OFFSET_POS_ASC: {
                        windowElement.scrollLeft = scrollOffset;
                        break;
                      }
                      default: {
                        const { clientWidth, scrollWidth } = windowElement;
                        windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;
                        break;
                      }
                    }
                  } else {
                    windowElement.scrollLeft = scrollOffset;
                  }
                } else {
                  windowElement.scrollTop = scrollOffset;
                }
              }
            });
            onActivated(() => {
              unref(windowRef).scrollTop = unref(states).scrollOffset;
            });
            const api = {
              ns,
              clientSize,
              estimatedTotalSize,
              windowStyle,
              windowRef,
              innerRef,
              innerStyle,
              itemsToRender,
              scrollbarRef,
              states,
              getItemStyle,
              onScroll,
              onScrollbarScroll,
              onWheel,
              scrollTo,
              scrollToItem,
              resetScrollTop
            };
            expose({
              windowRef,
              innerRef,
              getItemStyleCache,
              scrollTo,
              scrollToItem,
              resetScrollTop,
              states
            });
            return api;
          },
          render(ctx) {
            var _a;
            const {
              $slots,
              className,
              clientSize,
              containerElement,
              data,
              getItemStyle,
              innerElement,
              itemsToRender,
              innerStyle,
              layout: layout2,
              total: total2,
              onScroll,
              onScrollbarScroll,
              states,
              useIsScrolling,
              windowStyle,
              ns
            } = ctx;
            const [start, end] = itemsToRender;
            const Container2 = resolveDynamicComponent(containerElement);
            const Inner = resolveDynamicComponent(innerElement);
            const children = [];
            if (total2 > 0) {
              for (let i = start; i <= end; i++) {
                children.push(h$1(Fragment, { key: i }, (_a = $slots.default) == null ? void 0 : _a.call($slots, {
                  data,
                  index: i,
                  isScrolling: useIsScrolling ? states.isScrolling : void 0,
                  style: getItemStyle(i)
                })));
              }
            }
            const InnerNode = [
              h$1(Inner, {
                style: innerStyle,
                ref: "innerRef"
              }, !isString$1(Inner) ? {
                default: () => children
              } : children)
            ];
            const scrollbar = h$1(Scrollbar, {
              ref: "scrollbarRef",
              clientSize,
              layout: layout2,
              onScroll: onScrollbarScroll,
              ratio: clientSize * 100 / this.estimatedTotalSize,
              scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),
              total: total2,
              alwaysOn: states.scrollbarAlwaysOn
            });
            const listContainer = h$1(Container2, {
              class: [ns.e("window"), className],
              style: windowStyle,
              onScroll,
              ref: "windowRef",
              key: 0
            }, !isString$1(Container2) ? { default: () => [InnerNode] } : [InnerNode]);
            return h$1("div", {
              key: 0,
              class: [ns.e("wrapper"), states.scrollbarAlwaysOn ? "always-on" : ""]
            }, [listContainer, scrollbar]);
          }
        });
      };
      var createList$1 = createList;
      const FixedSizeList = createList$1({
        name: "ElFixedSizeList",
        getItemOffset: ({ itemSize: itemSize2 }, index2) => index2 * itemSize2,
        getItemSize: ({ itemSize: itemSize2 }) => itemSize2,
        getEstimatedTotalSize: ({ total: total2, itemSize: itemSize2 }) => itemSize2 * total2,
        getOffset: ({ height, total: total2, itemSize: itemSize2, layout: layout2, width }, index2, alignment, scrollOffset) => {
          const size = isHorizontal(layout2) ? width : height;
          const lastItemOffset = Math.max(0, total2 * itemSize2 - size);
          const maxOffset = Math.min(lastItemOffset, index2 * itemSize2);
          const minOffset = Math.max(0, (index2 + 1) * itemSize2 - size);
          if (alignment === SMART_ALIGNMENT) {
            if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
              alignment = AUTO_ALIGNMENT;
            } else {
              alignment = CENTERED_ALIGNMENT;
            }
          }
          switch (alignment) {
            case START_ALIGNMENT: {
              return maxOffset;
            }
            case END_ALIGNMENT: {
              return minOffset;
            }
            case CENTERED_ALIGNMENT: {
              const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
              if (middleOffset < Math.ceil(size / 2)) {
                return 0;
              } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {
                return lastItemOffset;
              } else {
                return middleOffset;
              }
            }
            case AUTO_ALIGNMENT:
            default: {
              if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
                return scrollOffset;
              } else if (scrollOffset < minOffset) {
                return minOffset;
              } else {
                return maxOffset;
              }
            }
          }
        },
        getStartIndexForOffset: ({ total: total2, itemSize: itemSize2 }, offset2) => Math.max(0, Math.min(total2 - 1, Math.floor(offset2 / itemSize2))),
        getStopIndexForStartIndex: ({ height, total: total2, itemSize: itemSize2, layout: layout2, width }, startIndex, scrollOffset) => {
          const offset2 = startIndex * itemSize2;
          const size = isHorizontal(layout2) ? width : height;
          const numVisibleItems = Math.ceil((size + scrollOffset - offset2) / itemSize2);
          return Math.max(0, Math.min(total2 - 1, startIndex + numVisibleItems - 1));
        },
        initCache() {
          return void 0;
        },
        clearCache: true,
        validateProps() {
        }
      });
      var FixedSizeList$1 = exports("FixedSizeList", FixedSizeList);
      const getItemFromCache$1 = (props2, index2, listCache) => {
        const { itemSize: itemSize2 } = props2;
        const { items, lastVisitedIndex } = listCache;
        if (index2 > lastVisitedIndex) {
          let offset2 = 0;
          if (lastVisitedIndex >= 0) {
            const item = items[lastVisitedIndex];
            offset2 = item.offset + item.size;
          }
          for (let i = lastVisitedIndex + 1; i <= index2; i++) {
            const size = itemSize2(i);
            items[i] = {
              offset: offset2,
              size
            };
            offset2 += size;
          }
          listCache.lastVisitedIndex = index2;
        }
        return items[index2];
      };
      const findItem$1 = (props2, listCache, offset2) => {
        const { items, lastVisitedIndex } = listCache;
        const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;
        if (lastVisitedOffset >= offset2) {
          return bs$1(props2, listCache, 0, lastVisitedIndex, offset2);
        }
        return es$1(props2, listCache, Math.max(0, lastVisitedIndex), offset2);
      };
      const bs$1 = (props2, listCache, low, high, offset2) => {
        while (low <= high) {
          const mid = low + Math.floor((high - low) / 2);
          const currentOffset = getItemFromCache$1(props2, mid, listCache).offset;
          if (currentOffset === offset2) {
            return mid;
          } else if (currentOffset < offset2) {
            low = mid + 1;
          } else if (currentOffset > offset2) {
            high = mid - 1;
          }
        }
        return Math.max(0, low - 1);
      };
      const es$1 = (props2, listCache, index2, offset2) => {
        const { total: total2 } = props2;
        let exponent = 1;
        while (index2 < total2 && getItemFromCache$1(props2, index2, listCache).offset < offset2) {
          index2 += exponent;
          exponent *= 2;
        }
        return bs$1(props2, listCache, Math.floor(index2 / 2), Math.min(index2, total2 - 1), offset2);
      };
      const getEstimatedTotalSize = ({ total: total2 }, { items, estimatedItemSize: estimatedItemSize2, lastVisitedIndex }) => {
        let totalSizeOfMeasuredItems = 0;
        if (lastVisitedIndex >= total2) {
          lastVisitedIndex = total2 - 1;
        }
        if (lastVisitedIndex >= 0) {
          const item = items[lastVisitedIndex];
          totalSizeOfMeasuredItems = item.offset + item.size;
        }
        const numUnmeasuredItems = total2 - lastVisitedIndex - 1;
        const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize2;
        return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;
      };
      const DynamicSizeList = createList$1({
        name: "ElDynamicSizeList",
        getItemOffset: (props2, index2, listCache) => getItemFromCache$1(props2, index2, listCache).offset,
        getItemSize: (_2, index2, { items }) => items[index2].size,
        getEstimatedTotalSize,
        getOffset: (props2, index2, alignment, scrollOffset, listCache) => {
          const { height, layout: layout2, width } = props2;
          const size = isHorizontal(layout2) ? width : height;
          const item = getItemFromCache$1(props2, index2, listCache);
          const estimatedTotalSize = getEstimatedTotalSize(props2, listCache);
          const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, item.offset));
          const minOffset = Math.max(0, item.offset - size + item.size);
          if (alignment === SMART_ALIGNMENT) {
            if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
              alignment = AUTO_ALIGNMENT;
            } else {
              alignment = CENTERED_ALIGNMENT;
            }
          }
          switch (alignment) {
            case START_ALIGNMENT: {
              return maxOffset;
            }
            case END_ALIGNMENT: {
              return minOffset;
            }
            case CENTERED_ALIGNMENT: {
              return Math.round(minOffset + (maxOffset - minOffset) / 2);
            }
            case AUTO_ALIGNMENT:
            default: {
              if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
                return scrollOffset;
              } else if (scrollOffset < minOffset) {
                return minOffset;
              } else {
                return maxOffset;
              }
            }
          }
        },
        getStartIndexForOffset: (props2, offset2, listCache) => findItem$1(props2, listCache, offset2),
        getStopIndexForStartIndex: (props2, startIndex, scrollOffset, listCache) => {
          const { height, total: total2, layout: layout2, width } = props2;
          const size = isHorizontal(layout2) ? width : height;
          const item = getItemFromCache$1(props2, startIndex, listCache);
          const maxOffset = scrollOffset + size;
          let offset2 = item.offset + item.size;
          let stopIndex = startIndex;
          while (stopIndex < total2 - 1 && offset2 < maxOffset) {
            stopIndex++;
            offset2 += getItemFromCache$1(props2, stopIndex, listCache).size;
          }
          return stopIndex;
        },
        initCache({ estimatedItemSize: estimatedItemSize2 = DEFAULT_DYNAMIC_LIST_ITEM_SIZE }, instance) {
          const cache2 = {
            items: {},
            estimatedItemSize: estimatedItemSize2,
            lastVisitedIndex: -1
          };
          cache2.clearCacheAfterIndex = (index2, forceUpdate = true) => {
            var _a, _b;
            cache2.lastVisitedIndex = Math.min(cache2.lastVisitedIndex, index2 - 1);
            (_a = instance.exposed) == null ? void 0 : _a.getItemStyleCache(-1);
            if (forceUpdate) {
              (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();
            }
          };
          return cache2;
        },
        clearCache: false,
        validateProps: ({ itemSize: itemSize2 }) => {
        }
      });
      var DynamicSizeList$1 = exports("DynamicSizeList", DynamicSizeList);
      const useGridWheel = ({ atXEndEdge, atXStartEdge, atYEndEdge, atYStartEdge }, onWheelDelta) => {
        let frameHandle = null;
        let xOffset = 0;
        let yOffset = 0;
        const hasReachedEdge = (x2, y) => {
          const xEdgeReached = x2 <= 0 && atXStartEdge.value || x2 >= 0 && atXEndEdge.value;
          const yEdgeReached = y <= 0 && atYStartEdge.value || y >= 0 && atYEndEdge.value;
          return xEdgeReached && yEdgeReached;
        };
        const onWheel = (e) => {
          cAF(frameHandle);
          let x2 = e.deltaX;
          let y = e.deltaY;
          if (Math.abs(x2) > Math.abs(y)) {
            y = 0;
          } else {
            x2 = 0;
          }
          if (e.shiftKey && y !== 0) {
            x2 = y;
            y = 0;
          }
          if (hasReachedEdge(xOffset, yOffset) && hasReachedEdge(xOffset + x2, yOffset + y))
            return;
          xOffset += x2;
          yOffset += y;
          e.preventDefault();
          frameHandle = rAF(() => {
            onWheelDelta(xOffset, yOffset);
            xOffset = 0;
            yOffset = 0;
          });
        };
        return {
          hasReachedEdge,
          onWheel
        };
      };
      const createGrid = ({
        name,
        clearCache,
        getColumnPosition,
        getColumnStartIndexForOffset,
        getColumnStopIndexForStartIndex,
        getEstimatedTotalHeight: getEstimatedTotalHeight2,
        getEstimatedTotalWidth: getEstimatedTotalWidth2,
        getColumnOffset,
        getRowOffset,
        getRowPosition,
        getRowStartIndexForOffset,
        getRowStopIndexForStartIndex,
        initCache,
        injectToInstance,
        validateProps
      }) => {
        return defineComponent({
          name: name != null ? name : "ElVirtualList",
          props: virtualizedGridProps,
          emits: [ITEM_RENDER_EVT, SCROLL_EVT],
          setup(props2, { emit, expose, slots }) {
            const ns = useNamespace("vl");
            validateProps(props2);
            const instance = getCurrentInstance();
            const cache2 = ref(initCache(props2, instance));
            injectToInstance == null ? void 0 : injectToInstance(instance, cache2);
            const windowRef = ref();
            const hScrollbar = ref();
            const vScrollbar = ref();
            const innerRef = ref(null);
            const states = ref({
              isScrolling: false,
              scrollLeft: isNumber(props2.initScrollLeft) ? props2.initScrollLeft : 0,
              scrollTop: isNumber(props2.initScrollTop) ? props2.initScrollTop : 0,
              updateRequested: false,
              xAxisScrollDir: FORWARD,
              yAxisScrollDir: FORWARD
            });
            const getItemStyleCache = useCache();
            const parsedHeight = computed(() => Number.parseInt(`${props2.height}`, 10));
            const parsedWidth = computed(() => Number.parseInt(`${props2.width}`, 10));
            const columnsToRender = computed(() => {
              const { totalColumn, totalRow, columnCache } = props2;
              const { isScrolling, xAxisScrollDir, scrollLeft } = unref(states);
              if (totalColumn === 0 || totalRow === 0) {
                return [0, 0, 0, 0];
              }
              const startIndex = getColumnStartIndexForOffset(props2, scrollLeft, unref(cache2));
              const stopIndex = getColumnStopIndexForStartIndex(props2, startIndex, scrollLeft, unref(cache2));
              const cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;
              const cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;
              return [
                Math.max(0, startIndex - cacheBackward),
                Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)),
                startIndex,
                stopIndex
              ];
            });
            const rowsToRender = computed(() => {
              const { totalColumn, totalRow, rowCache } = props2;
              const { isScrolling, yAxisScrollDir, scrollTop } = unref(states);
              if (totalColumn === 0 || totalRow === 0) {
                return [0, 0, 0, 0];
              }
              const startIndex = getRowStartIndexForOffset(props2, scrollTop, unref(cache2));
              const stopIndex = getRowStopIndexForStartIndex(props2, startIndex, scrollTop, unref(cache2));
              const cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;
              const cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;
              return [
                Math.max(0, startIndex - cacheBackward),
                Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)),
                startIndex,
                stopIndex
              ];
            });
            const estimatedTotalHeight = computed(() => getEstimatedTotalHeight2(props2, unref(cache2)));
            const estimatedTotalWidth = computed(() => getEstimatedTotalWidth2(props2, unref(cache2)));
            const windowStyle = computed(() => {
              var _a;
              return [
                {
                  position: "relative",
                  overflow: "hidden",
                  WebkitOverflowScrolling: "touch",
                  willChange: "transform"
                },
                {
                  direction: props2.direction,
                  height: isNumber(props2.height) ? `${props2.height}px` : props2.height,
                  width: isNumber(props2.width) ? `${props2.width}px` : props2.width
                },
                (_a = props2.style) != null ? _a : {}
              ];
            });
            const innerStyle = computed(() => {
              const width = `${unref(estimatedTotalWidth)}px`;
              const height = `${unref(estimatedTotalHeight)}px`;
              return {
                height,
                pointerEvents: unref(states).isScrolling ? "none" : void 0,
                width
              };
            });
            const emitEvents = () => {
              const { totalColumn, totalRow } = props2;
              if (totalColumn > 0 && totalRow > 0) {
                const [
                  columnCacheStart,
                  columnCacheEnd,
                  columnVisibleStart,
                  columnVisibleEnd
                ] = unref(columnsToRender);
                const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = unref(rowsToRender);
                emit(ITEM_RENDER_EVT, {
                  columnCacheStart,
                  columnCacheEnd,
                  rowCacheStart,
                  rowCacheEnd,
                  columnVisibleStart,
                  columnVisibleEnd,
                  rowVisibleStart,
                  rowVisibleEnd
                });
              }
              const {
                scrollLeft,
                scrollTop,
                updateRequested,
                xAxisScrollDir,
                yAxisScrollDir
              } = unref(states);
              emit(SCROLL_EVT, {
                xAxisScrollDir,
                scrollLeft,
                yAxisScrollDir,
                scrollTop,
                updateRequested
              });
            };
            const onScroll = (e) => {
              const {
                clientHeight,
                clientWidth,
                scrollHeight,
                scrollLeft,
                scrollTop,
                scrollWidth
              } = e.currentTarget;
              const _states = unref(states);
              if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {
                return;
              }
              let _scrollLeft = scrollLeft;
              if (isRTL(props2.direction)) {
                switch (getRTLOffsetType()) {
                  case RTL_OFFSET_NAG:
                    _scrollLeft = -scrollLeft;
                    break;
                  case RTL_OFFSET_POS_DESC:
                    _scrollLeft = scrollWidth - clientWidth - scrollLeft;
                    break;
                }
              }
              states.value = {
                ..._states,
                isScrolling: true,
                scrollLeft: _scrollLeft,
                scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),
                updateRequested: true,
                xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),
                yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)
              };
              nextTick(() => resetIsScrolling());
              onUpdated2();
              emitEvents();
            };
            const onVerticalScroll = (distance, totalSteps) => {
              const height = unref(parsedHeight);
              const offset2 = (estimatedTotalHeight.value - height) / totalSteps * distance;
              scrollTo({
                scrollTop: Math.min(estimatedTotalHeight.value - height, offset2)
              });
            };
            const onHorizontalScroll = (distance, totalSteps) => {
              const width = unref(parsedWidth);
              const offset2 = (estimatedTotalWidth.value - width) / totalSteps * distance;
              scrollTo({
                scrollLeft: Math.min(estimatedTotalWidth.value - width, offset2)
              });
            };
            const { onWheel } = useGridWheel({
              atXStartEdge: computed(() => states.value.scrollLeft <= 0),
              atXEndEdge: computed(() => states.value.scrollLeft >= estimatedTotalWidth.value - unref(parsedWidth)),
              atYStartEdge: computed(() => states.value.scrollTop <= 0),
              atYEndEdge: computed(() => states.value.scrollTop >= estimatedTotalHeight.value - unref(parsedHeight))
            }, (x2, y) => {
              var _a, _b, _c, _d;
              (_b = (_a = hScrollbar.value) == null ? void 0 : _a.onMouseUp) == null ? void 0 : _b.call(_a);
              (_d = (_c = vScrollbar.value) == null ? void 0 : _c.onMouseUp) == null ? void 0 : _d.call(_c);
              const width = unref(parsedWidth);
              const height = unref(parsedHeight);
              scrollTo({
                scrollLeft: Math.min(states.value.scrollLeft + x2, estimatedTotalWidth.value - width),
                scrollTop: Math.min(states.value.scrollTop + y, estimatedTotalHeight.value - height)
              });
            });
            useEventListener(windowRef, "wheel", onWheel, {
              passive: false
            });
            const scrollTo = ({
              scrollLeft = states.value.scrollLeft,
              scrollTop = states.value.scrollTop
            }) => {
              scrollLeft = Math.max(scrollLeft, 0);
              scrollTop = Math.max(scrollTop, 0);
              const _states = unref(states);
              if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {
                return;
              }
              states.value = {
                ..._states,
                xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),
                yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),
                scrollLeft,
                scrollTop,
                updateRequested: true
              };
              nextTick(() => resetIsScrolling());
              onUpdated2();
              emitEvents();
            };
            const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = AUTO_ALIGNMENT) => {
              const _states = unref(states);
              columnIdx = Math.max(0, Math.min(columnIdx, props2.totalColumn - 1));
              rowIndex = Math.max(0, Math.min(rowIndex, props2.totalRow - 1));
              const scrollBarWidth2 = getScrollBarWidth(ns.namespace.value);
              const _cache = unref(cache2);
              const estimatedHeight = getEstimatedTotalHeight2(props2, _cache);
              const estimatedWidth = getEstimatedTotalWidth2(props2, _cache);
              scrollTo({
                scrollLeft: getColumnOffset(props2, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props2.width ? scrollBarWidth2 : 0),
                scrollTop: getRowOffset(props2, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props2.height ? scrollBarWidth2 : 0)
              });
            };
            const getItemStyle = (rowIndex, columnIndex) => {
              const { columnWidth, direction: direction2, rowHeight } = props2;
              const itemStyleCache = getItemStyleCache.value(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction2);
              const key = `${rowIndex},${columnIndex}`;
              if (hasOwn(itemStyleCache, key)) {
                return itemStyleCache[key];
              } else {
                const [, left] = getColumnPosition(props2, columnIndex, unref(cache2));
                const _cache = unref(cache2);
                const rtl = isRTL(direction2);
                const [height, top] = getRowPosition(props2, rowIndex, _cache);
                const [width] = getColumnPosition(props2, columnIndex, _cache);
                itemStyleCache[key] = {
                  position: "absolute",
                  left: rtl ? void 0 : `${left}px`,
                  right: rtl ? `${left}px` : void 0,
                  top: `${top}px`,
                  height: `${height}px`,
                  width: `${width}px`
                };
                return itemStyleCache[key];
              }
            };
            const resetIsScrolling = () => {
              states.value.isScrolling = false;
              nextTick(() => {
                getItemStyleCache.value(-1, null, null);
              });
            };
            onMounted(() => {
              if (!isClient)
                return;
              const { initScrollLeft, initScrollTop } = props2;
              const windowElement = unref(windowRef);
              if (windowElement) {
                if (isNumber(initScrollLeft)) {
                  windowElement.scrollLeft = initScrollLeft;
                }
                if (isNumber(initScrollTop)) {
                  windowElement.scrollTop = initScrollTop;
                }
              }
              emitEvents();
            });
            const onUpdated2 = () => {
              const { direction: direction2 } = props2;
              const { scrollLeft, scrollTop, updateRequested } = unref(states);
              const windowElement = unref(windowRef);
              if (updateRequested && windowElement) {
                if (direction2 === RTL) {
                  switch (getRTLOffsetType()) {
                    case RTL_OFFSET_NAG: {
                      windowElement.scrollLeft = -scrollLeft;
                      break;
                    }
                    case RTL_OFFSET_POS_ASC: {
                      windowElement.scrollLeft = scrollLeft;
                      break;
                    }
                    default: {
                      const { clientWidth, scrollWidth } = windowElement;
                      windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;
                      break;
                    }
                  }
                } else {
                  windowElement.scrollLeft = Math.max(0, scrollLeft);
                }
                windowElement.scrollTop = Math.max(0, scrollTop);
              }
            };
            const { resetAfterColumnIndex, resetAfterRowIndex, resetAfter } = instance.proxy;
            expose({
              windowRef,
              innerRef,
              getItemStyleCache,
              scrollTo,
              scrollToItem,
              states,
              resetAfterColumnIndex,
              resetAfterRowIndex,
              resetAfter
            });
            const renderScrollbars = () => {
              const {
                scrollbarAlwaysOn,
                scrollbarStartGap,
                scrollbarEndGap,
                totalColumn,
                totalRow
              } = props2;
              const width = unref(parsedWidth);
              const height = unref(parsedHeight);
              const estimatedWidth = unref(estimatedTotalWidth);
              const estimatedHeight = unref(estimatedTotalHeight);
              const { scrollLeft, scrollTop } = unref(states);
              const horizontalScrollbar = h$1(Scrollbar, {
                ref: hScrollbar,
                alwaysOn: scrollbarAlwaysOn,
                startGap: scrollbarStartGap,
                endGap: scrollbarEndGap,
                class: ns.e("horizontal"),
                clientSize: width,
                layout: "horizontal",
                onScroll: onHorizontalScroll,
                ratio: width * 100 / estimatedWidth,
                scrollFrom: scrollLeft / (estimatedWidth - width),
                total: totalRow,
                visible: true
              });
              const verticalScrollbar = h$1(Scrollbar, {
                ref: vScrollbar,
                alwaysOn: scrollbarAlwaysOn,
                startGap: scrollbarStartGap,
                endGap: scrollbarEndGap,
                class: ns.e("vertical"),
                clientSize: height,
                layout: "vertical",
                onScroll: onVerticalScroll,
                ratio: height * 100 / estimatedHeight,
                scrollFrom: scrollTop / (estimatedHeight - height),
                total: totalColumn,
                visible: true
              });
              return {
                horizontalScrollbar,
                verticalScrollbar
              };
            };
            const renderItems = () => {
              var _a;
              const [columnStart, columnEnd] = unref(columnsToRender);
              const [rowStart, rowEnd] = unref(rowsToRender);
              const { data, totalColumn, totalRow, useIsScrolling, itemKey } = props2;
              const children = [];
              if (totalRow > 0 && totalColumn > 0) {
                for (let row = rowStart; row <= rowEnd; row++) {
                  for (let column = columnStart; column <= columnEnd; column++) {
                    const key = itemKey({ columnIndex: column, data, rowIndex: row });
                    children.push(h$1(Fragment, { key }, (_a = slots.default) == null ? void 0 : _a.call(slots, {
                      columnIndex: column,
                      data,
                      isScrolling: useIsScrolling ? unref(states).isScrolling : void 0,
                      style: getItemStyle(row, column),
                      rowIndex: row
                    })));
                  }
                }
              }
              return children;
            };
            const renderInner = () => {
              const Inner = resolveDynamicComponent(props2.innerElement);
              const children = renderItems();
              return [
                h$1(Inner, {
                  style: unref(innerStyle),
                  ref: innerRef
                }, !isString$1(Inner) ? {
                  default: () => children
                } : children)
              ];
            };
            const renderWindow = () => {
              const Container2 = resolveDynamicComponent(props2.containerElement);
              const { horizontalScrollbar, verticalScrollbar } = renderScrollbars();
              const Inner = renderInner();
              return h$1("div", {
                key: 0,
                class: ns.e("wrapper"),
                role: props2.role
              }, [
                h$1(Container2, {
                  class: props2.className,
                  style: unref(windowStyle),
                  onScroll,
                  ref: windowRef
                }, !isString$1(Container2) ? { default: () => Inner } : Inner),
                horizontalScrollbar,
                verticalScrollbar
              ]);
            };
            return renderWindow;
          }
        });
      };
      var createGrid$1 = createGrid;
      const FixedSizeGrid = createGrid$1({
        name: "ElFixedSizeGrid",
        getColumnPosition: ({ columnWidth }, index2) => [
          columnWidth,
          index2 * columnWidth
        ],
        getRowPosition: ({ rowHeight }, index2) => [
          rowHeight,
          index2 * rowHeight
        ],
        getEstimatedTotalHeight: ({ totalRow, rowHeight }) => rowHeight * totalRow,
        getEstimatedTotalWidth: ({ totalColumn, columnWidth }) => columnWidth * totalColumn,
        getColumnOffset: ({ totalColumn, columnWidth, width }, columnIndex, alignment, scrollLeft, _2, scrollBarWidth2) => {
          width = Number(width);
          const lastColumnOffset = Math.max(0, totalColumn * columnWidth - width);
          const maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);
          const minOffset = Math.max(0, columnIndex * columnWidth - width + scrollBarWidth2 + columnWidth);
          if (alignment === "smart") {
            if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {
              alignment = AUTO_ALIGNMENT;
            } else {
              alignment = CENTERED_ALIGNMENT;
            }
          }
          switch (alignment) {
            case START_ALIGNMENT:
              return maxOffset;
            case END_ALIGNMENT:
              return minOffset;
            case CENTERED_ALIGNMENT: {
              const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
              if (middleOffset < Math.ceil(width / 2)) {
                return 0;
              } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {
                return lastColumnOffset;
              } else {
                return middleOffset;
              }
            }
            case AUTO_ALIGNMENT:
            default:
              if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {
                return scrollLeft;
              } else if (minOffset > maxOffset) {
                return minOffset;
              } else if (scrollLeft < minOffset) {
                return minOffset;
              } else {
                return maxOffset;
              }
          }
        },
        getRowOffset: ({ rowHeight, height, totalRow }, rowIndex, align, scrollTop, _2, scrollBarWidth2) => {
          height = Number(height);
          const lastRowOffset = Math.max(0, totalRow * rowHeight - height);
          const maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);
          const minOffset = Math.max(0, rowIndex * rowHeight - height + scrollBarWidth2 + rowHeight);
          if (align === SMART_ALIGNMENT) {
            if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {
              align = AUTO_ALIGNMENT;
            } else {
              align = CENTERED_ALIGNMENT;
            }
          }
          switch (align) {
            case START_ALIGNMENT:
              return maxOffset;
            case END_ALIGNMENT:
              return minOffset;
            case CENTERED_ALIGNMENT: {
              const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);
              if (middleOffset < Math.ceil(height / 2)) {
                return 0;
              } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {
                return lastRowOffset;
              } else {
                return middleOffset;
              }
            }
            case AUTO_ALIGNMENT:
            default:
              if (scrollTop >= minOffset && scrollTop <= maxOffset) {
                return scrollTop;
              } else if (minOffset > maxOffset) {
                return minOffset;
              } else if (scrollTop < minOffset) {
                return minOffset;
              } else {
                return maxOffset;
              }
          }
        },
        getColumnStartIndexForOffset: ({ columnWidth, totalColumn }, scrollLeft) => Math.max(0, Math.min(totalColumn - 1, Math.floor(scrollLeft / columnWidth))),
        getColumnStopIndexForStartIndex: ({ columnWidth, totalColumn, width }, startIndex, scrollLeft) => {
          const left = startIndex * columnWidth;
          const visibleColumnsCount = Math.ceil((width + scrollLeft - left) / columnWidth);
          return Math.max(0, Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1));
        },
        getRowStartIndexForOffset: ({ rowHeight, totalRow }, scrollTop) => Math.max(0, Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight))),
        getRowStopIndexForStartIndex: ({ rowHeight, totalRow, height }, startIndex, scrollTop) => {
          const top = startIndex * rowHeight;
          const numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);
          return Math.max(0, Math.min(totalRow - 1, startIndex + numVisibleRows - 1));
        },
        initCache: () => void 0,
        clearCache: true,
        validateProps: ({ columnWidth, rowHeight }) => {
        }
      });
      var FixedSizeGrid$1 = exports("FixedSizeGrid", FixedSizeGrid);
      const { max: max$2, min: min$2, floor } = Math;
      const ACCESS_SIZER_KEY_MAP = {
        column: "columnWidth",
        row: "rowHeight"
      };
      const ACCESS_LAST_VISITED_KEY_MAP = {
        column: "lastVisitedColumnIndex",
        row: "lastVisitedRowIndex"
      };
      const getItemFromCache = (props2, index2, gridCache, type) => {
        const [cachedItems, sizer, lastVisited] = [
          gridCache[type],
          props2[ACCESS_SIZER_KEY_MAP[type]],
          gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]
        ];
        if (index2 > lastVisited) {
          let offset2 = 0;
          if (lastVisited >= 0) {
            const item = cachedItems[lastVisited];
            offset2 = item.offset + item.size;
          }
          for (let i = lastVisited + 1; i <= index2; i++) {
            const size = sizer(i);
            cachedItems[i] = {
              offset: offset2,
              size
            };
            offset2 += size;
          }
          gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index2;
        }
        return cachedItems[index2];
      };
      const bs = (props2, gridCache, low, high, offset2, type) => {
        while (low <= high) {
          const mid = low + floor((high - low) / 2);
          const currentOffset = getItemFromCache(props2, mid, gridCache, type).offset;
          if (currentOffset === offset2) {
            return mid;
          } else if (currentOffset < offset2) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        return max$2(0, low - 1);
      };
      const es = (props2, gridCache, idx, offset2, type) => {
        const total2 = type === "column" ? props2.totalColumn : props2.totalRow;
        let exponent = 1;
        while (idx < total2 && getItemFromCache(props2, idx, gridCache, type).offset < offset2) {
          idx += exponent;
          exponent *= 2;
        }
        return bs(props2, gridCache, floor(idx / 2), min$2(idx, total2 - 1), offset2, type);
      };
      const findItem = (props2, gridCache, offset2, type) => {
        const [cache2, lastVisitedIndex] = [
          gridCache[type],
          gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]
        ];
        const lastVisitedItemOffset = lastVisitedIndex > 0 ? cache2[lastVisitedIndex].offset : 0;
        if (lastVisitedItemOffset >= offset2) {
          return bs(props2, gridCache, 0, lastVisitedIndex, offset2, type);
        }
        return es(props2, gridCache, max$2(0, lastVisitedIndex), offset2, type);
      };
      const getEstimatedTotalHeight = ({ totalRow }, { estimatedRowHeight, lastVisitedRowIndex, row }) => {
        let sizeOfVisitedRows = 0;
        if (lastVisitedRowIndex >= totalRow) {
          lastVisitedRowIndex = totalRow - 1;
        }
        if (lastVisitedRowIndex >= 0) {
          const item = row[lastVisitedRowIndex];
          sizeOfVisitedRows = item.offset + item.size;
        }
        const unvisitedItems = totalRow - lastVisitedRowIndex - 1;
        const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;
        return sizeOfVisitedRows + sizeOfUnvisitedItems;
      };
      const getEstimatedTotalWidth = ({ totalColumn }, { column, estimatedColumnWidth, lastVisitedColumnIndex }) => {
        let sizeOfVisitedColumns = 0;
        if (lastVisitedColumnIndex > totalColumn) {
          lastVisitedColumnIndex = totalColumn - 1;
        }
        if (lastVisitedColumnIndex >= 0) {
          const item = column[lastVisitedColumnIndex];
          sizeOfVisitedColumns = item.offset + item.size;
        }
        const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;
        const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;
        return sizeOfVisitedColumns + sizeOfUnvisitedItems;
      };
      const ACCESS_ESTIMATED_SIZE_KEY_MAP = {
        column: getEstimatedTotalWidth,
        row: getEstimatedTotalHeight
      };
      const getOffset$1 = (props2, index2, alignment, scrollOffset, cache2, type, scrollBarWidth2) => {
        const [size, estimatedSizeAssociates] = [
          type === "row" ? props2.height : props2.width,
          ACCESS_ESTIMATED_SIZE_KEY_MAP[type]
        ];
        const item = getItemFromCache(props2, index2, cache2, type);
        const estimatedSize = estimatedSizeAssociates(props2, cache2);
        const maxOffset = max$2(0, min$2(estimatedSize - size, item.offset));
        const minOffset = max$2(0, item.offset - size + scrollBarWidth2 + item.size);
        if (alignment === SMART_ALIGNMENT) {
          if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {
            alignment = AUTO_ALIGNMENT;
          } else {
            alignment = CENTERED_ALIGNMENT;
          }
        }
        switch (alignment) {
          case START_ALIGNMENT: {
            return maxOffset;
          }
          case END_ALIGNMENT: {
            return minOffset;
          }
          case CENTERED_ALIGNMENT: {
            return Math.round(minOffset + (maxOffset - minOffset) / 2);
          }
          case AUTO_ALIGNMENT:
          default: {
            if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {
              return scrollOffset;
            } else if (minOffset > maxOffset) {
              return minOffset;
            } else if (scrollOffset < minOffset) {
              return minOffset;
            } else {
              return maxOffset;
            }
          }
        }
      };
      const DynamicSizeGrid = createGrid$1({
        name: "ElDynamicSizeGrid",
        getColumnPosition: (props2, idx, cache2) => {
          const item = getItemFromCache(props2, idx, cache2, "column");
          return [item.size, item.offset];
        },
        getRowPosition: (props2, idx, cache2) => {
          const item = getItemFromCache(props2, idx, cache2, "row");
          return [item.size, item.offset];
        },
        getColumnOffset: (props2, columnIndex, alignment, scrollLeft, cache2, scrollBarWidth2) => getOffset$1(props2, columnIndex, alignment, scrollLeft, cache2, "column", scrollBarWidth2),
        getRowOffset: (props2, rowIndex, alignment, scrollTop, cache2, scrollBarWidth2) => getOffset$1(props2, rowIndex, alignment, scrollTop, cache2, "row", scrollBarWidth2),
        getColumnStartIndexForOffset: (props2, scrollLeft, cache2) => findItem(props2, cache2, scrollLeft, "column"),
        getColumnStopIndexForStartIndex: (props2, startIndex, scrollLeft, cache2) => {
          const item = getItemFromCache(props2, startIndex, cache2, "column");
          const maxOffset = scrollLeft + props2.width;
          let offset2 = item.offset + item.size;
          let stopIndex = startIndex;
          while (stopIndex < props2.totalColumn - 1 && offset2 < maxOffset) {
            stopIndex++;
            offset2 += getItemFromCache(props2, startIndex, cache2, "column").size;
          }
          return stopIndex;
        },
        getEstimatedTotalHeight,
        getEstimatedTotalWidth,
        getRowStartIndexForOffset: (props2, scrollTop, cache2) => findItem(props2, cache2, scrollTop, "row"),
        getRowStopIndexForStartIndex: (props2, startIndex, scrollTop, cache2) => {
          const { totalRow, height } = props2;
          const item = getItemFromCache(props2, startIndex, cache2, "row");
          const maxOffset = scrollTop + height;
          let offset2 = item.size + item.offset;
          let stopIndex = startIndex;
          while (stopIndex < totalRow - 1 && offset2 < maxOffset) {
            stopIndex++;
            offset2 += getItemFromCache(props2, stopIndex, cache2, "row").size;
          }
          return stopIndex;
        },
        injectToInstance: (instance, cache2) => {
          const resetAfter = ({ columnIndex, rowIndex }, forceUpdate) => {
            var _a, _b;
            forceUpdate = isUndefined(forceUpdate) ? true : forceUpdate;
            if (isNumber(columnIndex)) {
              cache2.value.lastVisitedColumnIndex = Math.min(cache2.value.lastVisitedColumnIndex, columnIndex - 1);
            }
            if (isNumber(rowIndex)) {
              cache2.value.lastVisitedRowIndex = Math.min(cache2.value.lastVisitedRowIndex, rowIndex - 1);
            }
            (_a = instance.exposed) == null ? void 0 : _a.getItemStyleCache.value(-1, null, null);
            if (forceUpdate)
              (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();
          };
          const resetAfterColumnIndex = (columnIndex, forceUpdate) => {
            resetAfter({
              columnIndex
            }, forceUpdate);
          };
          const resetAfterRowIndex = (rowIndex, forceUpdate) => {
            resetAfter({
              rowIndex
            }, forceUpdate);
          };
          Object.assign(instance.proxy, {
            resetAfterColumnIndex,
            resetAfterRowIndex,
            resetAfter
          });
        },
        initCache: ({
          estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,
          estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE
        }) => {
          const cache2 = {
            column: {},
            estimatedColumnWidth,
            estimatedRowHeight,
            lastVisitedColumnIndex: -1,
            lastVisitedRowIndex: -1,
            row: {}
          };
          return cache2;
        },
        clearCache: false,
        validateProps: ({ columnWidth, rowHeight }) => {
        }
      });
      var DynamicSizeGrid$1 = exports("DynamicSizeGrid", DynamicSizeGrid);
      const _sfc_main$R = defineComponent({
        props: {
          item: {
            type: Object,
            required: true
          },
          style: {
            type: Object
          },
          height: Number
        },
        setup() {
          const ns = useNamespace("select");
          return {
            ns
          };
        }
      });
      function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(_ctx.ns.be("group", "title")),
          style: normalizeStyle({ ..._ctx.style, lineHeight: `${_ctx.height}px` })
        }, toDisplayString(_ctx.item.label), 7);
      }
      var GroupItem = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$7], ["__file", "group-item.vue"]]);
      function useOption(props2, { emit }) {
        return {
          hoverItem: () => {
            if (!props2.disabled) {
              emit("hover", props2.index);
            }
          },
          selectOptionClick: () => {
            if (!props2.disabled) {
              emit("select", props2.item, props2.index);
            }
          }
        };
      }
      const defaultProps$5 = {
        label: "label",
        value: "value",
        disabled: "disabled",
        options: "options"
      };
      function useProps(props2) {
        const aliasProps = computed(() => ({ ...defaultProps$5, ...props2.props }));
        const getLabel = (option) => get(option, aliasProps.value.label);
        const getValue2 = (option) => get(option, aliasProps.value.value);
        const getDisabled = (option) => get(option, aliasProps.value.disabled);
        const getOptions = (option) => get(option, aliasProps.value.options);
        return {
          aliasProps,
          getLabel,
          getValue: getValue2,
          getDisabled,
          getOptions
        };
      }
      const selectV2Props = buildProps({
        allowCreate: Boolean,
        autocomplete: {
          type: definePropType(String),
          default: "none"
        },
        automaticDropdown: Boolean,
        clearable: Boolean,
        clearIcon: {
          type: iconPropType,
          default: circle_close_default$1
        },
        effect: {
          type: definePropType(String),
          default: "light"
        },
        collapseTags: Boolean,
        collapseTagsTooltip: Boolean,
        maxCollapseTags: {
          type: Number,
          default: 1
        },
        defaultFirstOption: Boolean,
        disabled: Boolean,
        estimatedOptionHeight: {
          type: Number,
          default: void 0
        },
        filterable: Boolean,
        filterMethod: {
          type: definePropType(Function)
        },
        height: {
          type: Number,
          default: 274
        },
        itemHeight: {
          type: Number,
          default: 34
        },
        id: String,
        loading: Boolean,
        loadingText: String,
        modelValue: {
          type: definePropType([Array, String, Number, Boolean, Object]),
          default: void 0
        },
        multiple: Boolean,
        multipleLimit: {
          type: Number,
          default: 0
        },
        name: String,
        noDataText: String,
        noMatchText: String,
        remoteMethod: {
          type: definePropType(Function)
        },
        reserveKeyword: {
          type: Boolean,
          default: true
        },
        options: {
          type: definePropType(Array),
          required: true
        },
        placeholder: {
          type: String
        },
        teleported: useTooltipContentProps.teleported,
        persistent: {
          type: Boolean,
          default: true
        },
        popperClass: {
          type: String,
          default: ""
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        },
        remote: Boolean,
        size: useSizeProp,
        props: {
          type: definePropType(Object),
          default: () => defaultProps$5
        },
        valueKey: {
          type: String,
          default: "value"
        },
        scrollbarAlwaysOn: Boolean,
        validateEvent: {
          type: Boolean,
          default: true
        },
        offset: {
          type: Number,
          default: 12
        },
        showArrow: {
          type: Boolean,
          default: true
        },
        placement: {
          type: definePropType(String),
          values: Ee,
          default: "bottom-start"
        },
        fallbackPlacements: {
          type: definePropType(Array),
          default: ["bottom-start", "top-start", "right", "left"]
        },
        tagType: { ...tagProps.type, default: "info" },
        tagEffect: { ...tagProps.effect, default: "light" },
        tabindex: {
          type: [String, Number],
          default: 0
        },
        appendTo: useTooltipContentProps.appendTo,
        fitInputWidth: {
          type: [Boolean, Number],
          default: true,
          validator(val) {
            return isBoolean(val) || isNumber(val);
          }
        },
        suffixIcon: {
          type: iconPropType,
          default: arrow_down_default$1
        },
        ...useEmptyValuesProps,
        ...useAriaProps(["ariaLabel"])
      });
      const optionV2Props = buildProps({
        data: Array,
        disabled: Boolean,
        hovering: Boolean,
        item: {
          type: definePropType(Object),
          required: true
        },
        index: Number,
        style: Object,
        selected: Boolean,
        created: Boolean
      });
      const selectV2Emits = {
        [UPDATE_MODEL_EVENT]: (val) => true,
        [CHANGE_EVENT]: (val) => true,
        "remove-tag": (val) => true,
        "visible-change": (visible) => true,
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent,
        clear: () => true
      };
      const optionV2Emits = {
        hover: (index2) => isNumber(index2),
        select: (val, index2) => true
      };
      const selectV2InjectionKey = exports("selectV2InjectionKey", Symbol("ElSelectV2Injection"));
      const _sfc_main$Q = defineComponent({
        props: optionV2Props,
        emits: optionV2Emits,
        setup(props2, { emit }) {
          const select = inject(selectV2InjectionKey);
          const ns = useNamespace("select");
          const { hoverItem, selectOptionClick } = useOption(props2, { emit });
          const { getLabel } = useProps(select.props);
          return {
            ns,
            hoverItem,
            selectOptionClick,
            getLabel
          };
        }
      });
      function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("li", {
          "aria-selected": _ctx.selected,
          style: normalizeStyle(_ctx.style),
          class: normalizeClass([
            _ctx.ns.be("dropdown", "item"),
            _ctx.ns.is("selected", _ctx.selected),
            _ctx.ns.is("disabled", _ctx.disabled),
            _ctx.ns.is("created", _ctx.created),
            _ctx.ns.is("hovering", _ctx.hovering)
          ]),
          onMousemove: _ctx.hoverItem,
          onClick: withModifiers(_ctx.selectOptionClick, ["stop"])
        }, [
          renderSlot(_ctx.$slots, "default", {
            item: _ctx.item,
            index: _ctx.index,
            disabled: _ctx.disabled
          }, () => [
            createElementVNode("span", null, toDisplayString(_ctx.getLabel(_ctx.item)), 1)
          ])
        ], 46, ["aria-selected", "onMousemove", "onClick"]);
      }
      var OptionItem = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$6], ["__file", "option-item.vue"]]);
      const props = {
        loading: Boolean,
        data: {
          type: Array,
          required: true
        },
        hoveringIndex: Number,
        width: Number
      };
      var ElSelectMenu = defineComponent({
        name: "ElSelectDropdown",
        props,
        setup(props2, {
          slots,
          expose
        }) {
          const select = inject(selectV2InjectionKey);
          const ns = useNamespace("select");
          const {
            getLabel,
            getValue: getValue2,
            getDisabled
          } = useProps(select.props);
          const cachedHeights = ref([]);
          const listRef = ref();
          const size = computed(() => props2.data.length);
          watch(() => size.value, () => {
            var _a, _b;
            (_b = (_a = select.tooltipRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
          });
          const isSized = computed(() => isUndefined(select.props.estimatedOptionHeight));
          const listProps = computed(() => {
            if (isSized.value) {
              return {
                itemSize: select.props.itemHeight
              };
            }
            return {
              estimatedSize: select.props.estimatedOptionHeight,
              itemSize: (idx) => cachedHeights.value[idx]
            };
          });
          const contains2 = (arr = [], target2) => {
            const {
              props: {
                valueKey
              }
            } = select;
            if (!isObject$1(target2)) {
              return arr.includes(target2);
            }
            return arr && arr.some((item) => {
              return toRaw(get(item, valueKey)) === get(target2, valueKey);
            });
          };
          const isEqual2 = (selected, target2) => {
            if (!isObject$1(target2)) {
              return selected === target2;
            } else {
              const {
                valueKey
              } = select.props;
              return get(selected, valueKey) === get(target2, valueKey);
            }
          };
          const isItemSelected = (modelValue, target2) => {
            if (select.props.multiple) {
              return contains2(modelValue, getValue2(target2));
            }
            return isEqual2(modelValue, getValue2(target2));
          };
          const isItemDisabled = (modelValue, selected) => {
            const {
              disabled,
              multiple,
              multipleLimit
            } = select.props;
            return disabled || !selected && (multiple ? multipleLimit > 0 && modelValue.length >= multipleLimit : false);
          };
          const isItemHovering = (target2) => props2.hoveringIndex === target2;
          const scrollToItem = (index2) => {
            const list = listRef.value;
            if (list) {
              list.scrollToItem(index2);
            }
          };
          const resetScrollTop = () => {
            const list = listRef.value;
            if (list) {
              list.resetScrollTop();
            }
          };
          const exposed = {
            listRef,
            isSized,
            isItemDisabled,
            isItemHovering,
            isItemSelected,
            scrollToItem,
            resetScrollTop
          };
          expose(exposed);
          const Item = (itemProps) => {
            const {
              index: index2,
              data,
              style
            } = itemProps;
            const sized = unref(isSized);
            const {
              itemSize: itemSize2,
              estimatedSize
            } = unref(listProps);
            const {
              modelValue
            } = select.props;
            const {
              onSelect,
              onHover
            } = select;
            const item = data[index2];
            if (item.type === "Group") {
              return createVNode(GroupItem, {
                "item": item,
                "style": style,
                "height": sized ? itemSize2 : estimatedSize
              }, null);
            }
            const isSelected = isItemSelected(modelValue, item);
            const isDisabled = isItemDisabled(modelValue, isSelected);
            const isHovering = isItemHovering(index2);
            return createVNode(OptionItem, mergeProps(itemProps, {
              "selected": isSelected,
              "disabled": getDisabled(item) || isDisabled,
              "created": !!item.created,
              "hovering": isHovering,
              "item": item,
              "onSelect": onSelect,
              "onHover": onHover
            }), {
              default: (props3) => {
                var _a;
                return ((_a = slots.default) == null ? void 0 : _a.call(slots, props3)) || createVNode("span", null, [getLabel(item)]);
              }
            });
          };
          const {
            onKeyboardNavigate,
            onKeyboardSelect
          } = select;
          const onForward = () => {
            onKeyboardNavigate("forward");
          };
          const onBackward = () => {
            onKeyboardNavigate("backward");
          };
          const onKeydown = (e) => {
            const {
              code
            } = e;
            const {
              tab,
              esc,
              down,
              up,
              enter,
              numpadEnter
            } = EVENT_CODE;
            if ([esc, down, up, enter, numpadEnter].includes(code)) {
              e.preventDefault();
              e.stopPropagation();
            }
            switch (code) {
              case tab:
              case esc:
                break;
              case down:
                onForward();
                break;
              case up:
                onBackward();
                break;
              case enter:
              case numpadEnter:
                onKeyboardSelect();
                break;
            }
          };
          return () => {
            var _a, _b, _c, _d;
            const {
              data,
              width
            } = props2;
            const {
              height,
              multiple,
              scrollbarAlwaysOn
            } = select.props;
            const isScrollbarAlwaysOn = computed(() => {
              return isIOS ? true : scrollbarAlwaysOn;
            });
            const List = unref(isSized) ? FixedSizeList$1 : DynamicSizeList$1;
            return createVNode("div", {
              "class": [ns.b("dropdown"), ns.is("multiple", multiple)],
              "style": {
                width: `${width}px`
              }
            }, [(_a = slots.header) == null ? void 0 : _a.call(slots), ((_b = slots.loading) == null ? void 0 : _b.call(slots)) || ((_c = slots.empty) == null ? void 0 : _c.call(slots)) || createVNode(List, mergeProps({
              "ref": listRef
            }, unref(listProps), {
              "className": ns.be("dropdown", "list"),
              "scrollbarAlwaysOn": isScrollbarAlwaysOn.value,
              "data": data,
              "height": height,
              "width": width,
              "total": data.length,
              "onKeydown": onKeydown
            }), {
              default: (props3) => createVNode(Item, props3, null)
            }), (_d = slots.footer) == null ? void 0 : _d.call(slots)]);
          };
        }
      });
      function useAllowCreate(props2, states) {
        const { aliasProps, getLabel, getValue: getValue2 } = useProps(props2);
        const createOptionCount = ref(0);
        const cachedSelectedOption = ref();
        const enableAllowCreateMode = computed(() => {
          return props2.allowCreate && props2.filterable;
        });
        watch(() => props2.options, (options) => {
          const optionLabelsSet = new Set(options.map((option) => getLabel(option)));
          states.createdOptions = states.createdOptions.filter((createdOption) => !optionLabelsSet.has(getLabel(createdOption)));
        });
        function hasExistingOption(query) {
          const hasOption = (option) => getLabel(option) === query;
          return props2.options && props2.options.some(hasOption) || states.createdOptions.some(hasOption);
        }
        function selectNewOption(option) {
          if (!enableAllowCreateMode.value) {
            return;
          }
          if (props2.multiple && option.created) {
            createOptionCount.value++;
          } else {
            cachedSelectedOption.value = option;
          }
        }
        function createNewOption(query) {
          if (enableAllowCreateMode.value) {
            if (query && query.length > 0) {
              if (hasExistingOption(query)) {
                states.createdOptions = states.createdOptions.filter((createdOption) => getLabel(createdOption) !== states.previousQuery);
                return;
              }
              const newOption = {
                [aliasProps.value.value]: query,
                [aliasProps.value.label]: query,
                created: true,
                [aliasProps.value.disabled]: false
              };
              if (states.createdOptions.length >= createOptionCount.value) {
                states.createdOptions[createOptionCount.value] = newOption;
              } else {
                states.createdOptions.push(newOption);
              }
            } else {
              if (props2.multiple) {
                states.createdOptions.length = createOptionCount.value;
              } else {
                const selectedOption = cachedSelectedOption.value;
                states.createdOptions.length = 0;
                if (selectedOption && selectedOption.created) {
                  states.createdOptions.push(selectedOption);
                }
              }
            }
          }
        }
        function removeNewOption(option) {
          if (!enableAllowCreateMode.value || !option || !option.created || option.created && props2.reserveKeyword && states.inputValue === getLabel(option)) {
            return;
          }
          const idx = states.createdOptions.findIndex((it2) => getValue2(it2) === getValue2(option));
          if (~idx) {
            states.createdOptions.splice(idx, 1);
            createOptionCount.value--;
          }
        }
        function clearAllNewOption() {
          if (enableAllowCreateMode.value) {
            states.createdOptions.length = 0;
            createOptionCount.value = 0;
          }
        }
        return {
          createNewOption,
          removeNewOption,
          selectNewOption,
          clearAllNewOption
        };
      }
      const useSelect$1 = (props2, emit) => {
        const { t } = useLocale();
        const nsSelect = useNamespace("select");
        const nsInput = useNamespace("input");
        const { form: elForm, formItem: elFormItem } = useFormItem();
        const { inputId } = useFormItemInputId(props2, {
          formItemContext: elFormItem
        });
        const { aliasProps, getLabel, getValue: getValue2, getDisabled, getOptions } = useProps(props2);
        const { valueOnClear, isEmptyValue: isEmptyValue2 } = useEmptyValues(props2);
        const states = reactive({
          inputValue: "",
          cachedOptions: [],
          createdOptions: [],
          hoveringIndex: -1,
          inputHovering: false,
          selectionWidth: 0,
          collapseItemWidth: 0,
          previousQuery: null,
          previousValue: void 0,
          selectedLabel: "",
          menuVisibleOnFocus: false,
          isBeforeHide: false
        });
        const popperSize = ref(-1);
        const selectRef = ref();
        const selectionRef = ref();
        const tooltipRef = ref();
        const tagTooltipRef = ref();
        const inputRef = ref();
        const prefixRef = ref();
        const suffixRef = ref();
        const menuRef = ref();
        const tagMenuRef = ref();
        const collapseItemRef = ref();
        const {
          isComposing,
          handleCompositionStart,
          handleCompositionEnd,
          handleCompositionUpdate
        } = useComposition({
          afterComposition: (e) => onInput(e)
        });
        const selectDisabled = computed(() => props2.disabled || !!(elForm == null ? void 0 : elForm.disabled));
        const { wrapperRef, isFocused, handleBlur } = useFocusController(inputRef, {
          disabled: selectDisabled,
          afterFocus() {
            if (props2.automaticDropdown && !expanded.value) {
              expanded.value = true;
              states.menuVisibleOnFocus = true;
            }
          },
          beforeBlur(event) {
            var _a, _b;
            return ((_a = tooltipRef.value) == null ? void 0 : _a.isFocusInsideContent(event)) || ((_b = tagTooltipRef.value) == null ? void 0 : _b.isFocusInsideContent(event));
          },
          afterBlur() {
            var _a;
            expanded.value = false;
            states.menuVisibleOnFocus = false;
            if (props2.validateEvent) {
              (_a = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "blur").catch((err) => debugWarn());
            }
          }
        });
        const allOptions = computed(() => filterOptions(""));
        const hasOptions = computed(() => {
          if (props2.loading)
            return false;
          return props2.options.length > 0 || states.createdOptions.length > 0;
        });
        const filteredOptions = ref([]);
        const expanded = ref(false);
        const needStatusIcon = computed(() => {
          var _a;
          return (_a = elForm == null ? void 0 : elForm.statusIcon) != null ? _a : false;
        });
        const popupHeight = computed(() => {
          const totalHeight = filteredOptions.value.length * props2.itemHeight;
          return totalHeight > props2.height ? props2.height : totalHeight;
        });
        const hasModelValue = computed(() => {
          return props2.multiple ? isArray$1(props2.modelValue) && props2.modelValue.length > 0 : !isEmptyValue2(props2.modelValue);
        });
        const showClearBtn = computed(() => {
          return props2.clearable && !selectDisabled.value && states.inputHovering && hasModelValue.value;
        });
        const iconComponent = computed(() => props2.remote && props2.filterable ? "" : props2.suffixIcon);
        const iconReverse = computed(() => iconComponent.value && nsSelect.is("reverse", expanded.value));
        const validateState = computed(() => (elFormItem == null ? void 0 : elFormItem.validateState) || "");
        const validateIcon = computed(() => {
          if (!validateState.value)
            return;
          return ValidateComponentsMap[validateState.value];
        });
        const debounce$1 = computed(() => props2.remote ? 300 : 0);
        const emptyText = computed(() => {
          if (props2.loading) {
            return props2.loadingText || t("el.select.loading");
          } else {
            if (props2.remote && !states.inputValue && !hasOptions.value)
              return false;
            if (props2.filterable && states.inputValue && hasOptions.value && filteredOptions.value.length === 0) {
              return props2.noMatchText || t("el.select.noMatch");
            }
            if (!hasOptions.value) {
              return props2.noDataText || t("el.select.noData");
            }
          }
          return null;
        });
        const isFilterMethodValid = computed(() => props2.filterable && isFunction$1(props2.filterMethod));
        const isRemoteMethodValid = computed(() => props2.filterable && props2.remote && isFunction$1(props2.remoteMethod));
        const filterOptions = (query) => {
          const regexp = new RegExp(escapeStringRegexp(query), "i");
          const isValidOption = (o2) => {
            if (isFilterMethodValid.value || isRemoteMethodValid.value)
              return true;
            return query ? regexp.test(getLabel(o2) || "") : true;
          };
          if (props2.loading) {
            return [];
          }
          return [...states.createdOptions, ...props2.options].reduce((all, item) => {
            const options = getOptions(item);
            if (isArray$1(options)) {
              const filtered = options.filter(isValidOption);
              if (filtered.length > 0) {
                all.push({
                  label: getLabel(item),
                  type: "Group"
                }, ...filtered);
              }
            } else if (props2.remote || isValidOption(item)) {
              all.push(item);
            }
            return all;
          }, []);
        };
        const updateOptions2 = () => {
          filteredOptions.value = filterOptions(states.inputValue);
        };
        const allOptionsValueMap = computed(() => {
          const valueMap = /* @__PURE__ */ new Map();
          allOptions.value.forEach((option, index2) => {
            valueMap.set(getValueKey(getValue2(option)), { option, index: index2 });
          });
          return valueMap;
        });
        const filteredOptionsValueMap = computed(() => {
          const valueMap = /* @__PURE__ */ new Map();
          filteredOptions.value.forEach((option, index2) => {
            valueMap.set(getValueKey(getValue2(option)), { option, index: index2 });
          });
          return valueMap;
        });
        const optionsAllDisabled = computed(() => filteredOptions.value.every((option) => getDisabled(option)));
        const selectSize = useFormSize();
        const collapseTagSize = computed(() => selectSize.value === "small" ? "small" : "default");
        const calculatePopperSize = () => {
          var _a;
          if (isNumber(props2.fitInputWidth)) {
            popperSize.value = props2.fitInputWidth;
            return;
          }
          const width = ((_a = selectRef.value) == null ? void 0 : _a.offsetWidth) || 200;
          if (!props2.fitInputWidth && hasOptions.value) {
            nextTick(() => {
              popperSize.value = Math.max(width, calculateLabelMaxWidth());
            });
          } else {
            popperSize.value = width;
          }
        };
        const calculateLabelMaxWidth = () => {
          var _a, _b;
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          const selector = nsSelect.be("dropdown", "item");
          const dom = ((_b = (_a = menuRef.value) == null ? void 0 : _a.listRef) == null ? void 0 : _b.innerRef) || document;
          const dropdownItemEl = dom.querySelector(`.${selector}`);
          if (dropdownItemEl === null || ctx === null)
            return 0;
          const style = getComputedStyle(dropdownItemEl);
          const padding = Number.parseFloat(style.paddingLeft) + Number.parseFloat(style.paddingRight);
          ctx.font = `bold ${style.font.replace(new RegExp(`\\b${style.fontWeight}\\b`), "")}`;
          const maxWidth = filteredOptions.value.reduce((max2, option) => {
            const metrics = ctx.measureText(getLabel(option));
            return Math.max(metrics.width, max2);
          }, 0);
          return maxWidth + padding;
        };
        const getGapWidth = () => {
          if (!selectionRef.value)
            return 0;
          const style = window.getComputedStyle(selectionRef.value);
          return Number.parseFloat(style.gap || "6px");
        };
        const tagStyle = computed(() => {
          const gapWidth = getGapWidth();
          const maxWidth = collapseItemRef.value && props2.maxCollapseTags === 1 ? states.selectionWidth - states.collapseItemWidth - gapWidth : states.selectionWidth;
          return { maxWidth: `${maxWidth}px` };
        });
        const collapseTagStyle = computed(() => {
          return { maxWidth: `${states.selectionWidth}px` };
        });
        const shouldShowPlaceholder = computed(() => {
          if (isArray$1(props2.modelValue)) {
            return props2.modelValue.length === 0 && !states.inputValue;
          }
          return props2.filterable ? !states.inputValue : true;
        });
        const currentPlaceholder = computed(() => {
          var _a;
          const _placeholder = (_a = props2.placeholder) != null ? _a : t("el.select.placeholder");
          return props2.multiple || !hasModelValue.value ? _placeholder : states.selectedLabel;
        });
        const popperRef = computed(() => {
          var _a, _b;
          return (_b = (_a = tooltipRef.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
        });
        const indexRef = computed(() => {
          if (props2.multiple) {
            const len = props2.modelValue.length;
            if (props2.modelValue.length > 0 && filteredOptionsValueMap.value.has(props2.modelValue[len - 1])) {
              const { index: index2 } = filteredOptionsValueMap.value.get(props2.modelValue[len - 1]);
              return index2;
            }
          } else {
            if (!isEmptyValue2(props2.modelValue) && filteredOptionsValueMap.value.has(props2.modelValue)) {
              const { index: index2 } = filteredOptionsValueMap.value.get(props2.modelValue);
              return index2;
            }
          }
          return -1;
        });
        const dropdownMenuVisible = computed({
          get() {
            return expanded.value && emptyText.value !== false;
          },
          set(val) {
            expanded.value = val;
          }
        });
        const showTagList = computed(() => {
          if (!props2.multiple) {
            return [];
          }
          return props2.collapseTags ? states.cachedOptions.slice(0, props2.maxCollapseTags) : states.cachedOptions;
        });
        const collapseTagList = computed(() => {
          if (!props2.multiple) {
            return [];
          }
          return props2.collapseTags ? states.cachedOptions.slice(props2.maxCollapseTags) : [];
        });
        const {
          createNewOption,
          removeNewOption,
          selectNewOption,
          clearAllNewOption
        } = useAllowCreate(props2, states);
        const toggleMenu = () => {
          if (selectDisabled.value)
            return;
          if (states.menuVisibleOnFocus) {
            states.menuVisibleOnFocus = false;
          } else {
            expanded.value = !expanded.value;
          }
        };
        const onInputChange = () => {
          if (states.inputValue.length > 0 && !expanded.value) {
            expanded.value = true;
          }
          createNewOption(states.inputValue);
          nextTick(() => {
            handleQueryChange(states.inputValue);
          });
        };
        const debouncedOnInputChange = debounce(onInputChange, debounce$1.value);
        const handleQueryChange = (val) => {
          if (states.previousQuery === val || isComposing.value) {
            return;
          }
          states.previousQuery = val;
          if (props2.filterable && isFunction$1(props2.filterMethod)) {
            props2.filterMethod(val);
          } else if (props2.filterable && props2.remote && isFunction$1(props2.remoteMethod)) {
            props2.remoteMethod(val);
          }
          if (props2.defaultFirstOption && (props2.filterable || props2.remote) && filteredOptions.value.length) {
            nextTick(checkDefaultFirstOption);
          } else {
            nextTick(updateHoveringIndex);
          }
        };
        const checkDefaultFirstOption = () => {
          const optionsInDropdown = filteredOptions.value.filter((n) => !n.disabled && n.type !== "Group");
          const userCreatedOption = optionsInDropdown.find((n) => n.created);
          const firstOriginOption = optionsInDropdown[0];
          states.hoveringIndex = getValueIndex(filteredOptions.value, userCreatedOption || firstOriginOption);
        };
        const emitChange = (val) => {
          if (!isEqual$1(props2.modelValue, val)) {
            emit(CHANGE_EVENT, val);
          }
        };
        const update2 = (val) => {
          emit(UPDATE_MODEL_EVENT, val);
          emitChange(val);
          states.previousValue = props2.multiple ? String(val) : val;
          nextTick(() => {
            if (props2.multiple && isArray$1(props2.modelValue)) {
              const cachedOptions = states.cachedOptions.slice();
              const selectedOptions = props2.modelValue.map((value) => getOption(value, cachedOptions));
              if (!isEqual$1(states.cachedOptions, selectedOptions)) {
                states.cachedOptions = selectedOptions;
              }
            } else {
              initStates(true);
            }
          });
        };
        const getValueIndex = (arr = [], value) => {
          if (!isObject$1(value)) {
            return arr.indexOf(value);
          }
          const valueKey = props2.valueKey;
          let index2 = -1;
          arr.some((item, i) => {
            if (get(item, valueKey) === get(value, valueKey)) {
              index2 = i;
              return true;
            }
            return false;
          });
          return index2;
        };
        const getValueKey = (item) => {
          return isObject$1(item) ? get(item, props2.valueKey) : item;
        };
        const handleResize = () => {
          calculatePopperSize();
        };
        const resetSelectionWidth = () => {
          states.selectionWidth = Number.parseFloat(window.getComputedStyle(selectionRef.value).width);
        };
        const resetCollapseItemWidth = () => {
          states.collapseItemWidth = collapseItemRef.value.getBoundingClientRect().width;
        };
        const updateTooltip = () => {
          var _a, _b;
          (_b = (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
        };
        const updateTagTooltip = () => {
          var _a, _b;
          (_b = (_a = tagTooltipRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
        };
        const onSelect = (option) => {
          if (props2.multiple) {
            let selectedOptions = props2.modelValue.slice();
            const index2 = getValueIndex(selectedOptions, getValue2(option));
            if (index2 > -1) {
              selectedOptions = [
                ...selectedOptions.slice(0, index2),
                ...selectedOptions.slice(index2 + 1)
              ];
              states.cachedOptions.splice(index2, 1);
              removeNewOption(option);
            } else if (props2.multipleLimit <= 0 || selectedOptions.length < props2.multipleLimit) {
              selectedOptions = [...selectedOptions, getValue2(option)];
              states.cachedOptions.push(option);
              selectNewOption(option);
            }
            update2(selectedOptions);
            if (option.created) {
              handleQueryChange("");
            }
            if (props2.filterable && !props2.reserveKeyword) {
              states.inputValue = "";
            }
          } else {
            states.selectedLabel = getLabel(option);
            update2(getValue2(option));
            expanded.value = false;
            selectNewOption(option);
            if (!option.created) {
              clearAllNewOption();
            }
          }
          focus();
        };
        const deleteTag = (event, option) => {
          let selectedOptions = props2.modelValue.slice();
          const index2 = getValueIndex(selectedOptions, getValue2(option));
          if (index2 > -1 && !selectDisabled.value) {
            selectedOptions = [
              ...props2.modelValue.slice(0, index2),
              ...props2.modelValue.slice(index2 + 1)
            ];
            states.cachedOptions.splice(index2, 1);
            update2(selectedOptions);
            emit("remove-tag", getValue2(option));
            removeNewOption(option);
          }
          event.stopPropagation();
          focus();
        };
        const focus = () => {
          var _a;
          (_a = inputRef.value) == null ? void 0 : _a.focus();
        };
        const blur = () => {
          var _a;
          if (expanded.value) {
            expanded.value = false;
            nextTick(() => {
              var _a2;
              return (_a2 = inputRef.value) == null ? void 0 : _a2.blur();
            });
            return;
          }
          (_a = inputRef.value) == null ? void 0 : _a.blur();
        };
        const handleEsc = () => {
          if (states.inputValue.length > 0) {
            states.inputValue = "";
          } else {
            expanded.value = false;
          }
        };
        const getLastNotDisabledIndex = (value) => findLastIndex(value, (it2) => !states.cachedOptions.some((option) => getValue2(option) === it2 && getDisabled(option)));
        const handleDel = (e) => {
          if (!props2.multiple)
            return;
          if (e.code === EVENT_CODE.delete)
            return;
          if (states.inputValue.length === 0) {
            e.preventDefault();
            const selected = props2.modelValue.slice();
            const lastNotDisabledIndex = getLastNotDisabledIndex(selected);
            if (lastNotDisabledIndex < 0)
              return;
            const removeTagValue = selected[lastNotDisabledIndex];
            selected.splice(lastNotDisabledIndex, 1);
            const option = states.cachedOptions[lastNotDisabledIndex];
            states.cachedOptions.splice(lastNotDisabledIndex, 1);
            removeNewOption(option);
            update2(selected);
            emit("remove-tag", removeTagValue);
          }
        };
        const handleClear = () => {
          let emptyValue;
          if (isArray$1(props2.modelValue)) {
            emptyValue = [];
          } else {
            emptyValue = valueOnClear.value;
          }
          states.selectedLabel = "";
          expanded.value = false;
          update2(emptyValue);
          emit("clear");
          clearAllNewOption();
          focus();
        };
        const onKeyboardNavigate = (direction2, hoveringIndex = void 0) => {
          const options = filteredOptions.value;
          if (!["forward", "backward"].includes(direction2) || selectDisabled.value || options.length <= 0 || optionsAllDisabled.value || isComposing.value) {
            return;
          }
          if (!expanded.value) {
            return toggleMenu();
          }
          if (isUndefined(hoveringIndex)) {
            hoveringIndex = states.hoveringIndex;
          }
          let newIndex = -1;
          if (direction2 === "forward") {
            newIndex = hoveringIndex + 1;
            if (newIndex >= options.length) {
              newIndex = 0;
            }
          } else if (direction2 === "backward") {
            newIndex = hoveringIndex - 1;
            if (newIndex < 0 || newIndex >= options.length) {
              newIndex = options.length - 1;
            }
          }
          const option = options[newIndex];
          if (getDisabled(option) || option.type === "Group") {
            return onKeyboardNavigate(direction2, newIndex);
          } else {
            states.hoveringIndex = newIndex;
            scrollToItem(newIndex);
          }
        };
        const onKeyboardSelect = () => {
          if (!expanded.value) {
            return toggleMenu();
          } else if (~states.hoveringIndex && filteredOptions.value[states.hoveringIndex]) {
            onSelect(filteredOptions.value[states.hoveringIndex]);
          }
        };
        const onHoverOption = (idx) => {
          states.hoveringIndex = idx != null ? idx : -1;
        };
        const updateHoveringIndex = () => {
          if (!props2.multiple) {
            states.hoveringIndex = filteredOptions.value.findIndex((item) => {
              return getValueKey(getValue2(item)) === getValueKey(props2.modelValue);
            });
          } else {
            states.hoveringIndex = filteredOptions.value.findIndex((item) => props2.modelValue.some((modelValue) => getValueKey(modelValue) === getValueKey(getValue2(item))));
          }
        };
        const onInput = (event) => {
          states.inputValue = event.target.value;
          if (props2.remote) {
            debouncedOnInputChange();
          } else {
            return onInputChange();
          }
        };
        const handleClickOutside = (event) => {
          expanded.value = false;
          if (isFocused.value) {
            const _event2 = new FocusEvent("blur", event);
            handleBlur(_event2);
          }
        };
        const handleMenuEnter = () => {
          states.isBeforeHide = false;
          return nextTick(() => {
            if (~indexRef.value) {
              scrollToItem(states.hoveringIndex);
            }
          });
        };
        const scrollToItem = (index2) => {
          menuRef.value.scrollToItem(index2);
        };
        const getOption = (value, cachedOptions) => {
          const selectValue = getValueKey(value);
          if (allOptionsValueMap.value.has(selectValue)) {
            const { option } = allOptionsValueMap.value.get(selectValue);
            return option;
          }
          if (cachedOptions && cachedOptions.length) {
            const option = cachedOptions.find((option2) => getValueKey(getValue2(option2)) === selectValue);
            if (option) {
              return option;
            }
          }
          return {
            [aliasProps.value.value]: value,
            [aliasProps.value.label]: value
          };
        };
        const initStates = (needUpdateSelectedLabel = false) => {
          if (props2.multiple) {
            if (props2.modelValue.length > 0) {
              const cachedOptions = states.cachedOptions.slice();
              states.cachedOptions.length = 0;
              states.previousValue = props2.modelValue.toString();
              for (const value of props2.modelValue) {
                const option = getOption(value, cachedOptions);
                states.cachedOptions.push(option);
              }
            } else {
              states.cachedOptions = [];
              states.previousValue = void 0;
            }
          } else {
            if (hasModelValue.value) {
              states.previousValue = props2.modelValue;
              const options = filteredOptions.value;
              const selectedItemIndex = options.findIndex((option) => getValueKey(getValue2(option)) === getValueKey(props2.modelValue));
              if (~selectedItemIndex) {
                states.selectedLabel = getLabel(options[selectedItemIndex]);
              } else {
                if (!states.selectedLabel || needUpdateSelectedLabel) {
                  states.selectedLabel = getValueKey(props2.modelValue);
                }
              }
            } else {
              states.selectedLabel = "";
              states.previousValue = void 0;
            }
          }
          clearAllNewOption();
          calculatePopperSize();
        };
        watch(() => props2.fitInputWidth, () => {
          calculatePopperSize();
        });
        watch(expanded, (val) => {
          if (val) {
            if (!props2.persistent) {
              calculatePopperSize();
            }
            handleQueryChange("");
          } else {
            states.inputValue = "";
            states.previousQuery = null;
            states.isBeforeHide = true;
            createNewOption("");
          }
          emit("visible-change", val);
        });
        watch(() => props2.modelValue, (val, oldVal) => {
          var _a;
          const isValEmpty = !val || isArray$1(val) && val.length === 0;
          if (isValEmpty || props2.multiple && !isEqual$1(val.toString(), states.previousValue) || !props2.multiple && getValueKey(val) !== getValueKey(states.previousValue)) {
            initStates(true);
          }
          if (!isEqual$1(val, oldVal) && props2.validateEvent) {
            (_a = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "change").catch((err) => debugWarn());
          }
        }, {
          deep: true
        });
        watch(() => props2.options, () => {
          const input = inputRef.value;
          if (!input || input && document.activeElement !== input) {
            initStates();
          }
        }, {
          deep: true,
          flush: "post"
        });
        watch(() => filteredOptions.value, () => {
          calculatePopperSize();
          return menuRef.value && nextTick(menuRef.value.resetScrollTop);
        });
        watchEffect(() => {
          if (states.isBeforeHide)
            return;
          updateOptions2();
        });
        watchEffect(() => {
          const { valueKey, options } = props2;
          const duplicateValue = /* @__PURE__ */ new Map();
          for (const item of options) {
            const optionValue = getValue2(item);
            let v2 = optionValue;
            if (isObject$1(v2)) {
              v2 = get(optionValue, valueKey);
            }
            if (duplicateValue.get(v2)) {
              break;
            } else {
              duplicateValue.set(v2, true);
            }
          }
        });
        onMounted(() => {
          initStates();
        });
        useResizeObserver(selectRef, handleResize);
        useResizeObserver(selectionRef, resetSelectionWidth);
        useResizeObserver(menuRef, updateTooltip);
        useResizeObserver(wrapperRef, updateTooltip);
        useResizeObserver(tagMenuRef, updateTagTooltip);
        useResizeObserver(collapseItemRef, resetCollapseItemWidth);
        return {
          inputId,
          collapseTagSize,
          currentPlaceholder,
          expanded,
          emptyText,
          popupHeight,
          debounce: debounce$1,
          allOptions,
          filteredOptions,
          iconComponent,
          iconReverse,
          tagStyle,
          collapseTagStyle,
          popperSize,
          dropdownMenuVisible,
          hasModelValue,
          shouldShowPlaceholder,
          selectDisabled,
          selectSize,
          needStatusIcon,
          showClearBtn,
          states,
          isFocused,
          nsSelect,
          nsInput,
          inputRef,
          menuRef,
          tagMenuRef,
          tooltipRef,
          tagTooltipRef,
          selectRef,
          wrapperRef,
          selectionRef,
          prefixRef,
          suffixRef,
          collapseItemRef,
          popperRef,
          validateState,
          validateIcon,
          showTagList,
          collapseTagList,
          debouncedOnInputChange,
          deleteTag,
          getLabel,
          getValue: getValue2,
          getDisabled,
          getValueKey,
          handleClear,
          handleClickOutside,
          handleDel,
          handleEsc,
          focus,
          blur,
          handleMenuEnter,
          handleResize,
          resetSelectionWidth,
          updateTooltip,
          updateTagTooltip,
          updateOptions: updateOptions2,
          toggleMenu,
          scrollTo: scrollToItem,
          onInput,
          onKeyboardNavigate,
          onKeyboardSelect,
          onSelect,
          onHover: onHoverOption,
          handleCompositionStart,
          handleCompositionEnd,
          handleCompositionUpdate
        };
      };
      var useSelect$2 = useSelect$1;
      const _sfc_main$P = defineComponent({
        name: "ElSelectV2",
        components: {
          ElSelectMenu,
          ElTag,
          ElTooltip,
          ElIcon
        },
        directives: { ClickOutside },
        props: selectV2Props,
        emits: selectV2Emits,
        setup(props2, { emit }) {
          const modelValue = computed(() => {
            const { modelValue: rawModelValue, multiple } = props2;
            const fallback = multiple ? [] : void 0;
            if (isArray$1(rawModelValue)) {
              return multiple ? rawModelValue : fallback;
            }
            return multiple ? fallback : rawModelValue;
          });
          const API = useSelect$2(reactive({
            ...toRefs(props2),
            modelValue
          }), emit);
          const { calculatorRef, inputStyle } = useCalcInputWidth();
          provide(selectV2InjectionKey, {
            props: reactive({
              ...toRefs(props2),
              height: API.popupHeight,
              modelValue
            }),
            expanded: API.expanded,
            tooltipRef: API.tooltipRef,
            onSelect: API.onSelect,
            onHover: API.onHover,
            onKeyboardNavigate: API.onKeyboardNavigate,
            onKeyboardSelect: API.onKeyboardSelect
          });
          const selectedLabel = computed(() => {
            if (!props2.multiple) {
              return API.states.selectedLabel;
            }
            return API.states.cachedOptions.map((i) => i.label);
          });
          return {
            ...API,
            modelValue,
            selectedLabel,
            calculatorRef,
            inputStyle
          };
        }
      });
      function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_tag = resolveComponent("el-tag");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_select_menu = resolveComponent("el-select-menu");
        const _directive_click_outside = resolveDirective("click-outside");
        return withDirectives((openBlock(), createElementBlock("div", {
          ref: "selectRef",
          class: normalizeClass([_ctx.nsSelect.b(), _ctx.nsSelect.m(_ctx.selectSize)]),
          onMouseenter: ($event) => _ctx.states.inputHovering = true,
          onMouseleave: ($event) => _ctx.states.inputHovering = false
        }, [
          createVNode(_component_el_tooltip, {
            ref: "tooltipRef",
            visible: _ctx.dropdownMenuVisible,
            teleported: _ctx.teleported,
            "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
            "gpu-acceleration": false,
            "stop-popper-mouse-event": false,
            "popper-options": _ctx.popperOptions,
            "fallback-placements": _ctx.fallbackPlacements,
            effect: _ctx.effect,
            placement: _ctx.placement,
            pure: "",
            transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
            trigger: "click",
            persistent: _ctx.persistent,
            "append-to": _ctx.appendTo,
            "show-arrow": _ctx.showArrow,
            offset: _ctx.offset,
            onBeforeShow: _ctx.handleMenuEnter,
            onHide: ($event) => _ctx.states.isBeforeHide = false
          }, {
            default: withCtx(() => [
              createElementVNode("div", {
                ref: "wrapperRef",
                class: normalizeClass([
                  _ctx.nsSelect.e("wrapper"),
                  _ctx.nsSelect.is("focused", _ctx.isFocused),
                  _ctx.nsSelect.is("hovering", _ctx.states.inputHovering),
                  _ctx.nsSelect.is("filterable", _ctx.filterable),
                  _ctx.nsSelect.is("disabled", _ctx.selectDisabled)
                ]),
                onClick: withModifiers(_ctx.toggleMenu, ["prevent"])
              }, [
                _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref: "prefixRef",
                  class: normalizeClass(_ctx.nsSelect.e("prefix"))
                }, [
                  renderSlot(_ctx.$slots, "prefix")
                ], 2)) : createCommentVNode("v-if", true),
                createElementVNode("div", {
                  ref: "selectionRef",
                  class: normalizeClass([
                    _ctx.nsSelect.e("selection"),
                    _ctx.nsSelect.is("near", _ctx.multiple && !_ctx.$slots.prefix && !!_ctx.modelValue.length)
                  ])
                }, [
                  _ctx.multiple ? renderSlot(_ctx.$slots, "tag", {
                    key: 0,
                    data: _ctx.states.cachedOptions,
                    deleteTag: _ctx.deleteTag,
                    selectDisabled: _ctx.selectDisabled
                  }, () => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.showTagList, (item) => {
                      return openBlock(), createElementBlock("div", {
                        key: _ctx.getValueKey(_ctx.getValue(item)),
                        class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                      }, [
                        createVNode(_component_el_tag, {
                          closable: !_ctx.selectDisabled && !_ctx.getDisabled(item),
                          size: _ctx.collapseTagSize,
                          type: _ctx.tagType,
                          effect: _ctx.tagEffect,
                          "disable-transitions": "",
                          style: normalizeStyle(_ctx.tagStyle),
                          onClose: ($event) => _ctx.deleteTag($event, item)
                        }, {
                          default: withCtx(() => [
                            createElementVNode("span", {
                              class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                            }, [
                              renderSlot(_ctx.$slots, "label", {
                                label: _ctx.getLabel(item),
                                value: _ctx.getValue(item)
                              }, () => [
                                createTextVNode(toDisplayString(_ctx.getLabel(item)), 1)
                              ])
                            ], 2)
                          ]),
                          _: 2
                        }, 1032, ["closable", "size", "type", "effect", "style", "onClose"])
                      ], 2);
                    }), 128)),
                    _ctx.collapseTags && _ctx.modelValue.length > _ctx.maxCollapseTags ? (openBlock(), createBlock(_component_el_tooltip, {
                      key: 0,
                      ref: "tagTooltipRef",
                      disabled: _ctx.dropdownMenuVisible || !_ctx.collapseTagsTooltip,
                      "fallback-placements": ["bottom", "top", "right", "left"],
                      effect: _ctx.effect,
                      placement: "bottom",
                      "popper-class": _ctx.popperClass,
                      teleported: _ctx.teleported
                    }, {
                      default: withCtx(() => [
                        createElementVNode("div", {
                          ref: "collapseItemRef",
                          class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                        }, [
                          createVNode(_component_el_tag, {
                            closable: false,
                            size: _ctx.collapseTagSize,
                            type: _ctx.tagType,
                            effect: _ctx.tagEffect,
                            style: normalizeStyle(_ctx.collapseTagStyle),
                            "disable-transitions": ""
                          }, {
                            default: withCtx(() => [
                              createElementVNode("span", {
                                class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                              }, " + " + toDisplayString(_ctx.modelValue.length - _ctx.maxCollapseTags), 3)
                            ]),
                            _: 1
                          }, 8, ["size", "type", "effect", "style"])
                        ], 2)
                      ]),
                      content: withCtx(() => [
                        createElementVNode("div", {
                          ref: "tagMenuRef",
                          class: normalizeClass(_ctx.nsSelect.e("selection"))
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.collapseTagList, (selected) => {
                            return openBlock(), createElementBlock("div", {
                              key: _ctx.getValueKey(_ctx.getValue(selected)),
                              class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                            }, [
                              createVNode(_component_el_tag, {
                                class: "in-tooltip",
                                closable: !_ctx.selectDisabled && !_ctx.getDisabled(selected),
                                size: _ctx.collapseTagSize,
                                type: _ctx.tagType,
                                effect: _ctx.tagEffect,
                                "disable-transitions": "",
                                onClose: ($event) => _ctx.deleteTag($event, selected)
                              }, {
                                default: withCtx(() => [
                                  createElementVNode("span", {
                                    class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                                  }, [
                                    renderSlot(_ctx.$slots, "label", {
                                      label: _ctx.getLabel(selected),
                                      value: _ctx.getValue(selected)
                                    }, () => [
                                      createTextVNode(toDisplayString(_ctx.getLabel(selected)), 1)
                                    ])
                                  ], 2)
                                ]),
                                _: 2
                              }, 1032, ["closable", "size", "type", "effect", "onClose"])
                            ], 2);
                          }), 128))
                        ], 2)
                      ]),
                      _: 3
                    }, 8, ["disabled", "effect", "popper-class", "teleported"])) : createCommentVNode("v-if", true)
                  ]) : createCommentVNode("v-if", true),
                  createElementVNode("div", {
                    class: normalizeClass([
                      _ctx.nsSelect.e("selected-item"),
                      _ctx.nsSelect.e("input-wrapper"),
                      _ctx.nsSelect.is("hidden", !_ctx.filterable)
                    ])
                  }, [
                    withDirectives(createElementVNode("input", {
                      id: _ctx.inputId,
                      ref: "inputRef",
                      "onUpdate:modelValue": ($event) => _ctx.states.inputValue = $event,
                      style: normalizeStyle(_ctx.inputStyle),
                      autocomplete: _ctx.autocomplete,
                      tabindex: _ctx.tabindex,
                      "aria-autocomplete": "list",
                      "aria-haspopup": "listbox",
                      autocapitalize: "off",
                      "aria-expanded": _ctx.expanded,
                      "aria-label": _ctx.ariaLabel,
                      class: normalizeClass([_ctx.nsSelect.e("input"), _ctx.nsSelect.is(_ctx.selectSize)]),
                      disabled: _ctx.selectDisabled,
                      role: "combobox",
                      readonly: !_ctx.filterable,
                      spellcheck: "false",
                      type: "text",
                      name: _ctx.name,
                      onInput: _ctx.onInput,
                      onCompositionstart: _ctx.handleCompositionStart,
                      onCompositionupdate: _ctx.handleCompositionUpdate,
                      onCompositionend: _ctx.handleCompositionEnd,
                      onKeydown: [
                        withKeys(withModifiers(($event) => _ctx.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"]),
                        withKeys(withModifiers(($event) => _ctx.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"]),
                        withKeys(withModifiers(_ctx.onKeyboardSelect, ["stop", "prevent"]), ["enter"]),
                        withKeys(withModifiers(_ctx.handleEsc, ["stop", "prevent"]), ["esc"]),
                        withKeys(withModifiers(_ctx.handleDel, ["stop"]), ["delete"])
                      ],
                      onClick: withModifiers(_ctx.toggleMenu, ["stop"])
                    }, null, 46, ["id", "onUpdate:modelValue", "autocomplete", "tabindex", "aria-expanded", "aria-label", "disabled", "readonly", "name", "onInput", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown", "onClick"]), [
                      [vModelText, _ctx.states.inputValue]
                    ]),
                    _ctx.filterable ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      ref: "calculatorRef",
                      "aria-hidden": "true",
                      class: normalizeClass(_ctx.nsSelect.e("input-calculator")),
                      textContent: toDisplayString(_ctx.states.inputValue)
                    }, null, 10, ["textContent"])) : createCommentVNode("v-if", true)
                  ], 2),
                  _ctx.shouldShowPlaceholder ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass([
                      _ctx.nsSelect.e("selected-item"),
                      _ctx.nsSelect.e("placeholder"),
                      _ctx.nsSelect.is("transparent", !_ctx.hasModelValue || _ctx.expanded && !_ctx.states.inputValue)
                    ])
                  }, [
                    _ctx.hasModelValue ? renderSlot(_ctx.$slots, "label", {
                      key: 0,
                      label: _ctx.currentPlaceholder,
                      value: _ctx.modelValue
                    }, () => [
                      createElementVNode("span", null, toDisplayString(_ctx.currentPlaceholder), 1)
                    ]) : (openBlock(), createElementBlock("span", { key: 1 }, toDisplayString(_ctx.currentPlaceholder), 1))
                  ], 2)) : createCommentVNode("v-if", true)
                ], 2),
                createElementVNode("div", {
                  ref: "suffixRef",
                  class: normalizeClass(_ctx.nsSelect.e("suffix"))
                }, [
                  _ctx.iconComponent ? withDirectives((openBlock(), createBlock(_component_el_icon, {
                    key: 0,
                    class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsInput.e("icon"), _ctx.iconReverse])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                    ]),
                    _: 1
                  }, 8, ["class"])), [
                    [vShow, !_ctx.showClearBtn]
                  ]) : createCommentVNode("v-if", true),
                  _ctx.showClearBtn && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                    key: 1,
                    class: normalizeClass([
                      _ctx.nsSelect.e("caret"),
                      _ctx.nsInput.e("icon"),
                      _ctx.nsSelect.e("clear")
                    ]),
                    onClick: withModifiers(_ctx.handleClear, ["prevent", "stop"])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
                  _ctx.validateState && _ctx.validateIcon && _ctx.needStatusIcon ? (openBlock(), createBlock(_component_el_icon, {
                    key: 2,
                    class: normalizeClass([
                      _ctx.nsInput.e("icon"),
                      _ctx.nsInput.e("validateIcon"),
                      _ctx.nsInput.is("loading", _ctx.validateState === "validating")
                    ])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.validateIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true)
                ], 2)
              ], 10, ["onClick"])
            ]),
            content: withCtx(() => [
              createVNode(_component_el_select_menu, {
                ref: "menuRef",
                data: _ctx.filteredOptions,
                width: _ctx.popperSize,
                "hovering-index": _ctx.states.hoveringIndex,
                "scrollbar-always-on": _ctx.scrollbarAlwaysOn
              }, createSlots({
                default: withCtx((scope) => [
                  renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(scope)))
                ]),
                _: 2
              }, [
                _ctx.$slots.header ? {
                  name: "header",
                  fn: withCtx(() => [
                    createElementVNode("div", {
                      class: normalizeClass(_ctx.nsSelect.be("dropdown", "header")),
                      onClick: withModifiers(() => {
                      }, ["stop"])
                    }, [
                      renderSlot(_ctx.$slots, "header")
                    ], 10, ["onClick"])
                  ])
                } : void 0,
                _ctx.$slots.loading && _ctx.loading ? {
                  name: "loading",
                  fn: withCtx(() => [
                    createElementVNode("div", {
                      class: normalizeClass(_ctx.nsSelect.be("dropdown", "loading"))
                    }, [
                      renderSlot(_ctx.$slots, "loading")
                    ], 2)
                  ])
                } : _ctx.loading || _ctx.filteredOptions.length === 0 ? {
                  name: "empty",
                  fn: withCtx(() => [
                    createElementVNode("div", {
                      class: normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
                    }, [
                      renderSlot(_ctx.$slots, "empty", {}, () => [
                        createElementVNode("span", null, toDisplayString(_ctx.emptyText), 1)
                      ])
                    ], 2)
                  ])
                } : void 0,
                _ctx.$slots.footer ? {
                  name: "footer",
                  fn: withCtx(() => [
                    createElementVNode("div", {
                      class: normalizeClass(_ctx.nsSelect.be("dropdown", "footer")),
                      onClick: withModifiers(() => {
                      }, ["stop"])
                    }, [
                      renderSlot(_ctx.$slots, "footer")
                    ], 10, ["onClick"])
                  ])
                } : void 0
              ]), 1032, ["data", "width", "hovering-index", "scrollbar-always-on"])
            ]),
            _: 3
          }, 8, ["visible", "teleported", "popper-class", "popper-options", "fallback-placements", "effect", "placement", "transition", "persistent", "append-to", "show-arrow", "offset", "onBeforeShow", "onHide"])
        ], 42, ["onMouseenter", "onMouseleave"])), [
          [_directive_click_outside, _ctx.handleClickOutside, _ctx.popperRef]
        ]);
      }
      var Select = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$5], ["__file", "select.vue"]]);
      const ElSelectV2 = exports("ElSelectV2", withInstall(Select));
      const skeletonProps = exports("skeletonProps", buildProps({
        animated: Boolean,
        count: {
          type: Number,
          default: 1
        },
        rows: {
          type: Number,
          default: 3
        },
        loading: {
          type: Boolean,
          default: true
        },
        throttle: {
          type: definePropType([Number, Object])
        }
      }));
      const skeletonItemProps = exports("skeletonItemProps", buildProps({
        variant: {
          type: String,
          values: [
            "circle",
            "rect",
            "h1",
            "h3",
            "text",
            "caption",
            "p",
            "image",
            "button"
          ],
          default: "text"
        }
      }));
      const __default__$H = defineComponent({
        name: "ElSkeletonItem"
      });
      const _sfc_main$O = /* @__PURE__ */ defineComponent({
        ...__default__$H,
        props: skeletonItemProps,
        setup(__props) {
          const ns = useNamespace("skeleton");
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).e("item"), unref(ns).e(_ctx.variant)])
            }, [
              _ctx.variant === "image" ? (openBlock(), createBlock(unref(picture_filled_default$1), { key: 0 })) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var SkeletonItem = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["__file", "skeleton-item.vue"]]);
      const __default__$G = defineComponent({
        name: "ElSkeleton"
      });
      const _sfc_main$N = /* @__PURE__ */ defineComponent({
        ...__default__$G,
        props: skeletonProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const ns = useNamespace("skeleton");
          const uiLoading = useThrottleRender(toRef(props2, "loading"), props2.throttle);
          expose({
            uiLoading
          });
          return (_ctx, _cache) => {
            return unref(uiLoading) ? (openBlock(), createElementBlock("div", mergeProps({
              key: 0,
              class: [unref(ns).b(), unref(ns).is("animated", _ctx.animated)]
            }, _ctx.$attrs), [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.count, (i) => {
                return openBlock(), createElementBlock(Fragment, { key: i }, [
                  unref(uiLoading) ? renderSlot(_ctx.$slots, "template", { key: i }, () => [
                    createVNode(SkeletonItem, {
                      class: normalizeClass(unref(ns).is("first")),
                      variant: "p"
                    }, null, 8, ["class"]),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (item) => {
                      return openBlock(), createBlock(SkeletonItem, {
                        key: item,
                        class: normalizeClass([
                          unref(ns).e("paragraph"),
                          unref(ns).is("last", item === _ctx.rows && _ctx.rows > 1)
                        ]),
                        variant: "p"
                      }, null, 8, ["class"]);
                    }), 128))
                  ]) : createCommentVNode("v-if", true)
                ], 64);
              }), 128))
            ], 16)) : renderSlot(_ctx.$slots, "default", normalizeProps(mergeProps({ key: 1 }, _ctx.$attrs)));
          };
        }
      });
      var Skeleton = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["__file", "skeleton.vue"]]);
      const ElSkeleton = exports("ElSkeleton", withInstall(Skeleton, {
        SkeletonItem
      }));
      const ElSkeletonItem = exports("ElSkeletonItem", withNoopInstall(SkeletonItem));
      const sliderContextKey = exports("sliderContextKey", Symbol("sliderContextKey"));
      const sliderProps = exports("sliderProps", buildProps({
        modelValue: {
          type: definePropType([Number, Array]),
          default: 0
        },
        id: {
          type: String,
          default: void 0
        },
        min: {
          type: Number,
          default: 0
        },
        max: {
          type: Number,
          default: 100
        },
        step: {
          type: Number,
          default: 1
        },
        showInput: Boolean,
        showInputControls: {
          type: Boolean,
          default: true
        },
        size: useSizeProp,
        inputSize: useSizeProp,
        showStops: Boolean,
        showTooltip: {
          type: Boolean,
          default: true
        },
        formatTooltip: {
          type: definePropType(Function),
          default: void 0
        },
        disabled: Boolean,
        range: Boolean,
        vertical: Boolean,
        height: String,
        debounce: {
          type: Number,
          default: 300
        },
        rangeStartLabel: {
          type: String,
          default: void 0
        },
        rangeEndLabel: {
          type: String,
          default: void 0
        },
        formatValueText: {
          type: definePropType(Function),
          default: void 0
        },
        tooltipClass: {
          type: String,
          default: void 0
        },
        placement: {
          type: String,
          values: Ee,
          default: "top"
        },
        marks: {
          type: definePropType(Object)
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        persistent: {
          type: Boolean,
          default: true
        },
        ...useAriaProps(["ariaLabel"])
      }));
      const isValidValue$1 = (value) => isNumber(value) || isArray$1(value) && value.every(isNumber);
      const sliderEmits = exports("sliderEmits", {
        [UPDATE_MODEL_EVENT]: isValidValue$1,
        [INPUT_EVENT]: isValidValue$1,
        [CHANGE_EVENT]: isValidValue$1
      });
      const useLifecycle = (props2, initData, resetSize) => {
        const sliderWrapper = ref();
        onMounted(async () => {
          if (props2.range) {
            if (isArray$1(props2.modelValue)) {
              initData.firstValue = Math.max(props2.min, props2.modelValue[0]);
              initData.secondValue = Math.min(props2.max, props2.modelValue[1]);
            } else {
              initData.firstValue = props2.min;
              initData.secondValue = props2.max;
            }
            initData.oldValue = [initData.firstValue, initData.secondValue];
          } else {
            if (!isNumber(props2.modelValue) || Number.isNaN(props2.modelValue)) {
              initData.firstValue = props2.min;
            } else {
              initData.firstValue = Math.min(props2.max, Math.max(props2.min, props2.modelValue));
            }
            initData.oldValue = initData.firstValue;
          }
          useEventListener(window, "resize", resetSize);
          await nextTick();
          resetSize();
        });
        return {
          sliderWrapper
        };
      };
      const useMarks = (props2) => {
        return computed(() => {
          if (!props2.marks) {
            return [];
          }
          const marksKeys = Object.keys(props2.marks);
          return marksKeys.map(Number.parseFloat).sort((a2, b2) => a2 - b2).filter((point) => point <= props2.max && point >= props2.min).map((point) => ({
            point,
            position: (point - props2.min) * 100 / (props2.max - props2.min),
            mark: props2.marks[point]
          }));
        });
      };
      const useSlide = (props2, initData, emit) => {
        const { form: elForm, formItem: elFormItem } = useFormItem();
        const slider = shallowRef();
        const firstButton = ref();
        const secondButton = ref();
        const buttonRefs = {
          firstButton,
          secondButton
        };
        const sliderDisabled = computed(() => {
          return props2.disabled || (elForm == null ? void 0 : elForm.disabled) || false;
        });
        const minValue = computed(() => {
          return Math.min(initData.firstValue, initData.secondValue);
        });
        const maxValue = computed(() => {
          return Math.max(initData.firstValue, initData.secondValue);
        });
        const barSize = computed(() => {
          return props2.range ? `${100 * (maxValue.value - minValue.value) / (props2.max - props2.min)}%` : `${100 * (initData.firstValue - props2.min) / (props2.max - props2.min)}%`;
        });
        const barStart = computed(() => {
          return props2.range ? `${100 * (minValue.value - props2.min) / (props2.max - props2.min)}%` : "0%";
        });
        const runwayStyle = computed(() => {
          return props2.vertical ? { height: props2.height } : {};
        });
        const barStyle = computed(() => {
          return props2.vertical ? {
            height: barSize.value,
            bottom: barStart.value
          } : {
            width: barSize.value,
            left: barStart.value
          };
        });
        const resetSize = () => {
          if (slider.value) {
            initData.sliderSize = slider.value[`client${props2.vertical ? "Height" : "Width"}`];
          }
        };
        const getButtonRefByPercent = (percent) => {
          const targetValue = props2.min + percent * (props2.max - props2.min) / 100;
          if (!props2.range) {
            return firstButton;
          }
          let buttonRefName;
          if (Math.abs(minValue.value - targetValue) < Math.abs(maxValue.value - targetValue)) {
            buttonRefName = initData.firstValue < initData.secondValue ? "firstButton" : "secondButton";
          } else {
            buttonRefName = initData.firstValue > initData.secondValue ? "firstButton" : "secondButton";
          }
          return buttonRefs[buttonRefName];
        };
        const setPosition = (percent) => {
          const buttonRef = getButtonRefByPercent(percent);
          buttonRef.value.setPosition(percent);
          return buttonRef;
        };
        const setFirstValue = (firstValue) => {
          initData.firstValue = firstValue != null ? firstValue : props2.min;
          _emit(props2.range ? [minValue.value, maxValue.value] : firstValue != null ? firstValue : props2.min);
        };
        const setSecondValue = (secondValue) => {
          initData.secondValue = secondValue;
          if (props2.range) {
            _emit([minValue.value, maxValue.value]);
          }
        };
        const _emit = (val) => {
          emit(UPDATE_MODEL_EVENT, val);
          emit(INPUT_EVENT, val);
        };
        const emitChange = async () => {
          await nextTick();
          emit(CHANGE_EVENT, props2.range ? [minValue.value, maxValue.value] : props2.modelValue);
        };
        const handleSliderPointerEvent = (event) => {
          var _a, _b, _c, _d, _e, _f;
          if (sliderDisabled.value || initData.dragging)
            return;
          resetSize();
          let newPercent = 0;
          if (props2.vertical) {
            const clientY = (_c = (_b = (_a = event.touches) == null ? void 0 : _a.item(0)) == null ? void 0 : _b.clientY) != null ? _c : event.clientY;
            const sliderOffsetBottom = slider.value.getBoundingClientRect().bottom;
            newPercent = (sliderOffsetBottom - clientY) / initData.sliderSize * 100;
          } else {
            const clientX = (_f = (_e = (_d = event.touches) == null ? void 0 : _d.item(0)) == null ? void 0 : _e.clientX) != null ? _f : event.clientX;
            const sliderOffsetLeft = slider.value.getBoundingClientRect().left;
            newPercent = (clientX - sliderOffsetLeft) / initData.sliderSize * 100;
          }
          if (newPercent < 0 || newPercent > 100)
            return;
          return setPosition(newPercent);
        };
        const onSliderWrapperPrevent = (event) => {
          var _a, _b;
          if (((_a = buttonRefs["firstButton"].value) == null ? void 0 : _a.dragging) || ((_b = buttonRefs["secondButton"].value) == null ? void 0 : _b.dragging)) {
            event.preventDefault();
          }
        };
        const onSliderDown = async (event) => {
          const buttonRef = handleSliderPointerEvent(event);
          if (buttonRef) {
            await nextTick();
            buttonRef.value.onButtonDown(event);
          }
        };
        const onSliderClick = (event) => {
          const buttonRef = handleSliderPointerEvent(event);
          if (buttonRef) {
            emitChange();
          }
        };
        const onSliderMarkerDown = (position) => {
          if (sliderDisabled.value || initData.dragging)
            return;
          const buttonRef = setPosition(position);
          if (buttonRef) {
            emitChange();
          }
        };
        return {
          elFormItem,
          slider,
          firstButton,
          secondButton,
          sliderDisabled,
          minValue,
          maxValue,
          runwayStyle,
          barStyle,
          resetSize,
          setPosition,
          emitChange,
          onSliderWrapperPrevent,
          onSliderClick,
          onSliderDown,
          onSliderMarkerDown,
          setFirstValue,
          setSecondValue
        };
      };
      const useTooltip = (props2, formatTooltip, showTooltip) => {
        const tooltip = ref();
        const tooltipVisible = ref(false);
        const enableFormat = computed(() => {
          return formatTooltip.value instanceof Function;
        });
        const formatValue = computed(() => {
          return enableFormat.value && formatTooltip.value(props2.modelValue) || props2.modelValue;
        });
        const displayTooltip = debounce(() => {
          showTooltip.value && (tooltipVisible.value = true);
        }, 50);
        const hideTooltip = debounce(() => {
          showTooltip.value && (tooltipVisible.value = false);
        }, 50);
        return {
          tooltip,
          tooltipVisible,
          formatValue,
          displayTooltip,
          hideTooltip
        };
      };
      const useSliderButton = (props2, initData, emit) => {
        const {
          disabled,
          min: min2,
          max: max2,
          step: step2,
          showTooltip,
          persistent,
          precision,
          sliderSize,
          formatTooltip,
          emitChange,
          resetSize,
          updateDragging
        } = inject(sliderContextKey);
        const { tooltip, tooltipVisible, formatValue, displayTooltip, hideTooltip } = useTooltip(props2, formatTooltip, showTooltip);
        const button = ref();
        const currentPosition = computed(() => {
          return `${(props2.modelValue - min2.value) / (max2.value - min2.value) * 100}%`;
        });
        const wrapperStyle = computed(() => {
          return props2.vertical ? { bottom: currentPosition.value } : { left: currentPosition.value };
        });
        const handleMouseEnter = () => {
          initData.hovering = true;
          displayTooltip();
        };
        const handleMouseLeave = () => {
          initData.hovering = false;
          if (!initData.dragging) {
            hideTooltip();
          }
        };
        const onButtonDown = (event) => {
          if (disabled.value)
            return;
          event.preventDefault();
          onDragStart(event);
          window.addEventListener("mousemove", onDragging);
          window.addEventListener("touchmove", onDragging);
          window.addEventListener("mouseup", onDragEnd);
          window.addEventListener("touchend", onDragEnd);
          window.addEventListener("contextmenu", onDragEnd);
          button.value.focus();
        };
        const incrementPosition = (amount) => {
          if (disabled.value)
            return;
          initData.newPosition = Number.parseFloat(currentPosition.value) + amount / (max2.value - min2.value) * 100;
          setPosition(initData.newPosition);
          emitChange();
        };
        const onLeftKeyDown = () => {
          incrementPosition(-step2.value);
        };
        const onRightKeyDown = () => {
          incrementPosition(step2.value);
        };
        const onPageDownKeyDown = () => {
          incrementPosition(-step2.value * 4);
        };
        const onPageUpKeyDown = () => {
          incrementPosition(step2.value * 4);
        };
        const onHomeKeyDown = () => {
          if (disabled.value)
            return;
          setPosition(0);
          emitChange();
        };
        const onEndKeyDown = () => {
          if (disabled.value)
            return;
          setPosition(100);
          emitChange();
        };
        const onKeyDown = (event) => {
          let isPreventDefault = true;
          switch (event.code) {
            case EVENT_CODE.left:
            case EVENT_CODE.down:
              onLeftKeyDown();
              break;
            case EVENT_CODE.right:
            case EVENT_CODE.up:
              onRightKeyDown();
              break;
            case EVENT_CODE.home:
              onHomeKeyDown();
              break;
            case EVENT_CODE.end:
              onEndKeyDown();
              break;
            case EVENT_CODE.pageDown:
              onPageDownKeyDown();
              break;
            case EVENT_CODE.pageUp:
              onPageUpKeyDown();
              break;
            default:
              isPreventDefault = false;
              break;
          }
          isPreventDefault && event.preventDefault();
        };
        const getClientXY2 = (event) => {
          let clientX;
          let clientY;
          if (event.type.startsWith("touch")) {
            clientY = event.touches[0].clientY;
            clientX = event.touches[0].clientX;
          } else {
            clientY = event.clientY;
            clientX = event.clientX;
          }
          return {
            clientX,
            clientY
          };
        };
        const onDragStart = (event) => {
          initData.dragging = true;
          initData.isClick = true;
          const { clientX, clientY } = getClientXY2(event);
          if (props2.vertical) {
            initData.startY = clientY;
          } else {
            initData.startX = clientX;
          }
          initData.startPosition = Number.parseFloat(currentPosition.value);
          initData.newPosition = initData.startPosition;
        };
        const onDragging = (event) => {
          if (initData.dragging) {
            initData.isClick = false;
            displayTooltip();
            resetSize();
            let diff;
            const { clientX, clientY } = getClientXY2(event);
            if (props2.vertical) {
              initData.currentY = clientY;
              diff = (initData.startY - initData.currentY) / sliderSize.value * 100;
            } else {
              initData.currentX = clientX;
              diff = (initData.currentX - initData.startX) / sliderSize.value * 100;
            }
            initData.newPosition = initData.startPosition + diff;
            setPosition(initData.newPosition);
          }
        };
        const onDragEnd = () => {
          if (initData.dragging) {
            setTimeout(() => {
              initData.dragging = false;
              if (!initData.hovering) {
                hideTooltip();
              }
              if (!initData.isClick) {
                setPosition(initData.newPosition);
              }
              emitChange();
            }, 0);
            window.removeEventListener("mousemove", onDragging);
            window.removeEventListener("touchmove", onDragging);
            window.removeEventListener("mouseup", onDragEnd);
            window.removeEventListener("touchend", onDragEnd);
            window.removeEventListener("contextmenu", onDragEnd);
          }
        };
        const setPosition = async (newPosition) => {
          if (newPosition === null || Number.isNaN(+newPosition))
            return;
          if (newPosition < 0) {
            newPosition = 0;
          } else if (newPosition > 100) {
            newPosition = 100;
          }
          const lengthPerStep = 100 / ((max2.value - min2.value) / step2.value);
          const steps = Math.round(newPosition / lengthPerStep);
          let value = steps * lengthPerStep * (max2.value - min2.value) * 0.01 + min2.value;
          value = Number.parseFloat(value.toFixed(precision.value));
          if (value !== props2.modelValue) {
            emit(UPDATE_MODEL_EVENT, value);
          }
          if (!initData.dragging && props2.modelValue !== initData.oldValue) {
            initData.oldValue = props2.modelValue;
          }
          await nextTick();
          initData.dragging && displayTooltip();
          tooltip.value.updatePopper();
        };
        watch(() => initData.dragging, (val) => {
          updateDragging(val);
        });
        useEventListener(button, "touchstart", onButtonDown, { passive: false });
        return {
          disabled,
          button,
          tooltip,
          tooltipVisible,
          showTooltip,
          persistent,
          wrapperStyle,
          formatValue,
          handleMouseEnter,
          handleMouseLeave,
          onButtonDown,
          onKeyDown,
          setPosition
        };
      };
      const useStops = (props2, initData, minValue, maxValue) => {
        const stops = computed(() => {
          if (!props2.showStops || props2.min > props2.max)
            return [];
          if (props2.step === 0) {
            return [];
          }
          const stopCount = (props2.max - props2.min) / props2.step;
          const stepWidth = 100 * props2.step / (props2.max - props2.min);
          const result2 = Array.from({ length: stopCount - 1 }).map((_2, index2) => (index2 + 1) * stepWidth);
          if (props2.range) {
            return result2.filter((step2) => {
              return step2 < 100 * (minValue.value - props2.min) / (props2.max - props2.min) || step2 > 100 * (maxValue.value - props2.min) / (props2.max - props2.min);
            });
          } else {
            return result2.filter((step2) => step2 > 100 * (initData.firstValue - props2.min) / (props2.max - props2.min));
          }
        });
        const getStopStyle = (position) => {
          return props2.vertical ? { bottom: `${position}%` } : { left: `${position}%` };
        };
        return {
          stops,
          getStopStyle
        };
      };
      const useWatch = (props2, initData, minValue, maxValue, emit, elFormItem) => {
        const _emit = (val) => {
          emit(UPDATE_MODEL_EVENT, val);
          emit(INPUT_EVENT, val);
        };
        const valueChanged = () => {
          if (props2.range) {
            return ![minValue.value, maxValue.value].every((item, index2) => item === initData.oldValue[index2]);
          } else {
            return props2.modelValue !== initData.oldValue;
          }
        };
        const setValues = () => {
          var _a, _b;
          if (props2.min > props2.max) {
            throwError("Slider", "min should not be greater than max.");
          }
          const val = props2.modelValue;
          if (props2.range && isArray$1(val)) {
            if (val[1] < props2.min) {
              _emit([props2.min, props2.min]);
            } else if (val[0] > props2.max) {
              _emit([props2.max, props2.max]);
            } else if (val[0] < props2.min) {
              _emit([props2.min, val[1]]);
            } else if (val[1] > props2.max) {
              _emit([val[0], props2.max]);
            } else {
              initData.firstValue = val[0];
              initData.secondValue = val[1];
              if (valueChanged()) {
                if (props2.validateEvent) {
                  (_a = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a.call(elFormItem, "change").catch((err) => debugWarn());
                }
                initData.oldValue = val.slice();
              }
            }
          } else if (!props2.range && isNumber(val) && !Number.isNaN(val)) {
            if (val < props2.min) {
              _emit(props2.min);
            } else if (val > props2.max) {
              _emit(props2.max);
            } else {
              initData.firstValue = val;
              if (valueChanged()) {
                if (props2.validateEvent) {
                  (_b = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _b.call(elFormItem, "change").catch((err) => debugWarn());
                }
                initData.oldValue = val;
              }
            }
          }
        };
        setValues();
        watch(() => initData.dragging, (val) => {
          if (!val) {
            setValues();
          }
        });
        watch(() => props2.modelValue, (val, oldVal) => {
          if (initData.dragging || isArray$1(val) && isArray$1(oldVal) && val.every((item, index2) => item === oldVal[index2]) && initData.firstValue === val[0] && initData.secondValue === val[1]) {
            return;
          }
          setValues();
        }, {
          deep: true
        });
        watch(() => [props2.min, props2.max], () => {
          setValues();
        });
      };
      const sliderButtonProps = buildProps({
        modelValue: {
          type: Number,
          default: 0
        },
        vertical: Boolean,
        tooltipClass: String,
        placement: {
          type: String,
          values: Ee,
          default: "top"
        }
      });
      const sliderButtonEmits = {
        [UPDATE_MODEL_EVENT]: (value) => isNumber(value)
      };
      const __default__$F = defineComponent({
        name: "ElSliderButton"
      });
      const _sfc_main$M = /* @__PURE__ */ defineComponent({
        ...__default__$F,
        props: sliderButtonProps,
        emits: sliderButtonEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const ns = useNamespace("slider");
          const initData = reactive({
            hovering: false,
            dragging: false,
            isClick: false,
            startX: 0,
            currentX: 0,
            startY: 0,
            currentY: 0,
            startPosition: 0,
            newPosition: 0,
            oldValue: props2.modelValue
          });
          const tooltipPersistent = computed(() => !showTooltip.value ? false : persistent.value);
          const {
            disabled,
            button,
            tooltip,
            showTooltip,
            persistent,
            tooltipVisible,
            wrapperStyle,
            formatValue,
            handleMouseEnter,
            handleMouseLeave,
            onButtonDown,
            onKeyDown,
            setPosition
          } = useSliderButton(props2, initData, emit);
          const { hovering, dragging } = toRefs(initData);
          expose({
            onButtonDown,
            onKeyDown,
            setPosition,
            hovering,
            dragging
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "button",
              ref: button,
              class: normalizeClass([unref(ns).e("button-wrapper"), { hover: unref(hovering), dragging: unref(dragging) }]),
              style: normalizeStyle(unref(wrapperStyle)),
              tabindex: unref(disabled) ? -1 : 0,
              onMouseenter: unref(handleMouseEnter),
              onMouseleave: unref(handleMouseLeave),
              onMousedown: unref(onButtonDown),
              onFocus: unref(handleMouseEnter),
              onBlur: unref(handleMouseLeave),
              onKeydown: unref(onKeyDown)
            }, [
              createVNode(unref(ElTooltip), {
                ref_key: "tooltip",
                ref: tooltip,
                visible: unref(tooltipVisible),
                placement: _ctx.placement,
                "fallback-placements": ["top", "bottom", "right", "left"],
                "stop-popper-mouse-event": false,
                "popper-class": _ctx.tooltipClass,
                disabled: !unref(showTooltip),
                persistent: unref(tooltipPersistent)
              }, {
                content: withCtx(() => [
                  createElementVNode("span", null, toDisplayString(unref(formatValue)), 1)
                ]),
                default: withCtx(() => [
                  createElementVNode("div", {
                    class: normalizeClass([unref(ns).e("button"), { hover: unref(hovering), dragging: unref(dragging) }])
                  }, null, 2)
                ]),
                _: 1
              }, 8, ["visible", "placement", "popper-class", "disabled", "persistent"])
            ], 46, ["tabindex", "onMouseenter", "onMouseleave", "onMousedown", "onFocus", "onBlur", "onKeydown"]);
          };
        }
      });
      var SliderButton = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["__file", "button.vue"]]);
      const sliderMarkerProps = buildProps({
        mark: {
          type: definePropType([String, Object]),
          default: void 0
        }
      });
      var SliderMarker = defineComponent({
        name: "ElSliderMarker",
        props: sliderMarkerProps,
        setup(props2) {
          const ns = useNamespace("slider");
          const label = computed(() => {
            return isString$1(props2.mark) ? props2.mark : props2.mark.label;
          });
          const style = computed(() => isString$1(props2.mark) ? void 0 : props2.mark.style);
          return () => h$1("div", {
            class: ns.e("marks-text"),
            style: style.value
          }, label.value);
        }
      });
      const __default__$E = defineComponent({
        name: "ElSlider"
      });
      const _sfc_main$L = /* @__PURE__ */ defineComponent({
        ...__default__$E,
        props: sliderProps,
        emits: sliderEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const ns = useNamespace("slider");
          const { t } = useLocale();
          const initData = reactive({
            firstValue: 0,
            secondValue: 0,
            oldValue: 0,
            dragging: false,
            sliderSize: 1
          });
          const {
            elFormItem,
            slider,
            firstButton,
            secondButton,
            sliderDisabled,
            minValue,
            maxValue,
            runwayStyle,
            barStyle,
            resetSize,
            emitChange,
            onSliderWrapperPrevent,
            onSliderClick,
            onSliderDown,
            onSliderMarkerDown,
            setFirstValue,
            setSecondValue
          } = useSlide(props2, initData, emit);
          const { stops, getStopStyle } = useStops(props2, initData, minValue, maxValue);
          const { inputId, isLabeledByFormItem } = useFormItemInputId(props2, {
            formItemContext: elFormItem
          });
          const sliderWrapperSize = useFormSize();
          const sliderInputSize = computed(() => props2.inputSize || sliderWrapperSize.value);
          const groupLabel = computed(() => {
            return props2.ariaLabel || t("el.slider.defaultLabel", {
              min: props2.min,
              max: props2.max
            });
          });
          const firstButtonLabel = computed(() => {
            if (props2.range) {
              return props2.rangeStartLabel || t("el.slider.defaultRangeStartLabel");
            } else {
              return groupLabel.value;
            }
          });
          const firstValueText = computed(() => {
            return props2.formatValueText ? props2.formatValueText(firstValue.value) : `${firstValue.value}`;
          });
          const secondButtonLabel = computed(() => {
            return props2.rangeEndLabel || t("el.slider.defaultRangeEndLabel");
          });
          const secondValueText = computed(() => {
            return props2.formatValueText ? props2.formatValueText(secondValue.value) : `${secondValue.value}`;
          });
          const sliderKls = computed(() => [
            ns.b(),
            ns.m(sliderWrapperSize.value),
            ns.is("vertical", props2.vertical),
            { [ns.m("with-input")]: props2.showInput }
          ]);
          const markList = useMarks(props2);
          useWatch(props2, initData, minValue, maxValue, emit, elFormItem);
          const precision = computed(() => {
            const precisions = [props2.min, props2.max, props2.step].map((item) => {
              const decimal = `${item}`.split(".")[1];
              return decimal ? decimal.length : 0;
            });
            return Math.max.apply(null, precisions);
          });
          const { sliderWrapper } = useLifecycle(props2, initData, resetSize);
          const { firstValue, secondValue, sliderSize } = toRefs(initData);
          const updateDragging = (val) => {
            initData.dragging = val;
          };
          useEventListener(sliderWrapper, "touchstart", onSliderWrapperPrevent, {
            passive: false
          });
          useEventListener(sliderWrapper, "touchmove", onSliderWrapperPrevent, {
            passive: false
          });
          provide(sliderContextKey, {
            ...toRefs(props2),
            sliderSize,
            disabled: sliderDisabled,
            precision,
            emitChange,
            resetSize,
            updateDragging
          });
          expose({
            onSliderClick
          });
          return (_ctx, _cache) => {
            var _a, _b;
            return openBlock(), createElementBlock("div", {
              id: _ctx.range ? unref(inputId) : void 0,
              ref_key: "sliderWrapper",
              ref: sliderWrapper,
              class: normalizeClass(unref(sliderKls)),
              role: _ctx.range ? "group" : void 0,
              "aria-label": _ctx.range && !unref(isLabeledByFormItem) ? unref(groupLabel) : void 0,
              "aria-labelledby": _ctx.range && unref(isLabeledByFormItem) ? (_a = unref(elFormItem)) == null ? void 0 : _a.labelId : void 0
            }, [
              createElementVNode("div", {
                ref_key: "slider",
                ref: slider,
                class: normalizeClass([
                  unref(ns).e("runway"),
                  { "show-input": _ctx.showInput && !_ctx.range },
                  unref(ns).is("disabled", unref(sliderDisabled))
                ]),
                style: normalizeStyle(unref(runwayStyle)),
                onMousedown: unref(onSliderDown),
                onTouchstartPassive: unref(onSliderDown)
              }, [
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).e("bar")),
                  style: normalizeStyle(unref(barStyle))
                }, null, 6),
                createVNode(SliderButton, {
                  id: !_ctx.range ? unref(inputId) : void 0,
                  ref_key: "firstButton",
                  ref: firstButton,
                  "model-value": unref(firstValue),
                  vertical: _ctx.vertical,
                  "tooltip-class": _ctx.tooltipClass,
                  placement: _ctx.placement,
                  role: "slider",
                  "aria-label": _ctx.range || !unref(isLabeledByFormItem) ? unref(firstButtonLabel) : void 0,
                  "aria-labelledby": !_ctx.range && unref(isLabeledByFormItem) ? (_b = unref(elFormItem)) == null ? void 0 : _b.labelId : void 0,
                  "aria-valuemin": _ctx.min,
                  "aria-valuemax": _ctx.range ? unref(secondValue) : _ctx.max,
                  "aria-valuenow": unref(firstValue),
                  "aria-valuetext": unref(firstValueText),
                  "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
                  "aria-disabled": unref(sliderDisabled),
                  "onUpdate:modelValue": unref(setFirstValue)
                }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]),
                _ctx.range ? (openBlock(), createBlock(SliderButton, {
                  key: 0,
                  ref_key: "secondButton",
                  ref: secondButton,
                  "model-value": unref(secondValue),
                  vertical: _ctx.vertical,
                  "tooltip-class": _ctx.tooltipClass,
                  placement: _ctx.placement,
                  role: "slider",
                  "aria-label": unref(secondButtonLabel),
                  "aria-valuemin": unref(firstValue),
                  "aria-valuemax": _ctx.max,
                  "aria-valuenow": unref(secondValue),
                  "aria-valuetext": unref(secondValueText),
                  "aria-orientation": _ctx.vertical ? "vertical" : "horizontal",
                  "aria-disabled": unref(sliderDisabled),
                  "onUpdate:modelValue": unref(setSecondValue)
                }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : createCommentVNode("v-if", true),
                _ctx.showStops ? (openBlock(), createElementBlock("div", { key: 1 }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(stops), (item, key) => {
                    return openBlock(), createElementBlock("div", {
                      key,
                      class: normalizeClass(unref(ns).e("stop")),
                      style: normalizeStyle(unref(getStopStyle)(item))
                    }, null, 6);
                  }), 128))
                ])) : createCommentVNode("v-if", true),
                unref(markList).length > 0 ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                  createElementVNode("div", null, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(markList), (item, key) => {
                      return openBlock(), createElementBlock("div", {
                        key,
                        style: normalizeStyle(unref(getStopStyle)(item.position)),
                        class: normalizeClass([unref(ns).e("stop"), unref(ns).e("marks-stop")])
                      }, null, 6);
                    }), 128))
                  ]),
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).e("marks"))
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(markList), (item, key) => {
                      return openBlock(), createBlock(unref(SliderMarker), {
                        key,
                        mark: item.mark,
                        style: normalizeStyle(unref(getStopStyle)(item.position)),
                        onMousedown: withModifiers(($event) => unref(onSliderMarkerDown)(item.position), ["stop"])
                      }, null, 8, ["mark", "style", "onMousedown"]);
                    }), 128))
                  ], 2)
                ], 64)) : createCommentVNode("v-if", true)
              ], 46, ["onMousedown", "onTouchstartPassive"]),
              _ctx.showInput && !_ctx.range ? (openBlock(), createBlock(unref(ElInputNumber), {
                key: 0,
                ref: "input",
                "model-value": unref(firstValue),
                class: normalizeClass(unref(ns).e("input")),
                step: _ctx.step,
                disabled: unref(sliderDisabled),
                controls: _ctx.showInputControls,
                min: _ctx.min,
                max: _ctx.max,
                precision: unref(precision),
                debounce: _ctx.debounce,
                size: unref(sliderInputSize),
                "onUpdate:modelValue": unref(setFirstValue),
                onChange: unref(emitChange)
              }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "precision", "debounce", "size", "onUpdate:modelValue", "onChange"])) : createCommentVNode("v-if", true)
            ], 10, ["id", "role", "aria-label", "aria-labelledby"]);
          };
        }
      });
      var Slider = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["__file", "slider.vue"]]);
      const ElSlider = exports("ElSlider", withInstall(Slider));
      const spaceItemProps = exports("spaceItemProps", buildProps({
        prefixCls: {
          type: String
        }
      }));
      const SpaceItem = defineComponent({
        name: "ElSpaceItem",
        props: spaceItemProps,
        setup(props2, { slots }) {
          const ns = useNamespace("space");
          const classes = computed(() => `${props2.prefixCls || ns.b()}__item`);
          return () => h$1("div", { class: classes.value }, renderSlot(slots, "default"));
        }
      });
      const SIZE_MAP = {
        small: 8,
        default: 12,
        large: 16
      };
      function useSpace(props2) {
        const ns = useNamespace("space");
        const classes = computed(() => [ns.b(), ns.m(props2.direction), props2.class]);
        const horizontalSize = ref(0);
        const verticalSize = ref(0);
        const containerStyle = computed(() => {
          const wrapKls = props2.wrap || props2.fill ? { flexWrap: "wrap" } : {};
          const alignment = {
            alignItems: props2.alignment
          };
          const gap = {
            rowGap: `${verticalSize.value}px`,
            columnGap: `${horizontalSize.value}px`
          };
          return [wrapKls, alignment, gap, props2.style];
        });
        const itemStyle = computed(() => {
          return props2.fill ? { flexGrow: 1, minWidth: `${props2.fillRatio}%` } : {};
        });
        watchEffect(() => {
          const { size = "small", wrap: wrap2, direction: dir, fill: fill2 } = props2;
          if (isArray$1(size)) {
            const [h2 = 0, v2 = 0] = size;
            horizontalSize.value = h2;
            verticalSize.value = v2;
          } else {
            let val;
            if (isNumber(size)) {
              val = size;
            } else {
              val = SIZE_MAP[size || "small"] || SIZE_MAP.small;
            }
            if ((wrap2 || fill2) && dir === "horizontal") {
              horizontalSize.value = verticalSize.value = val;
            } else {
              if (dir === "horizontal") {
                horizontalSize.value = val;
                verticalSize.value = 0;
              } else {
                verticalSize.value = val;
                horizontalSize.value = 0;
              }
            }
          }
        });
        return {
          classes,
          containerStyle,
          itemStyle
        };
      }
      const spaceProps = exports("spaceProps", buildProps({
        direction: {
          type: String,
          values: ["horizontal", "vertical"],
          default: "horizontal"
        },
        class: {
          type: definePropType([
            String,
            Object,
            Array
          ]),
          default: ""
        },
        style: {
          type: definePropType([String, Array, Object]),
          default: ""
        },
        alignment: {
          type: definePropType(String),
          default: "center"
        },
        prefixCls: {
          type: String
        },
        spacer: {
          type: definePropType([Object, String, Number, Array]),
          default: null,
          validator: (val) => isVNode(val) || isNumber(val) || isString$1(val)
        },
        wrap: Boolean,
        fill: Boolean,
        fillRatio: {
          type: Number,
          default: 100
        },
        size: {
          type: [String, Array, Number],
          values: componentSizes,
          validator: (val) => {
            return isNumber(val) || isArray$1(val) && val.length === 2 && val.every(isNumber);
          }
        }
      }));
      const Space = defineComponent({
        name: "ElSpace",
        props: spaceProps,
        setup(props2, { slots }) {
          const { classes, containerStyle, itemStyle } = useSpace(props2);
          function extractChildren(children, parentKey = "", extractedChildren = []) {
            const { prefixCls } = props2;
            children.forEach((child, loopKey) => {
              if (isFragment(child)) {
                if (isArray$1(child.children)) {
                  child.children.forEach((nested, key) => {
                    if (isFragment(nested) && isArray$1(nested.children)) {
                      extractChildren(nested.children, `${parentKey + key}-`, extractedChildren);
                    } else {
                      if (isVNode(nested) && (nested == null ? void 0 : nested.type) === Comment) {
                        extractedChildren.push(nested);
                      } else {
                        extractedChildren.push(createVNode(SpaceItem, {
                          style: itemStyle.value,
                          prefixCls,
                          key: `nested-${parentKey + key}`
                        }, {
                          default: () => [nested]
                        }, PatchFlags.PROPS | PatchFlags.STYLE, ["style", "prefixCls"]));
                      }
                    }
                  });
                }
              } else if (isValidElementNode(child)) {
                extractedChildren.push(createVNode(SpaceItem, {
                  style: itemStyle.value,
                  prefixCls,
                  key: `LoopKey${parentKey + loopKey}`
                }, {
                  default: () => [child]
                }, PatchFlags.PROPS | PatchFlags.STYLE, ["style", "prefixCls"]));
              }
            });
            return extractedChildren;
          }
          return () => {
            var _a;
            const { spacer, direction: direction2 } = props2;
            const children = renderSlot(slots, "default", { key: 0 }, () => []);
            if (((_a = children.children) != null ? _a : []).length === 0)
              return null;
            if (isArray$1(children.children)) {
              let extractedChildren = extractChildren(children.children);
              if (spacer) {
                const len = extractedChildren.length - 1;
                extractedChildren = extractedChildren.reduce((acc, child, idx) => {
                  const children2 = [...acc, child];
                  if (idx !== len) {
                    children2.push(createVNode("span", {
                      style: [
                        itemStyle.value,
                        direction2 === "vertical" ? "width: 100%" : null
                      ],
                      key: idx
                    }, [
                      isVNode(spacer) ? spacer : createTextVNode(spacer, PatchFlags.TEXT)
                    ], PatchFlags.STYLE));
                  }
                  return children2;
                }, []);
              }
              return createVNode("div", {
                class: classes.value,
                style: containerStyle.value
              }, extractedChildren, PatchFlags.STYLE | PatchFlags.CLASS);
            }
            return children.children;
          };
        }
      });
      const ElSpace = exports("ElSpace", withInstall(Space));
      const statisticProps = exports("statisticProps", buildProps({
        decimalSeparator: {
          type: String,
          default: "."
        },
        groupSeparator: {
          type: String,
          default: ","
        },
        precision: {
          type: Number,
          default: 0
        },
        formatter: Function,
        value: {
          type: definePropType([Number, Object]),
          default: 0
        },
        prefix: String,
        suffix: String,
        title: String,
        valueStyle: {
          type: definePropType([String, Object, Array])
        }
      }));
      const __default__$D = defineComponent({
        name: "ElStatistic"
      });
      const _sfc_main$K = /* @__PURE__ */ defineComponent({
        ...__default__$D,
        props: statisticProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const ns = useNamespace("statistic");
          const displayValue = computed(() => {
            const { value, formatter: formatter2, precision, decimalSeparator, groupSeparator } = props2;
            if (isFunction$1(formatter2))
              return formatter2(value);
            if (!isNumber(value) || Number.isNaN(value))
              return value;
            let [integer, decimal = ""] = String(value).split(".");
            decimal = decimal.padEnd(precision, "0").slice(0, precision > 0 ? precision : 0);
            integer = integer.replace(/\B(?=(\d{3})+(?!\d))/g, groupSeparator);
            return [integer, decimal].join(decimal ? decimalSeparator : "");
          });
          expose({
            displayValue
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b())
            }, [
              _ctx.$slots.title || _ctx.title ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).e("head"))
              }, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString(_ctx.title), 1)
                ])
              ], 2)) : createCommentVNode("v-if", true),
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("content"))
              }, [
                _ctx.$slots.prefix || _ctx.prefix ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).e("prefix"))
                }, [
                  renderSlot(_ctx.$slots, "prefix", {}, () => [
                    createElementVNode("span", null, toDisplayString(_ctx.prefix), 1)
                  ])
                ], 2)) : createCommentVNode("v-if", true),
                createElementVNode("span", {
                  class: normalizeClass(unref(ns).e("number")),
                  style: normalizeStyle(_ctx.valueStyle)
                }, toDisplayString(unref(displayValue)), 7),
                _ctx.$slots.suffix || _ctx.suffix ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(ns).e("suffix"))
                }, [
                  renderSlot(_ctx.$slots, "suffix", {}, () => [
                    createElementVNode("span", null, toDisplayString(_ctx.suffix), 1)
                  ])
                ], 2)) : createCommentVNode("v-if", true)
              ], 2)
            ], 2);
          };
        }
      });
      var Statistic = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["__file", "statistic.vue"]]);
      const ElStatistic = exports("ElStatistic", withInstall(Statistic));
      const countdownProps = exports("countdownProps", buildProps({
        format: {
          type: String,
          default: "HH:mm:ss"
        },
        prefix: String,
        suffix: String,
        title: String,
        value: {
          type: definePropType([Number, Object]),
          default: 0
        },
        valueStyle: {
          type: definePropType([String, Object, Array])
        }
      }));
      const countdownEmits = exports("countdownEmits", {
        finish: () => true,
        [CHANGE_EVENT]: (value) => isNumber(value)
      });
      const timeUnits = [
        ["Y", 1e3 * 60 * 60 * 24 * 365],
        ["M", 1e3 * 60 * 60 * 24 * 30],
        ["D", 1e3 * 60 * 60 * 24],
        ["H", 1e3 * 60 * 60],
        ["m", 1e3 * 60],
        ["s", 1e3],
        ["S", 1]
      ];
      const getTime = (value) => {
        return isNumber(value) ? new Date(value).getTime() : value.valueOf();
      };
      const formatTime$1 = (timestamp, format2) => {
        let timeLeft = timestamp;
        const escapeRegex = /\[([^\]]*)]/g;
        const replacedText = timeUnits.reduce((current, [name, unit2]) => {
          const replaceRegex = new RegExp(`${name}+(?![^\\[\\]]*\\])`, "g");
          if (replaceRegex.test(current)) {
            const value = Math.floor(timeLeft / unit2);
            timeLeft -= value * unit2;
            return current.replace(replaceRegex, (match) => String(value).padStart(match.length, "0"));
          }
          return current;
        }, format2);
        return replacedText.replace(escapeRegex, "$1");
      };
      const __default__$C = defineComponent({
        name: "ElCountdown"
      });
      const _sfc_main$J = /* @__PURE__ */ defineComponent({
        ...__default__$C,
        props: countdownProps,
        emits: countdownEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          let timer;
          const rawValue = ref(0);
          const displayValue = computed(() => formatTime$1(rawValue.value, props2.format));
          const formatter2 = (val) => formatTime$1(val, props2.format);
          const stopTimer = () => {
            if (timer) {
              cAF(timer);
              timer = void 0;
            }
          };
          const startTimer = () => {
            const timestamp = getTime(props2.value);
            const frameFunc = () => {
              let diff = timestamp - Date.now();
              emit(CHANGE_EVENT, diff);
              if (diff <= 0) {
                diff = 0;
                stopTimer();
                emit("finish");
              } else {
                timer = rAF(frameFunc);
              }
              rawValue.value = diff;
            };
            timer = rAF(frameFunc);
          };
          onMounted(() => {
            rawValue.value = getTime(props2.value) - Date.now();
            watch(() => [props2.value, props2.format], () => {
              stopTimer();
              startTimer();
            }, {
              immediate: true
            });
          });
          onBeforeUnmount(() => {
            stopTimer();
          });
          expose({
            displayValue
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElStatistic), {
              value: rawValue.value,
              title: _ctx.title,
              prefix: _ctx.prefix,
              suffix: _ctx.suffix,
              "value-style": _ctx.valueStyle,
              formatter: formatter2
            }, createSlots({
              _: 2
            }, [
              renderList(_ctx.$slots, (_2, name) => {
                return {
                  name,
                  fn: withCtx(() => [
                    renderSlot(_ctx.$slots, name)
                  ])
                };
              })
            ]), 1032, ["value", "title", "prefix", "suffix", "value-style"]);
          };
        }
      });
      var Countdown = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["__file", "countdown.vue"]]);
      const ElCountdown = exports("ElCountdown", withInstall(Countdown));
      const stepsProps = exports("stepsProps", buildProps({
        space: {
          type: [Number, String],
          default: ""
        },
        active: {
          type: Number,
          default: 0
        },
        direction: {
          type: String,
          default: "horizontal",
          values: ["horizontal", "vertical"]
        },
        alignCenter: {
          type: Boolean
        },
        simple: {
          type: Boolean
        },
        finishStatus: {
          type: String,
          values: ["wait", "process", "finish", "error", "success"],
          default: "finish"
        },
        processStatus: {
          type: String,
          values: ["wait", "process", "finish", "error", "success"],
          default: "process"
        }
      }));
      const stepsEmits = exports("stepsEmits", {
        [CHANGE_EVENT]: (newVal, oldVal) => [newVal, oldVal].every(isNumber)
      });
      const STEPS_INJECTION_KEY = exports("STEPS_INJECTION_KEY", "ElSteps");
      const __default__$B = defineComponent({
        name: "ElSteps"
      });
      const _sfc_main$I = /* @__PURE__ */ defineComponent({
        ...__default__$B,
        props: stepsProps,
        emits: stepsEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const ns = useNamespace("steps");
          const {
            children: steps,
            addChild: addStep,
            removeChild: removeStep,
            ChildrenSorter: StepsSorter
          } = useOrderedChildren(getCurrentInstance(), "ElStep");
          watch(steps, () => {
            steps.value.forEach((instance, index2) => {
              instance.setIndex(index2);
            });
          });
          provide(STEPS_INJECTION_KEY, { props: props2, steps, addStep, removeStep });
          watch(() => props2.active, (newVal, oldVal) => {
            emit(CHANGE_EVENT, newVal, oldVal);
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b(), unref(ns).m(_ctx.simple ? "simple" : _ctx.direction)])
            }, [
              renderSlot(_ctx.$slots, "default"),
              createVNode(unref(StepsSorter))
            ], 2);
          };
        }
      });
      var Steps = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["__file", "steps.vue"]]);
      const stepProps = exports("stepProps", buildProps({
        title: {
          type: String,
          default: ""
        },
        icon: {
          type: iconPropType
        },
        description: {
          type: String,
          default: ""
        },
        status: {
          type: String,
          values: ["", "wait", "process", "finish", "error", "success"],
          default: ""
        }
      }));
      const __default__$A = defineComponent({
        name: "ElStep"
      });
      const _sfc_main$H = defineComponent({
        ...__default__$A,
        props: stepProps,
        setup(__props) {
          const props2 = __props;
          const ns = useNamespace("step");
          const index2 = ref(-1);
          const lineStyle = ref({});
          const internalStatus = ref("");
          const parent2 = inject(STEPS_INJECTION_KEY);
          const currentInstance = getCurrentInstance();
          onMounted(() => {
            watch([
              () => parent2.props.active,
              () => parent2.props.processStatus,
              () => parent2.props.finishStatus
            ], ([active]) => {
              updateStatus(active);
            }, { immediate: true });
          });
          const currentStatus = computed(() => {
            return props2.status || internalStatus.value;
          });
          const prevStatus = computed(() => {
            const prevStep = parent2.steps.value[index2.value - 1];
            return prevStep ? prevStep.currentStatus : "wait";
          });
          const isCenter = computed(() => {
            return parent2.props.alignCenter;
          });
          const isVertical = computed(() => {
            return parent2.props.direction === "vertical";
          });
          const isSimple = computed(() => {
            return parent2.props.simple;
          });
          const stepsCount = computed(() => {
            return parent2.steps.value.length;
          });
          const isLast = computed(() => {
            var _a;
            return ((_a = parent2.steps.value[stepsCount.value - 1]) == null ? void 0 : _a.uid) === currentInstance.uid;
          });
          const space = computed(() => {
            return isSimple.value ? "" : parent2.props.space;
          });
          const containerKls = computed(() => {
            return [
              ns.b(),
              ns.is(isSimple.value ? "simple" : parent2.props.direction),
              ns.is("flex", isLast.value && !space.value && !isCenter.value),
              ns.is("center", isCenter.value && !isVertical.value && !isSimple.value)
            ];
          });
          const style = computed(() => {
            const style2 = {
              flexBasis: isNumber(space.value) ? `${space.value}px` : space.value ? space.value : `${100 / (stepsCount.value - (isCenter.value ? 0 : 1))}%`
            };
            if (isVertical.value)
              return style2;
            if (isLast.value) {
              style2.maxWidth = `${100 / stepsCount.value}%`;
            }
            return style2;
          });
          const setIndex = (val) => {
            index2.value = val;
          };
          const calcProgress = (status) => {
            const isWait = status === "wait";
            const style2 = {
              transitionDelay: `${isWait ? "-" : ""}${150 * index2.value}ms`
            };
            const step2 = status === parent2.props.processStatus || isWait ? 0 : 100;
            style2.borderWidth = step2 && !isSimple.value ? "1px" : 0;
            style2[parent2.props.direction === "vertical" ? "height" : "width"] = `${step2}%`;
            lineStyle.value = style2;
          };
          const updateStatus = (activeIndex) => {
            if (activeIndex > index2.value) {
              internalStatus.value = parent2.props.finishStatus;
            } else if (activeIndex === index2.value && prevStatus.value !== "error") {
              internalStatus.value = parent2.props.processStatus;
            } else {
              internalStatus.value = "wait";
            }
            const prevChild = parent2.steps.value[index2.value - 1];
            if (prevChild)
              prevChild.calcProgress(internalStatus.value);
          };
          const stepItemState = reactive({
            uid: currentInstance.uid,
            getVnode: () => currentInstance.vnode,
            currentStatus,
            setIndex,
            calcProgress
          });
          parent2.addStep(stepItemState);
          onBeforeUnmount(() => {
            parent2.removeStep(stepItemState);
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              style: normalizeStyle(unref(style)),
              class: normalizeClass(unref(containerKls))
            }, [
              createCommentVNode(" icon & line "),
              createElementVNode("div", {
                class: normalizeClass([unref(ns).e("head"), unref(ns).is(unref(currentStatus))])
              }, [
                !unref(isSimple) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).e("line"))
                }, [
                  createElementVNode("i", {
                    class: normalizeClass(unref(ns).e("line-inner")),
                    style: normalizeStyle(lineStyle.value)
                  }, null, 6)
                ], 2)) : createCommentVNode("v-if", true),
                createElementVNode("div", {
                  class: normalizeClass([unref(ns).e("icon"), unref(ns).is(_ctx.icon || _ctx.$slots.icon ? "icon" : "text")])
                }, [
                  renderSlot(_ctx.$slots, "icon", {}, () => [
                    _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(unref(ns).e("icon-inner"))
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : unref(currentStatus) === "success" ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 1,
                      class: normalizeClass([unref(ns).e("icon-inner"), unref(ns).is("status")])
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(check_default$1))
                      ]),
                      _: 1
                    }, 8, ["class"])) : unref(currentStatus) === "error" ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 2,
                      class: normalizeClass([unref(ns).e("icon-inner"), unref(ns).is("status")])
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(close_default$1))
                      ]),
                      _: 1
                    }, 8, ["class"])) : !unref(isSimple) ? (openBlock(), createElementBlock("div", {
                      key: 3,
                      class: normalizeClass(unref(ns).e("icon-inner"))
                    }, toDisplayString(index2.value + 1), 3)) : createCommentVNode("v-if", true)
                  ])
                ], 2)
              ], 2),
              createCommentVNode(" title & description "),
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("main"))
              }, [
                createElementVNode("div", {
                  class: normalizeClass([unref(ns).e("title"), unref(ns).is(unref(currentStatus))])
                }, [
                  renderSlot(_ctx.$slots, "title", {}, () => [
                    createTextVNode(toDisplayString(_ctx.title), 1)
                  ])
                ], 2),
                unref(isSimple) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).e("arrow"))
                }, null, 2)) : (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass([unref(ns).e("description"), unref(ns).is(unref(currentStatus))])
                }, [
                  renderSlot(_ctx.$slots, "description", {}, () => [
                    createTextVNode(toDisplayString(_ctx.description), 1)
                  ])
                ], 2))
              ], 2)
            ], 6);
          };
        }
      });
      var Step = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["__file", "item.vue"]]);
      const ElSteps = exports("ElSteps", withInstall(Steps, {
        Step
      }));
      const ElStep = exports("ElStep", withNoopInstall(Step));
      const switchProps = exports("switchProps", buildProps({
        modelValue: {
          type: [Boolean, String, Number],
          default: false
        },
        disabled: Boolean,
        loading: Boolean,
        size: {
          type: String,
          validator: isValidComponentSize
        },
        width: {
          type: [String, Number],
          default: ""
        },
        inlinePrompt: Boolean,
        inactiveActionIcon: {
          type: iconPropType
        },
        activeActionIcon: {
          type: iconPropType
        },
        activeIcon: {
          type: iconPropType
        },
        inactiveIcon: {
          type: iconPropType
        },
        activeText: {
          type: String,
          default: ""
        },
        inactiveText: {
          type: String,
          default: ""
        },
        activeValue: {
          type: [Boolean, String, Number],
          default: true
        },
        inactiveValue: {
          type: [Boolean, String, Number],
          default: false
        },
        name: {
          type: String,
          default: ""
        },
        validateEvent: {
          type: Boolean,
          default: true
        },
        beforeChange: {
          type: definePropType(Function)
        },
        id: String,
        tabindex: {
          type: [String, Number]
        },
        ...useAriaProps(["ariaLabel"])
      }));
      const switchEmits = exports("switchEmits", {
        [UPDATE_MODEL_EVENT]: (val) => isBoolean(val) || isString$1(val) || isNumber(val),
        [CHANGE_EVENT]: (val) => isBoolean(val) || isString$1(val) || isNumber(val),
        [INPUT_EVENT]: (val) => isBoolean(val) || isString$1(val) || isNumber(val)
      });
      const COMPONENT_NAME$9 = "ElSwitch";
      const __default__$z = defineComponent({
        name: COMPONENT_NAME$9
      });
      const _sfc_main$G = /* @__PURE__ */ defineComponent({
        ...__default__$z,
        props: switchProps,
        emits: switchEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const { formItem } = useFormItem();
          const switchSize = useFormSize();
          const ns = useNamespace("switch");
          const { inputId } = useFormItemInputId(props2, {
            formItemContext: formItem
          });
          const switchDisabled = useFormDisabled(computed(() => props2.loading));
          const isControlled = ref(props2.modelValue !== false);
          const input = ref();
          const core = ref();
          const switchKls = computed(() => [
            ns.b(),
            ns.m(switchSize.value),
            ns.is("disabled", switchDisabled.value),
            ns.is("checked", checked.value)
          ]);
          const labelLeftKls = computed(() => [
            ns.e("label"),
            ns.em("label", "left"),
            ns.is("active", !checked.value)
          ]);
          const labelRightKls = computed(() => [
            ns.e("label"),
            ns.em("label", "right"),
            ns.is("active", checked.value)
          ]);
          const coreStyle = computed(() => ({
            width: addUnit(props2.width)
          }));
          watch(() => props2.modelValue, () => {
            isControlled.value = true;
          });
          const actualValue = computed(() => {
            return isControlled.value ? props2.modelValue : false;
          });
          const checked = computed(() => actualValue.value === props2.activeValue);
          if (![props2.activeValue, props2.inactiveValue].includes(actualValue.value)) {
            emit(UPDATE_MODEL_EVENT, props2.inactiveValue);
            emit(CHANGE_EVENT, props2.inactiveValue);
            emit(INPUT_EVENT, props2.inactiveValue);
          }
          watch(checked, (val) => {
            var _a;
            input.value.checked = val;
            if (props2.validateEvent) {
              (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change").catch((err) => debugWarn());
            }
          });
          const handleChange = () => {
            const val = checked.value ? props2.inactiveValue : props2.activeValue;
            emit(UPDATE_MODEL_EVENT, val);
            emit(CHANGE_EVENT, val);
            emit(INPUT_EVENT, val);
            nextTick(() => {
              input.value.checked = checked.value;
            });
          };
          const switchValue = () => {
            if (switchDisabled.value)
              return;
            const { beforeChange } = props2;
            if (!beforeChange) {
              handleChange();
              return;
            }
            const shouldChange = beforeChange();
            const isPromiseOrBool = [
              isPromise(shouldChange),
              isBoolean(shouldChange)
            ].includes(true);
            if (!isPromiseOrBool) {
              throwError(COMPONENT_NAME$9, "beforeChange must return type `Promise<boolean>` or `boolean`");
            }
            if (isPromise(shouldChange)) {
              shouldChange.then((result2) => {
                if (result2) {
                  handleChange();
                }
              }).catch((e) => {
              });
            } else if (shouldChange) {
              handleChange();
            }
          };
          const focus = () => {
            var _a, _b;
            (_b = (_a = input.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
          };
          onMounted(() => {
            input.value.checked = checked.value;
          });
          expose({
            focus,
            checked
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(switchKls)),
              onClick: withModifiers(switchValue, ["prevent"])
            }, [
              createElementVNode("input", {
                id: unref(inputId),
                ref_key: "input",
                ref: input,
                class: normalizeClass(unref(ns).e("input")),
                type: "checkbox",
                role: "switch",
                "aria-checked": unref(checked),
                "aria-disabled": unref(switchDisabled),
                "aria-label": _ctx.ariaLabel,
                name: _ctx.name,
                "true-value": _ctx.activeValue,
                "false-value": _ctx.inactiveValue,
                disabled: unref(switchDisabled),
                tabindex: _ctx.tabindex,
                onChange: handleChange,
                onKeydown: withKeys(switchValue, ["enter"])
              }, null, 42, ["id", "aria-checked", "aria-disabled", "aria-label", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"]),
              !_ctx.inlinePrompt && (_ctx.inactiveIcon || _ctx.inactiveText) ? (openBlock(), createElementBlock("span", {
                key: 0,
                class: normalizeClass(unref(labelLeftKls))
              }, [
                _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveIcon)))
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                !_ctx.inactiveIcon && _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  "aria-hidden": unref(checked)
                }, toDisplayString(_ctx.inactiveText), 9, ["aria-hidden"])) : createCommentVNode("v-if", true)
              ], 2)) : createCommentVNode("v-if", true),
              createElementVNode("span", {
                ref_key: "core",
                ref: core,
                class: normalizeClass(unref(ns).e("core")),
                style: normalizeStyle(unref(coreStyle))
              }, [
                _ctx.inlinePrompt ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).e("inner"))
                }, [
                  _ctx.activeIcon || _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns).is("icon"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(checked) ? _ctx.activeIcon : _ctx.inactiveIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : _ctx.activeText || _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass(unref(ns).is("text")),
                    "aria-hidden": !unref(checked)
                  }, toDisplayString(unref(checked) ? _ctx.activeText : _ctx.inactiveText), 11, ["aria-hidden"])) : createCommentVNode("v-if", true)
                ], 2)) : createCommentVNode("v-if", true),
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).e("action"))
                }, [
                  _ctx.loading ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(ns).is("loading"))
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(loading_default$1))
                    ]),
                    _: 1
                  }, 8, ["class"])) : unref(checked) ? renderSlot(_ctx.$slots, "active-action", { key: 1 }, () => [
                    _ctx.activeActionIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeActionIcon)))
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true)
                  ]) : !unref(checked) ? renderSlot(_ctx.$slots, "inactive-action", { key: 2 }, () => [
                    _ctx.inactiveActionIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveActionIcon)))
                      ]),
                      _: 1
                    })) : createCommentVNode("v-if", true)
                  ]) : createCommentVNode("v-if", true)
                ], 2)
              ], 6),
              !_ctx.inlinePrompt && (_ctx.activeIcon || _ctx.activeText) ? (openBlock(), createElementBlock("span", {
                key: 1,
                class: normalizeClass(unref(labelRightKls))
              }, [
                _ctx.activeIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeIcon)))
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                !_ctx.activeIcon && _ctx.activeText ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  "aria-hidden": !unref(checked)
                }, toDisplayString(_ctx.activeText), 9, ["aria-hidden"])) : createCommentVNode("v-if", true)
              ], 2)) : createCommentVNode("v-if", true)
            ], 10, ["onClick"]);
          };
        }
      });
      var Switch = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["__file", "switch.vue"]]);
      const ElSwitch = exports("ElSwitch", withInstall(Switch));
      const getCell = function(event) {
        var _a;
        return (_a = event.target) == null ? void 0 : _a.closest("td");
      };
      const orderBy = function(array3, sortKey, reverse2, sortMethod, sortBy2) {
        if (!sortKey && !sortMethod && (!sortBy2 || isArray$1(sortBy2) && !sortBy2.length)) {
          return array3;
        }
        if (isString$1(reverse2)) {
          reverse2 = reverse2 === "descending" ? -1 : 1;
        } else {
          reverse2 = reverse2 && reverse2 < 0 ? -1 : 1;
        }
        const getKey = sortMethod ? null : function(value, index2) {
          if (sortBy2) {
            return flatMap(castArray$1(sortBy2), (by) => {
              if (isString$1(by)) {
                return get(value, by);
              } else {
                return by(value, index2, array3);
              }
            });
          }
          if (sortKey !== "$key") {
            if (isObject$1(value) && "$value" in value)
              value = value.$value;
          }
          return [
            isObject$1(value) ? sortKey ? get(value, sortKey) : null : value
          ];
        };
        const compare = function(a2, b2) {
          var _a, _b, _c, _d, _e, _f;
          if (sortMethod) {
            return sortMethod(a2.value, b2.value);
          }
          for (let i = 0, len = (_b = (_a = a2.key) == null ? void 0 : _a.length) != null ? _b : 0; i < len; i++) {
            if (((_c = a2.key) == null ? void 0 : _c[i]) < ((_d = b2.key) == null ? void 0 : _d[i])) {
              return -1;
            }
            if (((_e = a2.key) == null ? void 0 : _e[i]) > ((_f = b2.key) == null ? void 0 : _f[i])) {
              return 1;
            }
          }
          return 0;
        };
        return array3.map((value, index2) => {
          return {
            value,
            index: index2,
            key: getKey ? getKey(value, index2) : null
          };
        }).sort((a2, b2) => {
          let order = compare(a2, b2);
          if (!order) {
            order = a2.index - b2.index;
          }
          return order * +reverse2;
        }).map((item) => item.value);
      };
      const getColumnById = function(table, columnId) {
        let column = null;
        table.columns.forEach((item) => {
          if (item.id === columnId) {
            column = item;
          }
        });
        return column;
      };
      const getColumnByKey = function(table, columnKey) {
        let column = null;
        for (let i = 0; i < table.columns.length; i++) {
          const item = table.columns[i];
          if (item.columnKey === columnKey) {
            column = item;
            break;
          }
        }
        if (!column)
          throwError("ElTable", `No column matching with column-key: ${columnKey}`);
        return column;
      };
      const getColumnByCell = function(table, cell, namespace) {
        const matches2 = (cell.className || "").match(new RegExp(`${namespace}-table_[^\\s]+`, "gm"));
        if (matches2) {
          return getColumnById(table, matches2[0]);
        }
        return null;
      };
      const getRowIdentity = (row, rowKey2) => {
        if (!row)
          throw new Error("Row is required when get row identity");
        if (isString$1(rowKey2)) {
          if (!rowKey2.includes(".")) {
            return `${row[rowKey2]}`;
          }
          const key = rowKey2.split(".");
          let current = row;
          for (const element of key) {
            current = current[element];
          }
          return `${current}`;
        } else if (isFunction$1(rowKey2)) {
          return rowKey2.call(null, row);
        }
        return "";
      };
      const getKeysMap = function(array3, rowKey2, flatten2 = false, childrenKey = "children") {
        const data = array3 || [];
        const arrayMap2 = {};
        data.forEach((row, index2) => {
          arrayMap2[getRowIdentity(row, rowKey2)] = { row, index: index2 };
          if (flatten2) {
            const children = row[childrenKey];
            if (isArray$1(children)) {
              Object.assign(arrayMap2, getKeysMap(children, rowKey2, true, childrenKey));
            }
          }
        });
        return arrayMap2;
      };
      function mergeOptions(defaults2, config) {
        const options = {};
        let key;
        for (key in defaults2) {
          options[key] = defaults2[key];
        }
        for (key in config) {
          if (hasOwn(config, key)) {
            const value = config[key];
            if (!isUndefined(value)) {
              options[key] = value;
            }
          }
        }
        return options;
      }
      function parseWidth(width) {
        if (width === "")
          return width;
        if (!isUndefined(width)) {
          width = Number.parseInt(width, 10);
          if (Number.isNaN(width)) {
            width = "";
          }
        }
        return width;
      }
      function parseMinWidth(minWidth) {
        if (minWidth === "")
          return minWidth;
        if (!isUndefined(minWidth)) {
          minWidth = parseWidth(minWidth);
          if (Number.isNaN(minWidth)) {
            minWidth = 80;
          }
        }
        return minWidth;
      }
      function parseHeight(height) {
        if (isNumber(height)) {
          return height;
        }
        if (isString$1(height)) {
          if (/^\d+(?:px)?$/.test(height)) {
            return Number.parseInt(height, 10);
          } else {
            return height;
          }
        }
        return null;
      }
      function compose(...funcs) {
        if (funcs.length === 0) {
          return (arg) => arg;
        }
        if (funcs.length === 1) {
          return funcs[0];
        }
        return funcs.reduce((a2, b2) => (...args) => a2(b2(...args)));
      }
      function toggleRowStatus(statusArr, row, newVal, tableTreeProps, selectable, rowIndex, rowKey2) {
        let _rowIndex = rowIndex != null ? rowIndex : 0;
        let changed = false;
        const getIndex = () => {
          if (!rowKey2) {
            return statusArr.indexOf(row);
          }
          const id = getRowIdentity(row, rowKey2);
          return statusArr.findIndex((item) => getRowIdentity(item, rowKey2) === id);
        };
        const index2 = getIndex();
        const included = index2 !== -1;
        const isRowSelectable = selectable == null ? void 0 : selectable.call(null, row, _rowIndex);
        const toggleStatus = (type) => {
          if (type === "add") {
            statusArr.push(row);
          } else {
            statusArr.splice(index2, 1);
          }
          changed = true;
        };
        const getChildrenCount = (row2) => {
          let count = 0;
          const children = (tableTreeProps == null ? void 0 : tableTreeProps.children) && row2[tableTreeProps.children];
          if (children && isArray$1(children)) {
            count += children.length;
            children.forEach((item) => {
              count += getChildrenCount(item);
            });
          }
          return count;
        };
        if (!selectable || isRowSelectable) {
          if (isBoolean(newVal)) {
            if (newVal && !included) {
              toggleStatus("add");
            } else if (!newVal && included) {
              toggleStatus("remove");
            }
          } else {
            included ? toggleStatus("remove") : toggleStatus("add");
          }
        }
        if (!(tableTreeProps == null ? void 0 : tableTreeProps.checkStrictly) && (tableTreeProps == null ? void 0 : tableTreeProps.children) && isArray$1(row[tableTreeProps.children])) {
          row[tableTreeProps.children].forEach((item) => {
            const childChanged = toggleRowStatus(statusArr, item, newVal != null ? newVal : !included, tableTreeProps, selectable, _rowIndex + 1, rowKey2);
            _rowIndex += getChildrenCount(item) + 1;
            if (childChanged) {
              changed = childChanged;
            }
          });
        }
        return changed;
      }
      function walkTreeNode(root2, cb, childrenKey = "children", lazyKey = "hasChildren", lazy = false) {
        const isNil2 = (array3) => !(isArray$1(array3) && array3.length);
        function _walker(parent2, children, level) {
          cb(parent2, children, level);
          children.forEach((item) => {
            if (item[lazyKey] && lazy) {
              cb(item, null, level + 1);
              return;
            }
            const children2 = item[childrenKey];
            if (!isNil2(children2)) {
              _walker(item, children2, level + 1);
            }
          });
        }
        root2.forEach((item) => {
          if (item[lazyKey] && lazy) {
            cb(item, null, 0);
            return;
          }
          const children = item[childrenKey];
          if (!isNil2(children)) {
            _walker(item, children, 0);
          }
        });
      }
      const getTableOverflowTooltipProps = (props2, innerText, row, column) => {
        const popperOptions = {
          strategy: "fixed",
          ...props2.popperOptions
        };
        const tooltipFormatterContent = isFunction$1(column == null ? void 0 : column.tooltipFormatter) ? column.tooltipFormatter({
          row,
          column,
          cellValue: getProp(row, column.property).value
        }) : void 0;
        if (isVNode(tooltipFormatterContent)) {
          return {
            slotContent: tooltipFormatterContent,
            content: null,
            ...props2,
            popperOptions
          };
        }
        return {
          slotContent: null,
          content: tooltipFormatterContent != null ? tooltipFormatterContent : innerText,
          ...props2,
          popperOptions
        };
      };
      let removePopper = null;
      function createTablePopper(props2, popperContent, row, column, trigger, table) {
        var _a;
        const tableOverflowTooltipProps = getTableOverflowTooltipProps(props2, popperContent, row, column);
        const mergedProps = {
          ...tableOverflowTooltipProps,
          slotContent: void 0
        };
        if ((removePopper == null ? void 0 : removePopper.trigger) === trigger) {
          const comp = (_a = removePopper.vm) == null ? void 0 : _a.component;
          merge(comp == null ? void 0 : comp.props, mergedProps);
          if (comp && tableOverflowTooltipProps.slotContent) {
            comp.slots.content = () => [tableOverflowTooltipProps.slotContent];
          }
          return;
        }
        removePopper == null ? void 0 : removePopper();
        const parentNode = table == null ? void 0 : table.refs.tableWrapper;
        const ns = parentNode == null ? void 0 : parentNode.dataset.prefix;
        const vm = createVNode(ElTooltip, {
          virtualTriggering: true,
          virtualRef: trigger,
          appendTo: parentNode,
          placement: "top",
          transition: "none",
          offset: 0,
          hideAfter: 0,
          ...mergedProps
        }, tableOverflowTooltipProps.slotContent ? {
          content: () => tableOverflowTooltipProps.slotContent
        } : void 0);
        vm.appContext = { ...table.appContext, ...table };
        const container = document.createElement("div");
        render(vm, container);
        vm.component.exposed.onOpen();
        const scrollContainer = parentNode == null ? void 0 : parentNode.querySelector(`.${ns}-scrollbar__wrap`);
        removePopper = () => {
          render(null, container);
          scrollContainer == null ? void 0 : scrollContainer.removeEventListener("scroll", removePopper);
          removePopper = null;
        };
        removePopper.trigger = trigger != null ? trigger : void 0;
        removePopper.vm = vm;
        scrollContainer == null ? void 0 : scrollContainer.addEventListener("scroll", removePopper);
      }
      function getCurrentColumns(column) {
        if (column.children) {
          return flatMap(column.children, getCurrentColumns);
        } else {
          return [column];
        }
      }
      function getColSpan(colSpan, column) {
        return colSpan + column.colSpan;
      }
      const isFixedColumn = (index2, fixed, store, realColumns) => {
        let start = 0;
        let after2 = index2;
        const columns2 = store.states.columns.value;
        if (realColumns) {
          const curColumns = getCurrentColumns(realColumns[index2]);
          const preColumns = columns2.slice(0, columns2.indexOf(curColumns[0]));
          start = preColumns.reduce(getColSpan, 0);
          after2 = start + curColumns.reduce(getColSpan, 0) - 1;
        } else {
          start = index2;
        }
        let fixedLayout;
        switch (fixed) {
          case "left":
            if (after2 < store.states.fixedLeafColumnsLength.value) {
              fixedLayout = "left";
            }
            break;
          case "right":
            if (start >= columns2.length - store.states.rightFixedLeafColumnsLength.value) {
              fixedLayout = "right";
            }
            break;
          default:
            if (after2 < store.states.fixedLeafColumnsLength.value) {
              fixedLayout = "left";
            } else if (start >= columns2.length - store.states.rightFixedLeafColumnsLength.value) {
              fixedLayout = "right";
            }
        }
        return fixedLayout ? {
          direction: fixedLayout,
          start,
          after: after2
        } : {};
      };
      const getFixedColumnsClass = (namespace, index2, fixed, store, realColumns, offset2 = 0) => {
        const classes = [];
        const { direction: direction2, start, after: after2 } = isFixedColumn(index2, fixed, store, realColumns);
        if (direction2) {
          const isLeft = direction2 === "left";
          classes.push(`${namespace}-fixed-column--${direction2}`);
          if (isLeft && after2 + offset2 === store.states.fixedLeafColumnsLength.value - 1) {
            classes.push("is-last-column");
          } else if (!isLeft && start - offset2 === store.states.columns.value.length - store.states.rightFixedLeafColumnsLength.value) {
            classes.push("is-first-column");
          }
        }
        return classes;
      };
      function getOffset(offset2, column) {
        return offset2 + (isNull(column.realWidth) || Number.isNaN(column.realWidth) ? Number(column.width) : column.realWidth);
      }
      const getFixedColumnOffset = (index2, fixed, store, realColumns) => {
        const {
          direction: direction2,
          start = 0,
          after: after2 = 0
        } = isFixedColumn(index2, fixed, store, realColumns);
        if (!direction2) {
          return;
        }
        const styles = {};
        const isLeft = direction2 === "left";
        const columns2 = store.states.columns.value;
        if (isLeft) {
          styles.left = columns2.slice(0, start).reduce(getOffset, 0);
        } else {
          styles.right = columns2.slice(after2 + 1).reverse().reduce(getOffset, 0);
        }
        return styles;
      };
      const ensurePosition = (style, key) => {
        if (!style)
          return;
        if (!Number.isNaN(style[key])) {
          style[key] = `${style[key]}px`;
        }
      };
      function useExpand(watcherData) {
        const instance = getCurrentInstance();
        const defaultExpandAll = ref(false);
        const expandRows = ref([]);
        const updateExpandRows = () => {
          const data = watcherData.data.value || [];
          const rowKey2 = watcherData.rowKey.value;
          if (defaultExpandAll.value) {
            expandRows.value = data.slice();
          } else if (rowKey2) {
            const expandRowsMap = getKeysMap(expandRows.value, rowKey2);
            expandRows.value = data.reduce((prev, row) => {
              const rowId = getRowIdentity(row, rowKey2);
              const rowInfo = expandRowsMap[rowId];
              if (rowInfo) {
                prev.push(row);
              }
              return prev;
            }, []);
          } else {
            expandRows.value = [];
          }
        };
        const toggleRowExpansion = (row, expanded) => {
          const changed = toggleRowStatus(expandRows.value, row, expanded, void 0, void 0, void 0, watcherData.rowKey.value);
          if (changed) {
            instance.emit("expand-change", row, expandRows.value.slice());
          }
        };
        const setExpandRowKeys = (rowKeys) => {
          instance.store.assertRowKey();
          const data = watcherData.data.value || [];
          const rowKey2 = watcherData.rowKey.value;
          const keysMap = getKeysMap(data, rowKey2);
          expandRows.value = rowKeys.reduce((prev, cur) => {
            const info = keysMap[cur];
            if (info) {
              prev.push(info.row);
            }
            return prev;
          }, []);
        };
        const isRowExpanded = (row) => {
          const rowKey2 = watcherData.rowKey.value;
          if (rowKey2) {
            const expandMap = getKeysMap(expandRows.value, rowKey2);
            return !!expandMap[getRowIdentity(row, rowKey2)];
          }
          return expandRows.value.includes(row);
        };
        return {
          updateExpandRows,
          toggleRowExpansion,
          setExpandRowKeys,
          isRowExpanded,
          states: {
            expandRows,
            defaultExpandAll
          }
        };
      }
      function useCurrent(watcherData) {
        const instance = getCurrentInstance();
        const _currentRowKey = ref(null);
        const currentRow = ref(null);
        const setCurrentRowKey = (key) => {
          instance.store.assertRowKey();
          _currentRowKey.value = key;
          setCurrentRowByKey(key);
        };
        const restoreCurrentRowKey = () => {
          _currentRowKey.value = null;
        };
        const setCurrentRowByKey = (key) => {
          var _a;
          const { data, rowKey: rowKey2 } = watcherData;
          let _currentRow = null;
          if (rowKey2.value) {
            _currentRow = (_a = (unref(data) || []).find((item) => getRowIdentity(item, rowKey2.value) === key)) != null ? _a : null;
          }
          currentRow.value = _currentRow != null ? _currentRow : null;
          instance.emit("current-change", currentRow.value, null);
        };
        const updateCurrentRow = (_currentRow) => {
          const oldCurrentRow = currentRow.value;
          if (_currentRow && _currentRow !== oldCurrentRow) {
            currentRow.value = _currentRow;
            instance.emit("current-change", currentRow.value, oldCurrentRow);
            return;
          }
          if (!_currentRow && oldCurrentRow) {
            currentRow.value = null;
            instance.emit("current-change", null, oldCurrentRow);
          }
        };
        const updateCurrentRowData = () => {
          const rowKey2 = watcherData.rowKey.value;
          const data = watcherData.data.value || [];
          const oldCurrentRow = currentRow.value;
          if (oldCurrentRow && !data.includes(oldCurrentRow)) {
            if (rowKey2) {
              const currentRowKey = getRowIdentity(oldCurrentRow, rowKey2);
              setCurrentRowByKey(currentRowKey);
            } else {
              currentRow.value = null;
            }
            if (isNull(currentRow.value)) {
              instance.emit("current-change", null, oldCurrentRow);
            }
          } else if (_currentRowKey.value) {
            setCurrentRowByKey(_currentRowKey.value);
            restoreCurrentRowKey();
          }
        };
        return {
          setCurrentRowKey,
          restoreCurrentRowKey,
          setCurrentRowByKey,
          updateCurrentRow,
          updateCurrentRowData,
          states: {
            _currentRowKey,
            currentRow
          }
        };
      }
      function useTree$2(watcherData) {
        const expandRowKeys = ref([]);
        const treeData = ref({});
        const indent = ref(16);
        const lazy = ref(false);
        const lazyTreeNodeMap = ref({});
        const lazyColumnIdentifier = ref("hasChildren");
        const childrenColumnName = ref("children");
        const checkStrictly = ref(false);
        const instance = getCurrentInstance();
        const normalizedData = computed(() => {
          if (!watcherData.rowKey.value)
            return {};
          const data = watcherData.data.value || [];
          return normalize(data);
        });
        const normalizedLazyNode = computed(() => {
          const rowKey2 = watcherData.rowKey.value;
          const keys2 = Object.keys(lazyTreeNodeMap.value);
          const res = {};
          if (!keys2.length)
            return res;
          keys2.forEach((key) => {
            if (lazyTreeNodeMap.value[key].length) {
              const item = { children: [] };
              lazyTreeNodeMap.value[key].forEach((row) => {
                const currentRowKey = getRowIdentity(row, rowKey2);
                item.children.push(currentRowKey);
                if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {
                  res[currentRowKey] = { children: [] };
                }
              });
              res[key] = item;
            }
          });
          return res;
        });
        const normalize = (data) => {
          const rowKey2 = watcherData.rowKey.value;
          const res = {};
          walkTreeNode(data, (parent2, children, level) => {
            const parentId = getRowIdentity(parent2, rowKey2);
            if (isArray$1(children)) {
              res[parentId] = {
                children: children.map((row) => getRowIdentity(row, rowKey2)),
                level
              };
            } else if (lazy.value) {
              res[parentId] = {
                children: [],
                lazy: true,
                level
              };
            }
          }, childrenColumnName.value, lazyColumnIdentifier.value, lazy.value);
          return res;
        };
        const updateTreeData = (ifChangeExpandRowKeys = false, ifExpandAll) => {
          var _a, _b;
          ifExpandAll || (ifExpandAll = (_a = instance.store) == null ? void 0 : _a.states.defaultExpandAll.value);
          const nested = normalizedData.value;
          const normalizedLazyNode_ = normalizedLazyNode.value;
          const keys2 = Object.keys(nested);
          const newTreeData = {};
          if (keys2.length) {
            const oldTreeData = unref(treeData);
            const rootLazyRowKeys = [];
            const getExpanded = (oldValue, key) => {
              if (ifChangeExpandRowKeys) {
                if (expandRowKeys.value) {
                  return ifExpandAll || expandRowKeys.value.includes(key);
                } else {
                  return !!(ifExpandAll || (oldValue == null ? void 0 : oldValue.expanded));
                }
              } else {
                const included = ifExpandAll || expandRowKeys.value && expandRowKeys.value.includes(key);
                return !!((oldValue == null ? void 0 : oldValue.expanded) || included);
              }
            };
            keys2.forEach((key) => {
              const oldValue = oldTreeData[key];
              const newValue = { ...nested[key] };
              newValue.expanded = getExpanded(oldValue, key);
              if (newValue.lazy) {
                const { loaded = false, loading = false } = oldValue || {};
                newValue.loaded = !!loaded;
                newValue.loading = !!loading;
                rootLazyRowKeys.push(key);
              }
              newTreeData[key] = newValue;
            });
            const lazyKeys = Object.keys(normalizedLazyNode_);
            if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {
              lazyKeys.forEach((key) => {
                var _a2;
                const oldValue = oldTreeData[key];
                const lazyNodeChildren = normalizedLazyNode_[key].children;
                if (rootLazyRowKeys.includes(key)) {
                  if (((_a2 = newTreeData[key].children) == null ? void 0 : _a2.length) !== 0) {
                    throw new Error("[ElTable]children must be an empty array.");
                  }
                  newTreeData[key].children = lazyNodeChildren;
                } else {
                  const { loaded = false, loading = false } = oldValue || {};
                  newTreeData[key] = {
                    lazy: true,
                    loaded: !!loaded,
                    loading: !!loading,
                    expanded: getExpanded(oldValue, key),
                    children: lazyNodeChildren,
                    level: void 0
                  };
                }
              });
            }
          }
          treeData.value = newTreeData;
          (_b = instance.store) == null ? void 0 : _b.updateTableScrollY();
        };
        watch(() => expandRowKeys.value, () => {
          updateTreeData(true);
        });
        watch(() => normalizedData.value, () => {
          updateTreeData();
        });
        watch(() => normalizedLazyNode.value, () => {
          updateTreeData();
        });
        const updateTreeExpandKeys = (value) => {
          expandRowKeys.value = value;
          updateTreeData();
        };
        const isUseLazy = (data) => {
          return lazy.value && data && "loaded" in data && !data.loaded;
        };
        const toggleTreeExpansion = (row, expanded) => {
          instance.store.assertRowKey();
          const rowKey2 = watcherData.rowKey.value;
          const id = getRowIdentity(row, rowKey2);
          const data = id && treeData.value[id];
          if (id && data && "expanded" in data) {
            const oldExpanded = data.expanded;
            expanded = isUndefined(expanded) ? !data.expanded : expanded;
            treeData.value[id].expanded = expanded;
            if (oldExpanded !== expanded) {
              instance.emit("expand-change", row, expanded);
            }
            isUseLazy(data) && loadData(row, id, data);
            instance.store.updateTableScrollY();
          }
        };
        const loadOrToggle = (row) => {
          instance.store.assertRowKey();
          const rowKey2 = watcherData.rowKey.value;
          const id = getRowIdentity(row, rowKey2);
          const data = treeData.value[id];
          if (isUseLazy(data)) {
            loadData(row, id, data);
          } else {
            toggleTreeExpansion(row, void 0);
          }
        };
        const loadData = (row, key, treeNode) => {
          const { load } = instance.props;
          if (load && !treeData.value[key].loaded) {
            treeData.value[key].loading = true;
            load(row, treeNode, (data) => {
              if (!isArray$1(data)) {
                throw new TypeError("[ElTable] data must be an array");
              }
              treeData.value[key].loading = false;
              treeData.value[key].loaded = true;
              treeData.value[key].expanded = true;
              if (data.length) {
                lazyTreeNodeMap.value[key] = data;
              }
              instance.emit("expand-change", row, true);
            });
          }
        };
        const updateKeyChildren = (key, data) => {
          const { lazy: lazy2, rowKey: rowKey2 } = instance.props;
          if (!lazy2)
            return;
          if (!rowKey2)
            throw new Error("[Table] rowKey is required in updateKeyChild");
          if (lazyTreeNodeMap.value[key]) {
            lazyTreeNodeMap.value[key] = data;
          }
        };
        return {
          loadData,
          loadOrToggle,
          toggleTreeExpansion,
          updateTreeExpandKeys,
          updateTreeData,
          updateKeyChildren,
          normalize,
          states: {
            expandRowKeys,
            treeData,
            indent,
            lazy,
            lazyTreeNodeMap,
            lazyColumnIdentifier,
            childrenColumnName,
            checkStrictly
          }
        };
      }
      const sortData = (data, states) => {
        const sortingColumn = states.sortingColumn;
        if (!sortingColumn || isString$1(sortingColumn.sortable)) {
          return data;
        }
        return orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
      };
      const doFlattenColumns = (columns2) => {
        const result2 = [];
        columns2.forEach((column) => {
          if (column.children && column.children.length > 0) {
            result2.push.apply(result2, doFlattenColumns(column.children));
          } else {
            result2.push(column);
          }
        });
        return result2;
      };
      function useWatcher$1() {
        var _a;
        const instance = getCurrentInstance();
        const { size: tableSize } = toRefs((_a = instance.proxy) == null ? void 0 : _a.$props);
        const rowKey2 = ref(null);
        const data = ref([]);
        const _data = ref([]);
        const isComplex = ref(false);
        const _columns = ref([]);
        const originColumns = ref([]);
        const columns2 = ref([]);
        const fixedColumns = ref([]);
        const rightFixedColumns = ref([]);
        const leafColumns = ref([]);
        const fixedLeafColumns = ref([]);
        const rightFixedLeafColumns = ref([]);
        const updateOrderFns = [];
        const leafColumnsLength = ref(0);
        const fixedLeafColumnsLength = ref(0);
        const rightFixedLeafColumnsLength = ref(0);
        const isAllSelected = ref(false);
        const selection = ref([]);
        const reserveSelection = ref(false);
        const selectOnIndeterminate = ref(false);
        const selectable = ref(null);
        const filters = ref({});
        const filteredData = ref(null);
        const sortingColumn = ref(null);
        const sortProp = ref(null);
        const sortOrder = ref(null);
        const hoverRow = ref(null);
        const selectedMap = computed(() => {
          return rowKey2.value ? getKeysMap(selection.value, rowKey2.value) : void 0;
        });
        watch(data, () => {
          var _a2;
          if (instance.state) {
            scheduleLayout(false);
            const needUpdateFixed = instance.props.tableLayout === "auto";
            if (needUpdateFixed) {
              (_a2 = instance.refs.tableHeaderRef) == null ? void 0 : _a2.updateFixedColumnStyle();
            }
          }
        }, {
          deep: true
        });
        const assertRowKey = () => {
          if (!rowKey2.value)
            throw new Error("[ElTable] prop row-key is required");
        };
        const updateChildFixed = (column) => {
          var _a2;
          (_a2 = column.children) == null ? void 0 : _a2.forEach((childColumn) => {
            childColumn.fixed = column.fixed;
            updateChildFixed(childColumn);
          });
        };
        const updateColumns = () => {
          _columns.value.forEach((column) => {
            updateChildFixed(column);
          });
          fixedColumns.value = _columns.value.filter((column) => [true, "left"].includes(column.fixed));
          const selectColumn = _columns.value.find((column) => column.type === "selection");
          let selectColFixLeft;
          if (selectColumn && selectColumn.fixed !== "right" && !fixedColumns.value.includes(selectColumn)) {
            const selectColumnIndex = _columns.value.indexOf(selectColumn);
            if (selectColumnIndex === 0 && fixedColumns.value.length) {
              fixedColumns.value.unshift(selectColumn);
              selectColFixLeft = true;
            }
          }
          rightFixedColumns.value = _columns.value.filter((column) => column.fixed === "right");
          const notFixedColumns = _columns.value.filter((column) => (selectColFixLeft ? column.type !== "selection" : true) && !column.fixed);
          originColumns.value = Array.from(fixedColumns.value).concat(notFixedColumns).concat(rightFixedColumns.value);
          const leafColumns2 = doFlattenColumns(notFixedColumns);
          const fixedLeafColumns2 = doFlattenColumns(fixedColumns.value);
          const rightFixedLeafColumns2 = doFlattenColumns(rightFixedColumns.value);
          leafColumnsLength.value = leafColumns2.length;
          fixedLeafColumnsLength.value = fixedLeafColumns2.length;
          rightFixedLeafColumnsLength.value = rightFixedLeafColumns2.length;
          columns2.value = Array.from(fixedLeafColumns2).concat(leafColumns2).concat(rightFixedLeafColumns2);
          isComplex.value = fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;
        };
        const scheduleLayout = (needUpdateColumns, immediate = false) => {
          if (needUpdateColumns) {
            updateColumns();
          }
          if (immediate) {
            instance.state.doLayout();
          } else {
            instance.state.debouncedUpdateLayout();
          }
        };
        const isSelected = (row) => {
          if (selectedMap.value) {
            return !!selectedMap.value[getRowIdentity(row, rowKey2.value)];
          } else {
            return selection.value.includes(row);
          }
        };
        const clearSelection = () => {
          isAllSelected.value = false;
          const oldSelection = selection.value;
          selection.value = [];
          if (oldSelection.length) {
            instance.emit("selection-change", []);
          }
        };
        const cleanSelection = () => {
          var _a2, _b;
          let deleted;
          if (rowKey2.value) {
            deleted = [];
            const childrenKey = (_b = (_a2 = instance == null ? void 0 : instance.store) == null ? void 0 : _a2.states) == null ? void 0 : _b.childrenColumnName.value;
            const dataMap = getKeysMap(data.value, rowKey2.value, true, childrenKey);
            for (const key in selectedMap.value) {
              if (hasOwn(selectedMap.value, key) && !dataMap[key]) {
                deleted.push(selectedMap.value[key].row);
              }
            }
          } else {
            deleted = selection.value.filter((item) => !data.value.includes(item));
          }
          if (deleted.length) {
            const newSelection = selection.value.filter((item) => !deleted.includes(item));
            selection.value = newSelection;
            instance.emit("selection-change", newSelection.slice());
          }
        };
        const getSelectionRows = () => {
          return (selection.value || []).slice();
        };
        const toggleRowSelection = (row, selected, emitChange = true, ignoreSelectable = false) => {
          var _a2, _b, _c, _d;
          const treeProps2 = {
            children: (_b = (_a2 = instance == null ? void 0 : instance.store) == null ? void 0 : _a2.states) == null ? void 0 : _b.childrenColumnName.value,
            checkStrictly: (_d = (_c = instance == null ? void 0 : instance.store) == null ? void 0 : _c.states) == null ? void 0 : _d.checkStrictly.value
          };
          const changed = toggleRowStatus(selection.value, row, selected, treeProps2, ignoreSelectable ? void 0 : selectable.value, data.value.indexOf(row), rowKey2.value);
          if (changed) {
            const newSelection = (selection.value || []).slice();
            if (emitChange) {
              instance.emit("select", newSelection, row);
            }
            instance.emit("selection-change", newSelection);
          }
        };
        const _toggleAllSelection = () => {
          var _a2, _b;
          const value = selectOnIndeterminate.value ? !isAllSelected.value : !(isAllSelected.value || selection.value.length);
          isAllSelected.value = value;
          let selectionChanged = false;
          let childrenCount = 0;
          const rowKey22 = (_b = (_a2 = instance == null ? void 0 : instance.store) == null ? void 0 : _a2.states) == null ? void 0 : _b.rowKey.value;
          const { childrenColumnName } = instance.store.states;
          const treeProps2 = {
            children: childrenColumnName.value,
            checkStrictly: false
          };
          data.value.forEach((row, index2) => {
            const rowIndex = index2 + childrenCount;
            if (toggleRowStatus(selection.value, row, value, treeProps2, selectable.value, rowIndex, rowKey22)) {
              selectionChanged = true;
            }
            childrenCount += getChildrenCount(getRowIdentity(row, rowKey22));
          });
          if (selectionChanged) {
            instance.emit("selection-change", selection.value ? selection.value.slice() : []);
          }
          instance.emit("select-all", (selection.value || []).slice());
        };
        const updateAllSelected = () => {
          var _a2;
          if (((_a2 = data.value) == null ? void 0 : _a2.length) === 0) {
            isAllSelected.value = false;
            return;
          }
          const { childrenColumnName } = instance.store.states;
          let rowIndex = 0;
          let selectedCount = 0;
          const checkSelectedStatus = (data2) => {
            var _a3;
            for (const row of data2) {
              const isRowSelectable = selectable.value && selectable.value.call(null, row, rowIndex);
              if (!isSelected(row)) {
                if (!selectable.value || isRowSelectable) {
                  return false;
                }
              } else {
                selectedCount++;
              }
              rowIndex++;
              if (((_a3 = row[childrenColumnName.value]) == null ? void 0 : _a3.length) && !checkSelectedStatus(row[childrenColumnName.value])) {
                return false;
              }
            }
            return true;
          };
          const isAllSelected_ = checkSelectedStatus(data.value || []);
          isAllSelected.value = selectedCount === 0 ? false : isAllSelected_;
        };
        const getChildrenCount = (rowKey22) => {
          var _a2;
          if (!instance || !instance.store)
            return 0;
          const { treeData } = instance.store.states;
          let count = 0;
          const children = (_a2 = treeData.value[rowKey22]) == null ? void 0 : _a2.children;
          if (children) {
            count += children.length;
            children.forEach((childKey) => {
              count += getChildrenCount(childKey);
            });
          }
          return count;
        };
        const updateFilters = (column, values2) => {
          const filters_ = {};
          castArray$1(column).forEach((col) => {
            filters.value[col.id] = values2;
            filters_[col.columnKey || col.id] = values2;
          });
          return filters_;
        };
        const updateSort = (column, prop, order) => {
          if (sortingColumn.value && sortingColumn.value !== column) {
            sortingColumn.value.order = null;
          }
          sortingColumn.value = column;
          sortProp.value = prop;
          sortOrder.value = order;
        };
        const execFilter = () => {
          let sourceData = unref(_data);
          Object.keys(filters.value).forEach((columnId) => {
            const values2 = filters.value[columnId];
            if (!values2 || values2.length === 0)
              return;
            const column = getColumnById({
              columns: columns2.value
            }, columnId);
            if (column && column.filterMethod) {
              sourceData = sourceData.filter((row) => {
                return values2.some((value) => column.filterMethod.call(null, value, row, column));
              });
            }
          });
          filteredData.value = sourceData;
        };
        const execSort = () => {
          var _a2;
          data.value = sortData((_a2 = filteredData.value) != null ? _a2 : [], {
            sortingColumn: sortingColumn.value,
            sortProp: sortProp.value,
            sortOrder: sortOrder.value
          });
        };
        const execQuery = (ignore = void 0) => {
          if (!(ignore == null ? void 0 : ignore.filter)) {
            execFilter();
          }
          execSort();
        };
        const clearFilter = (columnKeys) => {
          const { tableHeaderRef } = instance.refs;
          if (!tableHeaderRef)
            return;
          const panels = Object.assign({}, tableHeaderRef.filterPanels);
          const keys2 = Object.keys(panels);
          if (!keys2.length)
            return;
          if (isString$1(columnKeys)) {
            columnKeys = [columnKeys];
          }
          if (isArray$1(columnKeys)) {
            const columns_ = columnKeys.map((key) => getColumnByKey({
              columns: columns2.value
            }, key));
            keys2.forEach((key) => {
              const column = columns_.find((col) => col.id === key);
              if (column) {
                column.filteredValue = [];
              }
            });
            instance.store.commit("filterChange", {
              column: columns_,
              values: [],
              silent: true,
              multi: true
            });
          } else {
            keys2.forEach((key) => {
              const column = columns2.value.find((col) => col.id === key);
              if (column) {
                column.filteredValue = [];
              }
            });
            filters.value = {};
            instance.store.commit("filterChange", {
              column: {},
              values: [],
              silent: true
            });
          }
        };
        const clearSort = () => {
          if (!sortingColumn.value)
            return;
          updateSort(null, null, null);
          instance.store.commit("changeSortCondition", {
            silent: true
          });
        };
        const {
          setExpandRowKeys,
          toggleRowExpansion,
          updateExpandRows,
          states: expandStates,
          isRowExpanded
        } = useExpand({
          data,
          rowKey: rowKey2
        });
        const {
          updateTreeExpandKeys,
          toggleTreeExpansion,
          updateTreeData,
          updateKeyChildren,
          loadOrToggle,
          states: treeStates
        } = useTree$2({
          data,
          rowKey: rowKey2
        });
        const {
          updateCurrentRowData,
          updateCurrentRow,
          setCurrentRowKey,
          states: currentData
        } = useCurrent({
          data,
          rowKey: rowKey2
        });
        const setExpandRowKeysAdapter = (val) => {
          setExpandRowKeys(val);
          updateTreeExpandKeys(val);
        };
        const toggleRowExpansionAdapter = (row, expanded) => {
          const hasExpandColumn = columns2.value.some(({ type }) => type === "expand");
          if (hasExpandColumn) {
            toggleRowExpansion(row, expanded);
          } else {
            toggleTreeExpansion(row, expanded);
          }
        };
        return {
          assertRowKey,
          updateColumns,
          scheduleLayout,
          isSelected,
          clearSelection,
          cleanSelection,
          getSelectionRows,
          toggleRowSelection,
          _toggleAllSelection,
          toggleAllSelection: null,
          updateAllSelected,
          updateFilters,
          updateCurrentRow,
          updateSort,
          execFilter,
          execSort,
          execQuery,
          clearFilter,
          clearSort,
          toggleRowExpansion,
          setExpandRowKeysAdapter,
          setCurrentRowKey,
          toggleRowExpansionAdapter,
          isRowExpanded,
          updateExpandRows,
          updateCurrentRowData,
          loadOrToggle,
          updateTreeData,
          updateKeyChildren,
          states: {
            tableSize,
            rowKey: rowKey2,
            data,
            _data,
            isComplex,
            _columns,
            originColumns,
            columns: columns2,
            fixedColumns,
            rightFixedColumns,
            leafColumns,
            fixedLeafColumns,
            rightFixedLeafColumns,
            updateOrderFns,
            leafColumnsLength,
            fixedLeafColumnsLength,
            rightFixedLeafColumnsLength,
            isAllSelected,
            selection,
            reserveSelection,
            selectOnIndeterminate,
            selectable,
            filters,
            filteredData,
            sortingColumn,
            sortProp,
            sortOrder,
            hoverRow,
            ...expandStates,
            ...treeStates,
            ...currentData
          }
        };
      }
      function replaceColumn(array3, column) {
        return array3.map((item) => {
          var _a;
          if (item.id === column.id) {
            return column;
          } else if ((_a = item.children) == null ? void 0 : _a.length) {
            item.children = replaceColumn(item.children, column);
          }
          return item;
        });
      }
      function sortColumn(array3) {
        array3.forEach((item) => {
          var _a, _b;
          item.no = (_a = item.getColumnIndex) == null ? void 0 : _a.call(item);
          if ((_b = item.children) == null ? void 0 : _b.length) {
            sortColumn(item.children);
          }
        });
        array3.sort((cur, pre) => cur.no - pre.no);
      }
      function useStore() {
        const instance = getCurrentInstance();
        const watcher = useWatcher$1();
        const ns = useNamespace("table");
        const mutations = {
          setData(states, data) {
            const dataInstanceChanged = unref(states._data) !== data;
            states.data.value = data;
            states._data.value = data;
            instance.store.execQuery();
            instance.store.updateCurrentRowData();
            instance.store.updateExpandRows();
            instance.store.updateTreeData(instance.store.states.defaultExpandAll.value);
            if (unref(states.reserveSelection)) {
              instance.store.assertRowKey();
            } else {
              if (dataInstanceChanged) {
                instance.store.clearSelection();
              } else {
                instance.store.cleanSelection();
              }
            }
            instance.store.updateAllSelected();
            if (instance.$ready) {
              instance.store.scheduleLayout();
            }
          },
          insertColumn(states, column, parent2, updateColumnOrder) {
            var _a;
            const array3 = unref(states._columns);
            let newColumns = [];
            if (!parent2) {
              array3.push(column);
              newColumns = array3;
            } else {
              if (parent2 && !parent2.children) {
                parent2.children = [];
              }
              (_a = parent2.children) == null ? void 0 : _a.push(column);
              newColumns = replaceColumn(array3, parent2);
            }
            sortColumn(newColumns);
            states._columns.value = newColumns;
            states.updateOrderFns.push(updateColumnOrder);
            if (column.type === "selection") {
              states.selectable.value = column.selectable;
              states.reserveSelection.value = column.reserveSelection;
            }
            if (instance.$ready) {
              instance.store.updateColumns();
              instance.store.scheduleLayout();
            }
          },
          updateColumnOrder(states, column) {
            var _a;
            const newColumnIndex = (_a = column.getColumnIndex) == null ? void 0 : _a.call(column);
            if (newColumnIndex === column.no)
              return;
            sortColumn(states._columns.value);
            if (instance.$ready) {
              instance.store.updateColumns();
            }
          },
          removeColumn(states, column, parent2, updateColumnOrder) {
            var _a;
            const array3 = unref(states._columns) || [];
            if (parent2) {
              (_a = parent2.children) == null ? void 0 : _a.splice(parent2.children.findIndex((item) => item.id === column.id), 1);
              nextTick(() => {
                var _a2;
                if (((_a2 = parent2.children) == null ? void 0 : _a2.length) === 0) {
                  delete parent2.children;
                }
              });
              states._columns.value = replaceColumn(array3, parent2);
            } else {
              const index2 = array3.indexOf(column);
              if (index2 > -1) {
                array3.splice(index2, 1);
                states._columns.value = array3;
              }
            }
            const updateFnIndex = states.updateOrderFns.indexOf(updateColumnOrder);
            updateFnIndex > -1 && states.updateOrderFns.splice(updateFnIndex, 1);
            if (instance.$ready) {
              instance.store.updateColumns();
              instance.store.scheduleLayout();
            }
          },
          sort(states, options) {
            const { prop, order, init } = options;
            if (prop) {
              const column = unref(states.columns).find((column2) => column2.property === prop);
              if (column) {
                column.order = order;
                instance.store.updateSort(column, prop, order);
                instance.store.commit("changeSortCondition", { init });
              }
            }
          },
          changeSortCondition(states, options) {
            const { sortingColumn, sortProp, sortOrder } = states;
            const columnValue = unref(sortingColumn), propValue = unref(sortProp), orderValue = unref(sortOrder);
            if (isNull(orderValue)) {
              states.sortingColumn.value = null;
              states.sortProp.value = null;
            }
            const ignore = { filter: true };
            instance.store.execQuery(ignore);
            if (!options || !(options.silent || options.init)) {
              instance.emit("sort-change", {
                column: columnValue,
                prop: propValue,
                order: orderValue
              });
            }
            instance.store.updateTableScrollY();
          },
          filterChange(_states, options) {
            const { column, values: values2, silent } = options;
            const newFilters = instance.store.updateFilters(column, values2);
            instance.store.execQuery();
            if (!silent) {
              instance.emit("filter-change", newFilters);
            }
            instance.store.updateTableScrollY();
          },
          toggleAllSelection() {
            var _a, _b;
            (_b = (_a = instance.store).toggleAllSelection) == null ? void 0 : _b.call(_a);
          },
          rowSelectedChanged(_states, row) {
            instance.store.toggleRowSelection(row);
            instance.store.updateAllSelected();
          },
          setHoverRow(states, row) {
            states.hoverRow.value = row;
          },
          setCurrentRow(_states, row) {
            instance.store.updateCurrentRow(row);
          }
        };
        const commit = function(name, ...args) {
          const mutations2 = instance.store.mutations;
          if (mutations2[name]) {
            mutations2[name].apply(instance, [
              instance.store.states,
              ...args
            ]);
          } else {
            throw new Error(`Action not found: ${name}`);
          }
        };
        const updateTableScrollY = function() {
          nextTick(() => instance.layout.updateScrollY.apply(instance.layout));
        };
        return {
          ns,
          ...watcher,
          mutations,
          commit,
          updateTableScrollY
        };
      }
      const InitialStateMap = {
        rowKey: "rowKey",
        defaultExpandAll: "defaultExpandAll",
        selectOnIndeterminate: "selectOnIndeterminate",
        indent: "indent",
        lazy: "lazy",
        data: "data",
        ["treeProps.hasChildren"]: {
          key: "lazyColumnIdentifier",
          default: "hasChildren"
        },
        ["treeProps.children"]: {
          key: "childrenColumnName",
          default: "children"
        },
        ["treeProps.checkStrictly"]: {
          key: "checkStrictly",
          default: false
        }
      };
      function createStore(table, props2) {
        if (!table) {
          throw new Error("Table is required.");
        }
        const store = useStore();
        store.toggleAllSelection = debounce(store._toggleAllSelection, 10);
        Object.keys(InitialStateMap).forEach((key) => {
          handleValue(getArrKeysValue(props2, key), key, store);
        });
        proxyTableProps(store, props2);
        return store;
      }
      function proxyTableProps(store, props2) {
        Object.keys(InitialStateMap).forEach((key) => {
          watch(() => getArrKeysValue(props2, key), (value) => {
            handleValue(value, key, store);
          });
        });
      }
      function handleValue(value, propsKey, store) {
        let newVal = value;
        let storeKey = InitialStateMap[propsKey];
        if (isObject$1(storeKey)) {
          newVal = newVal || storeKey.default;
          storeKey = storeKey.key;
        }
        store.states[storeKey].value = newVal;
      }
      function getArrKeysValue(props2, key) {
        if (key.includes(".")) {
          const keyList = key.split(".");
          let value = props2;
          keyList.forEach((k) => {
            value = value[k];
          });
          return value;
        } else {
          return props2[key];
        }
      }
      class TableLayout {
        constructor(options) {
          this.observers = [];
          this.table = null;
          this.store = null;
          this.columns = [];
          this.fit = true;
          this.showHeader = true;
          this.height = ref(null);
          this.scrollX = ref(false);
          this.scrollY = ref(false);
          this.bodyWidth = ref(null);
          this.fixedWidth = ref(null);
          this.rightFixedWidth = ref(null);
          this.gutterWidth = 0;
          for (const name in options) {
            if (hasOwn(options, name)) {
              if (isRef(this[name])) {
                this[name].value = options[name];
              } else {
                this[name] = options[name];
              }
            }
          }
          if (!this.table) {
            throw new Error("Table is required for Table Layout");
          }
          if (!this.store) {
            throw new Error("Store is required for Table Layout");
          }
        }
        updateScrollY() {
          const height = this.height.value;
          if (isNull(height))
            return false;
          const scrollBarRef = this.table.refs.scrollBarRef;
          if (this.table.vnode.el && (scrollBarRef == null ? void 0 : scrollBarRef.wrapRef)) {
            let scrollY = true;
            const prevScrollY = this.scrollY.value;
            scrollY = scrollBarRef.wrapRef.scrollHeight > scrollBarRef.wrapRef.clientHeight;
            this.scrollY.value = scrollY;
            return prevScrollY !== scrollY;
          }
          return false;
        }
        setHeight(value, prop = "height") {
          if (!isClient)
            return;
          const el = this.table.vnode.el;
          value = parseHeight(value);
          this.height.value = Number(value);
          if (!el && (value || value === 0)) {
            nextTick(() => this.setHeight(value, prop));
            return;
          }
          if (el && isNumber(value)) {
            el.style[prop] = `${value}px`;
            this.updateElsHeight();
          } else if (el && isString$1(value)) {
            el.style[prop] = value;
            this.updateElsHeight();
          }
        }
        setMaxHeight(value) {
          this.setHeight(value, "max-height");
        }
        getFlattenColumns() {
          const flattenColumns = [];
          const columns2 = this.table.store.states.columns.value;
          columns2.forEach((column) => {
            if (column.isColumnGroup) {
              flattenColumns.push.apply(flattenColumns, column.columns);
            } else {
              flattenColumns.push(column);
            }
          });
          return flattenColumns;
        }
        updateElsHeight() {
          this.updateScrollY();
          this.notifyObservers("scrollable");
        }
        headerDisplayNone(elm) {
          if (!elm)
            return true;
          let headerChild = elm;
          while (headerChild.tagName !== "DIV") {
            if (getComputedStyle(headerChild).display === "none") {
              return true;
            }
            headerChild = headerChild.parentElement;
          }
          return false;
        }
        updateColumnsWidth() {
          var _a;
          if (!isClient)
            return;
          const fit = this.fit;
          const bodyWidth = (_a = this.table.vnode.el) == null ? void 0 : _a.clientWidth;
          let bodyMinWidth = 0;
          const flattenColumns = this.getFlattenColumns();
          const flexColumns = flattenColumns.filter((column) => !isNumber(column.width));
          flattenColumns.forEach((column) => {
            if (isNumber(column.width) && column.realWidth)
              column.realWidth = null;
          });
          if (flexColumns.length > 0 && fit) {
            flattenColumns.forEach((column) => {
              bodyMinWidth += Number(column.width || column.minWidth || 80);
            });
            if (bodyMinWidth <= bodyWidth) {
              this.scrollX.value = false;
              const totalFlexWidth = bodyWidth - bodyMinWidth;
              if (flexColumns.length === 1) {
                flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;
              } else {
                const allColumnsWidth = flexColumns.reduce((prev, column) => prev + Number(column.minWidth || 80), 0);
                const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
                let noneFirstWidth = 0;
                flexColumns.forEach((column, index2) => {
                  if (index2 === 0)
                    return;
                  const flexWidth = Math.floor(Number(column.minWidth || 80) * flexWidthPerPixel);
                  noneFirstWidth += flexWidth;
                  column.realWidth = Number(column.minWidth || 80) + flexWidth;
                });
                flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
              }
            } else {
              this.scrollX.value = true;
              flexColumns.forEach((column) => {
                column.realWidth = Number(column.minWidth);
              });
            }
            this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);
            this.table.state.resizeState.value.width = this.bodyWidth.value;
          } else {
            flattenColumns.forEach((column) => {
              if (!column.width && !column.minWidth) {
                column.realWidth = 80;
              } else {
                column.realWidth = Number(column.width || column.minWidth);
              }
              bodyMinWidth += column.realWidth;
            });
            this.scrollX.value = bodyMinWidth > bodyWidth;
            this.bodyWidth.value = bodyMinWidth;
          }
          const fixedColumns = this.store.states.fixedColumns.value;
          if (fixedColumns.length > 0) {
            let fixedWidth = 0;
            fixedColumns.forEach((column) => {
              fixedWidth += Number(column.realWidth || column.width);
            });
            this.fixedWidth.value = fixedWidth;
          }
          const rightFixedColumns = this.store.states.rightFixedColumns.value;
          if (rightFixedColumns.length > 0) {
            let rightFixedWidth = 0;
            rightFixedColumns.forEach((column) => {
              rightFixedWidth += Number(column.realWidth || column.width);
            });
            this.rightFixedWidth.value = rightFixedWidth;
          }
          this.notifyObservers("columns");
        }
        addObserver(observer) {
          this.observers.push(observer);
        }
        removeObserver(observer) {
          const index2 = this.observers.indexOf(observer);
          if (index2 !== -1) {
            this.observers.splice(index2, 1);
          }
        }
        notifyObservers(event) {
          const observers = this.observers;
          observers.forEach((observer) => {
            var _a, _b;
            switch (event) {
              case "columns":
                (_a = observer.state) == null ? void 0 : _a.onColumnsChange(this);
                break;
              case "scrollable":
                (_b = observer.state) == null ? void 0 : _b.onScrollableChange(this);
                break;
              default:
                throw new Error(`Table Layout don't have event ${event}.`);
            }
          });
        }
      }
      var TableLayout$1 = TableLayout;
      const { CheckboxGroup: ElCheckboxGroup } = ElCheckbox;
      const _sfc_main$F = defineComponent({
        name: "ElTableFilterPanel",
        components: {
          ElCheckbox,
          ElCheckboxGroup,
          ElScrollbar,
          ElTooltip,
          ElIcon,
          ArrowDown: arrow_down_default$1,
          ArrowUp: arrow_up_default$1
        },
        directives: { ClickOutside },
        props: {
          placement: {
            type: String,
            default: "bottom-start"
          },
          store: {
            type: Object
          },
          column: {
            type: Object
          },
          upDataColumn: {
            type: Function
          },
          appendTo: useTooltipContentProps.appendTo
        },
        setup(props2) {
          const instance = getCurrentInstance();
          const { t } = useLocale();
          const ns = useNamespace("table-filter");
          const parent2 = instance == null ? void 0 : instance.parent;
          if (props2.column && !parent2.filterPanels.value[props2.column.id]) {
            parent2.filterPanels.value[props2.column.id] = instance;
          }
          const tooltipVisible = ref(false);
          const tooltip = ref(null);
          const filters = computed(() => {
            return props2.column && props2.column.filters;
          });
          const filterClassName = computed(() => {
            if (props2.column && props2.column.filterClassName) {
              return `${ns.b()} ${props2.column.filterClassName}`;
            }
            return ns.b();
          });
          const filterValue = computed({
            get: () => {
              var _a;
              return (((_a = props2.column) == null ? void 0 : _a.filteredValue) || [])[0];
            },
            set: (value) => {
              if (filteredValue.value) {
                if (!isPropAbsent(value)) {
                  filteredValue.value.splice(0, 1, value);
                } else {
                  filteredValue.value.splice(0, 1);
                }
              }
            }
          });
          const filteredValue = computed({
            get() {
              if (props2.column) {
                return props2.column.filteredValue || [];
              }
              return [];
            },
            set(value) {
              var _a;
              if (props2.column) {
                (_a = props2.upDataColumn) == null ? void 0 : _a.call(props2, "filteredValue", value);
              }
            }
          });
          const multiple = computed(() => {
            if (props2.column) {
              return props2.column.filterMultiple;
            }
            return true;
          });
          const isActive = (filter2) => {
            return filter2.value === filterValue.value;
          };
          const hidden = () => {
            tooltipVisible.value = false;
          };
          const showFilterPanel = (e) => {
            e.stopPropagation();
            tooltipVisible.value = !tooltipVisible.value;
          };
          const hideFilterPanel = () => {
            tooltipVisible.value = false;
          };
          const handleConfirm = () => {
            confirmFilter(filteredValue.value);
            hidden();
          };
          const handleReset = () => {
            filteredValue.value = [];
            confirmFilter(filteredValue.value);
            hidden();
          };
          const handleSelect = (_filterValue) => {
            filterValue.value = _filterValue;
            if (!isPropAbsent(_filterValue)) {
              confirmFilter(filteredValue.value);
            } else {
              confirmFilter([]);
            }
            hidden();
          };
          const confirmFilter = (filteredValue2) => {
            var _a, _b;
            (_a = props2.store) == null ? void 0 : _a.commit("filterChange", {
              column: props2.column,
              values: filteredValue2
            });
            (_b = props2.store) == null ? void 0 : _b.updateAllSelected();
          };
          watch(tooltipVisible, (value) => {
            var _a;
            if (props2.column) {
              (_a = props2.upDataColumn) == null ? void 0 : _a.call(props2, "filterOpened", value);
            }
          }, {
            immediate: true
          });
          const popperPaneRef = computed(() => {
            var _a, _b;
            return (_b = (_a = tooltip.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.contentRef;
          });
          return {
            tooltipVisible,
            multiple,
            filterClassName,
            filteredValue,
            filterValue,
            filters,
            handleConfirm,
            handleReset,
            handleSelect,
            isPropAbsent,
            isActive,
            t,
            ns,
            showFilterPanel,
            hideFilterPanel,
            popperPaneRef,
            tooltip
          };
        }
      });
      function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_checkbox = resolveComponent("el-checkbox");
        const _component_el_checkbox_group = resolveComponent("el-checkbox-group");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _component_arrow_up = resolveComponent("arrow-up");
        const _component_arrow_down = resolveComponent("arrow-down");
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_tooltip = resolveComponent("el-tooltip");
        const _directive_click_outside = resolveDirective("click-outside");
        return openBlock(), createBlock(_component_el_tooltip, {
          ref: "tooltip",
          visible: _ctx.tooltipVisible,
          offset: 0,
          placement: _ctx.placement,
          "show-arrow": false,
          "stop-popper-mouse-event": false,
          teleported: "",
          effect: "light",
          pure: "",
          "popper-class": _ctx.filterClassName,
          persistent: "",
          "append-to": _ctx.appendTo
        }, {
          content: withCtx(() => [
            _ctx.multiple ? (openBlock(), createElementBlock("div", { key: 0 }, [
              createElementVNode("div", {
                class: normalizeClass(_ctx.ns.e("content"))
              }, [
                createVNode(_component_el_scrollbar, {
                  "wrap-class": _ctx.ns.e("wrap")
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_checkbox_group, {
                      modelValue: _ctx.filteredValue,
                      "onUpdate:modelValue": ($event) => _ctx.filteredValue = $event,
                      class: normalizeClass(_ctx.ns.e("checkbox-group"))
                    }, {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter2) => {
                          return openBlock(), createBlock(_component_el_checkbox, {
                            key: filter2.value,
                            value: filter2.value
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(filter2.text), 1)
                            ]),
                            _: 2
                          }, 1032, ["value"]);
                        }), 128))
                      ]),
                      _: 1
                    }, 8, ["modelValue", "onUpdate:modelValue", "class"])
                  ]),
                  _: 1
                }, 8, ["wrap-class"])
              ], 2),
              createElementVNode("div", {
                class: normalizeClass(_ctx.ns.e("bottom"))
              }, [
                createElementVNode("button", {
                  class: normalizeClass({ [_ctx.ns.is("disabled")]: _ctx.filteredValue.length === 0 }),
                  disabled: _ctx.filteredValue.length === 0,
                  type: "button",
                  onClick: _ctx.handleConfirm
                }, toDisplayString(_ctx.t("el.table.confirmFilter")), 11, ["disabled", "onClick"]),
                createElementVNode("button", {
                  type: "button",
                  onClick: _ctx.handleReset
                }, toDisplayString(_ctx.t("el.table.resetFilter")), 9, ["onClick"])
              ], 2)
            ])) : (openBlock(), createElementBlock("ul", {
              key: 1,
              class: normalizeClass(_ctx.ns.e("list"))
            }, [
              createElementVNode("li", {
                class: normalizeClass([
                  _ctx.ns.e("list-item"),
                  {
                    [_ctx.ns.is("active")]: _ctx.isPropAbsent(_ctx.filterValue)
                  }
                ]),
                onClick: ($event) => _ctx.handleSelect(null)
              }, toDisplayString(_ctx.t("el.table.clearFilter")), 11, ["onClick"]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter2) => {
                return openBlock(), createElementBlock("li", {
                  key: filter2.value,
                  class: normalizeClass([_ctx.ns.e("list-item"), _ctx.ns.is("active", _ctx.isActive(filter2))]),
                  label: filter2.value,
                  onClick: ($event) => _ctx.handleSelect(filter2.value)
                }, toDisplayString(filter2.text), 11, ["label", "onClick"]);
              }), 128))
            ], 2))
          ]),
          default: withCtx(() => [
            withDirectives((openBlock(), createElementBlock("span", {
              class: normalizeClass([
                `${_ctx.ns.namespace.value}-table__column-filter-trigger`,
                `${_ctx.ns.namespace.value}-none-outline`
              ]),
              onClick: _ctx.showFilterPanel
            }, [
              createVNode(_component_el_icon, null, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "filter-icon", {}, () => {
                    var _a;
                    return [
                      ((_a = _ctx.column) == null ? void 0 : _a.filterOpened) ? (openBlock(), createBlock(_component_arrow_up, { key: 0 })) : (openBlock(), createBlock(_component_arrow_down, { key: 1 }))
                    ];
                  })
                ]),
                _: 3
              })
            ], 10, ["onClick"])), [
              [_directive_click_outside, _ctx.hideFilterPanel, _ctx.popperPaneRef]
            ])
          ]),
          _: 3
        }, 8, ["visible", "placement", "popper-class", "append-to"]);
      }
      var FilterPanel = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$4], ["__file", "filter-panel.vue"]]);
      function useLayoutObserver(root2) {
        const instance = getCurrentInstance();
        onBeforeMount(() => {
          tableLayout.value.addObserver(instance);
        });
        onMounted(() => {
          onColumnsChange(tableLayout.value);
          onScrollableChange(tableLayout.value);
        });
        onUpdated(() => {
          onColumnsChange(tableLayout.value);
          onScrollableChange(tableLayout.value);
        });
        onUnmounted(() => {
          tableLayout.value.removeObserver(instance);
        });
        const tableLayout = computed(() => {
          const layout2 = root2.layout;
          if (!layout2) {
            throw new Error("Can not find table layout.");
          }
          return layout2;
        });
        const onColumnsChange = (layout2) => {
          var _a;
          const cols = ((_a = root2.vnode.el) == null ? void 0 : _a.querySelectorAll("colgroup > col")) || [];
          if (!cols.length)
            return;
          const flattenColumns = layout2.getFlattenColumns();
          const columnsMap = {};
          flattenColumns.forEach((column) => {
            columnsMap[column.id] = column;
          });
          for (let i = 0, j = cols.length; i < j; i++) {
            const col = cols[i];
            const name = col.getAttribute("name");
            const column = columnsMap[name];
            if (column) {
              col.setAttribute("width", column.realWidth || column.width);
            }
          }
        };
        const onScrollableChange = (layout2) => {
          var _a, _b;
          const cols = ((_a = root2.vnode.el) == null ? void 0 : _a.querySelectorAll("colgroup > col[name=gutter]")) || [];
          for (let i = 0, j = cols.length; i < j; i++) {
            const col = cols[i];
            col.setAttribute("width", layout2.scrollY.value ? layout2.gutterWidth : "0");
          }
          const ths = ((_b = root2.vnode.el) == null ? void 0 : _b.querySelectorAll("th.gutter")) || [];
          for (let i = 0, j = ths.length; i < j; i++) {
            const th = ths[i];
            th.style.width = layout2.scrollY.value ? `${layout2.gutterWidth}px` : "0";
            th.style.display = layout2.scrollY.value ? "" : "none";
          }
        };
        return {
          tableLayout: tableLayout.value,
          onColumnsChange,
          onScrollableChange
        };
      }
      const TABLE_INJECTION_KEY = Symbol("ElTable");
      function useEvent(props2, emit) {
        const instance = getCurrentInstance();
        const parent2 = inject(TABLE_INJECTION_KEY);
        const handleFilterClick = (event) => {
          event.stopPropagation();
          return;
        };
        const handleHeaderClick = (event, column) => {
          if (!column.filters && column.sortable) {
            handleSortClick(event, column, false);
          } else if (column.filterable && !column.sortable) {
            handleFilterClick(event);
          }
          parent2 == null ? void 0 : parent2.emit("header-click", column, event);
        };
        const handleHeaderContextMenu = (event, column) => {
          parent2 == null ? void 0 : parent2.emit("header-contextmenu", column, event);
        };
        const draggingColumn = ref(null);
        const dragging = ref(false);
        const dragState = ref();
        const handleMouseDown = (event, column) => {
          var _a, _b;
          if (!isClient)
            return;
          if (column.children && column.children.length > 0)
            return;
          if (draggingColumn.value && props2.border) {
            dragging.value = true;
            const table = parent2;
            emit("set-drag-visible", true);
            const tableEl = table == null ? void 0 : table.vnode.el;
            const tableLeft = tableEl == null ? void 0 : tableEl.getBoundingClientRect().left;
            const columnEl = (_b = (_a = instance == null ? void 0 : instance.vnode) == null ? void 0 : _a.el) == null ? void 0 : _b.querySelector(`th.${column.id}`);
            const columnRect = columnEl.getBoundingClientRect();
            const minLeft = columnRect.left - tableLeft + 30;
            addClass(columnEl, "noclick");
            dragState.value = {
              startMouseLeft: event.clientX,
              startLeft: columnRect.right - tableLeft,
              startColumnLeft: columnRect.left - tableLeft,
              tableLeft
            };
            const resizeProxy = table == null ? void 0 : table.refs.resizeProxy;
            resizeProxy.style.left = `${dragState.value.startLeft}px`;
            document.onselectstart = function() {
              return false;
            };
            document.ondragstart = function() {
              return false;
            };
            const handleMouseMove2 = (event2) => {
              const deltaLeft = event2.clientX - dragState.value.startMouseLeft;
              const proxyLeft = dragState.value.startLeft + deltaLeft;
              resizeProxy.style.left = `${Math.max(minLeft, proxyLeft)}px`;
            };
            const handleMouseUp = () => {
              if (dragging.value) {
                const { startColumnLeft, startLeft } = dragState.value;
                const finalLeft = Number.parseInt(resizeProxy.style.left, 10);
                const columnWidth = finalLeft - startColumnLeft;
                column.width = column.realWidth = columnWidth;
                table == null ? void 0 : table.emit("header-dragend", column.width, startLeft - startColumnLeft, column, event);
                requestAnimationFrame(() => {
                  props2.store.scheduleLayout(false, true);
                });
                document.body.style.cursor = "";
                dragging.value = false;
                draggingColumn.value = null;
                dragState.value = void 0;
                emit("set-drag-visible", false);
              }
              document.removeEventListener("mousemove", handleMouseMove2);
              document.removeEventListener("mouseup", handleMouseUp);
              document.onselectstart = null;
              document.ondragstart = null;
              setTimeout(() => {
                removeClass(columnEl, "noclick");
              }, 0);
            };
            document.addEventListener("mousemove", handleMouseMove2);
            document.addEventListener("mouseup", handleMouseUp);
          }
        };
        const handleMouseMove = (event, column) => {
          var _a;
          if (column.children && column.children.length > 0)
            return;
          const el = event.target;
          if (!isElement$2(el)) {
            return;
          }
          const target2 = el == null ? void 0 : el.closest("th");
          if (!column || !column.resizable || !target2)
            return;
          if (!dragging.value && props2.border) {
            const rect = target2.getBoundingClientRect();
            const bodyStyle = document.body.style;
            const isLastTh = ((_a = target2.parentNode) == null ? void 0 : _a.lastElementChild) === target2;
            const allowDarg = props2.allowDragLastColumn || !isLastTh;
            if (rect.width > 12 && rect.right - event.clientX < 8 && allowDarg) {
              bodyStyle.cursor = "col-resize";
              if (hasClass(target2, "is-sortable")) {
                target2.style.cursor = "col-resize";
              }
              draggingColumn.value = column;
            } else if (!dragging.value) {
              bodyStyle.cursor = "";
              if (hasClass(target2, "is-sortable")) {
                target2.style.cursor = "pointer";
              }
              draggingColumn.value = null;
            }
          }
        };
        const handleMouseOut = () => {
          if (!isClient)
            return;
          document.body.style.cursor = "";
        };
        const toggleOrder = ({ order, sortOrders }) => {
          if (order === "")
            return sortOrders[0];
          const index2 = sortOrders.indexOf(order || null);
          return sortOrders[index2 > sortOrders.length - 2 ? 0 : index2 + 1];
        };
        const handleSortClick = (event, column, givenOrder) => {
          var _a;
          event.stopPropagation();
          const order = column.order === givenOrder ? null : givenOrder || toggleOrder(column);
          const target2 = (_a = event.target) == null ? void 0 : _a.closest("th");
          if (target2) {
            if (hasClass(target2, "noclick")) {
              removeClass(target2, "noclick");
              return;
            }
          }
          if (!column.sortable)
            return;
          const clickTarget = event.currentTarget;
          if (["ascending", "descending"].some((str) => hasClass(clickTarget, str) && !column.sortOrders.includes(str))) {
            return;
          }
          const states = props2.store.states;
          let sortProp = states.sortProp.value;
          let sortOrder;
          const sortingColumn = states.sortingColumn.value;
          if (sortingColumn !== column || sortingColumn === column && isNull(sortingColumn.order)) {
            if (sortingColumn) {
              sortingColumn.order = null;
            }
            states.sortingColumn.value = column;
            sortProp = column.property;
          }
          if (!order) {
            sortOrder = column.order = null;
          } else {
            sortOrder = column.order = order;
          }
          states.sortProp.value = sortProp;
          states.sortOrder.value = sortOrder;
          parent2 == null ? void 0 : parent2.store.commit("changeSortCondition");
        };
        return {
          handleHeaderClick,
          handleHeaderContextMenu,
          handleMouseDown,
          handleMouseMove,
          handleMouseOut,
          handleSortClick,
          handleFilterClick
        };
      }
      function useStyle$2(props2) {
        const parent2 = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const getHeaderRowStyle = (rowIndex) => {
          const headerRowStyle = parent2 == null ? void 0 : parent2.props.headerRowStyle;
          if (isFunction$1(headerRowStyle)) {
            return headerRowStyle.call(null, { rowIndex });
          }
          return headerRowStyle;
        };
        const getHeaderRowClass = (rowIndex) => {
          const classes = [];
          const headerRowClassName = parent2 == null ? void 0 : parent2.props.headerRowClassName;
          if (isString$1(headerRowClassName)) {
            classes.push(headerRowClassName);
          } else if (isFunction$1(headerRowClassName)) {
            classes.push(headerRowClassName.call(null, { rowIndex }));
          }
          return classes.join(" ");
        };
        const getHeaderCellStyle = (rowIndex, columnIndex, row, column) => {
          var _a;
          let headerCellStyles = (_a = parent2 == null ? void 0 : parent2.props.headerCellStyle) != null ? _a : {};
          if (isFunction$1(headerCellStyles)) {
            headerCellStyles = headerCellStyles.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            });
          }
          const fixedStyle = getFixedColumnOffset(columnIndex, column.fixed, props2.store, row);
          ensurePosition(fixedStyle, "left");
          ensurePosition(fixedStyle, "right");
          return Object.assign({}, headerCellStyles, fixedStyle);
        };
        const getHeaderCellClass = (rowIndex, columnIndex, row, column) => {
          const fixedClasses = getFixedColumnsClass(ns.b(), columnIndex, column.fixed, props2.store, row);
          const classes = [
            column.id,
            column.order,
            column.headerAlign,
            column.className,
            column.labelClassName,
            ...fixedClasses
          ];
          if (!column.children) {
            classes.push("is-leaf");
          }
          if (column.sortable) {
            classes.push("is-sortable");
          }
          const headerCellClassName = parent2 == null ? void 0 : parent2.props.headerCellClassName;
          if (isString$1(headerCellClassName)) {
            classes.push(headerCellClassName);
          } else if (isFunction$1(headerCellClassName)) {
            classes.push(headerCellClassName.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            }));
          }
          classes.push(ns.e("cell"));
          return classes.filter((className) => Boolean(className)).join(" ");
        };
        return {
          getHeaderRowStyle,
          getHeaderRowClass,
          getHeaderCellStyle,
          getHeaderCellClass
        };
      }
      const getAllColumns = (columns2) => {
        const result2 = [];
        columns2.forEach((column) => {
          if (column.children) {
            result2.push(column);
            result2.push.apply(result2, getAllColumns(column.children));
          } else {
            result2.push(column);
          }
        });
        return result2;
      };
      const convertToRows = (originColumns) => {
        let maxLevel = 1;
        const traverse = (column, parent2) => {
          if (parent2) {
            column.level = parent2.level + 1;
            if (maxLevel < column.level) {
              maxLevel = column.level;
            }
          }
          if (column.children) {
            let colSpan = 0;
            column.children.forEach((subColumn) => {
              traverse(subColumn, column);
              colSpan += subColumn.colSpan;
            });
            column.colSpan = colSpan;
          } else {
            column.colSpan = 1;
          }
        };
        originColumns.forEach((column) => {
          column.level = 1;
          traverse(column, void 0);
        });
        const rows = [];
        for (let i = 0; i < maxLevel; i++) {
          rows.push([]);
        }
        const allColumns = getAllColumns(originColumns);
        allColumns.forEach((column) => {
          if (!column.children) {
            column.rowSpan = maxLevel - column.level + 1;
          } else {
            column.rowSpan = 1;
            column.children.forEach((col) => col.isSubColumn = true);
          }
          rows[column.level - 1].push(column);
        });
        return rows;
      };
      function useUtils$1(props2) {
        const parent2 = inject(TABLE_INJECTION_KEY);
        const columnRows = computed(() => {
          return convertToRows(props2.store.states.originColumns.value);
        });
        const isGroup = computed(() => {
          const result2 = columnRows.value.length > 1;
          if (result2 && parent2) {
            parent2.state.isGroup.value = true;
          }
          return result2;
        });
        const toggleAllSelection = (event) => {
          event.stopPropagation();
          parent2 == null ? void 0 : parent2.store.commit("toggleAllSelection");
        };
        return {
          isGroup,
          toggleAllSelection,
          columnRows
        };
      }
      var TableHeader = defineComponent({
        name: "ElTableHeader",
        components: {
          ElCheckbox
        },
        props: {
          fixed: {
            type: String,
            default: ""
          },
          store: {
            required: true,
            type: Object
          },
          border: Boolean,
          defaultSort: {
            type: Object,
            default: () => {
              return {
                prop: "",
                order: ""
              };
            }
          },
          appendFilterPanelTo: {
            type: String
          },
          allowDragLastColumn: {
            type: Boolean
          }
        },
        setup(props2, { emit }) {
          const instance = getCurrentInstance();
          const parent2 = inject(TABLE_INJECTION_KEY);
          const ns = useNamespace("table");
          const filterPanels = ref({});
          const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent2);
          const isTableLayoutAuto = (parent2 == null ? void 0 : parent2.props.tableLayout) === "auto";
          const saveIndexSelection = reactive(/* @__PURE__ */ new Map());
          const theadRef = ref();
          let delayId;
          const updateFixedColumnStyle = () => {
            delayId = setTimeout(() => {
              if (saveIndexSelection.size > 0) {
                saveIndexSelection.forEach((column, key) => {
                  const el = theadRef.value.querySelector(`.${key.replace(/\s/g, ".")}`);
                  if (el) {
                    const width = el.getBoundingClientRect().width;
                    column.width = width || column.width;
                  }
                });
                saveIndexSelection.clear();
              }
            });
          };
          watch(saveIndexSelection, updateFixedColumnStyle);
          onBeforeUnmount(() => {
            if (delayId) {
              clearTimeout(delayId);
              delayId = void 0;
            }
          });
          onMounted(async () => {
            await nextTick();
            await nextTick();
            const { prop, order } = props2.defaultSort;
            parent2 == null ? void 0 : parent2.store.commit("sort", { prop, order, init: true });
            updateFixedColumnStyle();
          });
          const {
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleMouseOut,
            handleSortClick,
            handleFilterClick
          } = useEvent(props2, emit);
          const {
            getHeaderRowStyle,
            getHeaderRowClass,
            getHeaderCellStyle,
            getHeaderCellClass
          } = useStyle$2(props2);
          const { isGroup, toggleAllSelection, columnRows } = useUtils$1(props2);
          instance.state = {
            onColumnsChange,
            onScrollableChange
          };
          instance.filterPanels = filterPanels;
          return {
            ns,
            filterPanels,
            onColumnsChange,
            onScrollableChange,
            columnRows,
            getHeaderRowClass,
            getHeaderRowStyle,
            getHeaderCellClass,
            getHeaderCellStyle,
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleMouseOut,
            handleSortClick,
            handleFilterClick,
            isGroup,
            toggleAllSelection,
            saveIndexSelection,
            isTableLayoutAuto,
            theadRef,
            updateFixedColumnStyle
          };
        },
        render() {
          const {
            ns,
            isGroup,
            columnRows,
            getHeaderCellStyle,
            getHeaderCellClass,
            getHeaderRowClass,
            getHeaderRowStyle,
            handleHeaderClick,
            handleHeaderContextMenu,
            handleMouseDown,
            handleMouseMove,
            handleSortClick,
            handleMouseOut,
            store,
            $parent,
            saveIndexSelection,
            isTableLayoutAuto
          } = this;
          let rowSpan = 1;
          return h$1("thead", {
            ref: "theadRef",
            class: { [ns.is("group")]: isGroup }
          }, columnRows.map((subColumns, rowIndex) => h$1("tr", {
            class: getHeaderRowClass(rowIndex),
            key: rowIndex,
            style: getHeaderRowStyle(rowIndex)
          }, subColumns.map((column, cellIndex) => {
            if (column.rowSpan > rowSpan) {
              rowSpan = column.rowSpan;
            }
            const _class = getHeaderCellClass(rowIndex, cellIndex, subColumns, column);
            if (isTableLayoutAuto && column.fixed) {
              saveIndexSelection.set(_class, column);
            }
            return h$1("th", {
              class: _class,
              colspan: column.colSpan,
              key: `${column.id}-thead`,
              rowspan: column.rowSpan,
              style: getHeaderCellStyle(rowIndex, cellIndex, subColumns, column),
              onClick: ($event) => {
                var _a;
                if ((_a = $event.currentTarget) == null ? void 0 : _a.classList.contains("noclick")) {
                  return;
                }
                handleHeaderClick($event, column);
              },
              onContextmenu: ($event) => handleHeaderContextMenu($event, column),
              onMousedown: ($event) => handleMouseDown($event, column),
              onMousemove: ($event) => handleMouseMove($event, column),
              onMouseout: handleMouseOut
            }, [
              h$1("div", {
                class: [
                  "cell",
                  column.filteredValue && column.filteredValue.length > 0 ? "highlight" : ""
                ]
              }, [
                column.renderHeader ? column.renderHeader({
                  column,
                  $index: cellIndex,
                  store,
                  _self: $parent
                }) : column.label,
                column.sortable && h$1("span", {
                  onClick: ($event) => handleSortClick($event, column),
                  class: "caret-wrapper"
                }, [
                  h$1("i", {
                    onClick: ($event) => handleSortClick($event, column, "ascending"),
                    class: "sort-caret ascending"
                  }),
                  h$1("i", {
                    onClick: ($event) => handleSortClick($event, column, "descending"),
                    class: "sort-caret descending"
                  })
                ]),
                column.filterable && h$1(FilterPanel, {
                  store,
                  placement: column.filterPlacement || "bottom-start",
                  appendTo: $parent == null ? void 0 : $parent.appendFilterPanelTo,
                  column,
                  upDataColumn: (key, value) => {
                    column[key] = value;
                  }
                }, {
                  "filter-icon": () => column.renderFilterIcon ? column.renderFilterIcon({
                    filterOpened: column.filterOpened
                  }) : null
                })
              ])
            ]);
          }))));
        }
      });
      function isGreaterThan(a2, b2, epsilon = 0.03) {
        return a2 - b2 > epsilon;
      }
      function useEvents(props2) {
        const parent2 = inject(TABLE_INJECTION_KEY);
        const tooltipContent = ref("");
        const tooltipTrigger = ref(h$1("div"));
        const handleEvent = (event, row, name) => {
          var _a, _b, _c;
          const table = parent2;
          const cell = getCell(event);
          let column = null;
          const namespace = (_a = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a.dataset.prefix;
          if (cell) {
            column = getColumnByCell({
              columns: (_c = (_b = props2.store) == null ? void 0 : _b.states.columns.value) != null ? _c : []
            }, cell, namespace);
            if (column) {
              table == null ? void 0 : table.emit(`cell-${name}`, row, column, cell, event);
            }
          }
          table == null ? void 0 : table.emit(`row-${name}`, row, column, event);
        };
        const handleDoubleClick = (event, row) => {
          handleEvent(event, row, "dblclick");
        };
        const handleClick = (event, row) => {
          var _a;
          (_a = props2.store) == null ? void 0 : _a.commit("setCurrentRow", row);
          handleEvent(event, row, "click");
        };
        const handleContextMenu = (event, row) => {
          handleEvent(event, row, "contextmenu");
        };
        const handleMouseEnter = debounce((index2) => {
          var _a;
          (_a = props2.store) == null ? void 0 : _a.commit("setHoverRow", index2);
        }, 30);
        const handleMouseLeave = debounce(() => {
          var _a;
          (_a = props2.store) == null ? void 0 : _a.commit("setHoverRow", null);
        }, 30);
        const getPadding = (el) => {
          const style = window.getComputedStyle(el, null);
          const paddingLeft = Number.parseInt(style.paddingLeft, 10) || 0;
          const paddingRight = Number.parseInt(style.paddingRight, 10) || 0;
          const paddingTop = Number.parseInt(style.paddingTop, 10) || 0;
          const paddingBottom = Number.parseInt(style.paddingBottom, 10) || 0;
          return {
            left: paddingLeft,
            right: paddingRight,
            top: paddingTop,
            bottom: paddingBottom
          };
        };
        const toggleRowClassByCell = (rowSpan, event, toggle) => {
          var _a;
          let node = (_a = event == null ? void 0 : event.target) == null ? void 0 : _a.parentNode;
          while (rowSpan > 1) {
            node = node == null ? void 0 : node.nextSibling;
            if (!node || node.nodeName !== "TR")
              break;
            toggle(node, "hover-row hover-fixed-row");
            rowSpan--;
          }
        };
        const handleCellMouseEnter = (event, row, tooltipOptions) => {
          var _a, _b, _c, _d, _e, _f;
          if (!parent2)
            return;
          const table = parent2;
          const cell = getCell(event);
          const namespace = (_a = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a.dataset.prefix;
          let column = null;
          if (cell) {
            column = getColumnByCell({
              columns: (_c = (_b = props2.store) == null ? void 0 : _b.states.columns.value) != null ? _c : []
            }, cell, namespace);
            if (!column) {
              return;
            }
            if (cell.rowSpan > 1) {
              toggleRowClassByCell(cell.rowSpan, event, addClass);
            }
            const hoverState = table.hoverState = {
              cell,
              column,
              row
            };
            table == null ? void 0 : table.emit("cell-mouse-enter", hoverState.row, hoverState.column, hoverState.cell, event);
          }
          if (!tooltipOptions) {
            return;
          }
          const cellChild = event.target.querySelector(".cell");
          if (!(hasClass(cellChild, `${namespace}-tooltip`) && cellChild.childNodes.length)) {
            return;
          }
          const range2 = document.createRange();
          range2.setStart(cellChild, 0);
          range2.setEnd(cellChild, cellChild.childNodes.length);
          const { width: rangeWidth, height: rangeHeight } = range2.getBoundingClientRect();
          const { width: cellChildWidth, height: cellChildHeight } = cellChild.getBoundingClientRect();
          const { top, left, right, bottom } = getPadding(cellChild);
          const horizontalPadding = left + right;
          const verticalPadding = top + bottom;
          if (isGreaterThan(rangeWidth + horizontalPadding, cellChildWidth) || isGreaterThan(rangeHeight + verticalPadding, cellChildHeight) || isGreaterThan(cellChild.scrollWidth, cellChildWidth)) {
            createTablePopper(tooltipOptions, (_d = (cell == null ? void 0 : cell.innerText) || (cell == null ? void 0 : cell.textContent)) != null ? _d : "", row, column, cell, table);
          } else if (((_e = removePopper) == null ? void 0 : _e.trigger) === cell) {
            (_f = removePopper) == null ? void 0 : _f();
          }
        };
        const handleCellMouseLeave = (event) => {
          const cell = getCell(event);
          if (!cell)
            return;
          if (cell.rowSpan > 1) {
            toggleRowClassByCell(cell.rowSpan, event, removeClass);
          }
          const oldHoverState = parent2 == null ? void 0 : parent2.hoverState;
          parent2 == null ? void 0 : parent2.emit("cell-mouse-leave", oldHoverState == null ? void 0 : oldHoverState.row, oldHoverState == null ? void 0 : oldHoverState.column, oldHoverState == null ? void 0 : oldHoverState.cell, event);
        };
        return {
          handleDoubleClick,
          handleClick,
          handleContextMenu,
          handleMouseEnter,
          handleMouseLeave,
          handleCellMouseEnter,
          handleCellMouseLeave,
          tooltipContent,
          tooltipTrigger
        };
      }
      function useStyles$1(props2) {
        const parent2 = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const getRowStyle = (row, rowIndex) => {
          const rowStyle = parent2 == null ? void 0 : parent2.props.rowStyle;
          if (isFunction$1(rowStyle)) {
            return rowStyle.call(null, {
              row,
              rowIndex
            });
          }
          return rowStyle || null;
        };
        const getRowClass = (row, rowIndex) => {
          var _a;
          const classes = [ns.e("row")];
          if ((parent2 == null ? void 0 : parent2.props.highlightCurrentRow) && row === ((_a = props2.store) == null ? void 0 : _a.states.currentRow.value)) {
            classes.push("current-row");
          }
          if (props2.stripe && rowIndex % 2 === 1) {
            classes.push(ns.em("row", "striped"));
          }
          const rowClassName = parent2 == null ? void 0 : parent2.props.rowClassName;
          if (isString$1(rowClassName)) {
            classes.push(rowClassName);
          } else if (isFunction$1(rowClassName)) {
            classes.push(rowClassName.call(null, {
              row,
              rowIndex
            }));
          }
          return classes;
        };
        const getCellStyle = (rowIndex, columnIndex, row, column) => {
          const cellStyle = parent2 == null ? void 0 : parent2.props.cellStyle;
          let cellStyles = cellStyle != null ? cellStyle : {};
          if (isFunction$1(cellStyle)) {
            cellStyles = cellStyle.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            });
          }
          const fixedStyle = getFixedColumnOffset(columnIndex, props2 == null ? void 0 : props2.fixed, props2.store);
          ensurePosition(fixedStyle, "left");
          ensurePosition(fixedStyle, "right");
          return Object.assign({}, cellStyles, fixedStyle);
        };
        const getCellClass = (rowIndex, columnIndex, row, column, offset2) => {
          const fixedClasses = getFixedColumnsClass(ns.b(), columnIndex, props2 == null ? void 0 : props2.fixed, props2.store, void 0, offset2);
          const classes = [column.id, column.align, column.className, ...fixedClasses];
          const cellClassName = parent2 == null ? void 0 : parent2.props.cellClassName;
          if (isString$1(cellClassName)) {
            classes.push(cellClassName);
          } else if (isFunction$1(cellClassName)) {
            classes.push(cellClassName.call(null, {
              rowIndex,
              columnIndex,
              row,
              column
            }));
          }
          classes.push(ns.e("cell"));
          return classes.filter((className) => Boolean(className)).join(" ");
        };
        const getSpan = (row, column, rowIndex, columnIndex) => {
          let rowspan = 1;
          let colspan = 1;
          const fn2 = parent2 == null ? void 0 : parent2.props.spanMethod;
          if (isFunction$1(fn2)) {
            const result2 = fn2({
              row,
              column,
              rowIndex,
              columnIndex
            });
            if (isArray$1(result2)) {
              rowspan = result2[0];
              colspan = result2[1];
            } else if (isObject$1(result2)) {
              rowspan = result2.rowspan;
              colspan = result2.colspan;
            }
          }
          return { rowspan, colspan };
        };
        const getColspanRealWidth = (columns2, colspan, index2) => {
          if (colspan < 1) {
            return columns2[index2].realWidth;
          }
          const widthArr = columns2.map(({ realWidth, width }) => realWidth || width).slice(index2, index2 + colspan);
          return Number(widthArr.reduce((acc, width) => Number(acc) + Number(width), -1));
        };
        return {
          getRowStyle,
          getRowClass,
          getCellStyle,
          getCellClass,
          getSpan,
          getColspanRealWidth
        };
      }
      const __default__$y = defineComponent({
        name: "TableTdWrapper"
      });
      const _sfc_main$E = /* @__PURE__ */ defineComponent({
        ...__default__$y,
        props: {
          colspan: {
            type: Number,
            default: 1
          },
          rowspan: {
            type: Number,
            default: 1
          }
        },
        setup(__props) {
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("td", {
              colspan: __props.colspan,
              rowspan: __props.rowspan
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 8, ["colspan", "rowspan"]);
          };
        }
      });
      var TdWrapper = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["__file", "td-wrapper.vue"]]);
      function useRender$1(props2) {
        const parent2 = inject(TABLE_INJECTION_KEY);
        const ns = useNamespace("table");
        const {
          handleDoubleClick,
          handleClick,
          handleContextMenu,
          handleMouseEnter,
          handleMouseLeave,
          handleCellMouseEnter,
          handleCellMouseLeave,
          tooltipContent,
          tooltipTrigger
        } = useEvents(props2);
        const {
          getRowStyle,
          getRowClass,
          getCellStyle,
          getCellClass,
          getSpan,
          getColspanRealWidth
        } = useStyles$1(props2);
        const firstDefaultColumnIndex = computed(() => {
          var _a;
          return (_a = props2.store) == null ? void 0 : _a.states.columns.value.findIndex(({ type }) => type === "default");
        });
        const getKeyOfRow = (row, index2) => {
          var _a;
          const rowKey2 = (_a = parent2 == null ? void 0 : parent2.props) == null ? void 0 : _a.rowKey;
          if (rowKey2) {
            return getRowIdentity(row, rowKey2);
          }
          return index2;
        };
        const rowRender = (row, $index, treeRowData, expanded = false) => {
          const { tooltipEffect, tooltipOptions, store } = props2;
          const { indent, columns: columns2 } = store.states;
          const rowClasses = getRowClass(row, $index);
          let display = true;
          if (treeRowData) {
            rowClasses.push(ns.em("row", `level-${treeRowData.level}`));
            display = !!treeRowData.display;
          }
          const displayStyle = display ? null : { display: "none" };
          return h$1("tr", {
            style: [displayStyle, getRowStyle(row, $index)],
            class: rowClasses,
            key: getKeyOfRow(row, $index),
            onDblclick: ($event) => handleDoubleClick($event, row),
            onClick: ($event) => handleClick($event, row),
            onContextmenu: ($event) => handleContextMenu($event, row),
            onMouseenter: () => handleMouseEnter($index),
            onMouseleave: handleMouseLeave
          }, columns2.value.map((column, cellIndex) => {
            const { rowspan, colspan } = getSpan(row, column, $index, cellIndex);
            if (!rowspan || !colspan) {
              return null;
            }
            const columnData = Object.assign({}, column);
            columnData.realWidth = getColspanRealWidth(columns2.value, colspan, cellIndex);
            const data = {
              store,
              _self: props2.context || parent2,
              column: columnData,
              row,
              $index,
              cellIndex,
              expanded
            };
            if (cellIndex === firstDefaultColumnIndex.value && treeRowData) {
              data.treeNode = {
                indent: treeRowData.level && treeRowData.level * indent.value,
                level: treeRowData.level
              };
              if (isBoolean(treeRowData.expanded)) {
                data.treeNode.expanded = treeRowData.expanded;
                if ("loading" in treeRowData) {
                  data.treeNode.loading = treeRowData.loading;
                }
                if ("noLazyChildren" in treeRowData) {
                  data.treeNode.noLazyChildren = treeRowData.noLazyChildren;
                }
              }
            }
            const baseKey = `${getKeyOfRow(row, $index)},${cellIndex}`;
            const patchKey = columnData.columnKey || columnData.rawColumnKey || "";
            const mergedTooltipOptions = column.showOverflowTooltip && merge({
              effect: tooltipEffect
            }, tooltipOptions, column.showOverflowTooltip);
            return h$1(TdWrapper, {
              style: getCellStyle($index, cellIndex, row, column),
              class: getCellClass($index, cellIndex, row, column, colspan - 1),
              key: `${patchKey}${baseKey}`,
              rowspan,
              colspan,
              onMouseenter: ($event) => handleCellMouseEnter($event, row, mergedTooltipOptions),
              onMouseleave: handleCellMouseLeave
            }, {
              default: () => cellChildren(cellIndex, column, data)
            });
          }));
        };
        const cellChildren = (_cellIndex, column, data) => {
          return column.renderCell(data);
        };
        const wrappedRowRender = (row, $index) => {
          const store = props2.store;
          const { isRowExpanded, assertRowKey } = store;
          const { treeData, lazyTreeNodeMap, childrenColumnName, rowKey: rowKey2 } = store.states;
          const columns2 = store.states.columns.value;
          const hasExpandColumn = columns2.some(({ type }) => type === "expand");
          if (hasExpandColumn) {
            const expanded = isRowExpanded(row);
            const tr = rowRender(row, $index, void 0, expanded);
            const renderExpanded = parent2 == null ? void 0 : parent2.renderExpanded;
            if (!renderExpanded) {
              console.error("[Element Error]renderExpanded is required.");
              return tr;
            }
            const rows = [[tr]];
            if (parent2.props.preserveExpandedContent || expanded) {
              rows[0].push(h$1("tr", {
                key: `expanded-row__${tr.key}`,
                style: { display: expanded ? "" : "none" }
              }, [
                h$1("td", {
                  colspan: columns2.length,
                  class: `${ns.e("cell")} ${ns.e("expanded-cell")}`
                }, [renderExpanded({ row, $index, store, expanded })])
              ]));
            }
            return rows;
          } else if (Object.keys(treeData.value).length) {
            assertRowKey();
            const key = getRowIdentity(row, rowKey2.value);
            let cur = treeData.value[key];
            let treeRowData = null;
            if (cur) {
              treeRowData = {
                expanded: cur.expanded,
                level: cur.level,
                display: true,
                noLazyChildren: void 0,
                loading: void 0
              };
              if (isBoolean(cur.lazy)) {
                if (treeRowData && isBoolean(cur.loaded) && cur.loaded) {
                  treeRowData.noLazyChildren = !(cur.children && cur.children.length);
                }
                treeRowData.loading = cur.loading;
              }
            }
            const tmp = [rowRender(row, $index, treeRowData != null ? treeRowData : void 0)];
            if (cur) {
              let i = 0;
              const traverse = (children, parent22) => {
                if (!(children && children.length && parent22))
                  return;
                children.forEach((node) => {
                  const innerTreeRowData = {
                    display: parent22.display && parent22.expanded,
                    level: parent22.level + 1,
                    expanded: false,
                    noLazyChildren: false,
                    loading: false
                  };
                  const childKey = getRowIdentity(node, rowKey2.value);
                  if (isPropAbsent(childKey)) {
                    throw new Error("For nested data item, row-key is required.");
                  }
                  cur = { ...treeData.value[childKey] };
                  if (cur) {
                    innerTreeRowData.expanded = cur.expanded;
                    cur.level = cur.level || innerTreeRowData.level;
                    cur.display = !!(cur.expanded && innerTreeRowData.display);
                    if (isBoolean(cur.lazy)) {
                      if (isBoolean(cur.loaded) && cur.loaded) {
                        innerTreeRowData.noLazyChildren = !(cur.children && cur.children.length);
                      }
                      innerTreeRowData.loading = cur.loading;
                    }
                  }
                  i++;
                  tmp.push(rowRender(node, $index + i, innerTreeRowData));
                  if (cur) {
                    const nodes2 = lazyTreeNodeMap.value[childKey] || node[childrenColumnName.value];
                    traverse(nodes2, cur);
                  }
                });
              };
              cur.display = true;
              const nodes = lazyTreeNodeMap.value[key] || row[childrenColumnName.value];
              traverse(nodes, cur);
            }
            return tmp;
          } else {
            return rowRender(row, $index, void 0);
          }
        };
        return {
          wrappedRowRender,
          tooltipContent,
          tooltipTrigger
        };
      }
      const defaultProps$3 = {
        store: {
          required: true,
          type: Object
        },
        stripe: Boolean,
        tooltipEffect: String,
        tooltipOptions: {
          type: Object
        },
        context: {
          default: () => ({}),
          type: Object
        },
        rowClassName: [String, Function],
        rowStyle: [Object, Function],
        fixed: {
          type: String,
          default: ""
        },
        highlight: Boolean
      };
      var defaultProps$4 = defaultProps$3;
      var TableBody = defineComponent({
        name: "ElTableBody",
        props: defaultProps$4,
        setup(props2) {
          var _a;
          const instance = getCurrentInstance();
          const parent2 = inject(TABLE_INJECTION_KEY);
          const ns = useNamespace("table");
          const { wrappedRowRender, tooltipContent, tooltipTrigger } = useRender$1(props2);
          const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent2);
          const hoveredCellList = [];
          watch((_a = props2.store) == null ? void 0 : _a.states.hoverRow, (newVal, oldVal) => {
            var _a2, _b;
            const el = instance == null ? void 0 : instance.vnode.el;
            const rows = Array.from((el == null ? void 0 : el.children) || []).filter((e) => e == null ? void 0 : e.classList.contains(`${ns.e("row")}`));
            let rowNum = newVal;
            const childNodes = (_a2 = rows[rowNum]) == null ? void 0 : _a2.childNodes;
            if (childNodes == null ? void 0 : childNodes.length) {
              let control = 0;
              const indexes = Array.from(childNodes).reduce((acc, item, index2) => {
                var _a3, _b2;
                if (((_a3 = childNodes[index2]) == null ? void 0 : _a3.colSpan) > 1) {
                  control = (_b2 = childNodes[index2]) == null ? void 0 : _b2.colSpan;
                }
                if (item.nodeName !== "TD" && control === 0) {
                  acc.push(index2);
                }
                control > 0 && control--;
                return acc;
              }, []);
              indexes.forEach((rowIndex) => {
                var _a3;
                rowNum = newVal;
                while (rowNum > 0) {
                  const preChildNodes = (_a3 = rows[rowNum - 1]) == null ? void 0 : _a3.childNodes;
                  if (preChildNodes[rowIndex] && preChildNodes[rowIndex].nodeName === "TD" && preChildNodes[rowIndex].rowSpan > 1) {
                    addClass(preChildNodes[rowIndex], "hover-cell");
                    hoveredCellList.push(preChildNodes[rowIndex]);
                    break;
                  }
                  rowNum--;
                }
              });
            } else {
              hoveredCellList.forEach((item) => removeClass(item, "hover-cell"));
              hoveredCellList.length = 0;
            }
            if (!((_b = props2.store) == null ? void 0 : _b.states.isComplex.value) || !isClient)
              return;
            rAF(() => {
              const oldRow = rows[oldVal];
              const newRow = rows[newVal];
              if (oldRow && !oldRow.classList.contains("hover-fixed-row")) {
                removeClass(oldRow, "hover-row");
              }
              if (newRow) {
                addClass(newRow, "hover-row");
              }
            });
          });
          onUnmounted(() => {
            var _a2;
            (_a2 = removePopper) == null ? void 0 : _a2();
          });
          return {
            ns,
            onColumnsChange,
            onScrollableChange,
            wrappedRowRender,
            tooltipContent,
            tooltipTrigger
          };
        },
        render() {
          const { wrappedRowRender, store } = this;
          const data = (store == null ? void 0 : store.states.data.value) || [];
          return h$1("tbody", { tabIndex: -1 }, [
            data.reduce((acc, row) => {
              return acc.concat(wrappedRowRender(row, acc.length));
            }, [])
          ]);
        }
      });
      function useMapState() {
        const table = inject(TABLE_INJECTION_KEY);
        const store = table == null ? void 0 : table.store;
        const leftFixedLeafCount = computed(() => {
          var _a;
          return (_a = store == null ? void 0 : store.states.fixedLeafColumnsLength.value) != null ? _a : 0;
        });
        const rightFixedLeafCount = computed(() => {
          var _a;
          return (_a = store == null ? void 0 : store.states.rightFixedColumns.value.length) != null ? _a : 0;
        });
        const columnsCount = computed(() => {
          var _a;
          return (_a = store == null ? void 0 : store.states.columns.value.length) != null ? _a : 0;
        });
        const leftFixedCount = computed(() => {
          var _a;
          return (_a = store == null ? void 0 : store.states.fixedColumns.value.length) != null ? _a : 0;
        });
        const rightFixedCount = computed(() => {
          var _a;
          return (_a = store == null ? void 0 : store.states.rightFixedColumns.value.length) != null ? _a : 0;
        });
        return {
          leftFixedLeafCount,
          rightFixedLeafCount,
          columnsCount,
          leftFixedCount,
          rightFixedCount,
          columns: computed(() => {
            var _a;
            return (_a = store == null ? void 0 : store.states.columns.value) != null ? _a : [];
          })
        };
      }
      function useStyle$1(props2) {
        const { columns: columns2 } = useMapState();
        const ns = useNamespace("table");
        const getCellClasses = (columns22, cellIndex) => {
          const column = columns22[cellIndex];
          const classes = [
            ns.e("cell"),
            column.id,
            column.align,
            column.labelClassName,
            ...getFixedColumnsClass(ns.b(), cellIndex, column.fixed, props2.store)
          ];
          if (column.className) {
            classes.push(column.className);
          }
          if (!column.children) {
            classes.push(ns.is("leaf"));
          }
          return classes;
        };
        const getCellStyles = (column, cellIndex) => {
          const fixedStyle = getFixedColumnOffset(cellIndex, column.fixed, props2.store);
          ensurePosition(fixedStyle, "left");
          ensurePosition(fixedStyle, "right");
          return fixedStyle;
        };
        return {
          getCellClasses,
          getCellStyles,
          columns: columns2
        };
      }
      var TableFooter = defineComponent({
        name: "ElTableFooter",
        props: {
          fixed: {
            type: String,
            default: ""
          },
          store: {
            required: true,
            type: Object
          },
          summaryMethod: Function,
          sumText: String,
          border: Boolean,
          defaultSort: {
            type: Object,
            default: () => {
              return {
                prop: "",
                order: ""
              };
            }
          }
        },
        setup(props2) {
          const parent2 = inject(TABLE_INJECTION_KEY);
          const ns = useNamespace("table");
          const { getCellClasses, getCellStyles, columns: columns2 } = useStyle$1(props2);
          const { onScrollableChange, onColumnsChange } = useLayoutObserver(parent2);
          return {
            ns,
            onScrollableChange,
            onColumnsChange,
            getCellClasses,
            getCellStyles,
            columns: columns2
          };
        },
        render() {
          const { columns: columns2, getCellStyles, getCellClasses, summaryMethod, sumText } = this;
          const data = this.store.states.data.value;
          let sums = [];
          if (summaryMethod) {
            sums = summaryMethod({
              columns: columns2,
              data
            });
          } else {
            columns2.forEach((column, index2) => {
              if (index2 === 0) {
                sums[index2] = sumText;
                return;
              }
              const values2 = data.map((item) => Number(item[column.property]));
              const precisions = [];
              let notNumber = true;
              values2.forEach((value) => {
                if (!Number.isNaN(+value)) {
                  notNumber = false;
                  const decimal = `${value}`.split(".")[1];
                  precisions.push(decimal ? decimal.length : 0);
                }
              });
              const precision = Math.max.apply(null, precisions);
              if (!notNumber) {
                sums[index2] = values2.reduce((prev, curr) => {
                  const value = Number(curr);
                  if (!Number.isNaN(+value)) {
                    return Number.parseFloat((prev + curr).toFixed(Math.min(precision, 20)));
                  } else {
                    return prev;
                  }
                }, 0);
              } else {
                sums[index2] = "";
              }
            });
          }
          return h$1(h$1("tfoot", [
            h$1("tr", {}, [
              ...columns2.map((column, cellIndex) => h$1("td", {
                key: cellIndex,
                colspan: column.colSpan,
                rowspan: column.rowSpan,
                class: getCellClasses(columns2, cellIndex),
                style: getCellStyles(column, cellIndex)
              }, [
                h$1("div", {
                  class: ["cell", column.labelClassName]
                }, [sums[cellIndex]])
              ]))
            ])
          ]));
        }
      });
      function useUtils(store) {
        const setCurrentRow = (row) => {
          store.commit("setCurrentRow", row);
        };
        const getSelectionRows = () => {
          return store.getSelectionRows();
        };
        const toggleRowSelection = (row, selected, ignoreSelectable = true) => {
          store.toggleRowSelection(row, selected, false, ignoreSelectable);
          store.updateAllSelected();
        };
        const clearSelection = () => {
          store.clearSelection();
        };
        const clearFilter = (columnKeys) => {
          store.clearFilter(columnKeys);
        };
        const toggleAllSelection = () => {
          store.commit("toggleAllSelection");
        };
        const toggleRowExpansion = (row, expanded) => {
          store.toggleRowExpansionAdapter(row, expanded);
        };
        const clearSort = () => {
          store.clearSort();
        };
        const sort = (prop, order) => {
          store.commit("sort", { prop, order });
        };
        const updateKeyChildren = (key, data) => {
          store.updateKeyChildren(key, data);
        };
        return {
          setCurrentRow,
          getSelectionRows,
          toggleRowSelection,
          clearSelection,
          clearFilter,
          toggleAllSelection,
          toggleRowExpansion,
          clearSort,
          sort,
          updateKeyChildren
        };
      }
      function useStyle(props2, layout2, store, table) {
        const isHidden2 = ref(false);
        const renderExpanded = ref(null);
        const resizeProxyVisible = ref(false);
        const setDragVisible = (visible) => {
          resizeProxyVisible.value = visible;
        };
        const resizeState = ref({
          width: null,
          height: null,
          headerHeight: null
        });
        const isGroup = ref(false);
        const scrollbarViewStyle = {
          display: "inline-block",
          verticalAlign: "middle"
        };
        const tableWidth = ref();
        const tableScrollHeight = ref(0);
        const bodyScrollHeight = ref(0);
        const headerScrollHeight = ref(0);
        const footerScrollHeight = ref(0);
        const appendScrollHeight = ref(0);
        watchEffect(() => {
          var _a;
          layout2.setHeight((_a = props2.height) != null ? _a : null);
        });
        watchEffect(() => {
          var _a;
          layout2.setMaxHeight((_a = props2.maxHeight) != null ? _a : null);
        });
        watch(() => [props2.currentRowKey, store.states.rowKey], ([currentRowKey, rowKey2]) => {
          if (!unref(rowKey2) || !unref(currentRowKey))
            return;
          store.setCurrentRowKey(`${currentRowKey}`);
        }, {
          immediate: true
        });
        watch(() => props2.data, (data) => {
          table.store.commit("setData", data);
        }, {
          immediate: true,
          deep: true
        });
        watchEffect(() => {
          if (props2.expandRowKeys) {
            store.setExpandRowKeysAdapter(props2.expandRowKeys);
          }
        });
        const handleMouseLeave = () => {
          table.store.commit("setHoverRow", null);
          if (table.hoverState)
            table.hoverState = null;
        };
        const handleHeaderFooterMousewheel = (_event2, data) => {
          const { pixelX, pixelY } = data;
          if (Math.abs(pixelX) >= Math.abs(pixelY)) {
            table.refs.bodyWrapper.scrollLeft += data.pixelX / 5;
          }
        };
        const shouldUpdateHeight = computed(() => {
          return props2.height || props2.maxHeight || store.states.fixedColumns.value.length > 0 || store.states.rightFixedColumns.value.length > 0;
        });
        const tableBodyStyles = computed(() => {
          return {
            width: layout2.bodyWidth.value ? `${layout2.bodyWidth.value}px` : ""
          };
        });
        const doLayout = () => {
          if (shouldUpdateHeight.value) {
            layout2.updateElsHeight();
          }
          layout2.updateColumnsWidth();
          if (typeof window === "undefined")
            return;
          requestAnimationFrame(syncPosition);
        };
        onMounted(async () => {
          await nextTick();
          store.updateColumns();
          bindEvents();
          requestAnimationFrame(doLayout);
          const el = table.vnode.el;
          const tableHeader = table.refs.headerWrapper;
          if (props2.flexible && el && el.parentElement) {
            el.parentElement.style.minWidth = "0";
          }
          resizeState.value = {
            width: tableWidth.value = el.offsetWidth,
            height: el.offsetHeight,
            headerHeight: props2.showHeader && tableHeader ? tableHeader.offsetHeight : null
          };
          store.states.columns.value.forEach((column) => {
            if (column.filteredValue && column.filteredValue.length) {
              table.store.commit("filterChange", {
                column,
                values: column.filteredValue,
                silent: true
              });
            }
          });
          table.$ready = true;
        });
        const setScrollClassByEl = (el, className) => {
          if (!el)
            return;
          const classList = Array.from(el.classList).filter((item) => !item.startsWith("is-scrolling-"));
          classList.push(layout2.scrollX.value ? className : "is-scrolling-none");
          el.className = classList.join(" ");
        };
        const setScrollClass = (className) => {
          const { tableWrapper } = table.refs;
          setScrollClassByEl(tableWrapper, className);
        };
        const hasScrollClass = (className) => {
          const { tableWrapper } = table.refs;
          return !!(tableWrapper && tableWrapper.classList.contains(className));
        };
        const syncPosition = function() {
          if (!table.refs.scrollBarRef)
            return;
          if (!layout2.scrollX.value) {
            const scrollingNoneClass = "is-scrolling-none";
            if (!hasScrollClass(scrollingNoneClass)) {
              setScrollClass(scrollingNoneClass);
            }
            return;
          }
          const scrollContainer = table.refs.scrollBarRef.wrapRef;
          if (!scrollContainer)
            return;
          const { scrollLeft, offsetWidth, scrollWidth } = scrollContainer;
          const { headerWrapper, footerWrapper } = table.refs;
          if (headerWrapper)
            headerWrapper.scrollLeft = scrollLeft;
          if (footerWrapper)
            footerWrapper.scrollLeft = scrollLeft;
          const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;
          if (scrollLeft >= maxScrollLeftPosition) {
            setScrollClass("is-scrolling-right");
          } else if (scrollLeft === 0) {
            setScrollClass("is-scrolling-left");
          } else {
            setScrollClass("is-scrolling-middle");
          }
        };
        const bindEvents = () => {
          if (!table.refs.scrollBarRef)
            return;
          if (table.refs.scrollBarRef.wrapRef) {
            useEventListener(table.refs.scrollBarRef.wrapRef, "scroll", syncPosition, {
              passive: true
            });
          }
          if (props2.fit) {
            useResizeObserver(table.vnode.el, resizeListener);
          } else {
            useEventListener(window, "resize", resizeListener);
          }
          useResizeObserver(table.refs.bodyWrapper, () => {
            var _a, _b;
            resizeListener();
            (_b = (_a = table.refs) == null ? void 0 : _a.scrollBarRef) == null ? void 0 : _b.update();
          });
        };
        const resizeListener = () => {
          var _a, _b, _c, _d;
          const el = table.vnode.el;
          if (!table.$ready || !el)
            return;
          let shouldUpdateLayout = false;
          const {
            width: oldWidth,
            height: oldHeight,
            headerHeight: oldHeaderHeight
          } = resizeState.value;
          const width = tableWidth.value = el.offsetWidth;
          if (oldWidth !== width) {
            shouldUpdateLayout = true;
          }
          const height = el.offsetHeight;
          if ((props2.height || shouldUpdateHeight.value) && oldHeight !== height) {
            shouldUpdateLayout = true;
          }
          const tableHeader = props2.tableLayout === "fixed" ? table.refs.headerWrapper : (_a = table.refs.tableHeaderRef) == null ? void 0 : _a.$el;
          if (props2.showHeader && (tableHeader == null ? void 0 : tableHeader.offsetHeight) !== oldHeaderHeight) {
            shouldUpdateLayout = true;
          }
          tableScrollHeight.value = ((_b = table.refs.tableWrapper) == null ? void 0 : _b.scrollHeight) || 0;
          headerScrollHeight.value = (tableHeader == null ? void 0 : tableHeader.scrollHeight) || 0;
          footerScrollHeight.value = ((_c = table.refs.footerWrapper) == null ? void 0 : _c.offsetHeight) || 0;
          appendScrollHeight.value = ((_d = table.refs.appendWrapper) == null ? void 0 : _d.offsetHeight) || 0;
          bodyScrollHeight.value = tableScrollHeight.value - headerScrollHeight.value - footerScrollHeight.value - appendScrollHeight.value;
          if (shouldUpdateLayout) {
            resizeState.value = {
              width,
              height,
              headerHeight: props2.showHeader && (tableHeader == null ? void 0 : tableHeader.offsetHeight) || 0
            };
            doLayout();
          }
        };
        const tableSize = useFormSize();
        const bodyWidth = computed(() => {
          const { bodyWidth: bodyWidth_, scrollY, gutterWidth } = layout2;
          return bodyWidth_.value ? `${bodyWidth_.value - (scrollY.value ? gutterWidth : 0)}px` : "";
        });
        const tableLayout = computed(() => {
          if (props2.maxHeight)
            return "fixed";
          return props2.tableLayout;
        });
        const emptyBlockStyle = computed(() => {
          if (props2.data && props2.data.length)
            return;
          let height = "100%";
          if (props2.height && bodyScrollHeight.value) {
            height = `${bodyScrollHeight.value}px`;
          }
          const width = tableWidth.value;
          return {
            width: width ? `${width}px` : "",
            height
          };
        });
        const scrollbarStyle = computed(() => {
          if (props2.height) {
            return {
              height: "100%"
            };
          }
          if (props2.maxHeight) {
            if (!Number.isNaN(Number(props2.maxHeight))) {
              return {
                maxHeight: `${+props2.maxHeight - headerScrollHeight.value - footerScrollHeight.value}px`
              };
            } else {
              return {
                maxHeight: `calc(${props2.maxHeight} - ${headerScrollHeight.value + footerScrollHeight.value}px)`
              };
            }
          }
          return {};
        });
        return {
          isHidden: isHidden2,
          renderExpanded,
          setDragVisible,
          isGroup,
          handleMouseLeave,
          handleHeaderFooterMousewheel,
          tableSize,
          emptyBlockStyle,
          resizeProxyVisible,
          bodyWidth,
          resizeState,
          doLayout,
          tableBodyStyles,
          tableLayout,
          scrollbarViewStyle,
          scrollbarStyle
        };
      }
      function useKeyRender(table) {
        const observer = ref();
        const initWatchDom = () => {
          const el = table.vnode.el;
          const columnsWrapper = el.querySelector(".hidden-columns");
          const config = { childList: true, subtree: true };
          const updateOrderFns = table.store.states.updateOrderFns;
          observer.value = new MutationObserver(() => {
            updateOrderFns.forEach((fn2) => fn2());
          });
          observer.value.observe(columnsWrapper, config);
        };
        onMounted(() => {
          initWatchDom();
        });
        onUnmounted(() => {
          var _a;
          (_a = observer.value) == null ? void 0 : _a.disconnect();
        });
      }
      var defaultProps$2 = {
        data: {
          type: Array,
          default: () => []
        },
        size: useSizeProp,
        width: [String, Number],
        height: [String, Number],
        maxHeight: [String, Number],
        fit: {
          type: Boolean,
          default: true
        },
        stripe: Boolean,
        border: Boolean,
        rowKey: [String, Function],
        showHeader: {
          type: Boolean,
          default: true
        },
        showSummary: Boolean,
        sumText: String,
        summaryMethod: Function,
        rowClassName: [String, Function],
        rowStyle: [Object, Function],
        cellClassName: [String, Function],
        cellStyle: [Object, Function],
        headerRowClassName: [String, Function],
        headerRowStyle: [Object, Function],
        headerCellClassName: [String, Function],
        headerCellStyle: [Object, Function],
        highlightCurrentRow: Boolean,
        currentRowKey: [String, Number],
        emptyText: String,
        expandRowKeys: Array,
        defaultExpandAll: Boolean,
        defaultSort: Object,
        tooltipEffect: String,
        tooltipOptions: Object,
        spanMethod: Function,
        selectOnIndeterminate: {
          type: Boolean,
          default: true
        },
        indent: {
          type: Number,
          default: 16
        },
        treeProps: {
          type: Object,
          default: () => {
            return {
              hasChildren: "hasChildren",
              children: "children",
              checkStrictly: false
            };
          }
        },
        lazy: Boolean,
        load: Function,
        style: {
          type: Object,
          default: () => ({})
        },
        className: {
          type: String,
          default: ""
        },
        tableLayout: {
          type: String,
          default: "fixed"
        },
        scrollbarAlwaysOn: Boolean,
        flexible: Boolean,
        showOverflowTooltip: [Boolean, Object],
        tooltipFormatter: Function,
        appendFilterPanelTo: String,
        scrollbarTabindex: {
          type: [Number, String],
          default: void 0
        },
        allowDragLastColumn: {
          type: Boolean,
          default: true
        },
        preserveExpandedContent: Boolean,
        nativeScrollbar: Boolean
      };
      function hColgroup(props2) {
        const isAuto = props2.tableLayout === "auto";
        let columns2 = props2.columns || [];
        if (isAuto) {
          if (columns2.every(({ width }) => isUndefined(width))) {
            columns2 = [];
          }
        }
        const getPropsData = (column) => {
          const propsData = {
            key: `${props2.tableLayout}_${column.id}`,
            style: {},
            name: void 0
          };
          if (isAuto) {
            propsData.style = {
              width: `${column.width}px`
            };
          } else {
            propsData.name = column.id;
          }
          return propsData;
        };
        return h$1("colgroup", {}, columns2.map((column) => h$1("col", getPropsData(column))));
      }
      hColgroup.props = ["columns", "tableLayout"];
      const useScrollbar$1 = () => {
        const scrollBarRef = ref();
        const scrollTo = (options, yCoord) => {
          const scrollbar = scrollBarRef.value;
          if (scrollbar) {
            scrollbar.scrollTo(options, yCoord);
          }
        };
        const setScrollPosition = (position, offset2) => {
          const scrollbar = scrollBarRef.value;
          if (scrollbar && isNumber(offset2) && ["Top", "Left"].includes(position)) {
            scrollbar[`setScroll${position}`](offset2);
          }
        };
        const setScrollTop = (top) => setScrollPosition("Top", top);
        const setScrollLeft = (left) => setScrollPosition("Left", left);
        return {
          scrollBarRef,
          scrollTo,
          setScrollTop,
          setScrollLeft
        };
      };
      let tableIdSeed = 1;
      const _sfc_main$D = defineComponent({
        name: "ElTable",
        directives: {
          Mousewheel
        },
        components: {
          TableHeader,
          TableBody,
          TableFooter,
          ElScrollbar,
          hColgroup
        },
        props: defaultProps$2,
        emits: [
          "select",
          "select-all",
          "selection-change",
          "cell-mouse-enter",
          "cell-mouse-leave",
          "cell-contextmenu",
          "cell-click",
          "cell-dblclick",
          "row-click",
          "row-contextmenu",
          "row-dblclick",
          "header-click",
          "header-contextmenu",
          "sort-change",
          "filter-change",
          "current-change",
          "header-dragend",
          "expand-change",
          "scroll"
        ],
        setup(props2) {
          const { t } = useLocale();
          const ns = useNamespace("table");
          const table = getCurrentInstance();
          provide(TABLE_INJECTION_KEY, table);
          const store = createStore(table, props2);
          table.store = store;
          const layout2 = new TableLayout$1({
            store: table.store,
            table,
            fit: props2.fit,
            showHeader: props2.showHeader
          });
          table.layout = layout2;
          const isEmpty2 = computed(() => (store.states.data.value || []).length === 0);
          const {
            setCurrentRow,
            getSelectionRows,
            toggleRowSelection,
            clearSelection,
            clearFilter,
            toggleAllSelection,
            toggleRowExpansion,
            clearSort,
            sort,
            updateKeyChildren
          } = useUtils(store);
          const {
            isHidden: isHidden2,
            renderExpanded,
            setDragVisible,
            isGroup,
            handleMouseLeave,
            handleHeaderFooterMousewheel,
            tableSize,
            emptyBlockStyle,
            resizeProxyVisible,
            bodyWidth,
            resizeState,
            doLayout,
            tableBodyStyles,
            tableLayout,
            scrollbarViewStyle,
            scrollbarStyle
          } = useStyle(props2, layout2, store, table);
          const { scrollBarRef, scrollTo, setScrollLeft, setScrollTop } = useScrollbar$1();
          const debouncedUpdateLayout = debounce(doLayout, 50);
          const tableId = `${ns.namespace.value}-table_${tableIdSeed++}`;
          table.tableId = tableId;
          table.state = {
            isGroup,
            resizeState,
            doLayout,
            debouncedUpdateLayout
          };
          const computedSumText = computed(() => {
            var _a;
            return (_a = props2.sumText) != null ? _a : t("el.table.sumText");
          });
          const computedEmptyText = computed(() => {
            var _a;
            return (_a = props2.emptyText) != null ? _a : t("el.table.emptyText");
          });
          const columns2 = computed(() => {
            return convertToRows(store.states.originColumns.value)[0];
          });
          useKeyRender(table);
          onBeforeUnmount(() => {
            debouncedUpdateLayout.cancel();
          });
          return {
            ns,
            layout: layout2,
            store,
            columns: columns2,
            handleHeaderFooterMousewheel,
            handleMouseLeave,
            tableId,
            tableSize,
            isHidden: isHidden2,
            isEmpty: isEmpty2,
            renderExpanded,
            resizeProxyVisible,
            resizeState,
            isGroup,
            bodyWidth,
            tableBodyStyles,
            emptyBlockStyle,
            debouncedUpdateLayout,
            setCurrentRow,
            getSelectionRows,
            toggleRowSelection,
            clearSelection,
            clearFilter,
            toggleAllSelection,
            toggleRowExpansion,
            clearSort,
            doLayout,
            sort,
            updateKeyChildren,
            t,
            setDragVisible,
            context: table,
            computedSumText,
            computedEmptyText,
            tableLayout,
            scrollbarViewStyle,
            scrollbarStyle,
            scrollBarRef,
            scrollTo,
            setScrollLeft,
            setScrollTop,
            allowDragLastColumn: props2.allowDragLastColumn
          };
        }
      });
      function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_hColgroup = resolveComponent("hColgroup");
        const _component_table_header = resolveComponent("table-header");
        const _component_table_body = resolveComponent("table-body");
        const _component_table_footer = resolveComponent("table-footer");
        const _component_el_scrollbar = resolveComponent("el-scrollbar");
        const _directive_mousewheel = resolveDirective("mousewheel");
        return openBlock(), createElementBlock("div", {
          ref: "tableWrapper",
          class: normalizeClass([
            {
              [_ctx.ns.m("fit")]: _ctx.fit,
              [_ctx.ns.m("striped")]: _ctx.stripe,
              [_ctx.ns.m("border")]: _ctx.border || _ctx.isGroup,
              [_ctx.ns.m("hidden")]: _ctx.isHidden,
              [_ctx.ns.m("group")]: _ctx.isGroup,
              [_ctx.ns.m("fluid-height")]: _ctx.maxHeight,
              [_ctx.ns.m("scrollable-x")]: _ctx.layout.scrollX.value,
              [_ctx.ns.m("scrollable-y")]: _ctx.layout.scrollY.value,
              [_ctx.ns.m("enable-row-hover")]: !_ctx.store.states.isComplex.value,
              [_ctx.ns.m("enable-row-transition")]: (_ctx.store.states.data.value || []).length !== 0 && (_ctx.store.states.data.value || []).length < 100,
              "has-footer": _ctx.showSummary
            },
            _ctx.ns.m(_ctx.tableSize),
            _ctx.className,
            _ctx.ns.b(),
            _ctx.ns.m(`layout-${_ctx.tableLayout}`)
          ]),
          style: normalizeStyle(_ctx.style),
          "data-prefix": _ctx.ns.namespace.value,
          onMouseleave: _ctx.handleMouseLeave
        }, [
          createElementVNode("div", {
            class: normalizeClass(_ctx.ns.e("inner-wrapper"))
          }, [
            createElementVNode("div", {
              ref: "hiddenColumns",
              class: "hidden-columns"
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 512),
            _ctx.showHeader && _ctx.tableLayout === "fixed" ? withDirectives((openBlock(), createElementBlock("div", {
              key: 0,
              ref: "headerWrapper",
              class: normalizeClass(_ctx.ns.e("header-wrapper"))
            }, [
              createElementVNode("table", {
                ref: "tableHeader",
                class: normalizeClass(_ctx.ns.e("header")),
                style: normalizeStyle(_ctx.tableBodyStyles),
                border: "0",
                cellpadding: "0",
                cellspacing: "0"
              }, [
                createVNode(_component_hColgroup, {
                  columns: _ctx.store.states.columns.value,
                  "table-layout": _ctx.tableLayout
                }, null, 8, ["columns", "table-layout"]),
                createVNode(_component_table_header, {
                  ref: "tableHeaderRef",
                  border: _ctx.border,
                  "default-sort": _ctx.defaultSort,
                  store: _ctx.store,
                  "append-filter-panel-to": _ctx.appendFilterPanelTo,
                  "allow-drag-last-column": _ctx.allowDragLastColumn,
                  onSetDragVisible: _ctx.setDragVisible
                }, null, 8, ["border", "default-sort", "store", "append-filter-panel-to", "allow-drag-last-column", "onSetDragVisible"])
              ], 6)
            ], 2)), [
              [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
            ]) : createCommentVNode("v-if", true),
            createElementVNode("div", {
              ref: "bodyWrapper",
              class: normalizeClass(_ctx.ns.e("body-wrapper"))
            }, [
              createVNode(_component_el_scrollbar, {
                ref: "scrollBarRef",
                "view-style": _ctx.scrollbarViewStyle,
                "wrap-style": _ctx.scrollbarStyle,
                always: _ctx.scrollbarAlwaysOn,
                tabindex: _ctx.scrollbarTabindex,
                native: _ctx.nativeScrollbar,
                onScroll: ($event) => _ctx.$emit("scroll", $event)
              }, {
                default: withCtx(() => [
                  createElementVNode("table", {
                    ref: "tableBody",
                    class: normalizeClass(_ctx.ns.e("body")),
                    cellspacing: "0",
                    cellpadding: "0",
                    border: "0",
                    style: normalizeStyle({
                      width: _ctx.bodyWidth,
                      tableLayout: _ctx.tableLayout
                    })
                  }, [
                    createVNode(_component_hColgroup, {
                      columns: _ctx.store.states.columns.value,
                      "table-layout": _ctx.tableLayout
                    }, null, 8, ["columns", "table-layout"]),
                    _ctx.showHeader && _ctx.tableLayout === "auto" ? (openBlock(), createBlock(_component_table_header, {
                      key: 0,
                      ref: "tableHeaderRef",
                      class: normalizeClass(_ctx.ns.e("body-header")),
                      border: _ctx.border,
                      "default-sort": _ctx.defaultSort,
                      store: _ctx.store,
                      "append-filter-panel-to": _ctx.appendFilterPanelTo,
                      onSetDragVisible: _ctx.setDragVisible
                    }, null, 8, ["class", "border", "default-sort", "store", "append-filter-panel-to", "onSetDragVisible"])) : createCommentVNode("v-if", true),
                    createVNode(_component_table_body, {
                      context: _ctx.context,
                      highlight: _ctx.highlightCurrentRow,
                      "row-class-name": _ctx.rowClassName,
                      "tooltip-effect": _ctx.tooltipEffect,
                      "tooltip-options": _ctx.tooltipOptions,
                      "row-style": _ctx.rowStyle,
                      store: _ctx.store,
                      stripe: _ctx.stripe
                    }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"]),
                    _ctx.showSummary && _ctx.tableLayout === "auto" ? (openBlock(), createBlock(_component_table_footer, {
                      key: 1,
                      class: normalizeClass(_ctx.ns.e("body-footer")),
                      border: _ctx.border,
                      "default-sort": _ctx.defaultSort,
                      store: _ctx.store,
                      "sum-text": _ctx.computedSumText,
                      "summary-method": _ctx.summaryMethod
                    }, null, 8, ["class", "border", "default-sort", "store", "sum-text", "summary-method"])) : createCommentVNode("v-if", true)
                  ], 6),
                  _ctx.isEmpty ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    ref: "emptyBlock",
                    style: normalizeStyle(_ctx.emptyBlockStyle),
                    class: normalizeClass(_ctx.ns.e("empty-block"))
                  }, [
                    createElementVNode("span", {
                      class: normalizeClass(_ctx.ns.e("empty-text"))
                    }, [
                      renderSlot(_ctx.$slots, "empty", {}, () => [
                        createTextVNode(toDisplayString(_ctx.computedEmptyText), 1)
                      ])
                    ], 2)
                  ], 6)) : createCommentVNode("v-if", true),
                  _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    ref: "appendWrapper",
                    class: normalizeClass(_ctx.ns.e("append-wrapper"))
                  }, [
                    renderSlot(_ctx.$slots, "append")
                  ], 2)) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["view-style", "wrap-style", "always", "tabindex", "native", "onScroll"])
            ], 2),
            _ctx.showSummary && _ctx.tableLayout === "fixed" ? withDirectives((openBlock(), createElementBlock("div", {
              key: 1,
              ref: "footerWrapper",
              class: normalizeClass(_ctx.ns.e("footer-wrapper"))
            }, [
              createElementVNode("table", {
                class: normalizeClass(_ctx.ns.e("footer")),
                cellspacing: "0",
                cellpadding: "0",
                border: "0",
                style: normalizeStyle(_ctx.tableBodyStyles)
              }, [
                createVNode(_component_hColgroup, {
                  columns: _ctx.store.states.columns.value,
                  "table-layout": _ctx.tableLayout
                }, null, 8, ["columns", "table-layout"]),
                createVNode(_component_table_footer, {
                  border: _ctx.border,
                  "default-sort": _ctx.defaultSort,
                  store: _ctx.store,
                  "sum-text": _ctx.computedSumText,
                  "summary-method": _ctx.summaryMethod
                }, null, 8, ["border", "default-sort", "store", "sum-text", "summary-method"])
              ], 6)
            ], 2)), [
              [vShow, !_ctx.isEmpty],
              [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
            ]) : createCommentVNode("v-if", true),
            _ctx.border || _ctx.isGroup ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: normalizeClass(_ctx.ns.e("border-left-patch"))
            }, null, 2)) : createCommentVNode("v-if", true)
          ], 2),
          withDirectives(createElementVNode("div", {
            ref: "resizeProxy",
            class: normalizeClass(_ctx.ns.e("column-resize-proxy"))
          }, null, 2), [
            [vShow, _ctx.resizeProxyVisible]
          ])
        ], 46, ["data-prefix", "onMouseleave"]);
      }
      var Table = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$3], ["__file", "table.vue"]]);
      const defaultClassNames = {
        selection: "table-column--selection",
        expand: "table__expand-column"
      };
      const cellStarts = {
        default: {
          order: ""
        },
        selection: {
          width: 48,
          minWidth: 48,
          realWidth: 48,
          order: ""
        },
        expand: {
          width: 48,
          minWidth: 48,
          realWidth: 48,
          order: ""
        },
        index: {
          width: 48,
          minWidth: 48,
          realWidth: 48,
          order: ""
        }
      };
      const getDefaultClassName = (type) => {
        return defaultClassNames[type] || "";
      };
      const cellForced = {
        selection: {
          renderHeader({
            store,
            column
          }) {
            var _a;
            function isDisabled() {
              return store.states.data.value && store.states.data.value.length === 0;
            }
            return h$1(ElCheckbox, {
              disabled: isDisabled(),
              size: store.states.tableSize.value,
              indeterminate: store.states.selection.value.length > 0 && !store.states.isAllSelected.value,
              "onUpdate:modelValue": (_a = store.toggleAllSelection) != null ? _a : void 0,
              modelValue: store.states.isAllSelected.value,
              ariaLabel: column.label
            });
          },
          renderCell({
            row,
            column,
            store,
            $index
          }) {
            return h$1(ElCheckbox, {
              disabled: column.selectable ? !column.selectable.call(null, row, $index) : false,
              size: store.states.tableSize.value,
              onChange: () => {
                store.commit("rowSelectedChanged", row);
              },
              onClick: (event) => event.stopPropagation(),
              modelValue: store.isSelected(row),
              ariaLabel: column.label
            });
          },
          sortable: false,
          resizable: false
        },
        index: {
          renderHeader({
            column
          }) {
            return column.label || "#";
          },
          renderCell({
            column,
            $index
          }) {
            let i = $index + 1;
            const index2 = column.index;
            if (isNumber(index2)) {
              i = $index + index2;
            } else if (isFunction$1(index2)) {
              i = index2($index);
            }
            return h$1("div", {}, [i]);
          },
          sortable: false
        },
        expand: {
          renderHeader({
            column
          }) {
            return column.label || "";
          },
          renderCell({
            column,
            row,
            store,
            expanded
          }) {
            const { ns } = store;
            const classes = [ns.e("expand-icon")];
            if (!column.renderExpand && expanded) {
              classes.push(ns.em("expand-icon", "expanded"));
            }
            const callback = function(e) {
              e.stopPropagation();
              store.toggleRowExpansion(row);
            };
            return h$1("div", {
              class: classes,
              onClick: callback
            }, {
              default: () => {
                if (column.renderExpand) {
                  return [
                    column.renderExpand({
                      expanded
                    })
                  ];
                }
                return [
                  h$1(ElIcon, null, {
                    default: () => {
                      return [h$1(arrow_right_default$1)];
                    }
                  })
                ];
              }
            });
          },
          sortable: false,
          resizable: false
        }
      };
      function defaultRenderCell({
        row,
        column,
        $index
      }) {
        var _a;
        const property2 = column.property;
        const value = property2 && getProp(row, property2).value;
        if (column && column.formatter) {
          return column.formatter(row, column, value, $index);
        }
        return ((_a = value == null ? void 0 : value.toString) == null ? void 0 : _a.call(value)) || "";
      }
      function treeCellPrefix({
        row,
        treeNode,
        store
      }, createPlaceholder = false) {
        const { ns } = store;
        if (!treeNode) {
          if (createPlaceholder) {
            return [
              h$1("span", {
                class: ns.e("placeholder")
              })
            ];
          }
          return null;
        }
        const ele = [];
        const callback = function(e) {
          e.stopPropagation();
          if (treeNode.loading) {
            return;
          }
          store.loadOrToggle(row);
        };
        if (treeNode.indent) {
          ele.push(h$1("span", {
            class: ns.e("indent"),
            style: { "padding-left": `${treeNode.indent}px` }
          }));
        }
        if (isBoolean(treeNode.expanded) && !treeNode.noLazyChildren) {
          const expandClasses = [
            ns.e("expand-icon"),
            treeNode.expanded ? ns.em("expand-icon", "expanded") : ""
          ];
          let icon = arrow_right_default$1;
          if (treeNode.loading) {
            icon = loading_default$1;
          }
          ele.push(h$1("div", {
            class: expandClasses,
            onClick: callback
          }, {
            default: () => {
              return [
                h$1(ElIcon, { class: { [ns.is("loading")]: treeNode.loading } }, {
                  default: () => [h$1(icon)]
                })
              ];
            }
          }));
        } else {
          ele.push(h$1("span", {
            class: ns.e("placeholder")
          }));
        }
        return ele;
      }
      function getAllAliases(props2, aliases) {
        return props2.reduce((prev, cur) => {
          prev[cur] = cur;
          return prev;
        }, aliases);
      }
      function useWatcher(owner, props_) {
        const instance = getCurrentInstance();
        const registerComplexWatchers = () => {
          const props2 = ["fixed"];
          const aliases = {
            realWidth: "width",
            realMinWidth: "minWidth"
          };
          const allAliases = getAllAliases(props2, aliases);
          Object.keys(allAliases).forEach((key) => {
            const columnKey = aliases[key];
            if (hasOwn(props_, columnKey)) {
              watch(() => props_[columnKey], (newVal) => {
                let value = newVal;
                if (columnKey === "width" && key === "realWidth") {
                  value = parseWidth(newVal);
                }
                if (columnKey === "minWidth" && key === "realMinWidth") {
                  value = parseMinWidth(newVal);
                }
                instance.columnConfig.value[columnKey] = value;
                instance.columnConfig.value[key] = value;
                const updateColumns = columnKey === "fixed";
                owner.value.store.scheduleLayout(updateColumns);
              });
            }
          });
        };
        const registerNormalWatchers = () => {
          const props2 = [
            "label",
            "filters",
            "filterMultiple",
            "filteredValue",
            "sortable",
            "index",
            "formatter",
            "className",
            "labelClassName",
            "filterClassName",
            "showOverflowTooltip",
            "tooltipFormatter"
          ];
          const aliases = {
            property: "prop",
            align: "realAlign",
            headerAlign: "realHeaderAlign"
          };
          const allAliases = getAllAliases(props2, aliases);
          Object.keys(allAliases).forEach((key) => {
            const columnKey = aliases[key];
            if (hasOwn(props_, columnKey)) {
              watch(() => props_[columnKey], (newVal) => {
                instance.columnConfig.value[key] = newVal;
              });
            }
          });
        };
        return {
          registerComplexWatchers,
          registerNormalWatchers
        };
      }
      function useRender(props2, slots, owner) {
        const instance = getCurrentInstance();
        const columnId = ref("");
        const isSubColumn = ref(false);
        const realAlign = ref();
        const realHeaderAlign = ref();
        const ns = useNamespace("table");
        watchEffect(() => {
          realAlign.value = props2.align ? `is-${props2.align}` : null;
          realAlign.value;
        });
        watchEffect(() => {
          realHeaderAlign.value = props2.headerAlign ? `is-${props2.headerAlign}` : realAlign.value;
          realHeaderAlign.value;
        });
        const columnOrTableParent = computed(() => {
          let parent2 = instance.vnode.vParent || instance.parent;
          while (parent2 && !parent2.tableId && !parent2.columnId) {
            parent2 = parent2.vnode.vParent || parent2.parent;
          }
          return parent2;
        });
        const hasTreeColumn = computed(() => {
          const { store } = instance.parent;
          if (!store)
            return false;
          const { treeData } = store.states;
          const treeDataValue = treeData.value;
          return treeDataValue && Object.keys(treeDataValue).length > 0;
        });
        const realWidth = ref(parseWidth(props2.width));
        const realMinWidth = ref(parseMinWidth(props2.minWidth));
        const setColumnWidth = (column) => {
          if (realWidth.value)
            column.width = realWidth.value;
          if (realMinWidth.value) {
            column.minWidth = realMinWidth.value;
          }
          if (!realWidth.value && realMinWidth.value) {
            column.width = void 0;
          }
          if (!column.minWidth) {
            column.minWidth = 80;
          }
          column.realWidth = Number(isUndefined(column.width) ? column.minWidth : column.width);
          return column;
        };
        const setColumnForcedProps = (column) => {
          const type = column.type;
          const source = cellForced[type] || {};
          Object.keys(source).forEach((prop) => {
            const value = source[prop];
            if (prop !== "className" && !isUndefined(value)) {
              column[prop] = value;
            }
          });
          const className = getDefaultClassName(type);
          if (className) {
            const forceClass = `${unref(ns.namespace)}-${className}`;
            column.className = column.className ? `${column.className} ${forceClass}` : forceClass;
          }
          return column;
        };
        const checkSubColumn = (children) => {
          if (isArray$1(children)) {
            children.forEach((child) => check(child));
          } else {
            check(children);
          }
          function check(item) {
            var _a;
            if (((_a = item == null ? void 0 : item.type) == null ? void 0 : _a.name) === "ElTableColumn") {
              item.vParent = instance;
            }
          }
        };
        const setColumnRenders = (column) => {
          if (props2.renderHeader)
            ;
          else if (column.type !== "selection") {
            column.renderHeader = (scope) => {
              instance.columnConfig.value["label"];
              return renderSlot(slots, "header", scope, () => [column.label]);
            };
          }
          if (slots["filter-icon"]) {
            column.renderFilterIcon = (scope) => {
              return renderSlot(slots, "filter-icon", scope);
            };
          }
          if (slots.expand) {
            column.renderExpand = (scope) => {
              return renderSlot(slots, "expand", scope);
            };
          }
          let originRenderCell = column.renderCell;
          if (column.type === "expand") {
            column.renderCell = (data) => h$1("div", {
              class: "cell"
            }, [originRenderCell(data)]);
            owner.value.renderExpanded = (row) => {
              return slots.default ? slots.default(row) : slots.default;
            };
          } else {
            originRenderCell = originRenderCell || defaultRenderCell;
            column.renderCell = (data) => {
              let children = null;
              if (slots.default) {
                const vnodes = slots.default(data);
                children = ensureValidVNode(vnodes) ? vnodes : originRenderCell(data);
              } else {
                children = originRenderCell(data);
              }
              const { columns: columns2 } = owner.value.store.states;
              const firstUserColumnIndex = columns2.value.findIndex((item) => item.type === "default");
              const shouldCreatePlaceholder = hasTreeColumn.value && data.cellIndex === firstUserColumnIndex;
              const prefix = treeCellPrefix(data, shouldCreatePlaceholder);
              const props22 = {
                class: "cell",
                style: {}
              };
              if (column.showOverflowTooltip) {
                props22.class = `${props22.class} ${unref(ns.namespace)}-tooltip`;
                props22.style = {
                  width: `${(data.column.realWidth || Number(data.column.width)) - 1}px`
                };
              }
              checkSubColumn(children);
              return h$1("div", props22, [prefix, children]);
            };
          }
          return column;
        };
        const getPropsData = (...propsKey) => {
          return propsKey.reduce((prev, cur) => {
            if (isArray$1(cur)) {
              cur.forEach((key) => {
                prev[key] = props2[key];
              });
            }
            return prev;
          }, {});
        };
        const getColumnElIndex = (children, child) => {
          return Array.prototype.indexOf.call(children, child);
        };
        const updateColumnOrder = () => {
          owner.value.store.commit("updateColumnOrder", instance.columnConfig.value);
        };
        return {
          columnId,
          realAlign,
          isSubColumn,
          realHeaderAlign,
          columnOrTableParent,
          setColumnWidth,
          setColumnForcedProps,
          setColumnRenders,
          getPropsData,
          getColumnElIndex,
          updateColumnOrder
        };
      }
      var defaultProps$1 = {
        type: {
          type: String,
          default: "default"
        },
        label: String,
        className: String,
        labelClassName: String,
        property: String,
        prop: String,
        width: {
          type: [String, Number],
          default: ""
        },
        minWidth: {
          type: [String, Number],
          default: ""
        },
        renderHeader: Function,
        sortable: {
          type: [Boolean, String],
          default: false
        },
        sortMethod: Function,
        sortBy: [String, Function, Array],
        resizable: {
          type: Boolean,
          default: true
        },
        columnKey: String,
        align: String,
        headerAlign: String,
        showOverflowTooltip: {
          type: [Boolean, Object],
          default: void 0
        },
        tooltipFormatter: Function,
        fixed: [Boolean, String],
        formatter: Function,
        selectable: Function,
        reserveSelection: Boolean,
        filterMethod: Function,
        filteredValue: Array,
        filters: Array,
        filterPlacement: String,
        filterMultiple: {
          type: Boolean,
          default: true
        },
        filterClassName: String,
        index: [Number, Function],
        sortOrders: {
          type: Array,
          default: () => {
            return ["ascending", "descending", null];
          },
          validator: (val) => {
            return val.every((order) => ["ascending", "descending", null].includes(order));
          }
        }
      };
      let columnIdSeed = 1;
      var ElTableColumn$1 = defineComponent({
        name: "ElTableColumn",
        components: {
          ElCheckbox
        },
        props: defaultProps$1,
        setup(props2, { slots }) {
          const instance = getCurrentInstance();
          const columnConfig = ref({});
          const owner = computed(() => {
            let parent22 = instance.parent;
            while (parent22 && !parent22.tableId) {
              parent22 = parent22.parent;
            }
            return parent22;
          });
          const { registerNormalWatchers, registerComplexWatchers } = useWatcher(owner, props2);
          const {
            columnId,
            isSubColumn,
            realHeaderAlign,
            columnOrTableParent,
            setColumnWidth,
            setColumnForcedProps,
            setColumnRenders,
            getPropsData,
            getColumnElIndex,
            realAlign,
            updateColumnOrder
          } = useRender(props2, slots, owner);
          const parent2 = columnOrTableParent.value;
          columnId.value = `${"tableId" in parent2 && parent2.tableId || "columnId" in parent2 && parent2.columnId}_column_${columnIdSeed++}`;
          onBeforeMount(() => {
            isSubColumn.value = owner.value !== parent2;
            const type = props2.type || "default";
            const sortable = props2.sortable === "" ? true : props2.sortable;
            const showOverflowTooltip = type === "selection" ? false : isUndefined(props2.showOverflowTooltip) ? parent2.props.showOverflowTooltip : props2.showOverflowTooltip;
            const tooltipFormatter = isUndefined(props2.tooltipFormatter) ? parent2.props.tooltipFormatter : props2.tooltipFormatter;
            const defaults2 = {
              ...cellStarts[type],
              id: columnId.value,
              type,
              property: props2.prop || props2.property,
              align: realAlign,
              headerAlign: realHeaderAlign,
              showOverflowTooltip,
              tooltipFormatter,
              filterable: props2.filters || props2.filterMethod,
              filteredValue: [],
              filterPlacement: "",
              filterClassName: "",
              isColumnGroup: false,
              isSubColumn: false,
              filterOpened: false,
              sortable,
              index: props2.index,
              rawColumnKey: instance.vnode.key
            };
            const basicProps = [
              "columnKey",
              "label",
              "className",
              "labelClassName",
              "type",
              "renderHeader",
              "formatter",
              "fixed",
              "resizable"
            ];
            const sortProps = ["sortMethod", "sortBy", "sortOrders"];
            const selectProps2 = ["selectable", "reserveSelection"];
            const filterProps = [
              "filterMethod",
              "filters",
              "filterMultiple",
              "filterOpened",
              "filteredValue",
              "filterPlacement",
              "filterClassName"
            ];
            let column = getPropsData(basicProps, sortProps, selectProps2, filterProps);
            column = mergeOptions(defaults2, column);
            const chains = compose(setColumnRenders, setColumnWidth, setColumnForcedProps);
            column = chains(column);
            columnConfig.value = column;
            registerNormalWatchers();
            registerComplexWatchers();
          });
          onMounted(() => {
            var _a, _b;
            const parent22 = columnOrTableParent.value;
            const children = isSubColumn.value ? (_a = parent22.vnode.el) == null ? void 0 : _a.children : (_b = parent22.refs.hiddenColumns) == null ? void 0 : _b.children;
            const getColumnIndex = () => getColumnElIndex(children || [], instance.vnode.el);
            columnConfig.value.getColumnIndex = getColumnIndex;
            const columnIndex = getColumnIndex();
            columnIndex > -1 && owner.value.store.commit("insertColumn", columnConfig.value, isSubColumn.value ? "columnConfig" in parent22 && parent22.columnConfig.value : null, updateColumnOrder);
          });
          onBeforeUnmount(() => {
            const getColumnIndex = columnConfig.value.getColumnIndex;
            const columnIndex = getColumnIndex ? getColumnIndex() : -1;
            columnIndex > -1 && owner.value.store.commit("removeColumn", columnConfig.value, isSubColumn.value ? "columnConfig" in parent2 && parent2.columnConfig.value : null, updateColumnOrder);
          });
          instance.columnId = columnId.value;
          instance.columnConfig = columnConfig;
          return;
        },
        render() {
          var _a, _b, _c;
          try {
            const renderDefault = (_b = (_a = this.$slots).default) == null ? void 0 : _b.call(_a, {
              row: {},
              column: {},
              $index: -1
            });
            const children = [];
            if (isArray$1(renderDefault)) {
              for (const childNode of renderDefault) {
                if (((_c = childNode.type) == null ? void 0 : _c.name) === "ElTableColumn" || childNode.shapeFlag & 2) {
                  children.push(childNode);
                } else if (childNode.type === Fragment && isArray$1(childNode.children)) {
                  childNode.children.forEach((vnode2) => {
                    if ((vnode2 == null ? void 0 : vnode2.patchFlag) !== 1024 && !isString$1(vnode2 == null ? void 0 : vnode2.children)) {
                      children.push(vnode2);
                    }
                  });
                }
              }
            }
            const vnode = h$1("div", children);
            return vnode;
          } catch (e) {
            return h$1("div", []);
          }
        }
      });
      const ElTable = exports("ElTable", withInstall(Table, {
        TableColumn: ElTableColumn$1
      }));
      const ElTableColumn = exports("ElTableColumn", withNoopInstall(ElTableColumn$1));
      var SortOrder = exports("TableV2SortOrder", /* @__PURE__ */ ((SortOrder2) => {
        SortOrder2["ASC"] = "asc";
        SortOrder2["DESC"] = "desc";
        return SortOrder2;
      })(SortOrder || {}));
      var Alignment = exports("TableV2Alignment", /* @__PURE__ */ ((Alignment2) => {
        Alignment2["CENTER"] = "center";
        Alignment2["RIGHT"] = "right";
        return Alignment2;
      })(Alignment || {}));
      var FixedDir = exports("TableV2FixedDir", /* @__PURE__ */ ((FixedDir2) => {
        FixedDir2["LEFT"] = "left";
        FixedDir2["RIGHT"] = "right";
        return FixedDir2;
      })(FixedDir || {}));
      const oppositeOrderMap = {
        [
          "asc"
          /* ASC */
        ]: "desc",
        [
          "desc"
          /* DESC */
        ]: "asc"
        /* ASC */
      };
      const placeholderSign = exports("TableV2Placeholder", Symbol("placeholder"));
      const calcColumnStyle = (column, fixedColumn, fixed) => {
        var _a;
        const flex = {
          flexGrow: 0,
          flexShrink: 0,
          ...fixed ? {} : {
            flexGrow: column.flexGrow || 0,
            flexShrink: column.flexShrink || 1
          }
        };
        if (!fixed) {
          flex.flexShrink = 1;
        }
        const style = {
          ...(_a = column.style) != null ? _a : {},
          ...flex,
          flexBasis: "auto",
          width: column.width
        };
        if (!fixedColumn) {
          if (column.maxWidth)
            style.maxWidth = column.maxWidth;
          if (column.minWidth)
            style.minWidth = column.minWidth;
        }
        return style;
      };
      function useColumns(props2, columns2, fixed) {
        const _columns = computed(() => unref(columns2).map((column, index2) => {
          var _a, _b;
          return {
            ...column,
            key: (_b = (_a = column.key) != null ? _a : column.dataKey) != null ? _b : index2
          };
        }));
        const visibleColumns = computed(() => {
          return unref(_columns).filter((column) => !column.hidden);
        });
        const fixedColumnsOnLeft = computed(() => unref(visibleColumns).filter((column) => column.fixed === "left" || column.fixed === true));
        const fixedColumnsOnRight = computed(() => unref(visibleColumns).filter((column) => column.fixed === "right"));
        const normalColumns = computed(() => unref(visibleColumns).filter((column) => !column.fixed));
        const mainColumns = computed(() => {
          const ret = [];
          unref(fixedColumnsOnLeft).forEach((column) => {
            ret.push({
              ...column,
              placeholderSign
            });
          });
          unref(normalColumns).forEach((column) => {
            ret.push(column);
          });
          unref(fixedColumnsOnRight).forEach((column) => {
            ret.push({
              ...column,
              placeholderSign
            });
          });
          return ret;
        });
        const hasFixedColumns = computed(() => {
          return unref(fixedColumnsOnLeft).length || unref(fixedColumnsOnRight).length;
        });
        const columnsStyles = computed(() => {
          return unref(_columns).reduce((style, column) => {
            style[column.key] = calcColumnStyle(column, unref(fixed), props2.fixed);
            return style;
          }, {});
        });
        const columnsTotalWidth = computed(() => {
          return unref(visibleColumns).reduce((width, column) => width + column.width, 0);
        });
        const getColumn = (key) => {
          return unref(_columns).find((column) => column.key === key);
        };
        const getColumnStyle = (key) => {
          return unref(columnsStyles)[key];
        };
        const updateColumnWidth = (column, width) => {
          column.width = width;
        };
        function onColumnSorted(e) {
          var _a;
          const { key } = e.currentTarget.dataset;
          if (!key)
            return;
          const { sortState, sortBy: sortBy2 } = props2;
          let order = SortOrder.ASC;
          if (isObject$1(sortState)) {
            order = oppositeOrderMap[sortState[key]];
          } else {
            order = oppositeOrderMap[sortBy2.order];
          }
          (_a = props2.onColumnSort) == null ? void 0 : _a.call(props2, { column: getColumn(key), key, order });
        }
        return {
          columns: _columns,
          columnsStyles,
          columnsTotalWidth,
          fixedColumnsOnLeft,
          fixedColumnsOnRight,
          hasFixedColumns,
          mainColumns,
          normalColumns,
          visibleColumns,
          getColumn,
          getColumnStyle,
          updateColumnWidth,
          onColumnSorted
        };
      }
      const useScrollbar = (props2, {
        mainTableRef,
        leftTableRef,
        rightTableRef,
        onMaybeEndReached
      }) => {
        const scrollPos = ref({ scrollLeft: 0, scrollTop: 0 });
        function doScroll(params) {
          var _a, _b, _c;
          const { scrollTop } = params;
          (_a = mainTableRef.value) == null ? void 0 : _a.scrollTo(params);
          (_b = leftTableRef.value) == null ? void 0 : _b.scrollToTop(scrollTop);
          (_c = rightTableRef.value) == null ? void 0 : _c.scrollToTop(scrollTop);
        }
        function scrollTo(params) {
          scrollPos.value = params;
          doScroll(params);
        }
        function scrollToTop(scrollTop) {
          scrollPos.value.scrollTop = scrollTop;
          doScroll(unref(scrollPos));
        }
        function scrollToLeft(scrollLeft) {
          var _a, _b;
          scrollPos.value.scrollLeft = scrollLeft;
          (_b = (_a = mainTableRef.value) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, unref(scrollPos));
        }
        function onScroll(params) {
          var _a;
          scrollTo(params);
          (_a = props2.onScroll) == null ? void 0 : _a.call(props2, params);
        }
        function onVerticalScroll({ scrollTop }) {
          const { scrollTop: currentScrollTop } = unref(scrollPos);
          if (scrollTop !== currentScrollTop)
            scrollToTop(scrollTop);
        }
        function scrollToRow(row, strategy = "auto") {
          var _a;
          (_a = mainTableRef.value) == null ? void 0 : _a.scrollToRow(row, strategy);
        }
        watch(() => unref(scrollPos).scrollTop, (cur, prev) => {
          if (cur > prev)
            onMaybeEndReached();
        });
        return {
          scrollPos,
          scrollTo,
          scrollToLeft,
          scrollToTop,
          scrollToRow,
          onScroll,
          onVerticalScroll
        };
      };
      const useRow = (props2, {
        mainTableRef,
        leftTableRef,
        rightTableRef,
        tableInstance,
        ns,
        isScrolling
      }) => {
        const vm = getCurrentInstance();
        const { emit } = vm;
        const isResetting = shallowRef(false);
        const expandedRowKeys = ref(props2.defaultExpandedRowKeys || []);
        const lastRenderedRowIndex = ref(-1);
        const resetIndex = shallowRef(null);
        const rowHeights = ref({});
        const pendingRowHeights = ref({});
        const leftTableHeights = shallowRef({});
        const mainTableHeights = shallowRef({});
        const rightTableHeights = shallowRef({});
        const isDynamic = computed(() => isNumber(props2.estimatedRowHeight));
        function onRowsRendered(params) {
          var _a;
          (_a = props2.onRowsRendered) == null ? void 0 : _a.call(props2, params);
          if (params.rowCacheEnd > unref(lastRenderedRowIndex)) {
            lastRenderedRowIndex.value = params.rowCacheEnd;
          }
        }
        function onRowHovered({ hovered, rowKey: rowKey2 }) {
          if (isScrolling.value) {
            return;
          }
          const tableRoot = tableInstance.vnode.el;
          const rows = tableRoot.querySelectorAll(`[rowkey="${String(rowKey2)}"]`);
          rows.forEach((row) => {
            if (hovered) {
              row.classList.add(ns.is("hovered"));
            } else {
              row.classList.remove(ns.is("hovered"));
            }
          });
        }
        function onRowExpanded({
          expanded,
          rowData,
          rowIndex,
          rowKey: rowKey2
        }) {
          var _a, _b;
          const _expandedRowKeys = [...unref(expandedRowKeys)];
          const currentKeyIndex = _expandedRowKeys.indexOf(rowKey2);
          if (expanded) {
            if (currentKeyIndex === -1)
              _expandedRowKeys.push(rowKey2);
          } else {
            if (currentKeyIndex > -1)
              _expandedRowKeys.splice(currentKeyIndex, 1);
          }
          expandedRowKeys.value = _expandedRowKeys;
          emit("update:expandedRowKeys", _expandedRowKeys);
          (_a = props2.onRowExpand) == null ? void 0 : _a.call(props2, {
            expanded,
            rowData,
            rowIndex,
            rowKey: rowKey2
          });
          (_b = props2.onExpandedRowsChange) == null ? void 0 : _b.call(props2, _expandedRowKeys);
          const tableRoot = tableInstance.vnode.el;
          const hoverRow = tableRoot.querySelector(`.${ns.is("hovered")}[rowkey="${String(rowKey2)}"]`);
          if (hoverRow) {
            nextTick(() => onRowHovered({ hovered: true, rowKey: rowKey2 }));
          }
        }
        const flushingRowHeights = debounce(() => {
          var _a, _b, _c, _d;
          isResetting.value = true;
          rowHeights.value = { ...unref(rowHeights), ...unref(pendingRowHeights) };
          resetAfterIndex(unref(resetIndex), false);
          pendingRowHeights.value = {};
          resetIndex.value = null;
          (_a = mainTableRef.value) == null ? void 0 : _a.forceUpdate();
          (_b = leftTableRef.value) == null ? void 0 : _b.forceUpdate();
          (_c = rightTableRef.value) == null ? void 0 : _c.forceUpdate();
          (_d = vm.proxy) == null ? void 0 : _d.$forceUpdate();
          isResetting.value = false;
        }, 0);
        function resetAfterIndex(index2, forceUpdate = false) {
          if (!unref(isDynamic))
            return;
          [mainTableRef, leftTableRef, rightTableRef].forEach((tableRef) => {
            const table = unref(tableRef);
            if (table)
              table.resetAfterRowIndex(index2, forceUpdate);
          });
        }
        function resetHeights(rowKey2, height, rowIdx) {
          const resetIdx = unref(resetIndex);
          if (resetIdx === null) {
            resetIndex.value = rowIdx;
          } else {
            if (resetIdx > rowIdx) {
              resetIndex.value = rowIdx;
            }
          }
          pendingRowHeights.value[rowKey2] = height;
        }
        function onRowHeightChange({ rowKey: rowKey2, height, rowIndex }, fixedDir) {
          if (!fixedDir) {
            mainTableHeights.value[rowKey2] = height;
          } else {
            if (fixedDir === FixedDir.RIGHT) {
              rightTableHeights.value[rowKey2] = height;
            } else {
              leftTableHeights.value[rowKey2] = height;
            }
          }
          const maximumHeight = Math.max(...[leftTableHeights, rightTableHeights, mainTableHeights].map((records) => records.value[rowKey2] || 0));
          if (unref(rowHeights)[rowKey2] !== maximumHeight) {
            resetHeights(rowKey2, maximumHeight, rowIndex);
            flushingRowHeights();
          }
        }
        return {
          expandedRowKeys,
          lastRenderedRowIndex,
          isDynamic,
          isResetting,
          rowHeights,
          resetAfterIndex,
          onRowExpanded,
          onRowHovered,
          onRowsRendered,
          onRowHeightChange
        };
      };
      const useData = (props2, { expandedRowKeys, lastRenderedRowIndex, resetAfterIndex }) => {
        const depthMap = ref({});
        const flattenedData = computed(() => {
          const depths = {};
          const { data: data2, rowKey: rowKey2 } = props2;
          const _expandedRowKeys = unref(expandedRowKeys);
          if (!_expandedRowKeys || !_expandedRowKeys.length)
            return data2;
          const array3 = [];
          const keysSet = /* @__PURE__ */ new Set();
          _expandedRowKeys.forEach((x2) => keysSet.add(x2));
          let copy = data2.slice();
          copy.forEach((x2) => depths[x2[rowKey2]] = 0);
          while (copy.length > 0) {
            const item = copy.shift();
            array3.push(item);
            if (keysSet.has(item[rowKey2]) && isArray$1(item.children) && item.children.length > 0) {
              copy = [...item.children, ...copy];
              item.children.forEach((child) => depths[child[rowKey2]] = depths[item[rowKey2]] + 1);
            }
          }
          depthMap.value = depths;
          return array3;
        });
        const data = computed(() => {
          const { data: data2, expandColumnKey: expandColumnKey2 } = props2;
          return expandColumnKey2 ? unref(flattenedData) : data2;
        });
        watch(data, (val, prev) => {
          if (val !== prev) {
            lastRenderedRowIndex.value = -1;
            resetAfterIndex(0, true);
          }
        });
        return {
          data,
          depthMap
        };
      };
      const sumReducer = (sum2, num) => sum2 + num;
      const sum = (listLike) => {
        return isArray$1(listLike) ? listLike.reduce(sumReducer, 0) : listLike;
      };
      const tryCall = (fLike, params, defaultRet = {}) => {
        return isFunction$1(fLike) ? fLike(params) : fLike != null ? fLike : defaultRet;
      };
      const enforceUnit = (style) => {
        ["width", "maxWidth", "minWidth", "height"].forEach((key) => {
          style[key] = addUnit(style[key]);
        });
        return style;
      };
      const componentToSlot = (ComponentLike) => isVNode(ComponentLike) ? (props2) => h$1(ComponentLike, props2) : ComponentLike;
      const useStyles = (props2, {
        columnsTotalWidth,
        rowsHeight,
        fixedColumnsOnLeft,
        fixedColumnsOnRight
      }) => {
        const bodyWidth = computed(() => {
          const { fixed, width, vScrollbarSize } = props2;
          const ret = width - vScrollbarSize;
          return fixed ? Math.max(Math.round(unref(columnsTotalWidth)), ret) : ret;
        });
        const mainTableHeight = computed(() => {
          const { height = 0, maxHeight = 0, footerHeight: footerHeight2, hScrollbarSize } = props2;
          if (maxHeight > 0) {
            const _fixedRowsHeight = unref(fixedRowsHeight);
            const _rowsHeight = unref(rowsHeight);
            const _headerHeight = unref(headerHeight);
            const total2 = _headerHeight + _fixedRowsHeight + _rowsHeight + hScrollbarSize;
            return Math.min(total2, maxHeight - footerHeight2);
          }
          return height - footerHeight2;
        });
        const fixedTableHeight = computed(() => {
          const { maxHeight } = props2;
          const tableHeight = unref(mainTableHeight);
          if (isNumber(maxHeight) && maxHeight > 0)
            return tableHeight;
          const totalHeight = unref(rowsHeight) + unref(headerHeight) + unref(fixedRowsHeight);
          return Math.min(tableHeight, totalHeight);
        });
        const mapColumn = (column) => column.width;
        const leftTableWidth = computed(() => sum(unref(fixedColumnsOnLeft).map(mapColumn)));
        const rightTableWidth = computed(() => sum(unref(fixedColumnsOnRight).map(mapColumn)));
        const headerHeight = computed(() => sum(props2.headerHeight));
        const fixedRowsHeight = computed(() => {
          var _a;
          return (((_a = props2.fixedData) == null ? void 0 : _a.length) || 0) * props2.rowHeight;
        });
        const windowHeight = computed(() => {
          return unref(mainTableHeight) - unref(headerHeight) - unref(fixedRowsHeight);
        });
        const rootStyle = computed(() => {
          const { style = {}, height, width } = props2;
          return enforceUnit({
            ...style,
            height,
            width
          });
        });
        const footerHeight = computed(() => enforceUnit({ height: props2.footerHeight }));
        const emptyStyle = computed(() => ({
          top: addUnit(unref(headerHeight)),
          bottom: addUnit(props2.footerHeight),
          width: addUnit(props2.width)
        }));
        return {
          bodyWidth,
          fixedTableHeight,
          mainTableHeight,
          leftTableWidth,
          rightTableWidth,
          windowHeight,
          footerHeight,
          emptyStyle,
          rootStyle,
          headerHeight
        };
      };
      const useAutoResize = (props2) => {
        const sizer = ref();
        const width$ = ref(0);
        const height$ = ref(0);
        let resizerStopper;
        onMounted(() => {
          resizerStopper = useResizeObserver(sizer, ([entry]) => {
            const { width, height } = entry.contentRect;
            const { paddingLeft, paddingRight, paddingTop, paddingBottom } = getComputedStyle(entry.target);
            const left = Number.parseInt(paddingLeft) || 0;
            const right = Number.parseInt(paddingRight) || 0;
            const top = Number.parseInt(paddingTop) || 0;
            const bottom = Number.parseInt(paddingBottom) || 0;
            width$.value = width - left - right;
            height$.value = height - top - bottom;
          }).stop;
        });
        onBeforeUnmount(() => {
          resizerStopper == null ? void 0 : resizerStopper();
        });
        watch([width$, height$], ([width, height]) => {
          var _a;
          (_a = props2.onResize) == null ? void 0 : _a.call(props2, {
            width,
            height
          });
        });
        return {
          sizer,
          width: width$,
          height: height$
        };
      };
      function useTable(props2) {
        const mainTableRef = ref();
        const leftTableRef = ref();
        const rightTableRef = ref();
        const {
          columns: columns2,
          columnsStyles,
          columnsTotalWidth,
          fixedColumnsOnLeft,
          fixedColumnsOnRight,
          hasFixedColumns,
          mainColumns,
          onColumnSorted
        } = useColumns(props2, toRef(props2, "columns"), toRef(props2, "fixed"));
        const {
          scrollTo,
          scrollToLeft,
          scrollToTop,
          scrollToRow,
          onScroll,
          onVerticalScroll,
          scrollPos
        } = useScrollbar(props2, {
          mainTableRef,
          leftTableRef,
          rightTableRef,
          onMaybeEndReached
        });
        const ns = useNamespace("table-v2");
        const instance = getCurrentInstance();
        const isScrolling = shallowRef(false);
        const {
          expandedRowKeys,
          lastRenderedRowIndex,
          isDynamic,
          isResetting,
          rowHeights,
          resetAfterIndex,
          onRowExpanded,
          onRowHeightChange,
          onRowHovered,
          onRowsRendered
        } = useRow(props2, {
          mainTableRef,
          leftTableRef,
          rightTableRef,
          tableInstance: instance,
          ns,
          isScrolling
        });
        const { data, depthMap } = useData(props2, {
          expandedRowKeys,
          lastRenderedRowIndex,
          resetAfterIndex
        });
        const rowsHeight = computed(() => {
          const { estimatedRowHeight, rowHeight } = props2;
          const _data = unref(data);
          if (isNumber(estimatedRowHeight)) {
            return Object.values(unref(rowHeights)).reduce((acc, curr) => acc + curr, 0);
          }
          return _data.length * rowHeight;
        });
        const {
          bodyWidth,
          fixedTableHeight,
          mainTableHeight,
          leftTableWidth,
          rightTableWidth,
          windowHeight,
          footerHeight,
          emptyStyle,
          rootStyle,
          headerHeight
        } = useStyles(props2, {
          columnsTotalWidth,
          fixedColumnsOnLeft,
          fixedColumnsOnRight,
          rowsHeight
        });
        const containerRef = ref();
        const showEmpty = computed(() => {
          const noData = unref(data).length === 0;
          return isArray$1(props2.fixedData) ? props2.fixedData.length === 0 && noData : noData;
        });
        function getRowHeight(rowIndex) {
          const { estimatedRowHeight, rowHeight, rowKey: rowKey2 } = props2;
          if (!estimatedRowHeight)
            return rowHeight;
          return unref(rowHeights)[unref(data)[rowIndex][rowKey2]] || estimatedRowHeight;
        }
        const isEndReached = ref(false);
        function onMaybeEndReached() {
          const { onEndReached } = props2;
          if (!onEndReached)
            return;
          const { scrollTop } = unref(scrollPos);
          const _totalHeight = unref(rowsHeight);
          const clientHeight = unref(windowHeight);
          const remainDistance = _totalHeight - (scrollTop + clientHeight) + props2.hScrollbarSize;
          if (!isEndReached.value && unref(lastRenderedRowIndex) >= 0 && _totalHeight <= scrollTop + unref(mainTableHeight) - unref(headerHeight)) {
            isEndReached.value = true;
            onEndReached(remainDistance);
          } else {
            isEndReached.value = false;
          }
        }
        watch(() => unref(rowsHeight), () => isEndReached.value = false);
        watch(() => props2.expandedRowKeys, (val) => expandedRowKeys.value = val, {
          deep: true
        });
        return {
          columns: columns2,
          containerRef,
          mainTableRef,
          leftTableRef,
          rightTableRef,
          isDynamic,
          isResetting,
          isScrolling,
          hasFixedColumns,
          columnsStyles,
          columnsTotalWidth,
          data,
          expandedRowKeys,
          depthMap,
          fixedColumnsOnLeft,
          fixedColumnsOnRight,
          mainColumns,
          bodyWidth,
          emptyStyle,
          rootStyle,
          footerHeight,
          mainTableHeight,
          fixedTableHeight,
          leftTableWidth,
          rightTableWidth,
          showEmpty,
          getRowHeight,
          onColumnSorted,
          onRowHovered,
          onRowExpanded,
          onRowsRendered,
          onRowHeightChange,
          scrollTo,
          scrollToLeft,
          scrollToTop,
          scrollToRow,
          onScroll,
          onVerticalScroll
        };
      }
      const TableV2InjectionKey = Symbol("tableV2");
      const TABLE_V2_GRID_INJECTION_KEY = "tableV2GridScrollLeft";
      const classType = String;
      const columns = {
        type: definePropType(Array),
        required: true
      };
      const fixedDataType = {
        type: definePropType(Array)
      };
      const dataType = {
        ...fixedDataType,
        required: true
      };
      const expandColumnKey = String;
      const expandKeys = {
        type: definePropType(Array),
        default: () => mutable([])
      };
      const requiredNumber = {
        type: Number,
        required: true
      };
      const rowKey = {
        type: definePropType([String, Number, Symbol]),
        default: "id"
      };
      const styleType = {
        type: definePropType(Object)
      };
      const tableV2RowProps = exports("tableV2RowProps", buildProps({
        class: String,
        columns,
        columnsStyles: {
          type: definePropType(Object),
          required: true
        },
        depth: Number,
        expandColumnKey,
        estimatedRowHeight: {
          ...virtualizedGridProps.estimatedRowHeight,
          default: void 0
        },
        isScrolling: Boolean,
        onRowExpand: {
          type: definePropType(Function)
        },
        onRowHover: {
          type: definePropType(Function)
        },
        onRowHeightChange: {
          type: definePropType(Function)
        },
        rowData: {
          type: definePropType(Object),
          required: true
        },
        rowEventHandlers: {
          type: definePropType(Object)
        },
        rowIndex: {
          type: Number,
          required: true
        },
        rowKey,
        style: {
          type: definePropType(Object)
        }
      }));
      const requiredNumberType = {
        type: Number,
        required: true
      };
      const tableV2HeaderProps = buildProps({
        class: String,
        columns,
        fixedHeaderData: {
          type: definePropType(Array)
        },
        headerData: {
          type: definePropType(Array),
          required: true
        },
        headerHeight: {
          type: definePropType([Number, Array]),
          default: 50
        },
        rowWidth: requiredNumberType,
        rowHeight: {
          type: Number,
          default: 50
        },
        height: requiredNumberType,
        width: requiredNumberType
      });
      const tableV2GridProps = buildProps({
        columns,
        data: dataType,
        fixedData: fixedDataType,
        estimatedRowHeight: tableV2RowProps.estimatedRowHeight,
        width: requiredNumber,
        height: requiredNumber,
        headerWidth: requiredNumber,
        headerHeight: tableV2HeaderProps.headerHeight,
        bodyWidth: requiredNumber,
        rowHeight: requiredNumber,
        cache: virtualizedListProps.cache,
        useIsScrolling: Boolean,
        scrollbarAlwaysOn: virtualizedGridProps.scrollbarAlwaysOn,
        scrollbarStartGap: virtualizedGridProps.scrollbarStartGap,
        scrollbarEndGap: virtualizedGridProps.scrollbarEndGap,
        class: classType,
        style: styleType,
        containerStyle: styleType,
        getRowHeight: {
          type: definePropType(Function),
          required: true
        },
        rowKey: tableV2RowProps.rowKey,
        onRowsRendered: {
          type: definePropType(Function)
        },
        onScroll: {
          type: definePropType(Function)
        }
      });
      const tableV2Props = exports("tableV2Props", buildProps({
        cache: tableV2GridProps.cache,
        estimatedRowHeight: tableV2RowProps.estimatedRowHeight,
        rowKey,
        headerClass: {
          type: definePropType([
            String,
            Function
          ])
        },
        headerProps: {
          type: definePropType([
            Object,
            Function
          ])
        },
        headerCellProps: {
          type: definePropType([
            Object,
            Function
          ])
        },
        headerHeight: tableV2HeaderProps.headerHeight,
        footerHeight: {
          type: Number,
          default: 0
        },
        rowClass: {
          type: definePropType([String, Function])
        },
        rowProps: {
          type: definePropType([Object, Function])
        },
        rowHeight: {
          type: Number,
          default: 50
        },
        cellProps: {
          type: definePropType([
            Object,
            Function
          ])
        },
        columns,
        data: dataType,
        dataGetter: {
          type: definePropType(Function)
        },
        fixedData: fixedDataType,
        expandColumnKey: tableV2RowProps.expandColumnKey,
        expandedRowKeys: expandKeys,
        defaultExpandedRowKeys: expandKeys,
        class: classType,
        fixed: Boolean,
        style: {
          type: definePropType(Object)
        },
        width: requiredNumber,
        height: requiredNumber,
        maxHeight: Number,
        useIsScrolling: Boolean,
        indentSize: {
          type: Number,
          default: 12
        },
        iconSize: {
          type: Number,
          default: 12
        },
        hScrollbarSize: virtualizedGridProps.hScrollbarSize,
        vScrollbarSize: virtualizedGridProps.vScrollbarSize,
        scrollbarAlwaysOn: virtualizedScrollbarProps.alwaysOn,
        sortBy: {
          type: definePropType(Object),
          default: () => ({})
        },
        sortState: {
          type: definePropType(Object),
          default: void 0
        },
        onColumnSort: {
          type: definePropType(Function)
        },
        onExpandedRowsChange: {
          type: definePropType(Function)
        },
        onEndReached: {
          type: definePropType(Function)
        },
        onRowExpand: tableV2RowProps.onRowExpand,
        onScroll: tableV2GridProps.onScroll,
        onRowsRendered: tableV2GridProps.onRowsRendered,
        rowEventHandlers: tableV2RowProps.rowEventHandlers
      }));
      const TableV2Cell = (props2, {
        slots
      }) => {
        var _a;
        const {
          cellData,
          style
        } = props2;
        const displayText = ((_a = cellData == null ? void 0 : cellData.toString) == null ? void 0 : _a.call(cellData)) || "";
        const defaultSlot = renderSlot(slots, "default", props2, () => [displayText]);
        return createVNode("div", {
          "class": props2.class,
          "title": displayText,
          "style": style
        }, [defaultSlot]);
      };
      TableV2Cell.displayName = "ElTableV2Cell";
      TableV2Cell.inheritAttrs = false;
      var TableCell = TableV2Cell;
      const HeaderCell = (props2, {
        slots
      }) => renderSlot(slots, "default", props2, () => {
        var _a, _b;
        return [createVNode("div", {
          "class": props2.class,
          "title": (_a = props2.column) == null ? void 0 : _a.title
        }, [(_b = props2.column) == null ? void 0 : _b.title])];
      });
      HeaderCell.displayName = "ElTableV2HeaderCell";
      HeaderCell.inheritAttrs = false;
      var HeaderCell$1 = HeaderCell;
      const tableV2HeaderRowProps = buildProps({
        class: String,
        columns,
        columnsStyles: {
          type: definePropType(Object),
          required: true
        },
        headerIndex: Number,
        style: { type: definePropType(Object) }
      });
      const TableV2HeaderRow = defineComponent({
        name: "ElTableV2HeaderRow",
        props: tableV2HeaderRowProps,
        setup(props2, {
          slots
        }) {
          return () => {
            const {
              columns: columns2,
              columnsStyles,
              headerIndex,
              style
            } = props2;
            let Cells = columns2.map((column, columnIndex) => {
              return slots.cell({
                columns: columns2,
                column,
                columnIndex,
                headerIndex,
                style: columnsStyles[column.key]
              });
            });
            if (slots.header) {
              Cells = slots.header({
                cells: Cells.map((node) => {
                  if (isArray$1(node) && node.length === 1) {
                    return node[0];
                  }
                  return node;
                }),
                columns: columns2,
                headerIndex
              });
            }
            return createVNode("div", {
              "class": props2.class,
              "style": style,
              "role": "row"
            }, [Cells]);
          };
        }
      });
      var HeaderRow = TableV2HeaderRow;
      const COMPONENT_NAME$8 = "ElTableV2Header";
      const TableV2Header = defineComponent({
        name: COMPONENT_NAME$8,
        props: tableV2HeaderProps,
        setup(props2, {
          slots,
          expose
        }) {
          const ns = useNamespace("table-v2");
          const scrollLeftInfo = inject(TABLE_V2_GRID_INJECTION_KEY);
          const headerRef = ref();
          const headerStyle = computed(() => enforceUnit({
            width: props2.width,
            height: props2.height
          }));
          const rowStyle = computed(() => enforceUnit({
            width: props2.rowWidth,
            height: props2.height
          }));
          const headerHeights = computed(() => castArray$1(unref(props2.headerHeight)));
          const scrollToLeft = (left) => {
            const headerEl = unref(headerRef);
            nextTick(() => {
              (headerEl == null ? void 0 : headerEl.scroll) && headerEl.scroll({
                left
              });
            });
          };
          const renderFixedRows = () => {
            const fixedRowClassName = ns.e("fixed-header-row");
            const {
              columns: columns2,
              fixedHeaderData,
              rowHeight
            } = props2;
            return fixedHeaderData == null ? void 0 : fixedHeaderData.map((fixedRowData, fixedRowIndex) => {
              var _a;
              const style = enforceUnit({
                height: rowHeight,
                width: "100%"
              });
              return (_a = slots.fixed) == null ? void 0 : _a.call(slots, {
                class: fixedRowClassName,
                columns: columns2,
                rowData: fixedRowData,
                rowIndex: -(fixedRowIndex + 1),
                style
              });
            });
          };
          const renderDynamicRows = () => {
            const dynamicRowClassName = ns.e("dynamic-header-row");
            const {
              columns: columns2
            } = props2;
            return unref(headerHeights).map((rowHeight, rowIndex) => {
              var _a;
              const style = enforceUnit({
                width: "100%",
                height: rowHeight
              });
              return (_a = slots.dynamic) == null ? void 0 : _a.call(slots, {
                class: dynamicRowClassName,
                columns: columns2,
                headerIndex: rowIndex,
                style
              });
            });
          };
          onUpdated(() => {
            if (scrollLeftInfo == null ? void 0 : scrollLeftInfo.value) {
              scrollToLeft(scrollLeftInfo.value);
            }
          });
          expose({
            scrollToLeft
          });
          return () => {
            if (props2.height <= 0)
              return;
            return createVNode("div", {
              "ref": headerRef,
              "class": props2.class,
              "style": unref(headerStyle),
              "role": "rowgroup"
            }, [createVNode("div", {
              "style": unref(rowStyle),
              "class": ns.e("header")
            }, [renderDynamicRows(), renderFixedRows()])]);
          };
        }
      });
      var Header = TableV2Header;
      const useTableRow = (props2) => {
        const {
          isScrolling
        } = inject(TableV2InjectionKey);
        const measured = ref(false);
        const rowRef = ref();
        const measurable = computed(() => {
          return isNumber(props2.estimatedRowHeight) && props2.rowIndex >= 0;
        });
        const doMeasure = (isInit = false) => {
          const $rowRef = unref(rowRef);
          if (!$rowRef)
            return;
          const {
            columns: columns2,
            onRowHeightChange,
            rowKey: rowKey2,
            rowIndex,
            style
          } = props2;
          const {
            height
          } = $rowRef.getBoundingClientRect();
          measured.value = true;
          nextTick(() => {
            if (isInit || height !== Number.parseInt(style.height)) {
              const firstColumn = columns2[0];
              const isPlaceholder = (firstColumn == null ? void 0 : firstColumn.placeholderSign) === placeholderSign;
              onRowHeightChange == null ? void 0 : onRowHeightChange({
                rowKey: rowKey2,
                height,
                rowIndex
              }, firstColumn && !isPlaceholder && firstColumn.fixed);
            }
          });
        };
        const eventHandlers = computed(() => {
          const {
            rowData,
            rowIndex,
            rowKey: rowKey2,
            onRowHover
          } = props2;
          const handlers = props2.rowEventHandlers || {};
          const eventHandlers2 = {};
          Object.entries(handlers).forEach(([eventName, handler]) => {
            if (isFunction$1(handler)) {
              eventHandlers2[eventName] = (event) => {
                handler({
                  event,
                  rowData,
                  rowIndex,
                  rowKey: rowKey2
                });
              };
            }
          });
          if (onRowHover) {
            [{
              name: "onMouseleave",
              hovered: false
            }, {
              name: "onMouseenter",
              hovered: true
            }].forEach(({
              name,
              hovered
            }) => {
              const existedHandler = eventHandlers2[name];
              eventHandlers2[name] = (event) => {
                onRowHover({
                  event,
                  hovered,
                  rowData,
                  rowIndex,
                  rowKey: rowKey2
                });
                existedHandler == null ? void 0 : existedHandler(event);
              };
            });
          }
          return eventHandlers2;
        });
        const onExpand = (expanded) => {
          const {
            onRowExpand,
            rowData,
            rowIndex,
            rowKey: rowKey2
          } = props2;
          onRowExpand == null ? void 0 : onRowExpand({
            expanded,
            rowData,
            rowIndex,
            rowKey: rowKey2
          });
        };
        onMounted(() => {
          if (unref(measurable)) {
            doMeasure(true);
          }
        });
        return {
          isScrolling,
          measurable,
          measured,
          rowRef,
          eventHandlers,
          onExpand
        };
      };
      const COMPONENT_NAME$7 = "ElTableV2TableRow";
      const TableV2Row = defineComponent({
        name: COMPONENT_NAME$7,
        props: tableV2RowProps,
        setup(props2, {
          expose,
          slots,
          attrs
        }) {
          const {
            eventHandlers,
            isScrolling,
            measurable,
            measured,
            rowRef,
            onExpand
          } = useTableRow(props2);
          expose({
            onExpand
          });
          return () => {
            const {
              columns: columns2,
              columnsStyles,
              expandColumnKey: expandColumnKey2,
              depth,
              rowData,
              rowIndex,
              style
            } = props2;
            let ColumnCells = columns2.map((column, columnIndex) => {
              const expandable = isArray$1(rowData.children) && rowData.children.length > 0 && column.key === expandColumnKey2;
              return slots.cell({
                column,
                columns: columns2,
                columnIndex,
                depth,
                style: columnsStyles[column.key],
                rowData,
                rowIndex,
                isScrolling: unref(isScrolling),
                expandIconProps: expandable ? {
                  rowData,
                  rowIndex,
                  onExpand
                } : void 0
              });
            });
            if (slots.row) {
              ColumnCells = slots.row({
                cells: ColumnCells.map((node) => {
                  if (isArray$1(node) && node.length === 1) {
                    return node[0];
                  }
                  return node;
                }),
                style,
                columns: columns2,
                depth,
                rowData,
                rowIndex,
                isScrolling: unref(isScrolling)
              });
            }
            if (unref(measurable)) {
              const {
                height,
                ...exceptHeightStyle
              } = style || {};
              const _measured = unref(measured);
              return createVNode("div", mergeProps({
                "ref": rowRef,
                "class": props2.class,
                "style": _measured ? style : exceptHeightStyle,
                "role": "row"
              }, attrs, unref(eventHandlers)), [ColumnCells]);
            }
            return createVNode("div", mergeProps(attrs, {
              "ref": rowRef,
              "class": props2.class,
              "style": style,
              "role": "row"
            }, unref(eventHandlers)), [ColumnCells]);
          };
        }
      });
      var Row = TableV2Row;
      const SortIcon = (props2) => {
        const {
          sortOrder
        } = props2;
        return createVNode(ElIcon, {
          "size": 14,
          "class": props2.class
        }, {
          default: () => [sortOrder === SortOrder.ASC ? createVNode(sort_up_default$1, null, null) : createVNode(sort_down_default$1, null, null)]
        });
      };
      var SortIcon$1 = SortIcon;
      const ExpandIcon = (props2) => {
        const {
          expanded,
          expandable,
          onExpand,
          style,
          size
        } = props2;
        const expandIconProps = {
          onClick: expandable ? () => onExpand(!expanded) : void 0,
          class: props2.class
        };
        return createVNode(ElIcon, mergeProps(expandIconProps, {
          "size": size,
          "style": style
        }), {
          default: () => [createVNode(arrow_right_default$1, null, null)]
        });
      };
      var ExpandIcon$1 = ExpandIcon;
      const COMPONENT_NAME$6 = "ElTableV2Grid";
      const useTableGrid = (props2) => {
        const headerRef = ref();
        const bodyRef = ref();
        const scrollLeft = ref(0);
        const totalHeight = computed(() => {
          const {
            data,
            rowHeight,
            estimatedRowHeight
          } = props2;
          if (estimatedRowHeight) {
            return;
          }
          return data.length * rowHeight;
        });
        const fixedRowHeight = computed(() => {
          const {
            fixedData,
            rowHeight
          } = props2;
          return ((fixedData == null ? void 0 : fixedData.length) || 0) * rowHeight;
        });
        const headerHeight = computed(() => sum(props2.headerHeight));
        const gridHeight = computed(() => {
          const {
            height
          } = props2;
          return Math.max(0, height - unref(headerHeight) - unref(fixedRowHeight));
        });
        const hasHeader = computed(() => {
          return unref(headerHeight) + unref(fixedRowHeight) > 0;
        });
        const itemKey = ({
          data,
          rowIndex
        }) => data[rowIndex][props2.rowKey];
        function onItemRendered({
          rowCacheStart,
          rowCacheEnd,
          rowVisibleStart,
          rowVisibleEnd
        }) {
          var _a;
          (_a = props2.onRowsRendered) == null ? void 0 : _a.call(props2, {
            rowCacheStart,
            rowCacheEnd,
            rowVisibleStart,
            rowVisibleEnd
          });
        }
        function resetAfterRowIndex(index2, forceUpdate2) {
          var _a;
          (_a = bodyRef.value) == null ? void 0 : _a.resetAfterRowIndex(index2, forceUpdate2);
        }
        function scrollTo(leftOrOptions, top) {
          const header$ = unref(headerRef);
          const body$ = unref(bodyRef);
          if (isObject$1(leftOrOptions)) {
            header$ == null ? void 0 : header$.scrollToLeft(leftOrOptions.scrollLeft);
            scrollLeft.value = leftOrOptions.scrollLeft;
            body$ == null ? void 0 : body$.scrollTo(leftOrOptions);
          } else {
            header$ == null ? void 0 : header$.scrollToLeft(leftOrOptions);
            scrollLeft.value = leftOrOptions;
            body$ == null ? void 0 : body$.scrollTo({
              scrollLeft: leftOrOptions,
              scrollTop: top
            });
          }
        }
        function scrollToTop(scrollTop) {
          var _a;
          (_a = unref(bodyRef)) == null ? void 0 : _a.scrollTo({
            scrollTop
          });
        }
        function scrollToRow(row, strategy) {
          var _a;
          (_a = unref(bodyRef)) == null ? void 0 : _a.scrollToItem(row, 1, strategy);
        }
        function forceUpdate() {
          var _a, _b;
          (_a = unref(bodyRef)) == null ? void 0 : _a.$forceUpdate();
          (_b = unref(headerRef)) == null ? void 0 : _b.$forceUpdate();
        }
        watch(() => props2.bodyWidth, () => {
          var _a;
          if (isNumber(props2.estimatedRowHeight))
            (_a = bodyRef.value) == null ? void 0 : _a.resetAfter({
              columnIndex: 0
            }, false);
        });
        return {
          bodyRef,
          forceUpdate,
          fixedRowHeight,
          gridHeight,
          hasHeader,
          headerHeight,
          headerRef,
          totalHeight,
          itemKey,
          onItemRendered,
          resetAfterRowIndex,
          scrollTo,
          scrollToTop,
          scrollToRow,
          scrollLeft
        };
      };
      const TableGrid = defineComponent({
        name: COMPONENT_NAME$6,
        props: tableV2GridProps,
        setup(props2, {
          slots,
          expose
        }) {
          const {
            ns
          } = inject(TableV2InjectionKey);
          const {
            bodyRef,
            fixedRowHeight,
            gridHeight,
            hasHeader,
            headerRef,
            headerHeight,
            totalHeight,
            forceUpdate,
            itemKey,
            onItemRendered,
            resetAfterRowIndex,
            scrollTo,
            scrollToTop,
            scrollToRow,
            scrollLeft
          } = useTableGrid(props2);
          provide(TABLE_V2_GRID_INJECTION_KEY, scrollLeft);
          onActivated(async () => {
            var _a;
            await nextTick();
            const scrollTop = (_a = bodyRef.value) == null ? void 0 : _a.states.scrollTop;
            scrollTop && scrollToTop(Math.round(scrollTop) + 1);
          });
          expose({
            forceUpdate,
            totalHeight,
            scrollTo,
            scrollToTop,
            scrollToRow,
            resetAfterRowIndex
          });
          const getColumnWidth = () => props2.bodyWidth;
          return () => {
            const {
              cache: cache2,
              columns: columns2,
              data,
              fixedData,
              useIsScrolling,
              scrollbarAlwaysOn,
              scrollbarEndGap,
              scrollbarStartGap,
              style,
              rowHeight,
              bodyWidth,
              estimatedRowHeight,
              headerWidth,
              height,
              width,
              getRowHeight,
              onScroll
            } = props2;
            const isDynamicRowEnabled = isNumber(estimatedRowHeight);
            const Grid = isDynamicRowEnabled ? DynamicSizeGrid$1 : FixedSizeGrid$1;
            const _headerHeight = unref(headerHeight);
            return createVNode("div", {
              "role": "table",
              "class": [ns.e("table"), props2.class],
              "style": style
            }, [createVNode(Grid, {
              "ref": bodyRef,
              "data": data,
              "useIsScrolling": useIsScrolling,
              "itemKey": itemKey,
              "columnCache": 0,
              "columnWidth": isDynamicRowEnabled ? getColumnWidth : bodyWidth,
              "totalColumn": 1,
              "totalRow": data.length,
              "rowCache": cache2,
              "rowHeight": isDynamicRowEnabled ? getRowHeight : rowHeight,
              "width": width,
              "height": unref(gridHeight),
              "class": ns.e("body"),
              "role": "rowgroup",
              "scrollbarStartGap": scrollbarStartGap,
              "scrollbarEndGap": scrollbarEndGap,
              "scrollbarAlwaysOn": scrollbarAlwaysOn,
              "onScroll": onScroll,
              "onItemRendered": onItemRendered,
              "perfMode": false
            }, {
              default: (params) => {
                var _a;
                const rowData = data[params.rowIndex];
                return (_a = slots.row) == null ? void 0 : _a.call(slots, {
                  ...params,
                  columns: columns2,
                  rowData
                });
              }
            }), unref(hasHeader) && createVNode(Header, {
              "ref": headerRef,
              "class": ns.e("header-wrapper"),
              "columns": columns2,
              "headerData": data,
              "headerHeight": props2.headerHeight,
              "fixedHeaderData": fixedData,
              "rowWidth": headerWidth,
              "rowHeight": rowHeight,
              "width": width,
              "height": Math.min(_headerHeight + unref(fixedRowHeight), height)
            }, {
              dynamic: slots.header,
              fixed: slots.row
            })]);
          };
        }
      });
      function _isSlot$5(s2) {
        return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
      }
      const MainTable = (props2, {
        slots
      }) => {
        const {
          mainTableRef,
          ...rest2
        } = props2;
        return createVNode(TableGrid, mergeProps({
          "ref": mainTableRef
        }, rest2), _isSlot$5(slots) ? slots : {
          default: () => [slots]
        });
      };
      function _isSlot$4(s2) {
        return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
      }
      const LeftTable$1 = (props2, {
        slots
      }) => {
        if (!props2.columns.length)
          return;
        const {
          leftTableRef,
          ...rest2
        } = props2;
        return createVNode(TableGrid, mergeProps({
          "ref": leftTableRef
        }, rest2), _isSlot$4(slots) ? slots : {
          default: () => [slots]
        });
      };
      function _isSlot$3(s2) {
        return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
      }
      const LeftTable = (props2, {
        slots
      }) => {
        if (!props2.columns.length)
          return;
        const {
          rightTableRef,
          ...rest2
        } = props2;
        return createVNode(TableGrid, mergeProps({
          "ref": rightTableRef
        }, rest2), _isSlot$3(slots) ? slots : {
          default: () => [slots]
        });
      };
      function _isSlot$2(s2) {
        return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
      }
      const RowRenderer = (props2, {
        slots
      }) => {
        const {
          columns: columns2,
          columnsStyles,
          depthMap,
          expandColumnKey: expandColumnKey2,
          expandedRowKeys,
          estimatedRowHeight,
          hasFixedColumns,
          rowData,
          rowIndex,
          style,
          isScrolling,
          rowProps: rowProps2,
          rowClass,
          rowKey: rowKey2,
          rowEventHandlers,
          ns,
          onRowHovered,
          onRowExpanded
        } = props2;
        const rowKls = tryCall(rowClass, {
          columns: columns2,
          rowData,
          rowIndex
        }, "");
        const additionalProps = tryCall(rowProps2, {
          columns: columns2,
          rowData,
          rowIndex
        });
        const _rowKey = rowData[rowKey2];
        const depth = depthMap[_rowKey] || 0;
        const canExpand = Boolean(expandColumnKey2);
        const isFixedRow = rowIndex < 0;
        const kls = [ns.e("row"), rowKls, {
          [ns.e(`row-depth-${depth}`)]: canExpand && rowIndex >= 0,
          [ns.is("expanded")]: canExpand && expandedRowKeys.includes(_rowKey),
          [ns.is("fixed")]: !depth && isFixedRow,
          [ns.is("customized")]: Boolean(slots.row)
        }];
        const onRowHover = hasFixedColumns ? onRowHovered : void 0;
        const _rowProps = {
          ...additionalProps,
          columns: columns2,
          columnsStyles,
          class: kls,
          depth,
          expandColumnKey: expandColumnKey2,
          estimatedRowHeight: isFixedRow ? void 0 : estimatedRowHeight,
          isScrolling,
          rowIndex,
          rowData,
          rowKey: _rowKey,
          rowEventHandlers,
          style
        };
        const handlerMouseEnter = (e) => {
          onRowHover == null ? void 0 : onRowHover({
            hovered: true,
            rowKey: _rowKey,
            event: e,
            rowData,
            rowIndex
          });
        };
        const handlerMouseLeave = (e) => {
          onRowHover == null ? void 0 : onRowHover({
            hovered: false,
            rowKey: _rowKey,
            event: e,
            rowData,
            rowIndex
          });
        };
        return createVNode(Row, mergeProps(_rowProps, {
          "onRowExpand": onRowExpanded,
          "onMouseenter": handlerMouseEnter,
          "onMouseleave": handlerMouseLeave,
          "rowkey": _rowKey
        }), _isSlot$2(slots) ? slots : {
          default: () => [slots]
        });
      };
      const CellRenderer = ({
        columns: columns2,
        column,
        columnIndex,
        depth,
        expandIconProps,
        isScrolling,
        rowData,
        rowIndex,
        style,
        expandedRowKeys,
        ns,
        cellProps: _cellProps,
        expandColumnKey: expandColumnKey2,
        indentSize,
        iconSize,
        rowKey: rowKey2
      }, {
        slots
      }) => {
        const cellStyle = enforceUnit(style);
        if (column.placeholderSign === placeholderSign) {
          return createVNode("div", {
            "class": ns.em("row-cell", "placeholder"),
            "style": cellStyle
          }, null);
        }
        const {
          cellRenderer,
          dataKey,
          dataGetter
        } = column;
        const cellData = isFunction$1(dataGetter) ? dataGetter({
          columns: columns2,
          column,
          columnIndex,
          rowData,
          rowIndex
        }) : get(rowData, dataKey != null ? dataKey : "");
        const extraCellProps = tryCall(_cellProps, {
          cellData,
          columns: columns2,
          column,
          columnIndex,
          rowIndex,
          rowData
        });
        const cellProps = {
          class: ns.e("cell-text"),
          columns: columns2,
          column,
          columnIndex,
          cellData,
          isScrolling,
          rowData,
          rowIndex
        };
        const columnCellRenderer = componentToSlot(cellRenderer);
        const Cell = columnCellRenderer ? columnCellRenderer(cellProps) : renderSlot(slots, "default", cellProps, () => [createVNode(TableCell, cellProps, null)]);
        const kls = [ns.e("row-cell"), column.class, column.align === Alignment.CENTER && ns.is("align-center"), column.align === Alignment.RIGHT && ns.is("align-right")];
        const expandable = rowIndex >= 0 && expandColumnKey2 && column.key === expandColumnKey2;
        const expanded = rowIndex >= 0 && expandedRowKeys.includes(rowData[rowKey2]);
        let IconOrPlaceholder;
        const iconStyle = `margin-inline-start: ${depth * indentSize}px;`;
        if (expandable) {
          if (isObject$1(expandIconProps)) {
            IconOrPlaceholder = createVNode(ExpandIcon$1, mergeProps(expandIconProps, {
              "class": [ns.e("expand-icon"), ns.is("expanded", expanded)],
              "size": iconSize,
              "expanded": expanded,
              "style": iconStyle,
              "expandable": true
            }), null);
          } else {
            IconOrPlaceholder = createVNode("div", {
              "style": [iconStyle, `width: ${iconSize}px; height: ${iconSize}px;`].join(" ")
            }, null);
          }
        }
        return createVNode("div", mergeProps({
          "class": kls,
          "style": cellStyle
        }, extraCellProps, {
          "role": "cell"
        }), [IconOrPlaceholder, Cell]);
      };
      CellRenderer.inheritAttrs = false;
      function _isSlot$1(s2) {
        return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
      }
      const HeaderRenderer = ({
        columns: columns2,
        columnsStyles,
        headerIndex,
        style,
        headerClass,
        headerProps,
        ns
      }, {
        slots
      }) => {
        const param = {
          columns: columns2,
          headerIndex
        };
        const kls = [ns.e("header-row"), tryCall(headerClass, param, ""), {
          [ns.is("customized")]: Boolean(slots.header)
        }];
        const extraProps = {
          ...tryCall(headerProps, param),
          columnsStyles,
          class: kls,
          columns: columns2,
          headerIndex,
          style
        };
        return createVNode(HeaderRow, extraProps, _isSlot$1(slots) ? slots : {
          default: () => [slots]
        });
      };
      const HeaderCellRenderer = (props2, {
        slots
      }) => {
        const {
          column,
          ns,
          style,
          onColumnSorted
        } = props2;
        const cellStyle = enforceUnit(style);
        if (column.placeholderSign === placeholderSign) {
          return createVNode("div", {
            "class": ns.em("header-row-cell", "placeholder"),
            "style": cellStyle
          }, null);
        }
        const {
          headerCellRenderer,
          headerClass,
          sortable
        } = column;
        const cellProps = {
          ...props2,
          class: ns.e("header-cell-text")
        };
        const columnCellRenderer = componentToSlot(headerCellRenderer);
        const Cell = columnCellRenderer ? columnCellRenderer(cellProps) : renderSlot(slots, "default", cellProps, () => [createVNode(HeaderCell$1, cellProps, null)]);
        const {
          sortBy: sortBy2,
          sortState,
          headerCellProps
        } = props2;
        let sorting, sortOrder;
        if (sortState) {
          const order = sortState[column.key];
          sorting = Boolean(oppositeOrderMap[order]);
          sortOrder = sorting ? order : SortOrder.ASC;
        } else {
          sorting = column.key === sortBy2.key;
          sortOrder = sorting ? sortBy2.order : SortOrder.ASC;
        }
        const cellKls = [ns.e("header-cell"), tryCall(headerClass, props2, ""), column.align === Alignment.CENTER && ns.is("align-center"), column.align === Alignment.RIGHT && ns.is("align-right"), sortable && ns.is("sortable")];
        const cellWrapperProps = {
          ...tryCall(headerCellProps, props2),
          onClick: column.sortable ? onColumnSorted : void 0,
          class: cellKls,
          style: cellStyle,
          ["data-key"]: column.key
        };
        return createVNode("div", mergeProps(cellWrapperProps, {
          "role": "columnheader"
        }), [Cell, sortable && createVNode(SortIcon$1, {
          "class": [ns.e("sort-icon"), sorting && ns.is("sorting")],
          "sortOrder": sortOrder
        }, null)]);
      };
      const Footer$1 = (props2, {
        slots
      }) => {
        var _a;
        return createVNode("div", {
          "class": props2.class,
          "style": props2.style
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
      Footer$1.displayName = "ElTableV2Footer";
      const Footer = (props2, {
        slots
      }) => {
        const defaultSlot = renderSlot(slots, "default", {}, () => [createVNode(ElEmpty, null, null)]);
        return createVNode("div", {
          "class": props2.class,
          "style": props2.style
        }, [defaultSlot]);
      };
      Footer.displayName = "ElTableV2Empty";
      const Overlay = (props2, {
        slots
      }) => {
        var _a;
        return createVNode("div", {
          "class": props2.class,
          "style": props2.style
        }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
      };
      Overlay.displayName = "ElTableV2Overlay";
      function _isSlot(s2) {
        return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
      }
      const COMPONENT_NAME$5 = "ElTableV2";
      const TableV2 = defineComponent({
        name: COMPONENT_NAME$5,
        props: tableV2Props,
        setup(props2, {
          slots,
          expose
        }) {
          const ns = useNamespace("table-v2");
          const {
            columnsStyles,
            fixedColumnsOnLeft,
            fixedColumnsOnRight,
            mainColumns,
            mainTableHeight,
            fixedTableHeight,
            leftTableWidth,
            rightTableWidth,
            data,
            depthMap,
            expandedRowKeys,
            hasFixedColumns,
            mainTableRef,
            leftTableRef,
            rightTableRef,
            isDynamic,
            isResetting,
            isScrolling,
            bodyWidth,
            emptyStyle,
            rootStyle,
            footerHeight,
            showEmpty,
            scrollTo,
            scrollToLeft,
            scrollToTop,
            scrollToRow,
            getRowHeight,
            onColumnSorted,
            onRowHeightChange,
            onRowHovered,
            onRowExpanded,
            onRowsRendered,
            onScroll,
            onVerticalScroll
          } = useTable(props2);
          expose({
            scrollTo,
            scrollToLeft,
            scrollToTop,
            scrollToRow
          });
          provide(TableV2InjectionKey, {
            ns,
            isResetting,
            isScrolling
          });
          return () => {
            const {
              cache: cache2,
              cellProps,
              estimatedRowHeight,
              expandColumnKey: expandColumnKey2,
              fixedData,
              headerHeight,
              headerClass,
              headerProps,
              headerCellProps,
              sortBy: sortBy2,
              sortState,
              rowHeight,
              rowClass,
              rowEventHandlers,
              rowKey: rowKey2,
              rowProps: rowProps2,
              scrollbarAlwaysOn,
              indentSize,
              iconSize,
              useIsScrolling,
              vScrollbarSize,
              width
            } = props2;
            const _data = unref(data);
            const mainTableProps = {
              cache: cache2,
              class: ns.e("main"),
              columns: unref(mainColumns),
              data: _data,
              fixedData,
              estimatedRowHeight,
              bodyWidth: unref(bodyWidth),
              headerHeight,
              headerWidth: unref(bodyWidth),
              height: unref(mainTableHeight),
              mainTableRef,
              rowKey: rowKey2,
              rowHeight,
              scrollbarAlwaysOn,
              scrollbarStartGap: 2,
              scrollbarEndGap: vScrollbarSize,
              useIsScrolling,
              width,
              getRowHeight,
              onRowsRendered,
              onScroll
            };
            const leftColumnsWidth = unref(leftTableWidth);
            const _fixedTableHeight = unref(fixedTableHeight);
            const leftTableProps = {
              cache: cache2,
              class: ns.e("left"),
              columns: unref(fixedColumnsOnLeft),
              data: _data,
              fixedData,
              estimatedRowHeight,
              leftTableRef,
              rowHeight,
              bodyWidth: leftColumnsWidth,
              headerWidth: leftColumnsWidth,
              headerHeight,
              height: _fixedTableHeight,
              rowKey: rowKey2,
              scrollbarAlwaysOn,
              scrollbarStartGap: 2,
              scrollbarEndGap: vScrollbarSize,
              useIsScrolling,
              width: leftColumnsWidth,
              getRowHeight,
              onScroll: onVerticalScroll
            };
            const rightColumnsWidth = unref(rightTableWidth);
            const rightTableProps = {
              cache: cache2,
              class: ns.e("right"),
              columns: unref(fixedColumnsOnRight),
              data: _data,
              fixedData,
              estimatedRowHeight,
              rightTableRef,
              rowHeight,
              bodyWidth: rightColumnsWidth,
              headerWidth: rightColumnsWidth,
              headerHeight,
              height: _fixedTableHeight,
              rowKey: rowKey2,
              scrollbarAlwaysOn,
              scrollbarStartGap: 2,
              scrollbarEndGap: vScrollbarSize,
              width: rightColumnsWidth,
              style: `--${unref(ns.namespace)}-table-scrollbar-size: ${vScrollbarSize}px`,
              useIsScrolling,
              getRowHeight,
              onScroll: onVerticalScroll
            };
            const _columnsStyles = unref(columnsStyles);
            const tableRowProps = {
              ns,
              depthMap: unref(depthMap),
              columnsStyles: _columnsStyles,
              expandColumnKey: expandColumnKey2,
              expandedRowKeys: unref(expandedRowKeys),
              estimatedRowHeight,
              hasFixedColumns: unref(hasFixedColumns),
              rowProps: rowProps2,
              rowClass,
              rowKey: rowKey2,
              rowEventHandlers,
              onRowHovered,
              onRowExpanded,
              onRowHeightChange
            };
            const tableCellProps = {
              cellProps,
              expandColumnKey: expandColumnKey2,
              indentSize,
              iconSize,
              rowKey: rowKey2,
              expandedRowKeys: unref(expandedRowKeys),
              ns
            };
            const tableHeaderProps = {
              ns,
              headerClass,
              headerProps,
              columnsStyles: _columnsStyles
            };
            const tableHeaderCellProps = {
              ns,
              sortBy: sortBy2,
              sortState,
              headerCellProps,
              onColumnSorted
            };
            const tableSlots = {
              row: (props22) => createVNode(RowRenderer, mergeProps(props22, tableRowProps), {
                row: slots.row,
                cell: (props3) => {
                  let _slot;
                  return slots.cell ? createVNode(CellRenderer, mergeProps(props3, tableCellProps, {
                    "style": _columnsStyles[props3.column.key]
                  }), _isSlot(_slot = slots.cell(props3)) ? _slot : {
                    default: () => [_slot]
                  }) : createVNode(CellRenderer, mergeProps(props3, tableCellProps, {
                    "style": _columnsStyles[props3.column.key]
                  }), null);
                }
              }),
              header: (props22) => createVNode(HeaderRenderer, mergeProps(props22, tableHeaderProps), {
                header: slots.header,
                cell: (props3) => {
                  let _slot2;
                  return slots["header-cell"] ? createVNode(HeaderCellRenderer, mergeProps(props3, tableHeaderCellProps, {
                    "style": _columnsStyles[props3.column.key]
                  }), _isSlot(_slot2 = slots["header-cell"](props3)) ? _slot2 : {
                    default: () => [_slot2]
                  }) : createVNode(HeaderCellRenderer, mergeProps(props3, tableHeaderCellProps, {
                    "style": _columnsStyles[props3.column.key]
                  }), null);
                }
              })
            };
            const rootKls = [props2.class, ns.b(), ns.e("root"), {
              [ns.is("dynamic")]: unref(isDynamic)
            }];
            const footerProps = {
              class: ns.e("footer"),
              style: unref(footerHeight)
            };
            return createVNode("div", {
              "class": rootKls,
              "style": unref(rootStyle)
            }, [createVNode(MainTable, mainTableProps, _isSlot(tableSlots) ? tableSlots : {
              default: () => [tableSlots]
            }), createVNode(LeftTable$1, leftTableProps, _isSlot(tableSlots) ? tableSlots : {
              default: () => [tableSlots]
            }), createVNode(LeftTable, rightTableProps, _isSlot(tableSlots) ? tableSlots : {
              default: () => [tableSlots]
            }), slots.footer && createVNode(Footer$1, footerProps, {
              default: slots.footer
            }), unref(showEmpty) && createVNode(Footer, {
              "class": ns.e("empty"),
              "style": unref(emptyStyle)
            }, {
              default: slots.empty
            }), slots.overlay && createVNode(Overlay, {
              "class": ns.e("overlay")
            }, {
              default: slots.overlay
            })]);
          };
        }
      });
      var TableV2$1 = exports("TableV2", TableV2);
      const autoResizerProps = exports("autoResizerProps", buildProps({
        disableWidth: Boolean,
        disableHeight: Boolean,
        onResize: {
          type: definePropType(Function)
        }
      }));
      const AutoResizer = defineComponent({
        name: "ElAutoResizer",
        props: autoResizerProps,
        setup(props2, {
          slots
        }) {
          const ns = useNamespace("auto-resizer");
          const {
            height,
            width,
            sizer
          } = useAutoResize(props2);
          const style = {
            width: "100%",
            height: "100%"
          };
          return () => {
            var _a;
            return createVNode("div", {
              "ref": sizer,
              "class": ns.b(),
              "style": style
            }, [(_a = slots.default) == null ? void 0 : _a.call(slots, {
              height: height.value,
              width: width.value
            })]);
          };
        }
      });
      const ElTableV2 = exports("ElTableV2", withInstall(TableV2$1));
      const ElAutoResizer = exports("ElAutoResizer", withInstall(AutoResizer));
      const tabsRootContextKey = exports("tabsRootContextKey", Symbol("tabsRootContextKey"));
      const tabBarProps = exports("tabBarProps", buildProps({
        tabs: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        tabRefs: {
          type: definePropType(Object),
          default: () => mutable({})
        }
      }));
      const COMPONENT_NAME$4 = "ElTabBar";
      const __default__$x = defineComponent({
        name: COMPONENT_NAME$4
      });
      const _sfc_main$C = /* @__PURE__ */ defineComponent({
        ...__default__$x,
        props: tabBarProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const rootTabs = inject(tabsRootContextKey);
          if (!rootTabs)
            throwError(COMPONENT_NAME$4, "<el-tabs><el-tab-bar /></el-tabs>");
          const ns = useNamespace("tabs");
          const barRef = ref();
          const barStyle = ref();
          const getBarStyle = () => {
            let offset2 = 0;
            let tabSize = 0;
            const sizeName = ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height";
            const sizeDir = sizeName === "width" ? "x" : "y";
            const position = sizeDir === "x" ? "left" : "top";
            props2.tabs.every((tab) => {
              if (isUndefined(tab.paneName))
                return false;
              const $el = props2.tabRefs[tab.paneName];
              if (!$el)
                return false;
              if (!tab.active) {
                return true;
              }
              offset2 = $el[`offset${capitalize(position)}`];
              tabSize = $el[`client${capitalize(sizeName)}`];
              const tabStyles = window.getComputedStyle($el);
              if (sizeName === "width") {
                tabSize -= Number.parseFloat(tabStyles.paddingLeft) + Number.parseFloat(tabStyles.paddingRight);
                offset2 += Number.parseFloat(tabStyles.paddingLeft);
              }
              return false;
            });
            return {
              [sizeName]: `${tabSize}px`,
              transform: `translate${capitalize(sizeDir)}(${offset2}px)`
            };
          };
          const update2 = () => barStyle.value = getBarStyle();
          const tabObservers = [];
          const observerTabs = () => {
            tabObservers.forEach((observer) => observer.stop());
            tabObservers.length = 0;
            Object.values(props2.tabRefs).forEach((tab) => {
              tabObservers.push(useResizeObserver(tab, update2));
            });
          };
          watch(() => props2.tabs, async () => {
            await nextTick();
            update2();
            observerTabs();
          }, { immediate: true });
          const barObserver = useResizeObserver(barRef, () => update2());
          onBeforeUnmount(() => {
            tabObservers.forEach((observer) => observer.stop());
            tabObservers.length = 0;
            barObserver.stop();
          });
          expose({
            ref: barRef,
            update: update2
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "barRef",
              ref: barRef,
              class: normalizeClass([unref(ns).e("active-bar"), unref(ns).is(unref(rootTabs).props.tabPosition)]),
              style: normalizeStyle(barStyle.value)
            }, null, 6);
          };
        }
      });
      var TabBar = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["__file", "tab-bar.vue"]]);
      const tabNavProps = exports("tabNavProps", buildProps({
        panes: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        currentName: {
          type: [String, Number],
          default: ""
        },
        editable: Boolean,
        type: {
          type: String,
          values: ["card", "border-card", ""],
          default: ""
        },
        stretch: Boolean
      }));
      const tabNavEmits = exports("tabNavEmits", {
        tabClick: (tab, tabName, ev) => ev instanceof Event,
        tabRemove: (tab, ev) => ev instanceof Event
      });
      const COMPONENT_NAME$3 = "ElTabNav";
      const TabNav = defineComponent({
        name: COMPONENT_NAME$3,
        props: tabNavProps,
        emits: tabNavEmits,
        setup(props2, {
          expose,
          emit
        }) {
          const rootTabs = inject(tabsRootContextKey);
          if (!rootTabs)
            throwError(COMPONENT_NAME$3, `<el-tabs><tab-nav /></el-tabs>`);
          const ns = useNamespace("tabs");
          const visibility = useDocumentVisibility();
          const focused = useWindowFocus();
          const navScroll$ = ref();
          const nav$ = ref();
          const el$ = ref();
          const tabRefsMap = ref({});
          const tabBarRef = ref();
          const scrollable = ref(false);
          const navOffset = ref(0);
          const isFocus = ref(false);
          const focusable = ref(true);
          const tracker = shallowRef();
          const sizeName = computed(() => ["top", "bottom"].includes(rootTabs.props.tabPosition) ? "width" : "height");
          const navStyle = computed(() => {
            const dir = sizeName.value === "width" ? "X" : "Y";
            return {
              transform: `translate${dir}(-${navOffset.value}px)`
            };
          });
          const scrollPrev = () => {
            if (!navScroll$.value)
              return;
            const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
            const currentOffset = navOffset.value;
            if (!currentOffset)
              return;
            const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;
            navOffset.value = newOffset;
          };
          const scrollNext = () => {
            if (!navScroll$.value || !nav$.value)
              return;
            const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
            const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
            const currentOffset = navOffset.value;
            if (navSize - currentOffset <= containerSize)
              return;
            const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;
            navOffset.value = newOffset;
          };
          const scrollToActiveTab = async () => {
            const nav = nav$.value;
            if (!scrollable.value || !el$.value || !navScroll$.value || !nav)
              return;
            await nextTick();
            const activeTab = tabRefsMap.value[props2.currentName];
            if (!activeTab)
              return;
            const navScroll = navScroll$.value;
            const isHorizontal2 = ["top", "bottom"].includes(rootTabs.props.tabPosition);
            const activeTabBounding = activeTab.getBoundingClientRect();
            const navScrollBounding = navScroll.getBoundingClientRect();
            const maxOffset = isHorizontal2 ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;
            const currentOffset = navOffset.value;
            let newOffset = currentOffset;
            if (isHorizontal2) {
              if (activeTabBounding.left < navScrollBounding.left) {
                newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);
              }
              if (activeTabBounding.right > navScrollBounding.right) {
                newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;
              }
            } else {
              if (activeTabBounding.top < navScrollBounding.top) {
                newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);
              }
              if (activeTabBounding.bottom > navScrollBounding.bottom) {
                newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);
              }
            }
            newOffset = Math.max(newOffset, 0);
            navOffset.value = Math.min(newOffset, maxOffset);
          };
          const update2 = () => {
            var _a;
            if (!nav$.value || !navScroll$.value)
              return;
            props2.stretch && ((_a = tabBarRef.value) == null ? void 0 : _a.update());
            const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
            const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];
            const currentOffset = navOffset.value;
            if (containerSize < navSize) {
              scrollable.value = scrollable.value || {};
              scrollable.value.prev = currentOffset;
              scrollable.value.next = currentOffset + containerSize < navSize;
              if (navSize - currentOffset < containerSize) {
                navOffset.value = navSize - containerSize;
              }
            } else {
              scrollable.value = false;
              if (currentOffset > 0) {
                navOffset.value = 0;
              }
            }
          };
          const changeTab = (event) => {
            let step2 = 0;
            switch (event.code) {
              case EVENT_CODE.left:
              case EVENT_CODE.up:
                step2 = -1;
                break;
              case EVENT_CODE.right:
              case EVENT_CODE.down:
                step2 = 1;
                break;
              default:
                return;
            }
            const tabList = Array.from(event.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)"));
            const currentIndex = tabList.indexOf(event.target);
            let nextIndex = currentIndex + step2;
            if (nextIndex < 0) {
              nextIndex = tabList.length - 1;
            } else if (nextIndex >= tabList.length) {
              nextIndex = 0;
            }
            tabList[nextIndex].focus({
              preventScroll: true
            });
            tabList[nextIndex].click();
            setFocus();
          };
          const setFocus = () => {
            if (focusable.value)
              isFocus.value = true;
          };
          const removeFocus = () => isFocus.value = false;
          const setRefs = (el, key) => {
            tabRefsMap.value[key] = el;
          };
          const focusActiveTab = async () => {
            await nextTick();
            const activeTab = tabRefsMap.value[props2.currentName];
            activeTab == null ? void 0 : activeTab.focus({
              preventScroll: true
            });
          };
          watch(visibility, (visibility2) => {
            if (visibility2 === "hidden") {
              focusable.value = false;
            } else if (visibility2 === "visible") {
              setTimeout(() => focusable.value = true, 50);
            }
          });
          watch(focused, (focused2) => {
            if (focused2) {
              setTimeout(() => focusable.value = true, 50);
            } else {
              focusable.value = false;
            }
          });
          useResizeObserver(el$, update2);
          onMounted(() => setTimeout(() => scrollToActiveTab(), 0));
          onUpdated(() => update2());
          expose({
            scrollToActiveTab,
            removeFocus,
            focusActiveTab,
            tabListRef: nav$,
            tabBarRef,
            scheduleRender: () => triggerRef(tracker)
          });
          return () => {
            const scrollBtn = scrollable.value ? [createVNode("span", {
              "class": [ns.e("nav-prev"), ns.is("disabled", !scrollable.value.prev)],
              "onClick": scrollPrev
            }, [createVNode(ElIcon, null, {
              default: () => [createVNode(arrow_left_default$1, null, null)]
            })]), createVNode("span", {
              "class": [ns.e("nav-next"), ns.is("disabled", !scrollable.value.next)],
              "onClick": scrollNext
            }, [createVNode(ElIcon, null, {
              default: () => [createVNode(arrow_right_default$1, null, null)]
            })])] : null;
            const tabs = props2.panes.map((pane, index2) => {
              var _a, _b, _c, _d;
              const uid2 = pane.uid;
              const disabled = pane.props.disabled;
              const tabName = (_b = (_a = pane.props.name) != null ? _a : pane.index) != null ? _b : `${index2}`;
              const closable = !disabled && (pane.isClosable || props2.editable);
              pane.index = `${index2}`;
              const btnClose = closable ? createVNode(ElIcon, {
                "class": "is-icon-close",
                "onClick": (ev) => emit("tabRemove", pane, ev)
              }, {
                default: () => [createVNode(close_default$1, null, null)]
              }) : null;
              const tabLabelContent = ((_d = (_c = pane.slots).label) == null ? void 0 : _d.call(_c)) || pane.props.label;
              const tabindex = !disabled && pane.active ? 0 : -1;
              return createVNode("div", {
                "ref": (el) => setRefs(el, tabName),
                "class": [ns.e("item"), ns.is(rootTabs.props.tabPosition), ns.is("active", pane.active), ns.is("disabled", disabled), ns.is("closable", closable), ns.is("focus", isFocus.value)],
                "id": `tab-${tabName}`,
                "key": `tab-${uid2}`,
                "aria-controls": `pane-${tabName}`,
                "role": "tab",
                "aria-selected": pane.active,
                "tabindex": tabindex,
                "onFocus": () => setFocus(),
                "onBlur": () => removeFocus(),
                "onClick": (ev) => {
                  removeFocus();
                  emit("tabClick", pane, tabName, ev);
                },
                "onKeydown": (ev) => {
                  if (closable && (ev.code === EVENT_CODE.delete || ev.code === EVENT_CODE.backspace)) {
                    emit("tabRemove", pane, ev);
                  }
                }
              }, [...[tabLabelContent, btnClose]]);
            });
            tracker.value;
            return createVNode("div", {
              "ref": el$,
              "class": [ns.e("nav-wrap"), ns.is("scrollable", !!scrollable.value), ns.is(rootTabs.props.tabPosition)]
            }, [scrollBtn, createVNode("div", {
              "class": ns.e("nav-scroll"),
              "ref": navScroll$
            }, [props2.panes.length > 0 ? createVNode("div", {
              "class": [ns.e("nav"), ns.is(rootTabs.props.tabPosition), ns.is("stretch", props2.stretch && ["top", "bottom"].includes(rootTabs.props.tabPosition))],
              "ref": nav$,
              "style": navStyle.value,
              "role": "tablist",
              "onKeydown": changeTab
            }, [...[!props2.type ? createVNode(TabBar, {
              "ref": tabBarRef,
              "tabs": [...props2.panes],
              "tabRefs": tabRefsMap.value
            }, null) : null, tabs]]) : null])]);
          };
        }
      });
      const tabsProps = exports("tabsProps", buildProps({
        type: {
          type: String,
          values: ["card", "border-card", ""],
          default: ""
        },
        closable: Boolean,
        addable: Boolean,
        modelValue: {
          type: [String, Number]
        },
        editable: Boolean,
        tabPosition: {
          type: String,
          values: ["top", "right", "bottom", "left"],
          default: "top"
        },
        beforeLeave: {
          type: definePropType(Function),
          default: () => true
        },
        stretch: Boolean
      }));
      const isPaneName = (value) => isString$1(value) || isNumber(value);
      const tabsEmits = exports("tabsEmits", {
        [UPDATE_MODEL_EVENT]: (name) => isPaneName(name),
        tabClick: (pane, ev) => ev instanceof Event,
        tabChange: (name) => isPaneName(name),
        edit: (paneName, action) => ["remove", "add"].includes(action),
        tabRemove: (name) => isPaneName(name),
        tabAdd: () => true
      });
      const Tabs = defineComponent({
        name: "ElTabs",
        props: tabsProps,
        emits: tabsEmits,
        setup(props2, {
          emit,
          slots,
          expose
        }) {
          var _a;
          const ns = useNamespace("tabs");
          const isVertical = computed(() => ["left", "right"].includes(props2.tabPosition));
          const {
            children: panes,
            addChild: registerPane,
            removeChild: unregisterPane,
            ChildrenSorter: PanesSorter
          } = useOrderedChildren(getCurrentInstance(), "ElTabPane");
          const nav$ = ref();
          const currentName = ref((_a = props2.modelValue) != null ? _a : "0");
          const setCurrentName = async (value, trigger = false) => {
            var _a2, _b, _c, _d;
            if (currentName.value === value || isUndefined(value))
              return;
            try {
              let canLeave;
              if (props2.beforeLeave) {
                const result2 = props2.beforeLeave(value, currentName.value);
                canLeave = result2 instanceof Promise ? await result2 : result2;
              } else {
                canLeave = true;
              }
              if (canLeave !== false) {
                const isFocusInsidePane = (_a2 = panes.value.find((item) => item.paneName === currentName.value)) == null ? void 0 : _a2.isFocusInsidePane();
                currentName.value = value;
                if (trigger) {
                  emit(UPDATE_MODEL_EVENT, value);
                  emit("tabChange", value);
                }
                (_c = (_b = nav$.value) == null ? void 0 : _b.removeFocus) == null ? void 0 : _c.call(_b);
                if (isFocusInsidePane) {
                  (_d = nav$.value) == null ? void 0 : _d.focusActiveTab();
                }
              }
            } catch (e) {
            }
          };
          const handleTabClick = (tab, tabName, event) => {
            if (tab.props.disabled)
              return;
            emit("tabClick", tab, event);
            setCurrentName(tabName, true);
          };
          const handleTabRemove = (pane, ev) => {
            if (pane.props.disabled || isUndefined(pane.props.name))
              return;
            ev.stopPropagation();
            emit("edit", pane.props.name, "remove");
            emit("tabRemove", pane.props.name);
          };
          const handleTabAdd = () => {
            emit("edit", void 0, "add");
            emit("tabAdd");
          };
          const swapChildren = (vnode) => {
            const actualFirstChild = vnode.el.firstChild;
            const firstChild = ["bottom", "right"].includes(props2.tabPosition) ? vnode.children[0].el : vnode.children[1].el;
            if (actualFirstChild !== firstChild) {
              actualFirstChild.before(firstChild);
            }
          };
          watch(() => props2.modelValue, (modelValue) => setCurrentName(modelValue));
          watch(currentName, async () => {
            var _a2;
            await nextTick();
            (_a2 = nav$.value) == null ? void 0 : _a2.scrollToActiveTab();
          });
          provide(tabsRootContextKey, {
            props: props2,
            currentName,
            registerPane,
            unregisterPane,
            nav$
          });
          expose({
            currentName,
            get tabNavRef() {
              return omit(nav$.value, ["scheduleRender"]);
            }
          });
          return () => {
            const addSlot = slots["add-icon"];
            const newButton = props2.editable || props2.addable ? createVNode("div", {
              "class": [ns.e("new-tab"), isVertical.value && ns.e("new-tab-vertical")],
              "tabindex": "0",
              "onClick": handleTabAdd,
              "onKeydown": (ev) => {
                if ([EVENT_CODE.enter, EVENT_CODE.numpadEnter].includes(ev.code))
                  handleTabAdd();
              }
            }, [addSlot ? renderSlot(slots, "add-icon") : createVNode(ElIcon, {
              "class": ns.is("icon-plus")
            }, {
              default: () => [createVNode(plus_default$1, null, null)]
            })]) : null;
            const tabNav = () => createVNode(TabNav, {
              "ref": nav$,
              "currentName": currentName.value,
              "editable": props2.editable,
              "type": props2.type,
              "panes": panes.value,
              "stretch": props2.stretch,
              "onTabClick": handleTabClick,
              "onTabRemove": handleTabRemove
            }, null);
            const header = createVNode("div", {
              "class": [ns.e("header"), isVertical.value && ns.e("header-vertical"), ns.is(props2.tabPosition)]
            }, [createVNode(PanesSorter, null, {
              default: tabNav,
              $stable: true
            }), newButton]);
            const panels = createVNode("div", {
              "class": ns.e("content")
            }, [renderSlot(slots, "default")]);
            return createVNode("div", {
              "class": [ns.b(), ns.m(props2.tabPosition), {
                [ns.m("card")]: props2.type === "card",
                [ns.m("border-card")]: props2.type === "border-card"
              }],
              "onVnodeMounted": swapChildren,
              "onVnodeUpdated": swapChildren
            }, [panels, header]);
          };
        }
      });
      const tabPaneProps = exports("tabPaneProps", buildProps({
        label: {
          type: String,
          default: ""
        },
        name: {
          type: [String, Number]
        },
        closable: Boolean,
        disabled: Boolean,
        lazy: Boolean
      }));
      const COMPONENT_NAME$2 = "ElTabPane";
      const __default__$w = defineComponent({
        name: COMPONENT_NAME$2
      });
      const _sfc_main$B = /* @__PURE__ */ defineComponent({
        ...__default__$w,
        props: tabPaneProps,
        setup(__props) {
          const props2 = __props;
          const instance = getCurrentInstance();
          const slots = useSlots();
          const tabsRoot = inject(tabsRootContextKey);
          if (!tabsRoot)
            throwError(COMPONENT_NAME$2, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
          const ns = useNamespace("tab-pane");
          const paneRef = ref();
          const index2 = ref();
          const isClosable = computed(() => props2.closable || tabsRoot.props.closable);
          const active = computedEager(() => {
            var _a;
            return tabsRoot.currentName.value === ((_a = props2.name) != null ? _a : index2.value);
          });
          const loaded = ref(active.value);
          const paneName = computed(() => {
            var _a;
            return (_a = props2.name) != null ? _a : index2.value;
          });
          const shouldBeRender = computedEager(() => !props2.lazy || loaded.value || active.value);
          const isFocusInsidePane = () => {
            var _a;
            return (_a = paneRef.value) == null ? void 0 : _a.contains(document.activeElement);
          };
          watch(active, (val) => {
            if (val)
              loaded.value = true;
          });
          const pane = reactive({
            uid: instance.uid,
            getVnode: () => instance.vnode,
            slots,
            props: props2,
            paneName,
            active,
            index: index2,
            isClosable,
            isFocusInsidePane
          });
          tabsRoot.registerPane(pane);
          onBeforeUnmount(() => {
            tabsRoot.unregisterPane(pane);
          });
          onBeforeUpdate(() => {
            var _a;
            if (slots.label)
              (_a = tabsRoot.nav$.value) == null ? void 0 : _a.scheduleRender();
          });
          return (_ctx, _cache) => {
            return unref(shouldBeRender) ? withDirectives((openBlock(), createElementBlock("div", {
              key: 0,
              id: `pane-${unref(paneName)}`,
              ref_key: "paneRef",
              ref: paneRef,
              class: normalizeClass(unref(ns).b()),
              role: "tabpanel",
              "aria-hidden": !unref(active),
              "aria-labelledby": `tab-${unref(paneName)}`
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 10, ["id", "aria-hidden", "aria-labelledby"])), [
              [vShow, unref(active)]
            ]) : createCommentVNode("v-if", true);
          };
        }
      });
      var TabPane = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["__file", "tab-pane.vue"]]);
      const ElTabs = exports("ElTabs", withInstall(Tabs, {
        TabPane
      }));
      const ElTabPane = exports("ElTabPane", withNoopInstall(TabPane));
      const textProps = exports("textProps", buildProps({
        type: {
          type: String,
          values: ["primary", "success", "info", "warning", "danger", ""],
          default: ""
        },
        size: {
          type: String,
          values: componentSizes,
          default: ""
        },
        truncated: Boolean,
        lineClamp: {
          type: [String, Number]
        },
        tag: {
          type: String,
          default: "span"
        }
      }));
      const __default__$v = defineComponent({
        name: "ElText"
      });
      const _sfc_main$A = /* @__PURE__ */ defineComponent({
        ...__default__$v,
        props: textProps,
        setup(__props) {
          const props2 = __props;
          const textRef = ref();
          const textSize = useFormSize();
          const ns = useNamespace("text");
          const textKls = computed(() => [
            ns.b(),
            ns.m(props2.type),
            ns.m(textSize.value),
            ns.is("truncated", props2.truncated),
            ns.is("line-clamp", !isUndefined(props2.lineClamp))
          ]);
          const bindTitle = () => {
            var _a, _b, _c, _d, _e, _f, _g;
            const inheritTitle = useAttrs$1().title;
            if (inheritTitle)
              return;
            let shouldAddTitle = false;
            const text = ((_a = textRef.value) == null ? void 0 : _a.textContent) || "";
            if (props2.truncated) {
              const width = (_b = textRef.value) == null ? void 0 : _b.offsetWidth;
              const scrollWidth = (_c = textRef.value) == null ? void 0 : _c.scrollWidth;
              if (width && scrollWidth && scrollWidth > width) {
                shouldAddTitle = true;
              }
            } else if (!isUndefined(props2.lineClamp)) {
              const height = (_d = textRef.value) == null ? void 0 : _d.offsetHeight;
              const scrollHeight = (_e = textRef.value) == null ? void 0 : _e.scrollHeight;
              if (height && scrollHeight && scrollHeight > height) {
                shouldAddTitle = true;
              }
            }
            if (shouldAddTitle) {
              (_f = textRef.value) == null ? void 0 : _f.setAttribute("title", text);
            } else {
              (_g = textRef.value) == null ? void 0 : _g.removeAttribute("title");
            }
          };
          onMounted(bindTitle);
          onUpdated(bindTitle);
          return (_ctx, _cache) => {
            return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
              ref_key: "textRef",
              ref: textRef,
              class: normalizeClass(unref(textKls)),
              style: normalizeStyle({ "-webkit-line-clamp": _ctx.lineClamp })
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["class", "style"]);
          };
        }
      });
      var Text = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["__file", "text.vue"]]);
      const ElText = exports("ElText", withInstall(Text));
      const timeSelectProps = exports("timeSelectProps", buildProps({
        format: {
          type: String,
          default: "HH:mm"
        },
        modelValue: {
          type: definePropType(String)
        },
        disabled: Boolean,
        editable: {
          type: Boolean,
          default: true
        },
        effect: {
          type: definePropType(String),
          default: "light"
        },
        clearable: {
          type: Boolean,
          default: true
        },
        size: useSizeProp,
        placeholder: String,
        start: {
          type: String,
          default: "09:00"
        },
        end: {
          type: String,
          default: "18:00"
        },
        step: {
          type: String,
          default: "00:30"
        },
        minTime: {
          type: definePropType(String)
        },
        maxTime: {
          type: definePropType(String)
        },
        includeEndTime: Boolean,
        name: String,
        prefixIcon: {
          type: definePropType([String, Object]),
          default: () => clock_default$1
        },
        clearIcon: {
          type: definePropType([String, Object]),
          default: () => circle_close_default$1
        },
        ...useEmptyValuesProps
      }));
      const parseTime = (time) => {
        const values2 = (time || "").split(":");
        if (values2.length >= 2) {
          let hours = Number.parseInt(values2[0], 10);
          const minutes = Number.parseInt(values2[1], 10);
          const timeUpper = time.toUpperCase();
          if (timeUpper.includes("AM") && hours === 12) {
            hours = 0;
          } else if (timeUpper.includes("PM") && hours !== 12) {
            hours += 12;
          }
          return {
            hours,
            minutes
          };
        }
        return null;
      };
      const compareTime = (time1, time2) => {
        const value1 = parseTime(time1);
        if (!value1)
          return -1;
        const value2 = parseTime(time2);
        if (!value2)
          return -1;
        const minutes1 = value1.minutes + value1.hours * 60;
        const minutes2 = value2.minutes + value2.hours * 60;
        if (minutes1 === minutes2) {
          return 0;
        }
        return minutes1 > minutes2 ? 1 : -1;
      };
      const padTime = (time) => {
        return `${time}`.padStart(2, "0");
      };
      const formatTime = (time) => {
        return `${padTime(time.hours)}:${padTime(time.minutes)}`;
      };
      const nextTime = (time, step2) => {
        const timeValue = parseTime(time);
        if (!timeValue)
          return "";
        const stepValue = parseTime(step2);
        if (!stepValue)
          return "";
        const next = {
          hours: timeValue.hours,
          minutes: timeValue.minutes
        };
        next.minutes += stepValue.minutes;
        next.hours += stepValue.hours;
        next.hours += Math.floor(next.minutes / 60);
        next.minutes = next.minutes % 60;
        return formatTime(next);
      };
      const __default__$u = defineComponent({
        name: "ElTimeSelect"
      });
      const _sfc_main$z = /* @__PURE__ */ defineComponent({
        ...__default__$u,
        props: timeSelectProps,
        emits: [CHANGE_EVENT, "blur", "focus", "clear", UPDATE_MODEL_EVENT],
        setup(__props, { expose }) {
          const props2 = __props;
          dayjs.extend(customParseFormat);
          const { Option: ElOption2 } = ElSelect;
          const nsInput = useNamespace("input");
          const select = ref();
          const _disabled = useFormDisabled();
          const { lang: lang2 } = useLocale();
          const value = computed(() => props2.modelValue);
          const start = computed(() => {
            const time = parseTime(props2.start);
            return time ? formatTime(time) : null;
          });
          const end = computed(() => {
            const time = parseTime(props2.end);
            return time ? formatTime(time) : null;
          });
          const step2 = computed(() => {
            const time = parseTime(props2.step);
            return time ? formatTime(time) : null;
          });
          const minTime = computed(() => {
            const time = parseTime(props2.minTime || "");
            return time ? formatTime(time) : null;
          });
          const maxTime = computed(() => {
            const time = parseTime(props2.maxTime || "");
            return time ? formatTime(time) : null;
          });
          const items = computed(() => {
            var _a;
            const result2 = [];
            const push = (formattedValue, rawValue) => {
              result2.push({
                value: formattedValue,
                disabled: compareTime(rawValue, minTime.value || "-1:-1") <= 0 || compareTime(rawValue, maxTime.value || "100:100") >= 0
              });
            };
            if (props2.start && props2.end && props2.step) {
              let current = start.value;
              let currentTime;
              while (current && end.value && compareTime(current, end.value) <= 0) {
                currentTime = dayjs(current, "HH:mm").locale(lang2.value).format(props2.format);
                push(currentTime, current);
                current = nextTime(current, step2.value);
              }
              if (props2.includeEndTime && end.value && ((_a = result2[result2.length - 1]) == null ? void 0 : _a.value) !== end.value) {
                const formattedValue = dayjs(end.value, "HH:mm").locale(lang2.value).format(props2.format);
                push(formattedValue, end.value);
              }
            }
            return result2;
          });
          const blur = () => {
            var _a, _b;
            (_b = (_a = select.value) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);
          };
          const focus = () => {
            var _a, _b;
            (_b = (_a = select.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
          };
          expose({
            blur,
            focus
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(ElSelect), {
              ref_key: "select",
              ref: select,
              "model-value": unref(value),
              disabled: unref(_disabled),
              clearable: _ctx.clearable,
              "clear-icon": _ctx.clearIcon,
              size: _ctx.size,
              effect: _ctx.effect,
              placeholder: _ctx.placeholder,
              "default-first-option": "",
              filterable: _ctx.editable,
              "empty-values": _ctx.emptyValues,
              "value-on-clear": _ctx.valueOnClear,
              "onUpdate:modelValue": (event) => _ctx.$emit(unref(UPDATE_MODEL_EVENT), event),
              onChange: (event) => _ctx.$emit(unref(CHANGE_EVENT), event),
              onBlur: (event) => _ctx.$emit("blur", event),
              onFocus: (event) => _ctx.$emit("focus", event),
              onClear: () => _ctx.$emit("clear")
            }, {
              prefix: withCtx(() => [
                _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass(unref(nsInput).e("prefix-icon"))
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true)
              ]),
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(items), (item) => {
                  return openBlock(), createBlock(unref(ElOption2), {
                    key: item.value,
                    label: item.value,
                    value: item.value,
                    disabled: item.disabled
                  }, null, 8, ["label", "value", "disabled"]);
                }), 128))
              ]),
              _: 1
            }, 8, ["model-value", "disabled", "clearable", "clear-icon", "size", "effect", "placeholder", "filterable", "empty-values", "value-on-clear", "onUpdate:modelValue", "onChange", "onBlur", "onFocus", "onClear"]);
          };
        }
      });
      var TimeSelect = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["__file", "time-select.vue"]]);
      const ElTimeSelect = exports("ElTimeSelect", withInstall(TimeSelect));
      const TIMELINE_INJECTION_KEY = exports("TIMELINE_INJECTION_KEY", "timeline");
      const Timeline = defineComponent({
        name: "ElTimeline",
        setup(_2, { slots }) {
          const ns = useNamespace("timeline");
          provide(TIMELINE_INJECTION_KEY, slots);
          return () => {
            return h$1("ul", { class: [ns.b()] }, [renderSlot(slots, "default")]);
          };
        }
      });
      var Timeline$1 = Timeline;
      const timelineItemProps = exports("timelineItemProps", buildProps({
        timestamp: {
          type: String,
          default: ""
        },
        hideTimestamp: Boolean,
        center: Boolean,
        placement: {
          type: String,
          values: ["top", "bottom"],
          default: "bottom"
        },
        type: {
          type: String,
          values: ["primary", "success", "warning", "danger", "info"],
          default: ""
        },
        color: {
          type: String,
          default: ""
        },
        size: {
          type: String,
          values: ["normal", "large"],
          default: "normal"
        },
        icon: {
          type: iconPropType
        },
        hollow: Boolean
      }));
      const __default__$t = defineComponent({
        name: "ElTimelineItem"
      });
      const _sfc_main$y = /* @__PURE__ */ defineComponent({
        ...__default__$t,
        props: timelineItemProps,
        setup(__props) {
          const props2 = __props;
          const ns = useNamespace("timeline-item");
          const defaultNodeKls = computed(() => [
            ns.e("node"),
            ns.em("node", props2.size || ""),
            ns.em("node", props2.type || ""),
            ns.is("hollow", props2.hollow)
          ]);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("li", {
              class: normalizeClass([unref(ns).b(), { [unref(ns).e("center")]: _ctx.center }])
            }, [
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("tail"))
              }, null, 2),
              !_ctx.$slots.dot ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(defaultNodeKls)),
                style: normalizeStyle({
                  backgroundColor: _ctx.color
                })
              }, [
                _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass(unref(ns).e("icon"))
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true)
              ], 6)) : createCommentVNode("v-if", true),
              _ctx.$slots.dot ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(ns).e("dot"))
              }, [
                renderSlot(_ctx.$slots, "dot")
              ], 2)) : createCommentVNode("v-if", true),
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("wrapper"))
              }, [
                !_ctx.hideTimestamp && _ctx.placement === "top" ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass([unref(ns).e("timestamp"), unref(ns).is("top")])
                }, toDisplayString(_ctx.timestamp), 3)) : createCommentVNode("v-if", true),
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).e("content"))
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2),
                !_ctx.hideTimestamp && _ctx.placement === "bottom" ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass([unref(ns).e("timestamp"), unref(ns).is("bottom")])
                }, toDisplayString(_ctx.timestamp), 3)) : createCommentVNode("v-if", true)
              ], 2)
            ], 2);
          };
        }
      });
      var TimelineItem = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__file", "timeline-item.vue"]]);
      const ElTimeline = exports("ElTimeline", withInstall(Timeline$1, {
        TimelineItem
      }));
      const ElTimelineItem = exports("ElTimelineItem", withNoopInstall(TimelineItem));
      const tooltipV2CommonProps = buildProps({
        nowrap: Boolean
      });
      var TooltipV2Sides = /* @__PURE__ */ ((TooltipV2Sides2) => {
        TooltipV2Sides2["top"] = "top";
        TooltipV2Sides2["bottom"] = "bottom";
        TooltipV2Sides2["left"] = "left";
        TooltipV2Sides2["right"] = "right";
        return TooltipV2Sides2;
      })(TooltipV2Sides || {});
      const tooltipV2Sides = Object.values(TooltipV2Sides);
      const tooltipV2ArrowProps = buildProps({
        width: {
          type: Number,
          default: 10
        },
        height: {
          type: Number,
          default: 10
        },
        style: {
          type: definePropType(Object),
          default: null
        }
      });
      const tooltipV2ArrowSpecialProps = buildProps({
        side: {
          type: definePropType(String),
          values: tooltipV2Sides,
          required: true
        }
      });
      const tooltipV2Strategies = ["absolute", "fixed"];
      const tooltipV2Placements = [
        "top-start",
        "top-end",
        "top",
        "bottom-start",
        "bottom-end",
        "bottom",
        "left-start",
        "left-end",
        "left",
        "right-start",
        "right-end",
        "right"
      ];
      const tooltipV2ContentProps = buildProps({
        arrowPadding: {
          type: definePropType(Number),
          default: 5
        },
        effect: {
          type: definePropType(String),
          default: "light"
        },
        contentClass: String,
        placement: {
          type: definePropType(String),
          values: tooltipV2Placements,
          default: "bottom"
        },
        reference: {
          type: definePropType(Object),
          default: null
        },
        offset: {
          type: Number,
          default: 8
        },
        strategy: {
          type: definePropType(String),
          values: tooltipV2Strategies,
          default: "absolute"
        },
        showArrow: Boolean,
        ...useAriaProps(["ariaLabel"])
      });
      const tooltipV2RootProps = buildProps({
        delayDuration: {
          type: Number,
          default: 300
        },
        defaultOpen: Boolean,
        open: {
          type: Boolean,
          default: void 0
        },
        onOpenChange: {
          type: definePropType(Function)
        },
        "onUpdate:open": {
          type: definePropType(Function)
        }
      });
      const EventHandler = {
        type: definePropType(Function)
      };
      const tooltipV2TriggerProps = buildProps({
        onBlur: EventHandler,
        onClick: EventHandler,
        onFocus: EventHandler,
        onMouseDown: EventHandler,
        onMouseEnter: EventHandler,
        onMouseLeave: EventHandler
      });
      const tooltipV2Props = buildProps({
        ...tooltipV2RootProps,
        ...tooltipV2ArrowProps,
        ...tooltipV2TriggerProps,
        ...tooltipV2ContentProps,
        alwaysOn: Boolean,
        fullTransition: Boolean,
        transitionProps: {
          type: definePropType(Object),
          default: null
        },
        teleported: Boolean,
        to: {
          type: definePropType([String, Object]),
          default: "body"
        }
      });
      const tooltipV2RootKey = Symbol("tooltipV2");
      const tooltipV2ContentKey = Symbol("tooltipV2Content");
      const TOOLTIP_V2_OPEN = "tooltip_v2.open";
      const __default__$s = defineComponent({
        name: "ElTooltipV2Root"
      });
      const _sfc_main$x = /* @__PURE__ */ defineComponent({
        ...__default__$s,
        props: tooltipV2RootProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const _open = ref(props2.defaultOpen);
          const triggerRef2 = ref(null);
          const open = computed({
            get: () => isPropAbsent(props2.open) ? _open.value : props2.open,
            set: (open2) => {
              var _a;
              _open.value = open2;
              (_a = props2["onUpdate:open"]) == null ? void 0 : _a.call(props2, open2);
            }
          });
          const isOpenDelayed = computed(() => isNumber(props2.delayDuration) && props2.delayDuration > 0);
          const { start: onDelayedOpen, stop: clearTimer } = useTimeoutFn(() => {
            open.value = true;
          }, computed(() => props2.delayDuration), {
            immediate: false
          });
          const ns = useNamespace("tooltip-v2");
          const contentId = useId();
          const onNormalOpen = () => {
            clearTimer();
            open.value = true;
          };
          const onDelayOpen = () => {
            unref(isOpenDelayed) ? onDelayedOpen() : onNormalOpen();
          };
          const onOpen = onNormalOpen;
          const onClose = () => {
            clearTimer();
            open.value = false;
          };
          const onChange = (open2) => {
            var _a;
            if (open2) {
              document.dispatchEvent(new CustomEvent(TOOLTIP_V2_OPEN));
              onOpen();
            }
            (_a = props2.onOpenChange) == null ? void 0 : _a.call(props2, open2);
          };
          watch(open, onChange);
          onMounted(() => {
            document.addEventListener(TOOLTIP_V2_OPEN, onClose);
          });
          onBeforeUnmount(() => {
            clearTimer();
            document.removeEventListener(TOOLTIP_V2_OPEN, onClose);
          });
          provide(tooltipV2RootKey, {
            contentId,
            triggerRef: triggerRef2,
            ns,
            onClose,
            onDelayOpen,
            onOpen
          });
          expose({
            onOpen,
            onClose
          });
          return (_ctx, _cache) => {
            return renderSlot(_ctx.$slots, "default", { open: unref(open) });
          };
        }
      });
      var TooltipV2Root = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["__file", "root.vue"]]);
      const __default__$r = defineComponent({
        name: "ElTooltipV2Arrow"
      });
      const _sfc_main$w = /* @__PURE__ */ defineComponent({
        ...__default__$r,
        props: {
          ...tooltipV2ArrowProps,
          ...tooltipV2ArrowSpecialProps
        },
        setup(__props) {
          const props2 = __props;
          const { ns } = inject(tooltipV2RootKey);
          const { arrowRef } = inject(tooltipV2ContentKey);
          const arrowStyle = computed(() => {
            const { style, width, height } = props2;
            const namespace = ns.namespace.value;
            return {
              [`--${namespace}-tooltip-v2-arrow-width`]: `${width}px`,
              [`--${namespace}-tooltip-v2-arrow-height`]: `${height}px`,
              [`--${namespace}-tooltip-v2-arrow-border-width`]: `${width / 2}px`,
              [`--${namespace}-tooltip-v2-arrow-cover-width`]: width / 2 - 1,
              ...style || {}
            };
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", {
              ref_key: "arrowRef",
              ref: arrowRef,
              style: normalizeStyle(unref(arrowStyle)),
              class: normalizeClass(unref(ns).e("arrow"))
            }, null, 6);
          };
        }
      });
      var TooltipV2Arrow = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__file", "arrow.vue"]]);
      function getSide(placement) {
        return placement.split("-")[0];
      }
      function getAlignment(placement) {
        return placement.split("-")[1];
      }
      function getMainAxisFromPlacement(placement) {
        return ["top", "bottom"].includes(getSide(placement)) ? "x" : "y";
      }
      function getLengthFromAxis(axis) {
        return axis === "y" ? "height" : "width";
      }
      function computeCoordsFromPlacement(_ref, placement, rtl) {
        let {
          reference,
          floating
        } = _ref;
        const commonX = reference.x + reference.width / 2 - floating.width / 2;
        const commonY = reference.y + reference.height / 2 - floating.height / 2;
        const mainAxis = getMainAxisFromPlacement(placement);
        const length = getLengthFromAxis(mainAxis);
        const commonAlign = reference[length] / 2 - floating[length] / 2;
        const side = getSide(placement);
        const isVertical = mainAxis === "x";
        let coords;
        switch (side) {
          case "top":
            coords = {
              x: commonX,
              y: reference.y - floating.height
            };
            break;
          case "bottom":
            coords = {
              x: commonX,
              y: reference.y + reference.height
            };
            break;
          case "right":
            coords = {
              x: reference.x + reference.width,
              y: commonY
            };
            break;
          case "left":
            coords = {
              x: reference.x - floating.width,
              y: commonY
            };
            break;
          default:
            coords = {
              x: reference.x,
              y: reference.y
            };
        }
        switch (getAlignment(placement)) {
          case "start":
            coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
            break;
          case "end":
            coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
            break;
        }
        return coords;
      }
      const computePosition$1 = async (reference, floating, config) => {
        const {
          placement = "bottom",
          strategy = "absolute",
          middleware = [],
          platform: platform2
        } = config;
        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
        let rects = await platform2.getElementRects({
          reference,
          floating,
          strategy
        });
        let {
          x: x2,
          y
        } = computeCoordsFromPlacement(rects, placement, rtl);
        let statefulPlacement = placement;
        let middlewareData = {};
        let resetCount = 0;
        for (let i = 0; i < middleware.length; i++) {
          const {
            name,
            fn: fn2
          } = middleware[i];
          const {
            x: nextX,
            y: nextY,
            data,
            reset
          } = await fn2({
            x: x2,
            y,
            initialPlacement: placement,
            placement: statefulPlacement,
            strategy,
            middlewareData,
            rects,
            platform: platform2,
            elements: {
              reference,
              floating
            }
          });
          x2 = nextX != null ? nextX : x2;
          y = nextY != null ? nextY : y;
          middlewareData = {
            ...middlewareData,
            [name]: {
              ...middlewareData[name],
              ...data
            }
          };
          if (reset && resetCount <= 50) {
            resetCount++;
            if (typeof reset === "object") {
              if (reset.placement) {
                statefulPlacement = reset.placement;
              }
              if (reset.rects) {
                rects = reset.rects === true ? await platform2.getElementRects({
                  reference,
                  floating,
                  strategy
                }) : reset.rects;
              }
              ({
                x: x2,
                y
              } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
            }
            i = -1;
            continue;
          }
        }
        return {
          x: x2,
          y,
          placement: statefulPlacement,
          strategy,
          middlewareData
        };
      };
      function expandPaddingObject(padding) {
        return {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0,
          ...padding
        };
      }
      function getSideObjectFromPadding(padding) {
        return typeof padding !== "number" ? expandPaddingObject(padding) : {
          top: padding,
          right: padding,
          bottom: padding,
          left: padding
        };
      }
      function rectToClientRect(rect) {
        return {
          ...rect,
          top: rect.y,
          left: rect.x,
          right: rect.x + rect.width,
          bottom: rect.y + rect.height
        };
      }
      async function detectOverflow(middlewareArguments, options) {
        var _await$platform$isEle;
        if (options === void 0) {
          options = {};
        }
        const {
          x: x2,
          y,
          platform: platform2,
          rects,
          elements,
          strategy
        } = middlewareArguments;
        const {
          boundary = "clippingAncestors",
          rootBoundary = "viewport",
          elementContext = "floating",
          altBoundary = false,
          padding = 0
        } = options;
        const paddingObject = getSideObjectFromPadding(padding);
        const altContext = elementContext === "floating" ? "reference" : "floating";
        const element = elements[altBoundary ? altContext : elementContext];
        const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
          element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
          boundary,
          rootBoundary,
          strategy
        }));
        const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
          rect: elementContext === "floating" ? {
            ...rects.floating,
            x: x2,
            y
          } : rects.reference,
          offsetParent: await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)),
          strategy
        }) : rects[elementContext]);
        return {
          top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
          bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
          left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
          right: elementClientRect.right - clippingClientRect.right + paddingObject.right
        };
      }
      const min$1 = Math.min;
      const max$1 = Math.max;
      function within(min$1$1, value, max$1$1) {
        return max$1(min$1$1, min$1(value, max$1$1));
      }
      const arrow = (options) => ({
        name: "arrow",
        options,
        async fn(middlewareArguments) {
          const {
            element,
            padding = 0
          } = options != null ? options : {};
          const {
            x: x2,
            y,
            placement,
            rects,
            platform: platform2
          } = middlewareArguments;
          if (element == null) {
            return {};
          }
          const paddingObject = getSideObjectFromPadding(padding);
          const coords = {
            x: x2,
            y
          };
          const axis = getMainAxisFromPlacement(placement);
          const alignment = getAlignment(placement);
          const length = getLengthFromAxis(axis);
          const arrowDimensions = await platform2.getDimensions(element);
          const minProp = axis === "y" ? "top" : "left";
          const maxProp = axis === "y" ? "bottom" : "right";
          const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
          const startDiff = coords[axis] - rects.reference[axis];
          const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
          let clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
          if (clientSize === 0) {
            clientSize = rects.floating[length];
          }
          const centerToReference = endDiff / 2 - startDiff / 2;
          const min2 = paddingObject[minProp];
          const max2 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
          const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
          const offset2 = within(min2, center, max2);
          const alignmentPadding = alignment === "start" ? paddingObject[minProp] : paddingObject[maxProp];
          const shouldAddOffset = alignmentPadding > 0 && center !== offset2 && rects.reference[length] <= rects.floating[length];
          const alignmentOffset = shouldAddOffset ? center < min2 ? min2 - center : max2 - center : 0;
          return {
            [axis]: coords[axis] - alignmentOffset,
            data: {
              [axis]: offset2,
              centerOffset: center - offset2
            }
          };
        }
      });
      const hash$1 = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
      };
      function getOppositePlacement(placement) {
        return placement.replace(/left|right|bottom|top/g, (matched) => hash$1[matched]);
      }
      function getAlignmentSides(placement, rects, rtl) {
        if (rtl === void 0) {
          rtl = false;
        }
        const alignment = getAlignment(placement);
        const mainAxis = getMainAxisFromPlacement(placement);
        const length = getLengthFromAxis(mainAxis);
        let mainAlignmentSide = mainAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
        if (rects.reference[length] > rects.floating[length]) {
          mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
        }
        return {
          main: mainAlignmentSide,
          cross: getOppositePlacement(mainAlignmentSide)
        };
      }
      const hash = {
        start: "end",
        end: "start"
      };
      function getOppositeAlignmentPlacement(placement) {
        return placement.replace(/start|end/g, (matched) => hash[matched]);
      }
      function getExpandedPlacements(placement) {
        const oppositePlacement = getOppositePlacement(placement);
        return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
      }
      const flip = function(options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "flip",
          options,
          async fn(middlewareArguments) {
            var _middlewareData$flip;
            const {
              placement,
              middlewareData,
              rects,
              initialPlacement,
              platform: platform2,
              elements
            } = middlewareArguments;
            const {
              mainAxis: checkMainAxis = true,
              crossAxis: checkCrossAxis = true,
              fallbackPlacements: specifiedFallbackPlacements,
              fallbackStrategy = "bestFit",
              flipAlignment = true,
              ...detectOverflowOptions
            } = options;
            const side = getSide(placement);
            const isBasePlacement = side === initialPlacement;
            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
            const placements = [initialPlacement, ...fallbackPlacements];
            const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
            const overflows = [];
            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
            if (checkMainAxis) {
              overflows.push(overflow[side]);
            }
            if (checkCrossAxis) {
              const {
                main,
                cross
              } = getAlignmentSides(placement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
              overflows.push(overflow[main], overflow[cross]);
            }
            overflowsData = [...overflowsData, {
              placement,
              overflows
            }];
            if (!overflows.every((side2) => side2 <= 0)) {
              var _middlewareData$flip$, _middlewareData$flip2;
              const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;
              const nextPlacement = placements[nextIndex];
              if (nextPlacement) {
                return {
                  data: {
                    index: nextIndex,
                    overflows: overflowsData
                  },
                  reset: {
                    placement: nextPlacement
                  }
                };
              }
              let resetPlacement = "bottom";
              switch (fallbackStrategy) {
                case "bestFit": {
                  var _overflowsData$map$so;
                  const placement2 = (_overflowsData$map$so = overflowsData.map((d2) => [d2, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;
                  if (placement2) {
                    resetPlacement = placement2;
                  }
                  break;
                }
                case "initialPlacement":
                  resetPlacement = initialPlacement;
                  break;
              }
              if (placement !== resetPlacement) {
                return {
                  reset: {
                    placement: resetPlacement
                  }
                };
              }
            }
            return {};
          }
        };
      };
      async function convertValueToCoords(middlewareArguments, value) {
        const {
          placement,
          platform: platform2,
          elements
        } = middlewareArguments;
        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
        const side = getSide(placement);
        const alignment = getAlignment(placement);
        const isVertical = getMainAxisFromPlacement(placement) === "x";
        const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
        const crossAxisMulti = rtl && isVertical ? -1 : 1;
        const rawValue = typeof value === "function" ? value(middlewareArguments) : value;
        let {
          mainAxis,
          crossAxis,
          alignmentAxis
        } = typeof rawValue === "number" ? {
          mainAxis: rawValue,
          crossAxis: 0,
          alignmentAxis: null
        } : {
          mainAxis: 0,
          crossAxis: 0,
          alignmentAxis: null,
          ...rawValue
        };
        if (alignment && typeof alignmentAxis === "number") {
          crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
        }
        return isVertical ? {
          x: crossAxis * crossAxisMulti,
          y: mainAxis * mainAxisMulti
        } : {
          x: mainAxis * mainAxisMulti,
          y: crossAxis * crossAxisMulti
        };
      }
      const offset = function(value) {
        if (value === void 0) {
          value = 0;
        }
        return {
          name: "offset",
          options: value,
          async fn(middlewareArguments) {
            const {
              x: x2,
              y
            } = middlewareArguments;
            const diffCoords = await convertValueToCoords(middlewareArguments, value);
            return {
              x: x2 + diffCoords.x,
              y: y + diffCoords.y,
              data: diffCoords
            };
          }
        };
      };
      function getCrossAxis(axis) {
        return axis === "x" ? "y" : "x";
      }
      const shift = function(options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "shift",
          options,
          async fn(middlewareArguments) {
            const {
              x: x2,
              y,
              placement
            } = middlewareArguments;
            const {
              mainAxis: checkMainAxis = true,
              crossAxis: checkCrossAxis = false,
              limiter = {
                fn: (_ref) => {
                  let {
                    x: x3,
                    y: y2
                  } = _ref;
                  return {
                    x: x3,
                    y: y2
                  };
                }
              },
              ...detectOverflowOptions
            } = options;
            const coords = {
              x: x2,
              y
            };
            const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
            const mainAxis = getMainAxisFromPlacement(getSide(placement));
            const crossAxis = getCrossAxis(mainAxis);
            let mainAxisCoord = coords[mainAxis];
            let crossAxisCoord = coords[crossAxis];
            if (checkMainAxis) {
              const minSide = mainAxis === "y" ? "top" : "left";
              const maxSide = mainAxis === "y" ? "bottom" : "right";
              const min2 = mainAxisCoord + overflow[minSide];
              const max2 = mainAxisCoord - overflow[maxSide];
              mainAxisCoord = within(min2, mainAxisCoord, max2);
            }
            if (checkCrossAxis) {
              const minSide = crossAxis === "y" ? "top" : "left";
              const maxSide = crossAxis === "y" ? "bottom" : "right";
              const min2 = crossAxisCoord + overflow[minSide];
              const max2 = crossAxisCoord - overflow[maxSide];
              crossAxisCoord = within(min2, crossAxisCoord, max2);
            }
            const limitedCoords = limiter.fn({
              ...middlewareArguments,
              [mainAxis]: mainAxisCoord,
              [crossAxis]: crossAxisCoord
            });
            return {
              ...limitedCoords,
              data: {
                x: limitedCoords.x - x2,
                y: limitedCoords.y - y
              }
            };
          }
        };
      };
      function isWindow(value) {
        return value && value.document && value.location && value.alert && value.setInterval;
      }
      function getWindow(node) {
        if (node == null) {
          return window;
        }
        if (!isWindow(node)) {
          const ownerDocument = node.ownerDocument;
          return ownerDocument ? ownerDocument.defaultView || window : window;
        }
        return node;
      }
      function getComputedStyle$1(element) {
        return getWindow(element).getComputedStyle(element);
      }
      function getNodeName(node) {
        return isWindow(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
      }
      function getUAString() {
        const uaData = navigator.userAgentData;
        if (uaData != null && uaData.brands) {
          return uaData.brands.map((item) => item.brand + "/" + item.version).join(" ");
        }
        return navigator.userAgent;
      }
      function isHTMLElement(value) {
        return value instanceof getWindow(value).HTMLElement;
      }
      function isElement(value) {
        return value instanceof getWindow(value).Element;
      }
      function isNode(value) {
        return value instanceof getWindow(value).Node;
      }
      function isShadowRoot(node) {
        if (typeof ShadowRoot === "undefined") {
          return false;
        }
        const OwnElement = getWindow(node).ShadowRoot;
        return node instanceof OwnElement || node instanceof ShadowRoot;
      }
      function isOverflowElement(element) {
        const {
          overflow,
          overflowX,
          overflowY
        } = getComputedStyle$1(element);
        return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
      }
      function isTableElement(element) {
        return ["table", "td", "th"].includes(getNodeName(element));
      }
      function isContainingBlock(element) {
        const isFirefox2 = /firefox/i.test(getUAString());
        const css = getComputedStyle$1(element);
        return css.transform !== "none" || css.perspective !== "none" || // @ts-ignore (TS 4.1 compat)
        css.contain === "paint" || ["transform", "perspective"].includes(css.willChange) || isFirefox2 && css.willChange === "filter" || isFirefox2 && (css.filter ? css.filter !== "none" : false);
      }
      function isLayoutViewport() {
        return !/^((?!chrome|android).)*safari/i.test(getUAString());
      }
      const min = Math.min;
      const max = Math.max;
      const round = Math.round;
      function getBoundingClientRect(element, includeScale, isFixedStrategy) {
        var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;
        if (includeScale === void 0) {
          includeScale = false;
        }
        if (isFixedStrategy === void 0) {
          isFixedStrategy = false;
        }
        const clientRect = element.getBoundingClientRect();
        let scaleX = 1;
        let scaleY = 1;
        if (includeScale && isHTMLElement(element)) {
          scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
          scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
        }
        const win = isElement(element) ? getWindow(element) : window;
        const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
        const x2 = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;
        const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;
        const width = clientRect.width / scaleX;
        const height = clientRect.height / scaleY;
        return {
          width,
          height,
          top: y,
          right: x2 + width,
          bottom: y + height,
          left: x2,
          x: x2,
          y
        };
      }
      function getDocumentElement(node) {
        return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
      }
      function getNodeScroll(element) {
        if (isElement(element)) {
          return {
            scrollLeft: element.scrollLeft,
            scrollTop: element.scrollTop
          };
        }
        return {
          scrollLeft: element.pageXOffset,
          scrollTop: element.pageYOffset
        };
      }
      function getWindowScrollBarX(element) {
        return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
      }
      function isScaled(element) {
        const rect = getBoundingClientRect(element);
        return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
      }
      function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
        const isOffsetParentAnElement = isHTMLElement(offsetParent);
        const documentElement = getDocumentElement(offsetParent);
        const rect = getBoundingClientRect(
          element,
          // @ts-ignore - checked above (TS 4.1 compat)
          isOffsetParentAnElement && isScaled(offsetParent),
          strategy === "fixed"
        );
        let scroll = {
          scrollLeft: 0,
          scrollTop: 0
        };
        const offsets = {
          x: 0,
          y: 0
        };
        if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
          if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
            scroll = getNodeScroll(offsetParent);
          }
          if (isHTMLElement(offsetParent)) {
            const offsetRect = getBoundingClientRect(offsetParent, true);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
          } else if (documentElement) {
            offsets.x = getWindowScrollBarX(documentElement);
          }
        }
        return {
          x: rect.left + scroll.scrollLeft - offsets.x,
          y: rect.top + scroll.scrollTop - offsets.y,
          width: rect.width,
          height: rect.height
        };
      }
      function getParentNode(node) {
        if (getNodeName(node) === "html") {
          return node;
        }
        return (
          // this is a quicker (but less type safe) way to save quite some bytes from the bundle
          // @ts-ignore
          node.assignedSlot || // step into the shadow DOM of the parent of a slotted node
          node.parentNode || // DOM Element detected
          (isShadowRoot(node) ? node.host : null) || // ShadowRoot detected
          getDocumentElement(node)
        );
      }
      function getTrueOffsetParent(element) {
        if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
          return null;
        }
        return composedOffsetParent(element);
      }
      function composedOffsetParent(element) {
        let {
          offsetParent
        } = element;
        let ancestor = element;
        let foundInsideSlot = false;
        while (ancestor && ancestor !== offsetParent) {
          const {
            assignedSlot
          } = ancestor;
          if (assignedSlot) {
            let newOffsetParent = assignedSlot.offsetParent;
            if (getComputedStyle$1(assignedSlot).display === "contents") {
              const hadStyleAttribute = assignedSlot.hasAttribute("style");
              const oldDisplay = assignedSlot.style.display;
              assignedSlot.style.display = getComputedStyle$1(ancestor).display;
              newOffsetParent = assignedSlot.offsetParent;
              assignedSlot.style.display = oldDisplay;
              if (!hadStyleAttribute) {
                assignedSlot.removeAttribute("style");
              }
            }
            ancestor = assignedSlot;
            if (offsetParent !== newOffsetParent) {
              offsetParent = newOffsetParent;
              foundInsideSlot = true;
            }
          } else if (isShadowRoot(ancestor) && ancestor.host && foundInsideSlot) {
            break;
          }
          ancestor = isShadowRoot(ancestor) && ancestor.host || ancestor.parentNode;
        }
        return offsetParent;
      }
      function getContainingBlock(element) {
        let currentNode = getParentNode(element);
        if (isShadowRoot(currentNode)) {
          currentNode = currentNode.host;
        }
        while (isHTMLElement(currentNode) && !["html", "body"].includes(getNodeName(currentNode))) {
          if (isContainingBlock(currentNode)) {
            return currentNode;
          } else {
            const parent2 = currentNode.parentNode;
            currentNode = isShadowRoot(parent2) ? parent2.host : parent2;
          }
        }
        return null;
      }
      function getOffsetParent(element) {
        const window2 = getWindow(element);
        let offsetParent = getTrueOffsetParent(element);
        while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
          offsetParent = getTrueOffsetParent(offsetParent);
        }
        if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
          return window2;
        }
        return offsetParent || getContainingBlock(element) || window2;
      }
      function getDimensions(element) {
        if (isHTMLElement(element)) {
          return {
            width: element.offsetWidth,
            height: element.offsetHeight
          };
        }
        const rect = getBoundingClientRect(element);
        return {
          width: rect.width,
          height: rect.height
        };
      }
      function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
        let {
          rect,
          offsetParent,
          strategy
        } = _ref;
        const isOffsetParentAnElement = isHTMLElement(offsetParent);
        const documentElement = getDocumentElement(offsetParent);
        if (offsetParent === documentElement) {
          return rect;
        }
        let scroll = {
          scrollLeft: 0,
          scrollTop: 0
        };
        const offsets = {
          x: 0,
          y: 0
        };
        if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
          if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
            scroll = getNodeScroll(offsetParent);
          }
          if (isHTMLElement(offsetParent)) {
            const offsetRect = getBoundingClientRect(offsetParent, true);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
          }
        }
        return {
          ...rect,
          x: rect.x - scroll.scrollLeft + offsets.x,
          y: rect.y - scroll.scrollTop + offsets.y
        };
      }
      function getViewportRect(element, strategy) {
        const win = getWindow(element);
        const html = getDocumentElement(element);
        const visualViewport = win.visualViewport;
        let width = html.clientWidth;
        let height = html.clientHeight;
        let x2 = 0;
        let y = 0;
        if (visualViewport) {
          width = visualViewport.width;
          height = visualViewport.height;
          const layoutViewport = isLayoutViewport();
          if (layoutViewport || !layoutViewport && strategy === "fixed") {
            x2 = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
          }
        }
        return {
          width,
          height,
          x: x2,
          y
        };
      }
      function getDocumentRect(element) {
        var _element$ownerDocumen;
        const html = getDocumentElement(element);
        const scroll = getNodeScroll(element);
        const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
        const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
        const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
        let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
        const y = -scroll.scrollTop;
        if (getComputedStyle$1(body || html).direction === "rtl") {
          x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
        }
        return {
          width,
          height,
          x: x2,
          y
        };
      }
      function getNearestOverflowAncestor(node) {
        const parentNode = getParentNode(node);
        if (["html", "body", "#document"].includes(getNodeName(parentNode))) {
          return node.ownerDocument.body;
        }
        if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
          return parentNode;
        }
        return getNearestOverflowAncestor(parentNode);
      }
      function getOverflowAncestors(node, list) {
        var _node$ownerDocument;
        if (list === void 0) {
          list = [];
        }
        const scrollableAncestor = getNearestOverflowAncestor(node);
        const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
        const win = getWindow(scrollableAncestor);
        const target2 = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;
        const updatedList = list.concat(target2);
        return isBody ? updatedList : (
          // @ts-ignore: isBody tells us target will be an HTMLElement here
          updatedList.concat(getOverflowAncestors(target2))
        );
      }
      function contains(parent2, child) {
        const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
        if (parent2.contains(child)) {
          return true;
        } else if (rootNode && isShadowRoot(rootNode)) {
          let next = child;
          do {
            if (next && parent2 === next) {
              return true;
            }
            next = next.parentNode || next.host;
          } while (next);
        }
        return false;
      }
      function getInnerBoundingClientRect(element, strategy) {
        const clientRect = getBoundingClientRect(element, false, strategy === "fixed");
        const top = clientRect.top + element.clientTop;
        const left = clientRect.left + element.clientLeft;
        return {
          top,
          left,
          x: left,
          y: top,
          right: left + element.clientWidth,
          bottom: top + element.clientHeight,
          width: element.clientWidth,
          height: element.clientHeight
        };
      }
      function getClientRectFromClippingAncestor(element, clippingParent, strategy) {
        if (clippingParent === "viewport") {
          return rectToClientRect(getViewportRect(element, strategy));
        }
        if (isElement(clippingParent)) {
          return getInnerBoundingClientRect(clippingParent, strategy);
        }
        return rectToClientRect(getDocumentRect(getDocumentElement(element)));
      }
      function getClippingAncestors(element) {
        const clippingAncestors = getOverflowAncestors(element);
        const canEscapeClipping = ["absolute", "fixed"].includes(getComputedStyle$1(element).position);
        const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
        if (!isElement(clipperElement)) {
          return [];
        }
        return clippingAncestors.filter((clippingAncestors2) => isElement(clippingAncestors2) && contains(clippingAncestors2, clipperElement) && getNodeName(clippingAncestors2) !== "body");
      }
      function getClippingRect(_ref) {
        let {
          element,
          boundary,
          rootBoundary,
          strategy
        } = _ref;
        const mainClippingAncestors = boundary === "clippingAncestors" ? getClippingAncestors(element) : [].concat(boundary);
        const clippingAncestors = [...mainClippingAncestors, rootBoundary];
        const firstClippingAncestor = clippingAncestors[0];
        const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
          const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
          accRect.top = max(rect.top, accRect.top);
          accRect.right = min(rect.right, accRect.right);
          accRect.bottom = min(rect.bottom, accRect.bottom);
          accRect.left = max(rect.left, accRect.left);
          return accRect;
        }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
        return {
          width: clippingRect.right - clippingRect.left,
          height: clippingRect.bottom - clippingRect.top,
          x: clippingRect.left,
          y: clippingRect.top
        };
      }
      const platform = {
        getClippingRect,
        convertOffsetParentRelativeRectToViewportRelativeRect,
        isElement,
        getDimensions,
        getOffsetParent,
        getDocumentElement,
        getElementRects: (_ref) => {
          let {
            reference,
            floating,
            strategy
          } = _ref;
          return {
            reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
            floating: {
              ...getDimensions(floating),
              x: 0,
              y: 0
            }
          };
        },
        getClientRects: (element) => Array.from(element.getClientRects()),
        isRTL: (element) => getComputedStyle$1(element).direction === "rtl"
      };
      function autoUpdate(reference, floating, update2, options) {
        if (options === void 0) {
          options = {};
        }
        const {
          ancestorScroll: _ancestorScroll = true,
          ancestorResize: _ancestorResize = true,
          elementResize = true,
          animationFrame = false
        } = options;
        const ancestorScroll = _ancestorScroll && !animationFrame;
        const ancestorResize = _ancestorResize && !animationFrame;
        const ancestors = ancestorScroll || ancestorResize ? [...isElement(reference) ? getOverflowAncestors(reference) : [], ...getOverflowAncestors(floating)] : [];
        ancestors.forEach((ancestor) => {
          ancestorScroll && ancestor.addEventListener("scroll", update2, {
            passive: true
          });
          ancestorResize && ancestor.addEventListener("resize", update2);
        });
        let observer = null;
        if (elementResize) {
          let initialUpdate = true;
          observer = new ResizeObserver(() => {
            if (!initialUpdate) {
              update2();
            }
            initialUpdate = false;
          });
          isElement(reference) && !animationFrame && observer.observe(reference);
          observer.observe(floating);
        }
        let frameId;
        let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
        if (animationFrame) {
          frameLoop();
        }
        function frameLoop() {
          const nextRefRect = getBoundingClientRect(reference);
          if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
            update2();
          }
          prevRefRect = nextRefRect;
          frameId = requestAnimationFrame(frameLoop);
        }
        update2();
        return () => {
          var _observer;
          ancestors.forEach((ancestor) => {
            ancestorScroll && ancestor.removeEventListener("scroll", update2);
            ancestorResize && ancestor.removeEventListener("resize", update2);
          });
          (_observer = observer) == null ? void 0 : _observer.disconnect();
          observer = null;
          if (animationFrame) {
            cancelAnimationFrame(frameId);
          }
        };
      }
      const computePosition = (reference, floating, options) => computePosition$1(reference, floating, {
        platform,
        ...options
      });
      const visualHiddenProps = buildProps({
        style: {
          type: definePropType([String, Object, Array]),
          default: () => ({})
        }
      });
      const __default__$q = defineComponent({
        name: "ElVisuallyHidden"
      });
      const _sfc_main$v = /* @__PURE__ */ defineComponent({
        ...__default__$q,
        props: visualHiddenProps,
        setup(__props) {
          const props2 = __props;
          const computedStyle = computed(() => {
            return [
              props2.style,
              {
                position: "absolute",
                border: 0,
                width: 1,
                height: 1,
                padding: 0,
                margin: -1,
                overflow: "hidden",
                clip: "rect(0, 0, 0, 0)",
                whiteSpace: "nowrap",
                wordWrap: "normal"
              }
            ];
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, { style: unref(computedStyle) }), [
              renderSlot(_ctx.$slots, "default")
            ], 16);
          };
        }
      });
      var ElVisuallyHidden = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__file", "visual-hidden.vue"]]);
      const __default__$p = defineComponent({
        name: "ElTooltipV2Content"
      });
      const _sfc_main$u = /* @__PURE__ */ defineComponent({
        ...__default__$p,
        props: { ...tooltipV2ContentProps, ...tooltipV2CommonProps },
        setup(__props) {
          const props2 = __props;
          const { triggerRef: triggerRef2, contentId } = inject(tooltipV2RootKey);
          const placement = ref(props2.placement);
          const strategy = ref(props2.strategy);
          const arrowRef = ref(null);
          const { referenceRef, contentRef, middlewareData, x: x2, y, update: update2 } = useFloating$1({
            placement,
            strategy,
            middleware: computed(() => {
              const middleware = [offset(props2.offset)];
              if (props2.showArrow) {
                middleware.push(arrowMiddleware({
                  arrowRef
                }));
              }
              return middleware;
            })
          });
          const zIndex2 = useZIndex().nextZIndex();
          const ns = useNamespace("tooltip-v2");
          const side = computed(() => {
            return placement.value.split("-")[0];
          });
          const contentStyle = computed(() => {
            return {
              position: unref(strategy),
              top: `${unref(y) || 0}px`,
              left: `${unref(x2) || 0}px`,
              zIndex: zIndex2
            };
          });
          const arrowStyle = computed(() => {
            if (!props2.showArrow)
              return {};
            const { arrow: arrow2 } = unref(middlewareData);
            return {
              [`--${ns.namespace.value}-tooltip-v2-arrow-x`]: `${arrow2 == null ? void 0 : arrow2.x}px` || "",
              [`--${ns.namespace.value}-tooltip-v2-arrow-y`]: `${arrow2 == null ? void 0 : arrow2.y}px` || ""
            };
          });
          const contentClass = computed(() => [
            ns.e("content"),
            ns.is("dark", props2.effect === "dark"),
            ns.is(unref(strategy)),
            props2.contentClass
          ]);
          watch(arrowRef, () => update2());
          watch(() => props2.placement, (val) => placement.value = val);
          onMounted(() => {
            watch(() => props2.reference || triggerRef2.value, (el) => {
              referenceRef.value = el || void 0;
            }, {
              immediate: true
            });
          });
          provide(tooltipV2ContentKey, { arrowRef });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "contentRef",
              ref: contentRef,
              style: normalizeStyle(unref(contentStyle)),
              "data-tooltip-v2-root": ""
            }, [
              !_ctx.nowrap ? (openBlock(), createElementBlock("div", {
                key: 0,
                "data-side": unref(side),
                class: normalizeClass(unref(contentClass))
              }, [
                renderSlot(_ctx.$slots, "default", {
                  contentStyle: unref(contentStyle),
                  contentClass: unref(contentClass)
                }),
                createVNode(unref(ElVisuallyHidden), {
                  id: unref(contentId),
                  role: "tooltip"
                }, {
                  default: withCtx(() => [
                    _ctx.ariaLabel ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      createTextVNode(toDisplayString(_ctx.ariaLabel), 1)
                    ], 64)) : renderSlot(_ctx.$slots, "default", { key: 1 })
                  ]),
                  _: 3
                }, 8, ["id"]),
                renderSlot(_ctx.$slots, "arrow", {
                  style: normalizeStyle(unref(arrowStyle)),
                  side: unref(side)
                })
              ], 10, ["data-side"])) : createCommentVNode("v-if", true)
            ], 4);
          };
        }
      });
      var TooltipV2Content = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__file", "content.vue"]]);
      const forwardRefProps = buildProps({
        setRef: {
          type: definePropType(Function),
          required: true
        },
        onlyChild: Boolean
      });
      var ForwardRef = defineComponent({
        props: forwardRefProps,
        setup(props2, {
          slots
        }) {
          const fragmentRef = ref();
          const setRef = composeRefs(fragmentRef, (el) => {
            if (el) {
              props2.setRef(el.nextElementSibling);
            } else {
              props2.setRef(null);
            }
          });
          return () => {
            var _a;
            const [firstChild] = ((_a = slots.default) == null ? void 0 : _a.call(slots)) || [];
            const child = props2.onlyChild ? ensureOnlyChild(firstChild.children) : firstChild.children;
            return createVNode(Fragment, {
              "ref": setRef
            }, [child]);
          };
        }
      });
      const __default__$o = defineComponent({
        name: "ElTooltipV2Trigger"
      });
      const _sfc_main$t = /* @__PURE__ */ defineComponent({
        ...__default__$o,
        props: {
          ...tooltipV2CommonProps,
          ...tooltipV2TriggerProps
        },
        setup(__props) {
          const props2 = __props;
          const { onClose, onOpen, onDelayOpen, triggerRef: triggerRef2, contentId } = inject(tooltipV2RootKey);
          let isMousedown = false;
          const setTriggerRef = (el) => {
            triggerRef2.value = el;
          };
          const onMouseup = () => {
            isMousedown = false;
          };
          const onMouseenter = composeEventHandlers(props2.onMouseEnter, onDelayOpen);
          const onMouseleave = composeEventHandlers(props2.onMouseLeave, onClose);
          const onMousedown = composeEventHandlers(props2.onMouseDown, () => {
            onClose();
            isMousedown = true;
            document.addEventListener("mouseup", onMouseup, { once: true });
          });
          const onFocus = composeEventHandlers(props2.onFocus, () => {
            if (!isMousedown)
              onOpen();
          });
          const onBlur = composeEventHandlers(props2.onBlur, onClose);
          const onClick = composeEventHandlers(props2.onClick, (e) => {
            if (e.detail === 0)
              onClose();
          });
          const events = {
            blur: onBlur,
            click: onClick,
            focus: onFocus,
            mousedown: onMousedown,
            mouseenter: onMouseenter,
            mouseleave: onMouseleave
          };
          const setEvents = (el, events2, type) => {
            if (el) {
              Object.entries(events2).forEach(([name, handler]) => {
                el[type](name, handler);
              });
            }
          };
          watch(triggerRef2, (triggerEl, previousTriggerEl) => {
            setEvents(triggerEl, events, "addEventListener");
            setEvents(previousTriggerEl, events, "removeEventListener");
            if (triggerEl) {
              triggerEl.setAttribute("aria-describedby", contentId.value);
            }
          });
          onBeforeUnmount(() => {
            setEvents(triggerRef2.value, events, "removeEventListener");
            document.removeEventListener("mouseup", onMouseup);
          });
          return (_ctx, _cache) => {
            return _ctx.nowrap ? (openBlock(), createBlock(unref(ForwardRef), {
              key: 0,
              "set-ref": setTriggerRef,
              "only-child": ""
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            })) : (openBlock(), createElementBlock("button", mergeProps({
              key: 1,
              ref_key: "triggerRef",
              ref: triggerRef2
            }, _ctx.$attrs), [
              renderSlot(_ctx.$slots, "default")
            ], 16));
          };
        }
      });
      var TooltipV2Trigger = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__file", "trigger.vue"]]);
      const __default__$n = defineComponent({
        name: "ElTooltipV2"
      });
      const _sfc_main$s = /* @__PURE__ */ defineComponent({
        ...__default__$n,
        props: tooltipV2Props,
        setup(__props) {
          const props2 = __props;
          const refedProps = toRefs(props2);
          const arrowProps = reactive(pick(refedProps, Object.keys(tooltipV2ArrowProps)));
          const contentProps = reactive(pick(refedProps, Object.keys(tooltipV2ContentProps)));
          const rootProps = reactive(pick(refedProps, Object.keys(tooltipV2RootProps)));
          const triggerProps = reactive(pick(refedProps, Object.keys(tooltipV2TriggerProps)));
          return (_ctx, _cache) => {
            return openBlock(), createBlock(TooltipV2Root, normalizeProps(guardReactiveProps(rootProps)), {
              default: withCtx(({ open }) => [
                createVNode(TooltipV2Trigger, mergeProps(triggerProps, { nowrap: "" }), {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "trigger")
                  ]),
                  _: 3
                }, 16),
                createVNode(unref(ElTeleport$1), {
                  to: _ctx.to,
                  disabled: !_ctx.teleported
                }, {
                  default: withCtx(() => [
                    _ctx.fullTransition ? (openBlock(), createBlock(Transition, normalizeProps(mergeProps({ key: 0 }, _ctx.transitionProps)), {
                      default: withCtx(() => [
                        _ctx.alwaysOn || open ? (openBlock(), createBlock(TooltipV2Content, normalizeProps(mergeProps({ key: 0 }, contentProps)), {
                          arrow: withCtx(({ style, side }) => [
                            _ctx.showArrow ? (openBlock(), createBlock(TooltipV2Arrow, mergeProps({ key: 0 }, arrowProps, {
                              style,
                              side
                            }), null, 16, ["style", "side"])) : createCommentVNode("v-if", true)
                          ]),
                          default: withCtx(() => [
                            renderSlot(_ctx.$slots, "default")
                          ]),
                          _: 3
                        }, 16)) : createCommentVNode("v-if", true)
                      ]),
                      _: 2
                    }, 1040)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      _ctx.alwaysOn || open ? (openBlock(), createBlock(TooltipV2Content, normalizeProps(mergeProps({ key: 0 }, contentProps)), {
                        arrow: withCtx(({ style, side }) => [
                          _ctx.showArrow ? (openBlock(), createBlock(TooltipV2Arrow, mergeProps({ key: 0 }, arrowProps, {
                            style,
                            side
                          }), null, 16, ["style", "side"])) : createCommentVNode("v-if", true)
                        ]),
                        default: withCtx(() => [
                          renderSlot(_ctx.$slots, "default")
                        ]),
                        _: 3
                      }, 16)) : createCommentVNode("v-if", true)
                    ], 64))
                  ]),
                  _: 2
                }, 1032, ["to", "disabled"])
              ]),
              _: 3
            }, 16);
          };
        }
      });
      var TooltipV2 = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__file", "tooltip.vue"]]);
      const ElTooltipV2 = withInstall(TooltipV2);
      const LEFT_CHECK_CHANGE_EVENT = exports("LEFT_CHECK_CHANGE_EVENT", "left-check-change");
      const RIGHT_CHECK_CHANGE_EVENT = exports("RIGHT_CHECK_CHANGE_EVENT", "right-check-change");
      const transferProps = exports("transferProps", buildProps({
        data: {
          type: definePropType(Array),
          default: () => []
        },
        titles: {
          type: definePropType(Array),
          default: () => []
        },
        buttonTexts: {
          type: definePropType(Array),
          default: () => []
        },
        filterPlaceholder: String,
        filterMethod: {
          type: definePropType(Function)
        },
        leftDefaultChecked: {
          type: definePropType(Array),
          default: () => []
        },
        rightDefaultChecked: {
          type: definePropType(Array),
          default: () => []
        },
        renderContent: {
          type: definePropType(Function)
        },
        modelValue: {
          type: definePropType(Array),
          default: () => []
        },
        format: {
          type: definePropType(Object),
          default: () => ({})
        },
        filterable: Boolean,
        props: {
          type: definePropType(Object),
          default: () => mutable({
            label: "label",
            key: "key",
            disabled: "disabled"
          })
        },
        targetOrder: {
          type: String,
          values: ["original", "push", "unshift"],
          default: "original"
        },
        validateEvent: {
          type: Boolean,
          default: true
        }
      }));
      const transferCheckedChangeFn = exports("transferCheckedChangeFn", (value, movedKeys) => [value, movedKeys].every(isArray$1) || isArray$1(value) && isNil(movedKeys));
      const transferEmits = exports("transferEmits", {
        [CHANGE_EVENT]: (value, direction2, movedKeys) => [value, movedKeys].every(isArray$1) && ["left", "right"].includes(direction2),
        [UPDATE_MODEL_EVENT]: (value) => isArray$1(value),
        [LEFT_CHECK_CHANGE_EVENT]: transferCheckedChangeFn,
        [RIGHT_CHECK_CHANGE_EVENT]: transferCheckedChangeFn
      });
      const CHECKED_CHANGE_EVENT = "checked-change";
      const transferPanelProps = buildProps({
        data: transferProps.data,
        optionRender: {
          type: definePropType(Function)
        },
        placeholder: String,
        title: String,
        filterable: Boolean,
        format: transferProps.format,
        filterMethod: transferProps.filterMethod,
        defaultChecked: transferProps.leftDefaultChecked,
        props: transferProps.props
      });
      const transferPanelEmits = {
        [CHECKED_CHANGE_EVENT]: transferCheckedChangeFn
      };
      const usePropsAlias = (props2) => {
        const initProps = {
          label: "label",
          key: "key",
          disabled: "disabled"
        };
        return computed(() => ({
          ...initProps,
          ...props2.props
        }));
      };
      const useCheck$1 = (props2, panelState, emit) => {
        const propsAlias = usePropsAlias(props2);
        const filteredData = computed(() => {
          return props2.data.filter((item) => {
            if (isFunction$1(props2.filterMethod)) {
              return props2.filterMethod(panelState.query, item);
            } else {
              const label = String(item[propsAlias.value.label] || item[propsAlias.value.key]);
              return label.toLowerCase().includes(panelState.query.toLowerCase());
            }
          });
        });
        const checkableData = computed(() => filteredData.value.filter((item) => !item[propsAlias.value.disabled]));
        const checkedSummary = computed(() => {
          const checkedLength = panelState.checked.length;
          const dataLength = props2.data.length;
          const { noChecked, hasChecked } = props2.format;
          if (noChecked && hasChecked) {
            return checkedLength > 0 ? hasChecked.replace(/\${checked}/g, checkedLength.toString()).replace(/\${total}/g, dataLength.toString()) : noChecked.replace(/\${total}/g, dataLength.toString());
          } else {
            return `${checkedLength}/${dataLength}`;
          }
        });
        const isIndeterminate = computed(() => {
          const checkedLength = panelState.checked.length;
          return checkedLength > 0 && checkedLength < checkableData.value.length;
        });
        const updateAllChecked = () => {
          const checkableDataKeys = checkableData.value.map((item) => item[propsAlias.value.key]);
          panelState.allChecked = checkableDataKeys.length > 0 && checkableDataKeys.every((item) => panelState.checked.includes(item));
        };
        const handleAllCheckedChange = (value) => {
          panelState.checked = value ? checkableData.value.map((item) => item[propsAlias.value.key]) : [];
        };
        watch(() => panelState.checked, (val, oldVal) => {
          updateAllChecked();
          if (panelState.checkChangeByUser) {
            const movedKeys = val.concat(oldVal).filter((v2) => !val.includes(v2) || !oldVal.includes(v2));
            emit(CHECKED_CHANGE_EVENT, val, movedKeys);
          } else {
            emit(CHECKED_CHANGE_EVENT, val);
            panelState.checkChangeByUser = true;
          }
        });
        watch(checkableData, () => {
          updateAllChecked();
        });
        watch(() => props2.data, () => {
          const checked = [];
          const filteredDataKeys = filteredData.value.map((item) => item[propsAlias.value.key]);
          panelState.checked.forEach((item) => {
            if (filteredDataKeys.includes(item)) {
              checked.push(item);
            }
          });
          panelState.checkChangeByUser = false;
          panelState.checked = checked;
        });
        watch(() => props2.defaultChecked, (val, oldVal) => {
          if (oldVal && val.length === oldVal.length && val.every((item) => oldVal.includes(item)))
            return;
          const checked = [];
          const checkableDataKeys = checkableData.value.map((item) => item[propsAlias.value.key]);
          val.forEach((item) => {
            if (checkableDataKeys.includes(item)) {
              checked.push(item);
            }
          });
          panelState.checkChangeByUser = false;
          panelState.checked = checked;
        }, {
          immediate: true
        });
        return {
          filteredData,
          checkableData,
          checkedSummary,
          isIndeterminate,
          updateAllChecked,
          handleAllCheckedChange
        };
      };
      const useCheckedChange = (checkedState, emit) => {
        const onSourceCheckedChange = (val, movedKeys) => {
          checkedState.leftChecked = val;
          if (!movedKeys)
            return;
          emit(LEFT_CHECK_CHANGE_EVENT, val, movedKeys);
        };
        const onTargetCheckedChange = (val, movedKeys) => {
          checkedState.rightChecked = val;
          if (!movedKeys)
            return;
          emit(RIGHT_CHECK_CHANGE_EVENT, val, movedKeys);
        };
        return {
          onSourceCheckedChange,
          onTargetCheckedChange
        };
      };
      const useComputedData = (props2) => {
        const propsAlias = usePropsAlias(props2);
        const dataObj = computed(() => props2.data.reduce((o2, cur) => (o2[cur[propsAlias.value.key]] = cur) && o2, {}));
        const sourceData = computed(() => props2.data.filter((item) => !props2.modelValue.includes(item[propsAlias.value.key])));
        const targetData = computed(() => {
          if (props2.targetOrder === "original") {
            return props2.data.filter((item) => props2.modelValue.includes(item[propsAlias.value.key]));
          } else {
            return props2.modelValue.reduce((arr, cur) => {
              const val = dataObj.value[cur];
              if (val) {
                arr.push(val);
              }
              return arr;
            }, []);
          }
        });
        return {
          sourceData,
          targetData
        };
      };
      const useMove = (props2, checkedState, emit) => {
        const propsAlias = usePropsAlias(props2);
        const _emit = (value, direction2, movedKeys) => {
          emit(UPDATE_MODEL_EVENT, value);
          emit(CHANGE_EVENT, value, direction2, movedKeys);
        };
        const addToLeft = () => {
          const currentValue = props2.modelValue.slice();
          checkedState.rightChecked.forEach((item) => {
            const index2 = currentValue.indexOf(item);
            if (index2 > -1) {
              currentValue.splice(index2, 1);
            }
          });
          _emit(currentValue, "left", checkedState.rightChecked);
        };
        const addToRight = () => {
          let currentValue = props2.modelValue.slice();
          const itemsToBeMoved = props2.data.filter((item) => {
            const itemKey = item[propsAlias.value.key];
            return checkedState.leftChecked.includes(itemKey) && !props2.modelValue.includes(itemKey);
          }).map((item) => item[propsAlias.value.key]);
          currentValue = props2.targetOrder === "unshift" ? itemsToBeMoved.concat(currentValue) : currentValue.concat(itemsToBeMoved);
          if (props2.targetOrder === "original") {
            currentValue = props2.data.filter((item) => currentValue.includes(item[propsAlias.value.key])).map((item) => item[propsAlias.value.key]);
          }
          _emit(currentValue, "right", checkedState.leftChecked);
        };
        return {
          addToLeft,
          addToRight
        };
      };
      const __default__$m = defineComponent({
        name: "ElTransferPanel"
      });
      const _sfc_main$r = /* @__PURE__ */ defineComponent({
        ...__default__$m,
        props: transferPanelProps,
        emits: transferPanelEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const slots = useSlots();
          const OptionContent = ({ option }) => option;
          const { t } = useLocale();
          const ns = useNamespace("transfer");
          const panelState = reactive({
            checked: [],
            allChecked: false,
            query: "",
            checkChangeByUser: true
          });
          const propsAlias = usePropsAlias(props2);
          const {
            filteredData,
            checkedSummary,
            isIndeterminate,
            handleAllCheckedChange
          } = useCheck$1(props2, panelState, emit);
          const hasNoMatch = computed(() => !isEmpty(panelState.query) && isEmpty(filteredData.value));
          const hasFooter = computed(() => !isEmpty(slots.default()[0].children));
          const { checked, allChecked, query } = toRefs(panelState);
          expose({
            query
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b("panel"))
            }, [
              createElementVNode("p", {
                class: normalizeClass(unref(ns).be("panel", "header"))
              }, [
                createVNode(unref(ElCheckbox), {
                  modelValue: unref(allChecked),
                  "onUpdate:modelValue": ($event) => isRef(allChecked) ? allChecked.value = $event : null,
                  indeterminate: unref(isIndeterminate),
                  "validate-event": false,
                  onChange: unref(handleAllCheckedChange)
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.title) + " ", 1),
                    createElementVNode("span", null, toDisplayString(unref(checkedSummary)), 1)
                  ]),
                  _: 1
                }, 8, ["modelValue", "onUpdate:modelValue", "indeterminate", "onChange"])
              ], 2),
              createElementVNode("div", {
                class: normalizeClass([unref(ns).be("panel", "body"), unref(ns).is("with-footer", unref(hasFooter))])
              }, [
                _ctx.filterable ? (openBlock(), createBlock(unref(ElInput), {
                  key: 0,
                  modelValue: unref(query),
                  "onUpdate:modelValue": ($event) => isRef(query) ? query.value = $event : null,
                  class: normalizeClass(unref(ns).be("panel", "filter")),
                  size: "default",
                  placeholder: _ctx.placeholder,
                  "prefix-icon": unref(search_default$1),
                  clearable: "",
                  "validate-event": false
                }, null, 8, ["modelValue", "onUpdate:modelValue", "class", "placeholder", "prefix-icon"])) : createCommentVNode("v-if", true),
                withDirectives(createVNode(unref(ElCheckboxGroup$1), {
                  modelValue: unref(checked),
                  "onUpdate:modelValue": ($event) => isRef(checked) ? checked.value = $event : null,
                  "validate-event": false,
                  class: normalizeClass([unref(ns).is("filterable", _ctx.filterable), unref(ns).be("panel", "list")])
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(filteredData), (item) => {
                      return openBlock(), createBlock(unref(ElCheckbox), {
                        key: item[unref(propsAlias).key],
                        class: normalizeClass(unref(ns).be("panel", "item")),
                        value: item[unref(propsAlias).key],
                        disabled: item[unref(propsAlias).disabled],
                        "validate-event": false
                      }, {
                        default: withCtx(() => {
                          var _a;
                          return [
                            createVNode(OptionContent, {
                              option: (_a = _ctx.optionRender) == null ? void 0 : _a.call(_ctx, item)
                            }, null, 8, ["option"])
                          ];
                        }),
                        _: 2
                      }, 1032, ["class", "value", "disabled"]);
                    }), 128))
                  ]),
                  _: 1
                }, 8, ["modelValue", "onUpdate:modelValue", "class"]), [
                  [vShow, !unref(hasNoMatch) && !unref(isEmpty)(_ctx.data)]
                ]),
                withDirectives(createElementVNode("div", {
                  class: normalizeClass(unref(ns).be("panel", "empty"))
                }, [
                  renderSlot(_ctx.$slots, "empty", {}, () => [
                    createTextVNode(toDisplayString(unref(hasNoMatch) ? unref(t)("el.transfer.noMatch") : unref(t)("el.transfer.noData")), 1)
                  ])
                ], 2), [
                  [vShow, unref(hasNoMatch) || unref(isEmpty)(_ctx.data)]
                ])
              ], 2),
              unref(hasFooter) ? (openBlock(), createElementBlock("p", {
                key: 0,
                class: normalizeClass(unref(ns).be("panel", "footer"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var TransferPanel = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__file", "transfer-panel.vue"]]);
      const __default__$l = defineComponent({
        name: "ElTransfer"
      });
      const _sfc_main$q = /* @__PURE__ */ defineComponent({
        ...__default__$l,
        props: transferProps,
        emits: transferEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const slots = useSlots();
          const { t } = useLocale();
          const ns = useNamespace("transfer");
          const { formItem } = useFormItem();
          const checkedState = reactive({
            leftChecked: [],
            rightChecked: []
          });
          const propsAlias = usePropsAlias(props2);
          const { sourceData, targetData } = useComputedData(props2);
          const { onSourceCheckedChange, onTargetCheckedChange } = useCheckedChange(checkedState, emit);
          const { addToLeft, addToRight } = useMove(props2, checkedState, emit);
          const leftPanel = ref();
          const rightPanel = ref();
          const clearQuery = (which) => {
            switch (which) {
              case "left":
                leftPanel.value.query = "";
                break;
              case "right":
                rightPanel.value.query = "";
                break;
            }
          };
          const hasButtonTexts = computed(() => props2.buttonTexts.length === 2);
          const leftPanelTitle = computed(() => props2.titles[0] || t("el.transfer.titles.0"));
          const rightPanelTitle = computed(() => props2.titles[1] || t("el.transfer.titles.1"));
          const panelFilterPlaceholder = computed(() => props2.filterPlaceholder || t("el.transfer.filterPlaceholder"));
          watch(() => props2.modelValue, () => {
            var _a;
            if (props2.validateEvent) {
              (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change").catch((err) => debugWarn());
            }
          });
          const optionRender = computed(() => (option) => {
            var _a;
            if (props2.renderContent)
              return props2.renderContent(h$1, option);
            const defaultSlotVNodes = (((_a = slots.default) == null ? void 0 : _a.call(slots, { option })) || []).filter((node) => node.type !== Comment);
            if (defaultSlotVNodes.length) {
              return defaultSlotVNodes;
            }
            return h$1("span", option[propsAlias.value.label] || option[propsAlias.value.key]);
          });
          expose({
            clearQuery,
            leftPanel,
            rightPanel
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).b())
            }, [
              createVNode(TransferPanel, {
                ref_key: "leftPanel",
                ref: leftPanel,
                data: unref(sourceData),
                "option-render": unref(optionRender),
                placeholder: unref(panelFilterPlaceholder),
                title: unref(leftPanelTitle),
                filterable: _ctx.filterable,
                format: _ctx.format,
                "filter-method": _ctx.filterMethod,
                "default-checked": _ctx.leftDefaultChecked,
                props: props2.props,
                onCheckedChange: unref(onSourceCheckedChange)
              }, {
                empty: withCtx(() => [
                  renderSlot(_ctx.$slots, "left-empty")
                ]),
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "left-footer")
                ]),
                _: 3
              }, 8, ["data", "option-render", "placeholder", "title", "filterable", "format", "filter-method", "default-checked", "props", "onCheckedChange"]),
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("buttons"))
              }, [
                createVNode(unref(ElButton), {
                  type: "primary",
                  class: normalizeClass([unref(ns).e("button"), unref(ns).is("with-texts", unref(hasButtonTexts))]),
                  disabled: unref(isEmpty)(checkedState.rightChecked),
                  onClick: unref(addToLeft)
                }, {
                  default: withCtx(() => [
                    createVNode(unref(ElIcon), null, {
                      default: withCtx(() => [
                        createVNode(unref(arrow_left_default$1))
                      ]),
                      _: 1
                    }),
                    !unref(isUndefined)(_ctx.buttonTexts[0]) ? (openBlock(), createElementBlock("span", { key: 0 }, toDisplayString(_ctx.buttonTexts[0]), 1)) : createCommentVNode("v-if", true)
                  ]),
                  _: 1
                }, 8, ["class", "disabled", "onClick"]),
                createVNode(unref(ElButton), {
                  type: "primary",
                  class: normalizeClass([unref(ns).e("button"), unref(ns).is("with-texts", unref(hasButtonTexts))]),
                  disabled: unref(isEmpty)(checkedState.leftChecked),
                  onClick: unref(addToRight)
                }, {
                  default: withCtx(() => [
                    !unref(isUndefined)(_ctx.buttonTexts[1]) ? (openBlock(), createElementBlock("span", { key: 0 }, toDisplayString(_ctx.buttonTexts[1]), 1)) : createCommentVNode("v-if", true),
                    createVNode(unref(ElIcon), null, {
                      default: withCtx(() => [
                        createVNode(unref(arrow_right_default$1))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["class", "disabled", "onClick"])
              ], 2),
              createVNode(TransferPanel, {
                ref_key: "rightPanel",
                ref: rightPanel,
                data: unref(targetData),
                "option-render": unref(optionRender),
                placeholder: unref(panelFilterPlaceholder),
                filterable: _ctx.filterable,
                format: _ctx.format,
                "filter-method": _ctx.filterMethod,
                title: unref(rightPanelTitle),
                "default-checked": _ctx.rightDefaultChecked,
                props: props2.props,
                onCheckedChange: unref(onTargetCheckedChange)
              }, {
                empty: withCtx(() => [
                  renderSlot(_ctx.$slots, "right-empty")
                ]),
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "right-footer")
                ]),
                _: 3
              }, 8, ["data", "option-render", "placeholder", "filterable", "format", "filter-method", "title", "default-checked", "props", "onCheckedChange"])
            ], 2);
          };
        }
      });
      var Transfer = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__file", "transfer.vue"]]);
      const ElTransfer = exports("ElTransfer", withInstall(Transfer));
      const NODE_KEY = "$treeNodeId";
      const markNodeData = function(node, data) {
        if (!data || data[NODE_KEY])
          return;
        Object.defineProperty(data, NODE_KEY, {
          value: node.id,
          enumerable: false,
          configurable: false,
          writable: false
        });
      };
      const getNodeKey = (key, data) => data == null ? void 0 : data[key || NODE_KEY];
      const handleCurrentChange = (store, emit, setCurrent) => {
        const preCurrentNode = store.value.currentNode;
        setCurrent();
        const currentNode = store.value.currentNode;
        if (preCurrentNode === currentNode)
          return;
        emit("current-change", currentNode ? currentNode.data : null, currentNode);
      };
      const getChildState = (node) => {
        let all = true;
        let none = true;
        let allWithoutDisable = true;
        for (let i = 0, j = node.length; i < j; i++) {
          const n = node[i];
          if (n.checked !== true || n.indeterminate) {
            all = false;
            if (!n.disabled) {
              allWithoutDisable = false;
            }
          }
          if (n.checked !== false || n.indeterminate) {
            none = false;
          }
        }
        return { all, none, allWithoutDisable, half: !all && !none };
      };
      const reInitChecked = function(node) {
        if (node.childNodes.length === 0 || node.loading)
          return;
        const { all, none, half } = getChildState(node.childNodes);
        if (all) {
          node.checked = true;
          node.indeterminate = false;
        } else if (half) {
          node.checked = false;
          node.indeterminate = true;
        } else if (none) {
          node.checked = false;
          node.indeterminate = false;
        }
        const parent2 = node.parent;
        if (!parent2 || parent2.level === 0)
          return;
        if (!node.store.checkStrictly) {
          reInitChecked(parent2);
        }
      };
      const getPropertyFromData = function(node, prop) {
        const props2 = node.store.props;
        const data = node.data || {};
        const config = props2[prop];
        if (isFunction$1(config)) {
          return config(data, node);
        } else if (isString$1(config)) {
          return data[config];
        } else if (isUndefined(config)) {
          const dataProp = data[prop];
          return isUndefined(dataProp) ? "" : dataProp;
        }
      };
      const setCanFocus = function(childNodes, focus) {
        childNodes.forEach((item) => {
          item.canFocus = focus;
          setCanFocus(item.childNodes, focus);
        });
      };
      let nodeIdSeed = 0;
      class Node$1 {
        constructor(options) {
          this.isLeafByUser = void 0;
          this.isLeaf = void 0;
          this.id = nodeIdSeed++;
          this.text = null;
          this.checked = false;
          this.indeterminate = false;
          this.data = null;
          this.expanded = false;
          this.parent = null;
          this.visible = true;
          this.isCurrent = false;
          this.canFocus = false;
          for (const name in options) {
            if (hasOwn(options, name)) {
              this[name] = options[name];
            }
          }
          this.level = 0;
          this.loaded = false;
          this.childNodes = [];
          this.loading = false;
          if (this.parent) {
            this.level = this.parent.level + 1;
          }
        }
        initialize() {
          var _a;
          const store = this.store;
          if (!store) {
            throw new Error("[Node]store is required!");
          }
          store.registerNode(this);
          const props2 = store.props;
          if (props2 && typeof props2.isLeaf !== "undefined") {
            const isLeaf2 = getPropertyFromData(this, "isLeaf");
            if (isBoolean(isLeaf2)) {
              this.isLeafByUser = isLeaf2;
            }
          }
          if (store.lazy !== true && this.data) {
            this.setData(this.data);
            if (store.defaultExpandAll) {
              this.expanded = true;
              this.canFocus = true;
            }
          } else if (this.level > 0 && store.lazy && store.defaultExpandAll && !this.isLeafByUser) {
            this.expand();
          }
          if (!isArray$1(this.data)) {
            markNodeData(this, this.data);
          }
          if (!this.data)
            return;
          const defaultExpandedKeys = store.defaultExpandedKeys;
          const key = store.key;
          if (key && !isNil(this.key) && defaultExpandedKeys && defaultExpandedKeys.includes(this.key)) {
            this.expand(null, store.autoExpandParent);
          }
          if (key && store.currentNodeKey !== void 0 && this.key === store.currentNodeKey) {
            store.currentNode = this;
            store.currentNode.isCurrent = true;
          }
          if (store.lazy) {
            store._initDefaultCheckedNode(this);
          }
          this.updateLeafState();
          if (this.level === 1 || ((_a = this.parent) == null ? void 0 : _a.expanded) === true)
            this.canFocus = true;
        }
        setData(data) {
          if (!isArray$1(data)) {
            markNodeData(this, data);
          }
          this.data = data;
          this.childNodes = [];
          let children;
          if (this.level === 0 && isArray$1(this.data)) {
            children = this.data;
          } else {
            children = getPropertyFromData(this, "children") || [];
          }
          for (let i = 0, j = children.length; i < j; i++) {
            this.insertChild({ data: children[i] });
          }
        }
        get label() {
          return getPropertyFromData(this, "label");
        }
        get key() {
          const nodeKey = this.store.key;
          if (this.data)
            return this.data[nodeKey];
          return null;
        }
        get disabled() {
          return getPropertyFromData(this, "disabled");
        }
        get nextSibling() {
          const parent2 = this.parent;
          if (parent2) {
            const index2 = parent2.childNodes.indexOf(this);
            if (index2 > -1) {
              return parent2.childNodes[index2 + 1];
            }
          }
          return null;
        }
        get previousSibling() {
          const parent2 = this.parent;
          if (parent2) {
            const index2 = parent2.childNodes.indexOf(this);
            if (index2 > -1) {
              return index2 > 0 ? parent2.childNodes[index2 - 1] : null;
            }
          }
          return null;
        }
        contains(target2, deep = true) {
          return (this.childNodes || []).some((child) => child === target2 || deep && child.contains(target2));
        }
        remove() {
          const parent2 = this.parent;
          if (parent2) {
            parent2.removeChild(this);
          }
        }
        insertChild(child, index2, batch) {
          if (!child)
            throw new Error("InsertChild error: child is required.");
          if (!(child instanceof Node$1)) {
            if (!batch) {
              const children = this.getChildren(true);
              if (!(children == null ? void 0 : children.includes(child.data))) {
                if (isUndefined(index2) || index2 < 0) {
                  children == null ? void 0 : children.push(child.data);
                } else {
                  children == null ? void 0 : children.splice(index2, 0, child.data);
                }
              }
            }
            Object.assign(child, {
              parent: this,
              store: this.store
            });
            child = reactive(new Node$1(child));
            if (child instanceof Node$1) {
              child.initialize();
            }
          }
          child.level = this.level + 1;
          if (isUndefined(index2) || index2 < 0) {
            this.childNodes.push(child);
          } else {
            this.childNodes.splice(index2, 0, child);
          }
          this.updateLeafState();
        }
        insertBefore(child, ref2) {
          let index2;
          if (ref2) {
            index2 = this.childNodes.indexOf(ref2);
          }
          this.insertChild(child, index2);
        }
        insertAfter(child, ref2) {
          let index2;
          if (ref2) {
            index2 = this.childNodes.indexOf(ref2);
            if (index2 !== -1)
              index2 += 1;
          }
          this.insertChild(child, index2);
        }
        removeChild(child) {
          const children = this.getChildren() || [];
          const dataIndex = children.indexOf(child.data);
          if (dataIndex > -1) {
            children.splice(dataIndex, 1);
          }
          const index2 = this.childNodes.indexOf(child);
          if (index2 > -1) {
            this.store && this.store.deregisterNode(child);
            child.parent = null;
            this.childNodes.splice(index2, 1);
          }
          this.updateLeafState();
        }
        removeChildByData(data) {
          let targetNode = null;
          for (let i = 0; i < this.childNodes.length; i++) {
            if (this.childNodes[i].data === data) {
              targetNode = this.childNodes[i];
              break;
            }
          }
          if (targetNode) {
            this.removeChild(targetNode);
          }
        }
        expand(callback, expandParent) {
          const done = () => {
            if (expandParent) {
              let parent2 = this.parent;
              while (parent2 && parent2.level > 0) {
                parent2.expanded = true;
                parent2 = parent2.parent;
              }
            }
            this.expanded = true;
            if (callback)
              callback();
            setCanFocus(this.childNodes, true);
          };
          if (this.shouldLoadData()) {
            this.loadData((data) => {
              if (isArray$1(data)) {
                if (this.checked) {
                  this.setChecked(true, true);
                } else if (!this.store.checkStrictly) {
                  reInitChecked(this);
                }
                done();
              }
            });
          } else {
            done();
          }
        }
        doCreateChildren(array3, defaultProps2 = {}) {
          array3.forEach((item) => {
            this.insertChild(Object.assign({ data: item }, defaultProps2), void 0, true);
          });
        }
        collapse() {
          this.expanded = false;
          setCanFocus(this.childNodes, false);
        }
        shouldLoadData() {
          return Boolean(this.store.lazy === true && this.store.load && !this.loaded);
        }
        updateLeafState() {
          if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== "undefined") {
            this.isLeaf = this.isLeafByUser;
            return;
          }
          const childNodes = this.childNodes;
          if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {
            this.isLeaf = !childNodes || childNodes.length === 0;
            return;
          }
          this.isLeaf = false;
        }
        setChecked(value, deep, recursion, passValue) {
          this.indeterminate = value === "half";
          this.checked = value === true;
          if (this.store.checkStrictly)
            return;
          if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
            const { all, allWithoutDisable } = getChildState(this.childNodes);
            if (!this.isLeaf && !all && allWithoutDisable) {
              this.checked = false;
              value = false;
            }
            const handleDescendants = () => {
              if (deep) {
                const childNodes = this.childNodes;
                for (let i = 0, j = childNodes.length; i < j; i++) {
                  const child = childNodes[i];
                  passValue = passValue || value !== false;
                  const isCheck = child.disabled ? child.checked : passValue;
                  child.setChecked(isCheck, deep, true, passValue);
                }
                const { half, all: all2 } = getChildState(childNodes);
                if (!all2) {
                  this.checked = all2;
                  this.indeterminate = half;
                }
              }
            };
            if (this.shouldLoadData()) {
              this.loadData(() => {
                handleDescendants();
                reInitChecked(this);
              }, {
                checked: value !== false
              });
              return;
            } else {
              handleDescendants();
            }
          }
          const parent2 = this.parent;
          if (!parent2 || parent2.level === 0)
            return;
          if (!recursion) {
            reInitChecked(parent2);
          }
        }
        getChildren(forceInit = false) {
          if (this.level === 0)
            return this.data;
          const data = this.data;
          if (!data)
            return null;
          const props2 = this.store.props;
          let children = "children";
          if (props2) {
            children = props2.children || "children";
          }
          if (isUndefined(data[children])) {
            data[children] = null;
          }
          if (forceInit && !data[children]) {
            data[children] = [];
          }
          return data[children];
        }
        updateChildren() {
          const newData = this.getChildren() || [];
          const oldData = this.childNodes.map((node) => node.data);
          const newDataMap = {};
          const newNodes = [];
          newData.forEach((item, index2) => {
            const key = item[NODE_KEY];
            const isNodeExists = !!key && oldData.findIndex((data) => (data == null ? void 0 : data[NODE_KEY]) === key) >= 0;
            if (isNodeExists) {
              newDataMap[key] = { index: index2, data: item };
            } else {
              newNodes.push({ index: index2, data: item });
            }
          });
          if (!this.store.lazy) {
            oldData.forEach((item) => {
              if (!newDataMap[item == null ? void 0 : item[NODE_KEY]])
                this.removeChildByData(item);
            });
          }
          newNodes.forEach(({ index: index2, data }) => {
            this.insertChild({ data }, index2);
          });
          this.updateLeafState();
        }
        loadData(callback, defaultProps2 = {}) {
          if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps2).length)) {
            this.loading = true;
            const resolve = (children) => {
              this.childNodes = [];
              this.doCreateChildren(children, defaultProps2);
              this.loaded = true;
              this.loading = false;
              this.updateLeafState();
              if (callback) {
                callback.call(this, children);
              }
            };
            const reject2 = () => {
              this.loading = false;
            };
            this.store.load(this, resolve, reject2);
          } else {
            if (callback) {
              callback.call(this);
            }
          }
        }
        eachNode(callback) {
          const arr = [this];
          while (arr.length) {
            const node = arr.shift();
            arr.unshift(...node.childNodes);
            callback(node);
          }
        }
        reInitChecked() {
          if (this.store.checkStrictly)
            return;
          reInitChecked(this);
        }
      }
      var Node$2 = Node$1;
      class TreeStore {
        constructor(options) {
          this.lazy = false;
          this.checkStrictly = false;
          this.autoExpandParent = false;
          this.defaultExpandAll = false;
          this.checkDescendants = false;
          this.currentNode = null;
          this.currentNodeKey = null;
          for (const option in options) {
            if (hasOwn(options, option)) {
              this[option] = options[option];
            }
          }
          this.nodesMap = {};
        }
        initialize() {
          this.root = new Node$2({
            data: this.data,
            store: this
          });
          this.root.initialize();
          if (this.lazy && this.load) {
            const loadFn = this.load;
            loadFn(this.root, (data) => {
              this.root.doCreateChildren(data);
              this._initDefaultCheckedNodes();
            }, NOOP);
          } else {
            this._initDefaultCheckedNodes();
          }
        }
        filter(value) {
          const filterNodeMethod = this.filterNodeMethod;
          const lazy = this.lazy;
          const traverse = async function(node) {
            const childNodes = node.root ? node.root.childNodes : node.childNodes;
            for (const [index2, child] of childNodes.entries()) {
              child.visible = !!(filterNodeMethod == null ? void 0 : filterNodeMethod.call(child, value, child.data, child));
              if (index2 % 80 === 0 && index2 > 0) {
                await nextTick();
              }
              await traverse(child);
            }
            if (!node.visible && childNodes.length) {
              let allHidden = true;
              allHidden = !childNodes.some((child) => child.visible);
              if (node.root) {
                node.root.visible = allHidden === false;
              } else {
                node.visible = allHidden === false;
              }
            }
            if (!value)
              return;
            if (node.visible && !node.isLeaf) {
              if (!lazy || node.loaded) {
                node.expand();
              }
            }
          };
          traverse(this);
        }
        setData(newVal) {
          const instanceChanged = newVal !== this.root.data;
          if (instanceChanged) {
            this.nodesMap = {};
            this.root.setData(newVal);
            this._initDefaultCheckedNodes();
            this.setCurrentNodeKey(this.currentNodeKey);
          } else {
            this.root.updateChildren();
          }
        }
        getNode(data) {
          if (data instanceof Node$2)
            return data;
          const key = isObject$1(data) ? getNodeKey(this.key, data) : data;
          return this.nodesMap[key] || null;
        }
        insertBefore(data, refData) {
          var _a;
          const refNode = this.getNode(refData);
          (_a = refNode.parent) == null ? void 0 : _a.insertBefore({ data }, refNode);
        }
        insertAfter(data, refData) {
          var _a;
          const refNode = this.getNode(refData);
          (_a = refNode.parent) == null ? void 0 : _a.insertAfter({ data }, refNode);
        }
        remove(data) {
          const node = this.getNode(data);
          if (node && node.parent) {
            if (node === this.currentNode) {
              this.currentNode = null;
            }
            node.parent.removeChild(node);
          }
        }
        append(data, parentData) {
          const parentNode = !isPropAbsent(parentData) ? this.getNode(parentData) : this.root;
          if (parentNode) {
            parentNode.insertChild({ data });
          }
        }
        _initDefaultCheckedNodes() {
          const defaultCheckedKeys = this.defaultCheckedKeys || [];
          const nodesMap = this.nodesMap;
          defaultCheckedKeys.forEach((checkedKey) => {
            const node = nodesMap[checkedKey];
            if (node) {
              node.setChecked(true, !this.checkStrictly);
            }
          });
        }
        _initDefaultCheckedNode(node) {
          const defaultCheckedKeys = this.defaultCheckedKeys || [];
          if (!isNil(node.key) && defaultCheckedKeys.includes(node.key)) {
            node.setChecked(true, !this.checkStrictly);
          }
        }
        setDefaultCheckedKey(newVal) {
          if (newVal !== this.defaultCheckedKeys) {
            this.defaultCheckedKeys = newVal;
            this._initDefaultCheckedNodes();
          }
        }
        registerNode(node) {
          const key = this.key;
          if (!node || !node.data)
            return;
          if (!key) {
            this.nodesMap[node.id] = node;
          } else {
            const nodeKey = node.key;
            if (!isNil(nodeKey))
              this.nodesMap[nodeKey] = node;
          }
        }
        deregisterNode(node) {
          const key = this.key;
          if (!key || !node || !node.data)
            return;
          node.childNodes.forEach((child) => {
            this.deregisterNode(child);
          });
          delete this.nodesMap[node.key];
        }
        getCheckedNodes(leafOnly = false, includeHalfChecked = false) {
          const checkedNodes = [];
          const traverse = function(node) {
            const childNodes = node.root ? node.root.childNodes : node.childNodes;
            childNodes.forEach((child) => {
              if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {
                checkedNodes.push(child.data);
              }
              traverse(child);
            });
          };
          traverse(this);
          return checkedNodes;
        }
        getCheckedKeys(leafOnly = false) {
          return this.getCheckedNodes(leafOnly).map((data) => (data || {})[this.key]);
        }
        getHalfCheckedNodes() {
          const nodes = [];
          const traverse = function(node) {
            const childNodes = node.root ? node.root.childNodes : node.childNodes;
            childNodes.forEach((child) => {
              if (child.indeterminate) {
                nodes.push(child.data);
              }
              traverse(child);
            });
          };
          traverse(this);
          return nodes;
        }
        getHalfCheckedKeys() {
          return this.getHalfCheckedNodes().map((data) => (data || {})[this.key]);
        }
        _getAllNodes() {
          const allNodes = [];
          const nodesMap = this.nodesMap;
          for (const nodeKey in nodesMap) {
            if (hasOwn(nodesMap, nodeKey)) {
              allNodes.push(nodesMap[nodeKey]);
            }
          }
          return allNodes;
        }
        updateChildren(key, data) {
          const node = this.nodesMap[key];
          if (!node)
            return;
          const childNodes = node.childNodes;
          for (let i = childNodes.length - 1; i >= 0; i--) {
            const child = childNodes[i];
            this.remove(child.data);
          }
          for (let i = 0, j = data.length; i < j; i++) {
            const child = data[i];
            this.append(child, node.data);
          }
        }
        _setCheckedKeys(key, leafOnly = false, checkedKeys) {
          const allNodes = this._getAllNodes().sort((a2, b2) => a2.level - b2.level);
          const cache2 = /* @__PURE__ */ Object.create(null);
          const keys2 = Object.keys(checkedKeys);
          allNodes.forEach((node) => node.setChecked(false, false));
          const cacheCheckedChild = (node) => {
            node.childNodes.forEach((child) => {
              var _a;
              cache2[child.data[key]] = true;
              if ((_a = child.childNodes) == null ? void 0 : _a.length) {
                cacheCheckedChild(child);
              }
            });
          };
          for (let i = 0, j = allNodes.length; i < j; i++) {
            const node = allNodes[i];
            const nodeKey = node.data[key].toString();
            const checked = keys2.includes(nodeKey);
            if (!checked) {
              if (node.checked && !cache2[nodeKey]) {
                node.setChecked(false, false);
              }
              continue;
            }
            if (node.childNodes.length) {
              cacheCheckedChild(node);
            }
            if (node.isLeaf || this.checkStrictly) {
              node.setChecked(true, false);
              continue;
            }
            node.setChecked(true, true);
            if (leafOnly) {
              node.setChecked(false, false);
              const traverse = function(node2) {
                const childNodes = node2.childNodes;
                childNodes.forEach((child) => {
                  if (!child.isLeaf) {
                    child.setChecked(false, false);
                  }
                  traverse(child);
                });
              };
              traverse(node);
            }
          }
        }
        setCheckedNodes(array3, leafOnly = false) {
          const key = this.key;
          const checkedKeys = {};
          array3.forEach((item) => {
            checkedKeys[(item || {})[key]] = true;
          });
          this._setCheckedKeys(key, leafOnly, checkedKeys);
        }
        setCheckedKeys(keys2, leafOnly = false) {
          this.defaultCheckedKeys = keys2;
          const key = this.key;
          const checkedKeys = {};
          keys2.forEach((key2) => {
            checkedKeys[key2] = true;
          });
          this._setCheckedKeys(key, leafOnly, checkedKeys);
        }
        setDefaultExpandedKeys(keys2) {
          keys2 = keys2 || [];
          this.defaultExpandedKeys = keys2;
          keys2.forEach((key) => {
            const node = this.getNode(key);
            if (node)
              node.expand(null, this.autoExpandParent);
          });
        }
        setChecked(data, checked, deep) {
          const node = this.getNode(data);
          if (node) {
            node.setChecked(!!checked, deep);
          }
        }
        getCurrentNode() {
          return this.currentNode;
        }
        setCurrentNode(currentNode) {
          const prevCurrentNode = this.currentNode;
          if (prevCurrentNode) {
            prevCurrentNode.isCurrent = false;
          }
          this.currentNode = currentNode;
          this.currentNode.isCurrent = true;
        }
        setUserCurrentNode(node, shouldAutoExpandParent = true) {
          var _a;
          const key = node[this.key];
          const currNode = this.nodesMap[key];
          this.setCurrentNode(currNode);
          if (shouldAutoExpandParent && this.currentNode && this.currentNode.level > 1) {
            (_a = this.currentNode.parent) == null ? void 0 : _a.expand(null, true);
          }
        }
        setCurrentNodeKey(key, shouldAutoExpandParent = true) {
          var _a;
          this.currentNodeKey = key;
          if (isPropAbsent(key)) {
            this.currentNode && (this.currentNode.isCurrent = false);
            this.currentNode = null;
            return;
          }
          const node = this.getNode(key);
          if (node) {
            this.setCurrentNode(node);
            if (shouldAutoExpandParent && this.currentNode && this.currentNode.level > 1) {
              (_a = this.currentNode.parent) == null ? void 0 : _a.expand(null, true);
            }
          }
        }
      }
      const ROOT_TREE_INJECTION_KEY$1 = exports("ROOT_TREE_INJECTION_KEY", "RootTree");
      const NODE_INSTANCE_INJECTION_KEY = exports("NODE_INSTANCE_INJECTION_KEY", "NodeInstance");
      const TREE_NODE_MAP_INJECTION_KEY = exports("TREE_NODE_MAP_INJECTION_KEY", "TreeNodeMap");
      const _sfc_main$p = defineComponent({
        name: "ElTreeNodeContent",
        props: {
          node: {
            type: Object,
            required: true
          },
          renderContent: Function
        },
        setup(props2) {
          const ns = useNamespace("tree");
          const nodeInstance = inject(NODE_INSTANCE_INJECTION_KEY);
          const tree = inject(ROOT_TREE_INJECTION_KEY$1);
          return () => {
            const node = props2.node;
            const { data, store } = node;
            return props2.renderContent ? props2.renderContent(h$1, { _self: nodeInstance, node, data, store }) : renderSlot(tree.ctx.slots, "default", { node, data }, () => [
              h$1(ElText, { tag: "span", truncated: true, class: ns.be("node", "label") }, () => [node.label])
            ]);
          };
        }
      });
      var NodeContent = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__file", "tree-node-content.vue"]]);
      function useNodeExpandEventBroadcast(props2) {
        const parentNodeMap = inject(TREE_NODE_MAP_INJECTION_KEY, null);
        const currentNodeMap = {
          treeNodeExpand: (node) => {
            var _a;
            if (props2.node !== node) {
              (_a = props2.node) == null ? void 0 : _a.collapse();
            }
          },
          children: []
        };
        if (parentNodeMap) {
          parentNodeMap.children.push(currentNodeMap);
        }
        provide(TREE_NODE_MAP_INJECTION_KEY, currentNodeMap);
        return {
          broadcastExpanded: (node) => {
            if (!props2.accordion)
              return;
            for (const childNode of currentNodeMap.children) {
              childNode.treeNodeExpand(node);
            }
          }
        };
      }
      const dragEventsKey = Symbol("dragEvents");
      function useDragNodeHandler({
        props: props2,
        ctx,
        el$,
        dropIndicator$,
        store
      }) {
        const ns = useNamespace("tree");
        const dragState = ref({
          showDropIndicator: false,
          draggingNode: null,
          dropNode: null,
          allowDrop: true,
          dropType: null
        });
        const treeNodeDragStart = ({ event, treeNode }) => {
          if (!event.dataTransfer)
            return;
          if (isFunction$1(props2.allowDrag) && !props2.allowDrag(treeNode.node)) {
            event.preventDefault();
            return false;
          }
          event.dataTransfer.effectAllowed = "move";
          try {
            event.dataTransfer.setData("text/plain", "");
          } catch (e) {
          }
          dragState.value.draggingNode = treeNode;
          ctx.emit("node-drag-start", treeNode.node, event);
        };
        const treeNodeDragOver = ({ event, treeNode }) => {
          if (!event.dataTransfer)
            return;
          const dropNode = treeNode;
          const oldDropNode = dragState.value.dropNode;
          if (oldDropNode && oldDropNode.node.id !== dropNode.node.id) {
            removeClass(oldDropNode.$el, ns.is("drop-inner"));
          }
          const draggingNode = dragState.value.draggingNode;
          if (!draggingNode || !dropNode)
            return;
          let dropPrev = true;
          let dropInner = true;
          let dropNext = true;
          let userAllowDropInner = true;
          if (isFunction$1(props2.allowDrop)) {
            dropPrev = props2.allowDrop(draggingNode.node, dropNode.node, "prev");
            userAllowDropInner = dropInner = props2.allowDrop(draggingNode.node, dropNode.node, "inner");
            dropNext = props2.allowDrop(draggingNode.node, dropNode.node, "next");
          }
          event.dataTransfer.dropEffect = dropInner || dropPrev || dropNext ? "move" : "none";
          if ((dropPrev || dropInner || dropNext) && (oldDropNode == null ? void 0 : oldDropNode.node.id) !== dropNode.node.id) {
            if (oldDropNode) {
              ctx.emit("node-drag-leave", draggingNode.node, oldDropNode.node, event);
            }
            ctx.emit("node-drag-enter", draggingNode.node, dropNode.node, event);
          }
          if (dropPrev || dropInner || dropNext) {
            dragState.value.dropNode = dropNode;
          } else {
            dragState.value.dropNode = null;
          }
          if (dropNode.node.nextSibling === draggingNode.node) {
            dropNext = false;
          }
          if (dropNode.node.previousSibling === draggingNode.node) {
            dropPrev = false;
          }
          if (dropNode.node.contains(draggingNode.node, false)) {
            dropInner = false;
          }
          if (draggingNode.node === dropNode.node || draggingNode.node.contains(dropNode.node)) {
            dropPrev = false;
            dropInner = false;
            dropNext = false;
          }
          const dropEl = dropNode.$el;
          const targetPosition = dropEl.querySelector(`.${ns.be("node", "content")}`).getBoundingClientRect();
          const treePosition = el$.value.getBoundingClientRect();
          let dropType;
          const prevPercent = dropPrev ? dropInner ? 0.25 : dropNext ? 0.45 : 1 : -1;
          const nextPercent = dropNext ? dropInner ? 0.75 : dropPrev ? 0.55 : 0 : 1;
          let indicatorTop = -9999;
          const distance = event.clientY - targetPosition.top;
          if (distance < targetPosition.height * prevPercent) {
            dropType = "before";
          } else if (distance > targetPosition.height * nextPercent) {
            dropType = "after";
          } else if (dropInner) {
            dropType = "inner";
          } else {
            dropType = "none";
          }
          const iconPosition = dropEl.querySelector(`.${ns.be("node", "expand-icon")}`).getBoundingClientRect();
          const dropIndicator = dropIndicator$.value;
          if (dropType === "before") {
            indicatorTop = iconPosition.top - treePosition.top;
          } else if (dropType === "after") {
            indicatorTop = iconPosition.bottom - treePosition.top;
          }
          dropIndicator.style.top = `${indicatorTop}px`;
          dropIndicator.style.left = `${iconPosition.right - treePosition.left}px`;
          if (dropType === "inner") {
            addClass(dropEl, ns.is("drop-inner"));
          } else {
            removeClass(dropEl, ns.is("drop-inner"));
          }
          dragState.value.showDropIndicator = dropType === "before" || dropType === "after";
          dragState.value.allowDrop = dragState.value.showDropIndicator || userAllowDropInner;
          dragState.value.dropType = dropType;
          ctx.emit("node-drag-over", draggingNode.node, dropNode.node, event);
        };
        const treeNodeDragEnd = (event) => {
          var _a, _b;
          const { draggingNode, dropType, dropNode } = dragState.value;
          event.preventDefault();
          if (event.dataTransfer) {
            event.dataTransfer.dropEffect = "move";
          }
          if ((draggingNode == null ? void 0 : draggingNode.node.data) && dropNode) {
            const draggingNodeCopy = { data: draggingNode.node.data };
            if (dropType !== "none") {
              draggingNode.node.remove();
            }
            if (dropType === "before") {
              (_a = dropNode.node.parent) == null ? void 0 : _a.insertBefore(draggingNodeCopy, dropNode.node);
            } else if (dropType === "after") {
              (_b = dropNode.node.parent) == null ? void 0 : _b.insertAfter(draggingNodeCopy, dropNode.node);
            } else if (dropType === "inner") {
              dropNode.node.insertChild(draggingNodeCopy);
            }
            if (dropType !== "none") {
              store.value.registerNode(draggingNodeCopy);
              if (store.value.key) {
                draggingNode.node.eachNode((node) => {
                  var _a2;
                  (_a2 = store.value.nodesMap[node.data[store.value.key]]) == null ? void 0 : _a2.setChecked(node.checked, !store.value.checkStrictly);
                });
              }
            }
            removeClass(dropNode.$el, ns.is("drop-inner"));
            ctx.emit("node-drag-end", draggingNode.node, dropNode.node, dropType, event);
            if (dropType !== "none") {
              ctx.emit("node-drop", draggingNode.node, dropNode.node, dropType, event);
            }
          }
          if (draggingNode && !dropNode) {
            ctx.emit("node-drag-end", draggingNode.node, null, dropType, event);
          }
          dragState.value.showDropIndicator = false;
          dragState.value.draggingNode = null;
          dragState.value.dropNode = null;
          dragState.value.allowDrop = true;
        };
        provide(dragEventsKey, {
          treeNodeDragStart,
          treeNodeDragOver,
          treeNodeDragEnd
        });
        return {
          dragState
        };
      }
      const _sfc_main$o = defineComponent({
        name: "ElTreeNode",
        components: {
          ElCollapseTransition,
          ElCheckbox,
          NodeContent,
          ElIcon,
          Loading: loading_default$1
        },
        props: {
          node: {
            type: Node$2,
            default: () => ({})
          },
          props: {
            type: Object,
            default: () => ({})
          },
          accordion: Boolean,
          renderContent: Function,
          renderAfterExpand: Boolean,
          showCheckbox: Boolean
        },
        emits: ["node-expand"],
        setup(props2, ctx) {
          const ns = useNamespace("tree");
          const { broadcastExpanded } = useNodeExpandEventBroadcast(props2);
          const tree = inject(ROOT_TREE_INJECTION_KEY$1);
          const expanded = ref(false);
          const childNodeRendered = ref(false);
          const oldChecked = ref();
          const oldIndeterminate = ref();
          const node$ = ref();
          const dragEvents = inject(dragEventsKey);
          const instance = getCurrentInstance();
          provide(NODE_INSTANCE_INJECTION_KEY, instance);
          if (props2.node.expanded) {
            expanded.value = true;
            childNodeRendered.value = true;
          }
          const childrenKey = tree.props.props["children"] || "children";
          watch(() => {
            var _a;
            const children = (_a = props2.node.data) == null ? void 0 : _a[childrenKey];
            return children && [...children];
          }, () => {
            props2.node.updateChildren();
          });
          watch(() => props2.node.indeterminate, (val) => {
            handleSelectChange(props2.node.checked, val);
          });
          watch(() => props2.node.checked, (val) => {
            handleSelectChange(val, props2.node.indeterminate);
          });
          watch(() => props2.node.childNodes.length, () => props2.node.reInitChecked());
          watch(() => props2.node.expanded, (val) => {
            nextTick(() => expanded.value = val);
            if (val) {
              childNodeRendered.value = true;
            }
          });
          const getNodeKey$1 = (node) => {
            return getNodeKey(tree.props.nodeKey, node.data);
          };
          const getNodeClass = (node) => {
            const nodeClassFunc = props2.props.class;
            if (!nodeClassFunc) {
              return {};
            }
            let className;
            if (isFunction$1(nodeClassFunc)) {
              const { data } = node;
              className = nodeClassFunc(data, node);
            } else {
              className = nodeClassFunc;
            }
            if (isString$1(className)) {
              return { [className]: true };
            } else {
              return className;
            }
          };
          const handleSelectChange = (checked, indeterminate) => {
            if (oldChecked.value !== checked || oldIndeterminate.value !== indeterminate) {
              tree.ctx.emit("check-change", props2.node.data, checked, indeterminate);
            }
            oldChecked.value = checked;
            oldIndeterminate.value = indeterminate;
          };
          const handleClick = (e) => {
            handleCurrentChange(tree.store, tree.ctx.emit, () => {
              var _a;
              const nodeKeyProp = (_a = tree == null ? void 0 : tree.props) == null ? void 0 : _a.nodeKey;
              if (nodeKeyProp) {
                const curNodeKey = getNodeKey$1(props2.node);
                tree.store.value.setCurrentNodeKey(curNodeKey);
              } else {
                tree.store.value.setCurrentNode(props2.node);
              }
            });
            tree.currentNode.value = props2.node;
            if (tree.props.expandOnClickNode) {
              handleExpandIconClick();
            }
            if ((tree.props.checkOnClickNode || props2.node.isLeaf && tree.props.checkOnClickLeaf && props2.showCheckbox) && !props2.node.disabled) {
              handleCheckChange(!props2.node.checked);
            }
            tree.ctx.emit("node-click", props2.node.data, props2.node, instance, e);
          };
          const handleContextMenu = (event) => {
            var _a;
            if ((_a = tree.instance.vnode.props) == null ? void 0 : _a["onNodeContextmenu"]) {
              event.stopPropagation();
              event.preventDefault();
            }
            tree.ctx.emit("node-contextmenu", event, props2.node.data, props2.node, instance);
          };
          const handleExpandIconClick = () => {
            if (props2.node.isLeaf)
              return;
            if (expanded.value) {
              tree.ctx.emit("node-collapse", props2.node.data, props2.node, instance);
              props2.node.collapse();
            } else {
              props2.node.expand(() => {
                ctx.emit("node-expand", props2.node.data, props2.node, instance);
              });
            }
          };
          const handleCheckChange = (value) => {
            props2.node.setChecked(value, !(tree == null ? void 0 : tree.props.checkStrictly));
            nextTick(() => {
              const store = tree.store.value;
              tree.ctx.emit("check", props2.node.data, {
                checkedNodes: store.getCheckedNodes(),
                checkedKeys: store.getCheckedKeys(),
                halfCheckedNodes: store.getHalfCheckedNodes(),
                halfCheckedKeys: store.getHalfCheckedKeys()
              });
            });
          };
          const handleChildNodeExpand = (nodeData, node, instance2) => {
            broadcastExpanded(node);
            tree.ctx.emit("node-expand", nodeData, node, instance2);
          };
          const handleDragStart = (event) => {
            if (!tree.props.draggable)
              return;
            dragEvents.treeNodeDragStart({ event, treeNode: props2 });
          };
          const handleDragOver = (event) => {
            event.preventDefault();
            if (!tree.props.draggable)
              return;
            dragEvents.treeNodeDragOver({
              event,
              treeNode: { $el: node$.value, node: props2.node }
            });
          };
          const handleDrop = (event) => {
            event.preventDefault();
          };
          const handleDragEnd = (event) => {
            if (!tree.props.draggable)
              return;
            dragEvents.treeNodeDragEnd(event);
          };
          return {
            ns,
            node$,
            tree,
            expanded,
            childNodeRendered,
            oldChecked,
            oldIndeterminate,
            getNodeKey: getNodeKey$1,
            getNodeClass,
            handleSelectChange,
            handleClick,
            handleContextMenu,
            handleExpandIconClick,
            handleCheckChange,
            handleChildNodeExpand,
            handleDragStart,
            handleDragOver,
            handleDrop,
            handleDragEnd,
            CaretRight: caret_right_default$1
          };
        }
      });
      function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_checkbox = resolveComponent("el-checkbox");
        const _component_loading = resolveComponent("loading");
        const _component_node_content = resolveComponent("node-content");
        const _component_el_tree_node = resolveComponent("el-tree-node");
        const _component_el_collapse_transition = resolveComponent("el-collapse-transition");
        return withDirectives((openBlock(), createElementBlock("div", {
          ref: "node$",
          class: normalizeClass([
            _ctx.ns.b("node"),
            _ctx.ns.is("expanded", _ctx.expanded),
            _ctx.ns.is("current", _ctx.node.isCurrent),
            _ctx.ns.is("hidden", !_ctx.node.visible),
            _ctx.ns.is("focusable", !_ctx.node.disabled),
            _ctx.ns.is("checked", !_ctx.node.disabled && _ctx.node.checked),
            _ctx.getNodeClass(_ctx.node)
          ]),
          role: "treeitem",
          tabindex: "-1",
          "aria-expanded": _ctx.expanded,
          "aria-disabled": _ctx.node.disabled,
          "aria-checked": _ctx.node.checked,
          draggable: _ctx.tree.props.draggable,
          "data-key": _ctx.getNodeKey(_ctx.node),
          onClick: withModifiers(_ctx.handleClick, ["stop"]),
          onContextmenu: _ctx.handleContextMenu,
          onDragstart: withModifiers(_ctx.handleDragStart, ["stop"]),
          onDragover: withModifiers(_ctx.handleDragOver, ["stop"]),
          onDragend: withModifiers(_ctx.handleDragEnd, ["stop"]),
          onDrop: withModifiers(_ctx.handleDrop, ["stop"])
        }, [
          createElementVNode("div", {
            class: normalizeClass(_ctx.ns.be("node", "content")),
            style: normalizeStyle({ paddingLeft: (_ctx.node.level - 1) * _ctx.tree.props.indent + "px" })
          }, [
            _ctx.tree.props.icon || _ctx.CaretRight ? (openBlock(), createBlock(_component_el_icon, {
              key: 0,
              class: normalizeClass([
                _ctx.ns.be("node", "expand-icon"),
                _ctx.ns.is("leaf", _ctx.node.isLeaf),
                {
                  expanded: !_ctx.node.isLeaf && _ctx.expanded
                }
              ]),
              onClick: withModifiers(_ctx.handleExpandIconClick, ["stop"])
            }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.tree.props.icon || _ctx.CaretRight)))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
            _ctx.showCheckbox ? (openBlock(), createBlock(_component_el_checkbox, {
              key: 1,
              "model-value": _ctx.node.checked,
              indeterminate: _ctx.node.indeterminate,
              disabled: !!_ctx.node.disabled,
              onClick: withModifiers(() => {
              }, ["stop"]),
              onChange: _ctx.handleCheckChange
            }, null, 8, ["model-value", "indeterminate", "disabled", "onClick", "onChange"])) : createCommentVNode("v-if", true),
            _ctx.node.loading ? (openBlock(), createBlock(_component_el_icon, {
              key: 2,
              class: normalizeClass([_ctx.ns.be("node", "loading-icon"), _ctx.ns.is("loading")])
            }, {
              default: withCtx(() => [
                createVNode(_component_loading)
              ]),
              _: 1
            }, 8, ["class"])) : createCommentVNode("v-if", true),
            createVNode(_component_node_content, {
              node: _ctx.node,
              "render-content": _ctx.renderContent
            }, null, 8, ["node", "render-content"])
          ], 6),
          createVNode(_component_el_collapse_transition, null, {
            default: withCtx(() => [
              !_ctx.renderAfterExpand || _ctx.childNodeRendered ? withDirectives((openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(_ctx.ns.be("node", "children")),
                role: "group",
                "aria-expanded": _ctx.expanded,
                onClick: withModifiers(() => {
                }, ["stop"])
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.node.childNodes, (child) => {
                  return openBlock(), createBlock(_component_el_tree_node, {
                    key: _ctx.getNodeKey(child),
                    "render-content": _ctx.renderContent,
                    "render-after-expand": _ctx.renderAfterExpand,
                    "show-checkbox": _ctx.showCheckbox,
                    node: child,
                    accordion: _ctx.accordion,
                    props: _ctx.props,
                    onNodeExpand: _ctx.handleChildNodeExpand
                  }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]);
                }), 128))
              ], 10, ["aria-expanded", "onClick"])), [
                [vShow, _ctx.expanded]
              ]) : createCommentVNode("v-if", true)
            ]),
            _: 1
          })
        ], 42, ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key", "onClick", "onContextmenu", "onDragstart", "onDragover", "onDragend", "onDrop"])), [
          [vShow, _ctx.node.visible]
        ]);
      }
      var ElTreeNode$1 = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$2], ["__file", "tree-node.vue"]]);
      function useKeydown({ el$ }, store) {
        const ns = useNamespace("tree");
        onMounted(() => {
          initTabIndex();
        });
        onUpdated(() => {
          const checkboxItems = Array.from(el$.value.querySelectorAll("input[type=checkbox]"));
          checkboxItems.forEach((checkbox) => {
            checkbox.setAttribute("tabindex", "-1");
          });
        });
        function canNodeFocus(treeItems, nextIndex) {
          var _a, _b;
          const currentNode = store.value.getNode(treeItems[nextIndex].dataset.key);
          return currentNode.canFocus && currentNode.visible && (((_a = currentNode.parent) == null ? void 0 : _a.expanded) || ((_b = currentNode.parent) == null ? void 0 : _b.level) === 0);
        }
        const handleKeydown = (ev) => {
          const currentItem = ev.target;
          if (!currentItem.className.includes(ns.b("node")))
            return;
          const code = ev.code;
          const treeItems = Array.from(el$.value.querySelectorAll(`.${ns.is("focusable")}[role=treeitem]`));
          const currentIndex = treeItems.indexOf(currentItem);
          let nextIndex;
          if ([EVENT_CODE.up, EVENT_CODE.down].includes(code)) {
            ev.preventDefault();
            if (code === EVENT_CODE.up) {
              nextIndex = currentIndex === -1 ? 0 : currentIndex !== 0 ? currentIndex - 1 : treeItems.length - 1;
              const startIndex = nextIndex;
              while (true) {
                if (canNodeFocus(treeItems, nextIndex)) {
                  break;
                }
                nextIndex--;
                if (nextIndex === startIndex) {
                  nextIndex = -1;
                  break;
                }
                if (nextIndex < 0) {
                  nextIndex = treeItems.length - 1;
                }
              }
            } else {
              nextIndex = currentIndex === -1 ? 0 : currentIndex < treeItems.length - 1 ? currentIndex + 1 : 0;
              const startIndex = nextIndex;
              while (true) {
                if (canNodeFocus(treeItems, nextIndex)) {
                  break;
                }
                nextIndex++;
                if (nextIndex === startIndex) {
                  nextIndex = -1;
                  break;
                }
                if (nextIndex >= treeItems.length) {
                  nextIndex = 0;
                }
              }
            }
            nextIndex !== -1 && treeItems[nextIndex].focus();
          }
          if ([EVENT_CODE.left, EVENT_CODE.right].includes(code)) {
            ev.preventDefault();
            currentItem.click();
          }
          const hasInput = currentItem.querySelector('[type="checkbox"]');
          if ([EVENT_CODE.enter, EVENT_CODE.numpadEnter, EVENT_CODE.space].includes(code) && hasInput) {
            ev.preventDefault();
            hasInput.click();
          }
        };
        useEventListener(el$, "keydown", handleKeydown);
        const initTabIndex = () => {
          var _a;
          if (!el$.value)
            return;
          const treeItems = Array.from(el$.value.querySelectorAll(`.${ns.is("focusable")}[role=treeitem]`));
          const checkboxItems = Array.from(el$.value.querySelectorAll("input[type=checkbox]"));
          checkboxItems.forEach((checkbox) => {
            checkbox.setAttribute("tabindex", "-1");
          });
          const checkedItem = el$.value.querySelectorAll(`.${ns.is("checked")}[role=treeitem]`);
          if (checkedItem.length) {
            checkedItem[0].setAttribute("tabindex", "0");
            return;
          }
          (_a = treeItems[0]) == null ? void 0 : _a.setAttribute("tabindex", "0");
        };
      }
      const _sfc_main$n = defineComponent({
        name: "ElTree",
        components: { ElTreeNode: ElTreeNode$1 },
        props: {
          data: {
            type: definePropType(Array),
            default: () => []
          },
          emptyText: {
            type: String
          },
          renderAfterExpand: {
            type: Boolean,
            default: true
          },
          nodeKey: String,
          checkStrictly: Boolean,
          defaultExpandAll: Boolean,
          expandOnClickNode: {
            type: Boolean,
            default: true
          },
          checkOnClickNode: Boolean,
          checkOnClickLeaf: {
            type: Boolean,
            default: true
          },
          checkDescendants: Boolean,
          autoExpandParent: {
            type: Boolean,
            default: true
          },
          defaultCheckedKeys: Array,
          defaultExpandedKeys: Array,
          currentNodeKey: [String, Number],
          renderContent: {
            type: definePropType(Function)
          },
          showCheckbox: Boolean,
          draggable: Boolean,
          allowDrag: {
            type: definePropType(Function)
          },
          allowDrop: {
            type: definePropType(Function)
          },
          props: {
            type: Object,
            default: () => ({
              children: "children",
              label: "label",
              disabled: "disabled"
            })
          },
          lazy: Boolean,
          highlightCurrent: Boolean,
          load: Function,
          filterNodeMethod: Function,
          accordion: Boolean,
          indent: {
            type: Number,
            default: 18
          },
          icon: {
            type: iconPropType
          }
        },
        emits: [
          "check-change",
          "current-change",
          "node-click",
          "node-contextmenu",
          "node-collapse",
          "node-expand",
          "check",
          "node-drag-start",
          "node-drag-end",
          "node-drop",
          "node-drag-leave",
          "node-drag-enter",
          "node-drag-over"
        ],
        setup(props2, ctx) {
          const { t } = useLocale();
          const ns = useNamespace("tree");
          const selectInfo = inject(selectKey, null);
          const store = ref(new TreeStore({
            key: props2.nodeKey,
            data: props2.data,
            lazy: props2.lazy,
            props: props2.props,
            load: props2.load,
            currentNodeKey: props2.currentNodeKey,
            checkStrictly: props2.checkStrictly,
            checkDescendants: props2.checkDescendants,
            defaultCheckedKeys: props2.defaultCheckedKeys,
            defaultExpandedKeys: props2.defaultExpandedKeys,
            autoExpandParent: props2.autoExpandParent,
            defaultExpandAll: props2.defaultExpandAll,
            filterNodeMethod: props2.filterNodeMethod
          }));
          store.value.initialize();
          const root2 = ref(store.value.root);
          const currentNode = ref(null);
          const el$ = ref(null);
          const dropIndicator$ = ref(null);
          const { broadcastExpanded } = useNodeExpandEventBroadcast(props2);
          const { dragState } = useDragNodeHandler({
            props: props2,
            ctx,
            el$,
            dropIndicator$,
            store
          });
          useKeydown({ el$ }, store);
          const isEmpty2 = computed(() => {
            const { childNodes } = root2.value;
            const hasFilteredOptions = selectInfo ? selectInfo.hasFilteredOptions !== 0 : false;
            return (!childNodes || childNodes.length === 0 || childNodes.every(({ visible }) => !visible)) && !hasFilteredOptions;
          });
          watch(() => props2.currentNodeKey, (newVal) => {
            store.value.setCurrentNodeKey(newVal != null ? newVal : null);
          });
          watch(() => props2.defaultCheckedKeys, (newVal, oldVal) => {
            if (isEqual$1(newVal, oldVal))
              return;
            store.value.setDefaultCheckedKey(newVal != null ? newVal : []);
          });
          watch(() => props2.defaultExpandedKeys, (newVal) => {
            store.value.setDefaultExpandedKeys(newVal != null ? newVal : []);
          });
          watch(() => props2.data, (newVal) => {
            store.value.setData(newVal);
          }, { deep: true });
          watch(() => props2.checkStrictly, (newVal) => {
            store.value.checkStrictly = newVal;
          });
          const filter2 = (value) => {
            if (!props2.filterNodeMethod)
              throw new Error("[Tree] filterNodeMethod is required when filter");
            store.value.filter(value);
          };
          const getNodeKey$1 = (node) => {
            return getNodeKey(props2.nodeKey, node.data);
          };
          const getNodePath = (data) => {
            if (!props2.nodeKey)
              throw new Error("[Tree] nodeKey is required in getNodePath");
            const node = store.value.getNode(data);
            if (!node)
              return [];
            const path = [node.data];
            let parent2 = node.parent;
            while (parent2 && parent2 !== root2.value) {
              path.push(parent2.data);
              parent2 = parent2.parent;
            }
            return path.reverse();
          };
          const getCheckedNodes = (leafOnly, includeHalfChecked) => {
            return store.value.getCheckedNodes(leafOnly, includeHalfChecked);
          };
          const getCheckedKeys = (leafOnly) => {
            return store.value.getCheckedKeys(leafOnly);
          };
          const getCurrentNode = () => {
            const currentNode2 = store.value.getCurrentNode();
            return currentNode2 ? currentNode2.data : null;
          };
          const getCurrentKey = () => {
            if (!props2.nodeKey)
              throw new Error("[Tree] nodeKey is required in getCurrentKey");
            const currentNode2 = getCurrentNode();
            return currentNode2 ? currentNode2[props2.nodeKey] : null;
          };
          const setCheckedNodes = (nodes, leafOnly) => {
            if (!props2.nodeKey)
              throw new Error("[Tree] nodeKey is required in setCheckedNodes");
            store.value.setCheckedNodes(nodes, leafOnly);
          };
          const setCheckedKeys = (keys2, leafOnly) => {
            if (!props2.nodeKey)
              throw new Error("[Tree] nodeKey is required in setCheckedKeys");
            store.value.setCheckedKeys(keys2, leafOnly);
          };
          const setChecked = (data, checked, deep) => {
            store.value.setChecked(data, checked, deep);
          };
          const getHalfCheckedNodes = () => {
            return store.value.getHalfCheckedNodes();
          };
          const getHalfCheckedKeys = () => {
            return store.value.getHalfCheckedKeys();
          };
          const setCurrentNode = (node, shouldAutoExpandParent = true) => {
            if (!props2.nodeKey)
              throw new Error("[Tree] nodeKey is required in setCurrentNode");
            handleCurrentChange(store, ctx.emit, () => {
              broadcastExpanded(node);
              store.value.setUserCurrentNode(node, shouldAutoExpandParent);
            });
          };
          const setCurrentKey = (key, shouldAutoExpandParent = true) => {
            if (!props2.nodeKey)
              throw new Error("[Tree] nodeKey is required in setCurrentKey");
            handleCurrentChange(store, ctx.emit, () => {
              broadcastExpanded();
              store.value.setCurrentNodeKey(key != null ? key : null, shouldAutoExpandParent);
            });
          };
          const getNode = (data) => {
            return store.value.getNode(data);
          };
          const remove2 = (data) => {
            store.value.remove(data);
          };
          const append = (data, parentNode) => {
            store.value.append(data, parentNode);
          };
          const insertBefore = (data, refNode) => {
            store.value.insertBefore(data, refNode);
          };
          const insertAfter = (data, refNode) => {
            store.value.insertAfter(data, refNode);
          };
          const handleNodeExpand = (nodeData, node, instance) => {
            broadcastExpanded(node);
            ctx.emit("node-expand", nodeData, node, instance);
          };
          const updateKeyChildren = (key, data) => {
            if (!props2.nodeKey)
              throw new Error("[Tree] nodeKey is required in updateKeyChild");
            store.value.updateChildren(key, data);
          };
          provide(ROOT_TREE_INJECTION_KEY$1, {
            ctx,
            props: props2,
            store,
            root: root2,
            currentNode,
            instance: getCurrentInstance()
          });
          provide(formItemContextKey, void 0);
          return {
            ns,
            store,
            root: root2,
            currentNode,
            dragState,
            el$,
            dropIndicator$,
            isEmpty: isEmpty2,
            filter: filter2,
            getNodeKey: getNodeKey$1,
            getNodePath,
            getCheckedNodes,
            getCheckedKeys,
            getCurrentNode,
            getCurrentKey,
            setCheckedNodes,
            setCheckedKeys,
            setChecked,
            getHalfCheckedNodes,
            getHalfCheckedKeys,
            setCurrentNode,
            setCurrentKey,
            t,
            getNode,
            remove: remove2,
            append,
            insertBefore,
            insertAfter,
            handleNodeExpand,
            updateKeyChildren
          };
        }
      });
      function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_tree_node = resolveComponent("el-tree-node");
        return openBlock(), createElementBlock("div", {
          ref: "el$",
          class: normalizeClass([
            _ctx.ns.b(),
            _ctx.ns.is("dragging", !!_ctx.dragState.draggingNode),
            _ctx.ns.is("drop-not-allow", !_ctx.dragState.allowDrop),
            _ctx.ns.is("drop-inner", _ctx.dragState.dropType === "inner"),
            { [_ctx.ns.m("highlight-current")]: _ctx.highlightCurrent }
          ]),
          role: "tree"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.root.childNodes, (child) => {
            return openBlock(), createBlock(_component_el_tree_node, {
              key: _ctx.getNodeKey(child),
              node: child,
              props: _ctx.props,
              accordion: _ctx.accordion,
              "render-after-expand": _ctx.renderAfterExpand,
              "show-checkbox": _ctx.showCheckbox,
              "render-content": _ctx.renderContent,
              onNodeExpand: _ctx.handleNodeExpand
            }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]);
          }), 128)),
          _ctx.isEmpty ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.ns.e("empty-block"))
          }, [
            renderSlot(_ctx.$slots, "empty", {}, () => {
              var _a;
              return [
                createElementVNode("span", {
                  class: normalizeClass(_ctx.ns.e("empty-text"))
                }, toDisplayString((_a = _ctx.emptyText) != null ? _a : _ctx.t("el.tree.emptyText")), 3)
              ];
            })
          ], 2)) : createCommentVNode("v-if", true),
          withDirectives(createElementVNode("div", {
            ref: "dropIndicator$",
            class: normalizeClass(_ctx.ns.e("drop-indicator"))
          }, null, 2), [
            [vShow, _ctx.dragState.showDropIndicator]
          ])
        ], 2);
      }
      var Tree = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$1], ["__file", "tree.vue"]]);
      const ElTree = exports("ElTree", withInstall(Tree));
      const useSelect = (props2, { attrs, emit }, {
        select,
        tree,
        key
      }) => {
        const ns = useNamespace("tree-select");
        watch(() => props2.data, () => {
          if (props2.filterable) {
            nextTick(() => {
              var _a, _b;
              (_b = tree.value) == null ? void 0 : _b.filter((_a = select.value) == null ? void 0 : _a.states.inputValue);
            });
          }
        }, { flush: "post" });
        const result2 = {
          ...pick(toRefs(props2), Object.keys(ElSelect.props)),
          ...attrs,
          class: computed(() => attrs.class),
          style: computed(() => attrs.style),
          "onUpdate:modelValue": (value) => emit(UPDATE_MODEL_EVENT, value),
          valueKey: key,
          popperClass: computed(() => {
            const classes = [ns.e("popper")];
            if (props2.popperClass)
              classes.push(props2.popperClass);
            return classes.join(" ");
          }),
          filterMethod: (keyword = "") => {
            var _a;
            if (props2.filterMethod) {
              props2.filterMethod(keyword);
            } else if (props2.remoteMethod) {
              props2.remoteMethod(keyword);
            } else {
              (_a = tree.value) == null ? void 0 : _a.filter(keyword);
            }
          }
        };
        return result2;
      };
      const component = defineComponent({
        extends: ElOption,
        setup(props2, ctx) {
          const result2 = ElOption.setup(props2, ctx);
          delete result2.selectOptionClick;
          const vm = getCurrentInstance().proxy;
          nextTick(() => {
            if (!result2.select.states.cachedOptions.get(vm.value)) {
              result2.select.onOptionCreate(vm);
            }
          });
          watch(() => ctx.attrs.visible, (val) => {
            nextTick(() => {
              result2.states.visible = val;
            });
          }, {
            immediate: true
          });
          return result2;
        },
        methods: {
          selectOptionClick() {
            this.$el.parentElement.click();
          }
        }
      });
      var TreeSelectOption = component;
      function isValidValue(val) {
        return val || val === 0;
      }
      function isValidArray(val) {
        return isArray$1(val) && val.length;
      }
      function toValidArray(val) {
        return isArray$1(val) ? val : isValidValue(val) ? [val] : [];
      }
      function treeFind(treeData, findCallback, getChildren, resultCallback, parent2) {
        for (let i = 0; i < treeData.length; i++) {
          const data = treeData[i];
          if (findCallback(data, i, treeData, parent2)) {
            return resultCallback ? resultCallback(data, i, treeData, parent2) : data;
          } else {
            const children = getChildren(data);
            if (isValidArray(children)) {
              const find2 = treeFind(children, findCallback, getChildren, resultCallback, data);
              if (find2)
                return find2;
            }
          }
        }
      }
      function treeEach(treeData, callback, getChildren, parent2) {
        for (let i = 0; i < treeData.length; i++) {
          const data = treeData[i];
          callback(data, i, treeData, parent2);
          const children = getChildren(data);
          if (isValidArray(children)) {
            treeEach(children, callback, getChildren, data);
          }
        }
      }
      const useTree$1 = (props2, { attrs, slots, emit }, {
        select,
        tree,
        key
      }) => {
        watch([() => props2.modelValue, tree], () => {
          if (props2.showCheckbox) {
            nextTick(() => {
              const treeInstance = tree.value;
              if (treeInstance && !isEqual$1(treeInstance.getCheckedKeys(), toValidArray(props2.modelValue))) {
                treeInstance.setCheckedKeys(toValidArray(props2.modelValue));
              }
            });
          }
        }, {
          immediate: true,
          deep: true
        });
        const propsMap = computed(() => ({
          value: key.value,
          label: "label",
          children: "children",
          disabled: "disabled",
          isLeaf: "isLeaf",
          ...props2.props
        }));
        const getNodeValByProp = (prop, data) => {
          var _a;
          const propVal = propsMap.value[prop];
          if (isFunction$1(propVal)) {
            return propVal(data, (_a = tree.value) == null ? void 0 : _a.getNode(getNodeValByProp("value", data)));
          } else {
            return data[propVal];
          }
        };
        const defaultExpandedParentKeys = toValidArray(props2.modelValue).map((value) => {
          return treeFind(props2.data || [], (data) => getNodeValByProp("value", data) === value, (data) => getNodeValByProp("children", data), (data, index2, array3, parent2) => parent2 && getNodeValByProp("value", parent2));
        }).filter((item) => isValidValue(item));
        const cacheOptions = computed(() => {
          if (!props2.renderAfterExpand && !props2.lazy)
            return [];
          const options = [];
          treeEach(props2.data.concat(props2.cacheData), (node) => {
            const value = getNodeValByProp("value", node);
            options.push({
              value,
              currentLabel: getNodeValByProp("label", node),
              isDisabled: getNodeValByProp("disabled", node)
            });
          }, (data) => getNodeValByProp("children", data));
          return options;
        });
        const getChildCheckedKeys = () => {
          var _a;
          return (_a = tree.value) == null ? void 0 : _a.getCheckedKeys().filter((checkedKey) => {
            var _a2;
            const node = (_a2 = tree.value) == null ? void 0 : _a2.getNode(checkedKey);
            return !isNil(node) && isEmpty(node.childNodes);
          });
        };
        return {
          ...pick(toRefs(props2), Object.keys(ElTree.props)),
          ...attrs,
          nodeKey: key,
          expandOnClickNode: computed(() => {
            return !props2.checkStrictly && props2.expandOnClickNode;
          }),
          defaultExpandedKeys: computed(() => {
            return props2.defaultExpandedKeys ? props2.defaultExpandedKeys.concat(defaultExpandedParentKeys) : defaultExpandedParentKeys;
          }),
          renderContent: (h2, { node, data, store }) => {
            return h2(TreeSelectOption, {
              value: getNodeValByProp("value", data),
              label: getNodeValByProp("label", data),
              disabled: getNodeValByProp("disabled", data),
              visible: node.visible
            }, props2.renderContent ? () => props2.renderContent(h2, { node, data, store }) : slots.default ? () => slots.default({ node, data, store }) : void 0);
          },
          filterNodeMethod: (value, data, node) => {
            if (props2.filterNodeMethod)
              return props2.filterNodeMethod(value, data, node);
            if (!value)
              return true;
            const regexp = new RegExp(escapeStringRegexp(value), "i");
            return regexp.test(getNodeValByProp("label", data) || "");
          },
          onNodeClick: (data, node, e) => {
            var _a, _b, _c, _d;
            (_a = attrs.onNodeClick) == null ? void 0 : _a.call(attrs, data, node, e);
            if (props2.showCheckbox && props2.checkOnClickNode)
              return;
            if (!props2.showCheckbox && (props2.checkStrictly || node.isLeaf)) {
              if (!getNodeValByProp("disabled", data)) {
                const option = (_b = select.value) == null ? void 0 : _b.states.options.get(getNodeValByProp("value", data));
                (_c = select.value) == null ? void 0 : _c.handleOptionSelect(option);
              }
            } else if (props2.expandOnClickNode) {
              e.proxy.handleExpandIconClick();
            }
            (_d = select.value) == null ? void 0 : _d.focus();
          },
          onCheck: (data, params) => {
            var _a;
            if (!props2.showCheckbox)
              return;
            const dataValue = getNodeValByProp("value", data);
            const dataMap = {};
            treeEach([tree.value.store.root], (node) => dataMap[node.key] = node, (node) => node.childNodes);
            const uncachedCheckedKeys = params.checkedKeys;
            const cachedKeys = props2.multiple ? toValidArray(props2.modelValue).filter((item) => !(item in dataMap) && !uncachedCheckedKeys.includes(item)) : [];
            const checkedKeys = cachedKeys.concat(uncachedCheckedKeys);
            if (props2.checkStrictly) {
              emit(UPDATE_MODEL_EVENT, props2.multiple ? checkedKeys : checkedKeys.includes(dataValue) ? dataValue : void 0);
            } else {
              if (props2.multiple) {
                const childKeys = getChildCheckedKeys();
                emit(UPDATE_MODEL_EVENT, cachedKeys.concat(childKeys));
              } else {
                const firstLeaf = treeFind([data], (data2) => !isValidArray(getNodeValByProp("children", data2)) && !getNodeValByProp("disabled", data2), (data2) => getNodeValByProp("children", data2));
                const firstLeafKey = firstLeaf ? getNodeValByProp("value", firstLeaf) : void 0;
                const hasCheckedChild = isValidValue(props2.modelValue) && !!treeFind([data], (data2) => getNodeValByProp("value", data2) === props2.modelValue, (data2) => getNodeValByProp("children", data2));
                emit(UPDATE_MODEL_EVENT, firstLeafKey === props2.modelValue || hasCheckedChild ? void 0 : firstLeafKey);
              }
            }
            nextTick(() => {
              var _a2;
              const checkedKeys2 = toValidArray(props2.modelValue);
              tree.value.setCheckedKeys(checkedKeys2);
              (_a2 = attrs.onCheck) == null ? void 0 : _a2.call(attrs, data, {
                checkedKeys: tree.value.getCheckedKeys(),
                checkedNodes: tree.value.getCheckedNodes(),
                halfCheckedKeys: tree.value.getHalfCheckedKeys(),
                halfCheckedNodes: tree.value.getHalfCheckedNodes()
              });
            });
            (_a = select.value) == null ? void 0 : _a.focus();
          },
          onNodeExpand: (data, node, e) => {
            var _a;
            (_a = attrs.onNodeExpand) == null ? void 0 : _a.call(attrs, data, node, e);
            nextTick(() => {
              if (!props2.checkStrictly && props2.lazy && props2.multiple && node.checked) {
                const dataMap = {};
                const uncachedCheckedKeys = tree.value.getCheckedKeys();
                treeEach([tree.value.store.root], (node2) => dataMap[node2.key] = node2, (node2) => node2.childNodes);
                const cachedKeys = toValidArray(props2.modelValue).filter((item) => !(item in dataMap) && !uncachedCheckedKeys.includes(item));
                const childKeys = getChildCheckedKeys();
                emit(UPDATE_MODEL_EVENT, cachedKeys.concat(childKeys));
              }
            });
          },
          cacheOptions
        };
      };
      var CacheOptions = defineComponent({
        props: {
          data: {
            type: Array,
            default: () => []
          }
        },
        setup(props2) {
          const select = inject(selectKey);
          watch(() => props2.data, () => {
            var _a;
            props2.data.forEach((item) => {
              if (!select.states.cachedOptions.has(item.value)) {
                select.states.cachedOptions.set(item.value, item);
              }
            });
            const inputs = ((_a = select.selectRef) == null ? void 0 : _a.querySelectorAll("input")) || [];
            if (isClient && !Array.from(inputs).includes(document.activeElement)) {
              select.setSelected();
            }
          }, { flush: "post", immediate: true });
          return () => void 0;
        }
      });
      const _sfc_main$m = defineComponent({
        name: "ElTreeSelect",
        inheritAttrs: false,
        props: {
          ...ElSelect.props,
          ...ElTree.props,
          cacheData: {
            type: Array,
            default: () => []
          }
        },
        setup(props2, context) {
          const { slots, expose } = context;
          const select = ref();
          const tree = ref();
          const key = computed(() => props2.nodeKey || props2.valueKey || "value");
          const selectProps2 = useSelect(props2, context, { select, tree, key });
          const { cacheOptions, ...treeProps2 } = useTree$1(props2, context, {
            select,
            tree,
            key
          });
          const methods = reactive({});
          expose(methods);
          onMounted(() => {
            Object.assign(methods, {
              ...pick(tree.value, [
                "filter",
                "updateKeyChildren",
                "getCheckedNodes",
                "setCheckedNodes",
                "getCheckedKeys",
                "setCheckedKeys",
                "setChecked",
                "getHalfCheckedNodes",
                "getHalfCheckedKeys",
                "getCurrentKey",
                "getCurrentNode",
                "setCurrentKey",
                "setCurrentNode",
                "getNode",
                "remove",
                "append",
                "insertBefore",
                "insertAfter"
              ]),
              ...pick(select.value, ["focus", "blur", "selectedLabel"])
            });
          });
          return () => h$1(ElSelect, reactive({
            ...selectProps2,
            ref: (ref2) => select.value = ref2
          }), {
            ...slots,
            default: () => [
              h$1(CacheOptions, { data: cacheOptions.value }),
              h$1(ElTree, reactive({
                ...treeProps2,
                ref: (ref2) => tree.value = ref2
              }))
            ]
          });
        }
      });
      var TreeSelect = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__file", "tree-select.vue"]]);
      const ElTreeSelect = exports("ElTreeSelect", withInstall(TreeSelect));
      const ROOT_TREE_INJECTION_KEY = Symbol();
      const EMPTY_NODE = {
        key: -1,
        level: -1,
        data: {}
      };
      var TreeOptionsEnum = /* @__PURE__ */ ((TreeOptionsEnum2) => {
        TreeOptionsEnum2["KEY"] = "id";
        TreeOptionsEnum2["LABEL"] = "label";
        TreeOptionsEnum2["CHILDREN"] = "children";
        TreeOptionsEnum2["DISABLED"] = "disabled";
        TreeOptionsEnum2["CLASS"] = "";
        return TreeOptionsEnum2;
      })(TreeOptionsEnum || {});
      var SetOperationEnum = /* @__PURE__ */ ((SetOperationEnum2) => {
        SetOperationEnum2["ADD"] = "add";
        SetOperationEnum2["DELETE"] = "delete";
        return SetOperationEnum2;
      })(SetOperationEnum || {});
      const itemSize = {
        type: Number,
        default: 26
      };
      const treeProps = buildProps({
        data: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        emptyText: {
          type: String
        },
        height: {
          type: Number,
          default: 200
        },
        props: {
          type: definePropType(Object),
          default: () => mutable({
            children: "children",
            label: "label",
            disabled: "disabled",
            value: "id",
            class: ""
            /* CLASS */
          })
        },
        highlightCurrent: Boolean,
        showCheckbox: Boolean,
        defaultCheckedKeys: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        checkStrictly: Boolean,
        defaultExpandedKeys: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        indent: {
          type: Number,
          default: 16
        },
        itemSize,
        icon: {
          type: iconPropType
        },
        expandOnClickNode: {
          type: Boolean,
          default: true
        },
        checkOnClickNode: Boolean,
        checkOnClickLeaf: {
          type: Boolean,
          default: true
        },
        currentNodeKey: {
          type: definePropType([String, Number])
        },
        accordion: Boolean,
        filterMethod: {
          type: definePropType(Function)
        },
        perfMode: {
          type: Boolean,
          default: true
        },
        scrollbarAlwaysOn: Boolean
      });
      const treeNodeProps = buildProps({
        node: {
          type: definePropType(Object),
          default: () => mutable(EMPTY_NODE)
        },
        expanded: Boolean,
        checked: Boolean,
        indeterminate: Boolean,
        showCheckbox: Boolean,
        disabled: Boolean,
        current: Boolean,
        hiddenExpandIcon: Boolean,
        itemSize
      });
      const treeNodeContentProps = buildProps({
        node: {
          type: definePropType(Object),
          required: true
        }
      });
      const NODE_CLICK = "node-click";
      const NODE_DROP = "node-drop";
      const NODE_EXPAND = "node-expand";
      const NODE_COLLAPSE = "node-collapse";
      const CURRENT_CHANGE = "current-change";
      const NODE_CHECK = "check";
      const NODE_CHECK_CHANGE = "check-change";
      const NODE_CONTEXTMENU = "node-contextmenu";
      const treeEmits = {
        [NODE_CLICK]: (data, node, e) => data && node && e,
        [NODE_DROP]: (data, node, e) => data && node && e,
        [NODE_EXPAND]: (data, node) => data && node,
        [NODE_COLLAPSE]: (data, node) => data && node,
        [CURRENT_CHANGE]: (data, node) => data && node,
        [NODE_CHECK]: (data, checkedInfo) => data && checkedInfo,
        [NODE_CHECK_CHANGE]: (data, checked) => data && isBoolean(checked),
        [NODE_CONTEXTMENU]: (evt, data, node) => evt && data && node
      };
      const treeNodeEmits = {
        click: (node, e) => !!(node && e),
        drop: (node, e) => !!(node && e),
        toggle: (node) => !!node,
        check: (node, checked) => node && isBoolean(checked)
      };
      function useCheck(props2, tree) {
        const checkedKeys = ref(/* @__PURE__ */ new Set());
        const indeterminateKeys = ref(/* @__PURE__ */ new Set());
        const { emit } = getCurrentInstance();
        watch([() => tree.value, () => props2.defaultCheckedKeys], () => {
          return nextTick(() => {
            _setCheckedKeys(props2.defaultCheckedKeys);
          });
        }, {
          immediate: true
        });
        const updateCheckedKeys = () => {
          if (!tree.value || !props2.showCheckbox || props2.checkStrictly) {
            return;
          }
          const { levelTreeNodeMap, maxLevel } = tree.value;
          const checkedKeySet = checkedKeys.value;
          const indeterminateKeySet = /* @__PURE__ */ new Set();
          for (let level = maxLevel - 1; level >= 1; --level) {
            const nodes = levelTreeNodeMap.get(level);
            if (!nodes)
              continue;
            nodes.forEach((node) => {
              const children = node.children;
              if (children) {
                let allChecked = true;
                let hasChecked = false;
                for (const childNode of children) {
                  const key = childNode.key;
                  if (checkedKeySet.has(key)) {
                    hasChecked = true;
                  } else if (indeterminateKeySet.has(key)) {
                    allChecked = false;
                    hasChecked = true;
                    break;
                  } else {
                    allChecked = false;
                  }
                }
                if (allChecked) {
                  checkedKeySet.add(node.key);
                } else if (hasChecked) {
                  indeterminateKeySet.add(node.key);
                  checkedKeySet.delete(node.key);
                } else {
                  checkedKeySet.delete(node.key);
                  indeterminateKeySet.delete(node.key);
                }
              }
            });
          }
          indeterminateKeys.value = indeterminateKeySet;
        };
        const isChecked = (node) => checkedKeys.value.has(node.key);
        const isIndeterminate = (node) => indeterminateKeys.value.has(node.key);
        const toggleCheckbox = (node, isChecked2, nodeClick = true, immediateUpdate = true) => {
          const checkedKeySet = checkedKeys.value;
          const toggle = (node2, checked) => {
            checkedKeySet[checked ? SetOperationEnum.ADD : SetOperationEnum.DELETE](node2.key);
            const children = node2.children;
            if (!props2.checkStrictly && children) {
              children.forEach((childNode) => {
                if (!childNode.disabled) {
                  toggle(childNode, checked);
                }
              });
            }
          };
          toggle(node, isChecked2);
          if (immediateUpdate) {
            updateCheckedKeys();
          }
          if (nodeClick) {
            afterNodeCheck(node, isChecked2);
          }
        };
        const afterNodeCheck = (node, checked) => {
          const { checkedNodes, checkedKeys: checkedKeys2 } = getChecked();
          const { halfCheckedNodes, halfCheckedKeys } = getHalfChecked();
          emit(NODE_CHECK, node.data, {
            checkedKeys: checkedKeys2,
            checkedNodes,
            halfCheckedKeys,
            halfCheckedNodes
          });
          emit(NODE_CHECK_CHANGE, node.data, checked);
        };
        function getCheckedKeys(leafOnly = false) {
          return getChecked(leafOnly).checkedKeys;
        }
        function getCheckedNodes(leafOnly = false) {
          return getChecked(leafOnly).checkedNodes;
        }
        function getHalfCheckedKeys() {
          return getHalfChecked().halfCheckedKeys;
        }
        function getHalfCheckedNodes() {
          return getHalfChecked().halfCheckedNodes;
        }
        function getChecked(leafOnly = false) {
          const checkedNodes = [];
          const keys2 = [];
          if ((tree == null ? void 0 : tree.value) && props2.showCheckbox) {
            const { treeNodeMap } = tree.value;
            checkedKeys.value.forEach((key) => {
              const node = treeNodeMap.get(key);
              if (node && (!leafOnly || leafOnly && node.isLeaf)) {
                keys2.push(key);
                checkedNodes.push(node.data);
              }
            });
          }
          return {
            checkedKeys: keys2,
            checkedNodes
          };
        }
        function getHalfChecked() {
          const halfCheckedNodes = [];
          const halfCheckedKeys = [];
          if ((tree == null ? void 0 : tree.value) && props2.showCheckbox) {
            const { treeNodeMap } = tree.value;
            indeterminateKeys.value.forEach((key) => {
              const node = treeNodeMap.get(key);
              if (node) {
                halfCheckedKeys.push(key);
                halfCheckedNodes.push(node.data);
              }
            });
          }
          return {
            halfCheckedNodes,
            halfCheckedKeys
          };
        }
        function setCheckedKeys(keys2) {
          checkedKeys.value.clear();
          indeterminateKeys.value.clear();
          nextTick(() => {
            _setCheckedKeys(keys2);
          });
        }
        function setChecked(key, isChecked2) {
          if ((tree == null ? void 0 : tree.value) && props2.showCheckbox) {
            const node = tree.value.treeNodeMap.get(key);
            if (node) {
              toggleCheckbox(node, isChecked2, false);
            }
          }
        }
        function _setCheckedKeys(keys2) {
          if (tree == null ? void 0 : tree.value) {
            const { treeNodeMap } = tree.value;
            if (props2.showCheckbox && treeNodeMap && (keys2 == null ? void 0 : keys2.length) > 0) {
              for (const key of keys2) {
                const node = treeNodeMap.get(key);
                if (node && !isChecked(node)) {
                  toggleCheckbox(node, true, false, false);
                }
              }
              updateCheckedKeys();
            }
          }
        }
        return {
          updateCheckedKeys,
          toggleCheckbox,
          isChecked,
          isIndeterminate,
          getCheckedKeys,
          getCheckedNodes,
          getHalfCheckedKeys,
          getHalfCheckedNodes,
          setChecked,
          setCheckedKeys
        };
      }
      function useFilter(props2, tree) {
        const hiddenNodeKeySet = ref(/* @__PURE__ */ new Set([]));
        const hiddenExpandIconKeySet = ref(/* @__PURE__ */ new Set([]));
        const filterable = computed(() => {
          return isFunction$1(props2.filterMethod);
        });
        function doFilter(query) {
          var _a;
          if (!filterable.value) {
            return;
          }
          const expandKeySet = /* @__PURE__ */ new Set();
          const hiddenExpandIconKeys = hiddenExpandIconKeySet.value;
          const hiddenKeys = hiddenNodeKeySet.value;
          const family = [];
          const nodes = ((_a = tree.value) == null ? void 0 : _a.treeNodes) || [];
          const filter2 = props2.filterMethod;
          hiddenKeys.clear();
          function traverse(nodes2) {
            nodes2.forEach((node) => {
              family.push(node);
              if (filter2 == null ? void 0 : filter2(query, node.data, node)) {
                family.forEach((member) => {
                  expandKeySet.add(member.key);
                });
              } else if (node.isLeaf) {
                hiddenKeys.add(node.key);
              }
              const children = node.children;
              if (children) {
                traverse(children);
              }
              if (!node.isLeaf) {
                if (!expandKeySet.has(node.key)) {
                  hiddenKeys.add(node.key);
                } else if (children) {
                  let allHidden = true;
                  for (const childNode of children) {
                    if (!hiddenKeys.has(childNode.key)) {
                      allHidden = false;
                      break;
                    }
                  }
                  if (allHidden) {
                    hiddenExpandIconKeys.add(node.key);
                  } else {
                    hiddenExpandIconKeys.delete(node.key);
                  }
                }
              }
              family.pop();
            });
          }
          traverse(nodes);
          return expandKeySet;
        }
        function isForceHiddenExpandIcon(node) {
          return hiddenExpandIconKeySet.value.has(node.key);
        }
        return {
          hiddenExpandIconKeySet,
          hiddenNodeKeySet,
          doFilter,
          isForceHiddenExpandIcon
        };
      }
      function useTree(props2, emit) {
        const expandedKeySet = ref(/* @__PURE__ */ new Set());
        const currentKey = ref();
        const tree = shallowRef();
        const listRef = ref();
        const {
          isIndeterminate,
          isChecked,
          toggleCheckbox,
          getCheckedKeys,
          getCheckedNodes,
          getHalfCheckedKeys,
          getHalfCheckedNodes,
          setChecked,
          setCheckedKeys
        } = useCheck(props2, tree);
        const { doFilter, hiddenNodeKeySet, isForceHiddenExpandIcon } = useFilter(props2, tree);
        const valueKey = computed(() => {
          var _a;
          return ((_a = props2.props) == null ? void 0 : _a.value) || TreeOptionsEnum.KEY;
        });
        const childrenKey = computed(() => {
          var _a;
          return ((_a = props2.props) == null ? void 0 : _a.children) || TreeOptionsEnum.CHILDREN;
        });
        const disabledKey = computed(() => {
          var _a;
          return ((_a = props2.props) == null ? void 0 : _a.disabled) || TreeOptionsEnum.DISABLED;
        });
        const labelKey = computed(() => {
          var _a;
          return ((_a = props2.props) == null ? void 0 : _a.label) || TreeOptionsEnum.LABEL;
        });
        const flattenTree = computed(() => {
          var _a;
          const expandedKeys = expandedKeySet.value;
          const hiddenKeys = hiddenNodeKeySet.value;
          const flattenNodes = [];
          const nodes = ((_a = tree.value) == null ? void 0 : _a.treeNodes) || [];
          const stack = [];
          for (let i = nodes.length - 1; i >= 0; --i) {
            stack.push(nodes[i]);
          }
          while (stack.length) {
            const node = stack.pop();
            if (hiddenKeys.has(node.key))
              continue;
            flattenNodes.push(node);
            if (node.children && expandedKeys.has(node.key)) {
              for (let i = node.children.length - 1; i >= 0; --i) {
                stack.push(node.children[i]);
              }
            }
          }
          return flattenNodes;
        });
        const isNotEmpty = computed(() => {
          return flattenTree.value.length > 0;
        });
        function createTree(data) {
          const treeNodeMap = /* @__PURE__ */ new Map();
          const levelTreeNodeMap = /* @__PURE__ */ new Map();
          let maxLevel = 1;
          function traverse(nodes, level = 1, parent2 = void 0) {
            var _a;
            const siblings = [];
            for (const rawNode of nodes) {
              const value = getKey(rawNode);
              const node = {
                level,
                key: value,
                data: rawNode
              };
              node.label = getLabel(rawNode);
              node.parent = parent2;
              const children = getChildren(rawNode);
              node.disabled = getDisabled(rawNode);
              node.isLeaf = !children || children.length === 0;
              node.expanded = expandedKeySet.value.has(value);
              if (children && children.length) {
                node.children = traverse(children, level + 1, node);
              }
              siblings.push(node);
              treeNodeMap.set(value, node);
              if (!levelTreeNodeMap.has(level)) {
                levelTreeNodeMap.set(level, []);
              }
              (_a = levelTreeNodeMap.get(level)) == null ? void 0 : _a.push(node);
            }
            if (level > maxLevel) {
              maxLevel = level;
            }
            return siblings;
          }
          const treeNodes = traverse(data);
          return {
            treeNodeMap,
            levelTreeNodeMap,
            maxLevel,
            treeNodes
          };
        }
        function filter2(query) {
          const keys2 = doFilter(query);
          if (keys2) {
            expandedKeySet.value = keys2;
          }
        }
        function getChildren(node) {
          return node[childrenKey.value];
        }
        function getKey(node) {
          if (!node) {
            return "";
          }
          return node[valueKey.value];
        }
        function getDisabled(node) {
          return node[disabledKey.value];
        }
        function getLabel(node) {
          return node[labelKey.value];
        }
        function toggleExpand(node) {
          const expandedKeys = expandedKeySet.value;
          if (expandedKeys.has(node.key)) {
            collapseNode(node);
          } else {
            expandNode(node);
          }
        }
        function setExpandedKeys(keys2) {
          const expandedKeys = /* @__PURE__ */ new Set();
          const nodeMap = tree.value.treeNodeMap;
          keys2.forEach((k) => {
            let node = nodeMap.get(k);
            while (node && !expandedKeys.has(node.key)) {
              expandedKeys.add(node.key);
              node.expanded = true;
              node = node.parent;
            }
          });
          expandedKeySet.value = expandedKeys;
        }
        function handleNodeClick(node, e) {
          emit(NODE_CLICK, node.data, node, e);
          handleCurrentChange2(node);
          if (props2.expandOnClickNode) {
            toggleExpand(node);
          }
          if (props2.showCheckbox && (props2.checkOnClickNode || node.isLeaf && props2.checkOnClickLeaf) && !node.disabled) {
            toggleCheckbox(node, !isChecked(node), true);
          }
        }
        function handleNodeDrop(node, e) {
          emit(NODE_DROP, node.data, node, e);
        }
        function handleCurrentChange2(node) {
          if (!isCurrent(node)) {
            currentKey.value = node.key;
            emit(CURRENT_CHANGE, node.data, node);
          }
        }
        function handleNodeCheck(node, checked) {
          toggleCheckbox(node, checked);
        }
        function expandNode(node) {
          const keySet = expandedKeySet.value;
          if (tree.value && props2.accordion) {
            const { treeNodeMap } = tree.value;
            keySet.forEach((key) => {
              const treeNode = treeNodeMap.get(key);
              if (node && node.level === (treeNode == null ? void 0 : treeNode.level)) {
                keySet.delete(key);
                treeNode.expanded = false;
              }
            });
          }
          keySet.add(node.key);
          node.expanded = true;
          emit(NODE_EXPAND, node.data, node);
        }
        function collapseNode(node) {
          expandedKeySet.value.delete(node.key);
          node.expanded = false;
          emit(NODE_COLLAPSE, node.data, node);
        }
        function isDisabled(node) {
          return !!node.disabled;
        }
        function isCurrent(node) {
          const current = currentKey.value;
          return current !== void 0 && current === node.key;
        }
        function getCurrentNode() {
          var _a, _b;
          if (!currentKey.value)
            return void 0;
          return (_b = (_a = tree.value) == null ? void 0 : _a.treeNodeMap.get(currentKey.value)) == null ? void 0 : _b.data;
        }
        function getCurrentKey() {
          return currentKey.value;
        }
        function setCurrentKey(key) {
          currentKey.value = key;
        }
        function setData2(data) {
          tree.value = createTree(data);
        }
        function getNode(data) {
          var _a;
          const key = isObject$1(data) ? getKey(data) : data;
          return (_a = tree.value) == null ? void 0 : _a.treeNodeMap.get(key);
        }
        function scrollToNode(key, strategy = "auto") {
          const node = getNode(key);
          if (node && listRef.value) {
            listRef.value.scrollToItem(flattenTree.value.indexOf(node), strategy);
          }
        }
        function scrollTo(offset2) {
          var _a;
          (_a = listRef.value) == null ? void 0 : _a.scrollTo(offset2);
        }
        watch(() => props2.currentNodeKey, (key) => {
          currentKey.value = key;
        }, {
          immediate: true
        });
        watch(() => props2.defaultExpandedKeys, (key) => {
          expandedKeySet.value = new Set(key);
        }, {
          immediate: true
        });
        watch(() => props2.data, (data) => {
          setData2(data);
        }, {
          immediate: true
        });
        return {
          tree,
          flattenTree,
          isNotEmpty,
          listRef,
          getKey,
          getChildren,
          toggleExpand,
          toggleCheckbox,
          isChecked,
          isIndeterminate,
          isDisabled,
          isCurrent,
          isForceHiddenExpandIcon,
          handleNodeClick,
          handleNodeDrop,
          handleNodeCheck,
          getCurrentNode,
          getCurrentKey,
          setCurrentKey,
          getCheckedKeys,
          getCheckedNodes,
          getHalfCheckedKeys,
          getHalfCheckedNodes,
          setChecked,
          setCheckedKeys,
          filter: filter2,
          setData: setData2,
          getNode,
          expandNode,
          collapseNode,
          setExpandedKeys,
          scrollToNode,
          scrollTo
        };
      }
      var ElNodeContent = defineComponent({
        name: "ElTreeNodeContent",
        props: treeNodeContentProps,
        setup(props2) {
          const tree = inject(ROOT_TREE_INJECTION_KEY);
          const ns = useNamespace("tree");
          return () => {
            const node = props2.node;
            const { data } = node;
            return (tree == null ? void 0 : tree.ctx.slots.default) ? tree.ctx.slots.default({ node, data }) : h$1(ElText, { tag: "span", truncated: true, class: ns.be("node", "label") }, () => [node == null ? void 0 : node.label]);
          };
        }
      });
      const __default__$k = defineComponent({
        name: "ElTreeNode"
      });
      const _sfc_main$l = /* @__PURE__ */ defineComponent({
        ...__default__$k,
        props: treeNodeProps,
        emits: treeNodeEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const tree = inject(ROOT_TREE_INJECTION_KEY);
          const ns = useNamespace("tree");
          const indent = computed(() => {
            var _a;
            return (_a = tree == null ? void 0 : tree.props.indent) != null ? _a : 16;
          });
          const icon = computed(() => {
            var _a;
            return (_a = tree == null ? void 0 : tree.props.icon) != null ? _a : caret_right_default$1;
          });
          const getNodeClass = (node) => {
            const nodeClassFunc = tree == null ? void 0 : tree.props.props.class;
            if (!nodeClassFunc)
              return {};
            let className;
            if (isFunction$1(nodeClassFunc)) {
              const { data } = node;
              className = nodeClassFunc(data, node);
            } else {
              className = nodeClassFunc;
            }
            return isString$1(className) ? { [className]: true } : className;
          };
          const handleClick = (e) => {
            emit("click", props2.node, e);
          };
          const handleDrop = (e) => {
            emit("drop", props2.node, e);
          };
          const handleExpandIconClick = () => {
            emit("toggle", props2.node);
          };
          const handleCheckChange = (value) => {
            emit("check", props2.node, value);
          };
          const handleContextMenu = (event) => {
            var _a, _b, _c, _d;
            if ((_c = (_b = (_a = tree == null ? void 0 : tree.instance) == null ? void 0 : _a.vnode) == null ? void 0 : _b.props) == null ? void 0 : _c["onNodeContextmenu"]) {
              event.stopPropagation();
              event.preventDefault();
            }
            tree == null ? void 0 : tree.ctx.emit(NODE_CONTEXTMENU, event, (_d = props2.node) == null ? void 0 : _d.data, props2.node);
          };
          return (_ctx, _cache) => {
            var _a, _b, _c;
            return openBlock(), createElementBlock("div", {
              ref: "node$",
              class: normalizeClass([
                unref(ns).b("node"),
                unref(ns).is("expanded", _ctx.expanded),
                unref(ns).is("current", _ctx.current),
                unref(ns).is("focusable", !_ctx.disabled),
                unref(ns).is("checked", !_ctx.disabled && _ctx.checked),
                getNodeClass(_ctx.node)
              ]),
              role: "treeitem",
              tabindex: "-1",
              "aria-expanded": _ctx.expanded,
              "aria-disabled": _ctx.disabled,
              "aria-checked": _ctx.checked,
              "data-key": (_a = _ctx.node) == null ? void 0 : _a.key,
              onClick: withModifiers(handleClick, ["stop"]),
              onContextmenu: handleContextMenu,
              onDragover: withModifiers(() => {
              }, ["prevent"]),
              onDragenter: withModifiers(() => {
              }, ["prevent"]),
              onDrop: withModifiers(handleDrop, ["stop"])
            }, [
              createElementVNode("div", {
                class: normalizeClass(unref(ns).be("node", "content")),
                style: normalizeStyle({
                  paddingLeft: `${(_ctx.node.level - 1) * unref(indent)}px`,
                  height: _ctx.itemSize + "px"
                })
              }, [
                unref(icon) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass([
                    unref(ns).is("leaf", !!((_b = _ctx.node) == null ? void 0 : _b.isLeaf)),
                    unref(ns).is("hidden", _ctx.hiddenExpandIcon),
                    {
                      expanded: !((_c = _ctx.node) == null ? void 0 : _c.isLeaf) && _ctx.expanded
                    },
                    unref(ns).be("node", "expand-icon")
                  ]),
                  onClick: withModifiers(handleExpandIconClick, ["stop"])
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(icon))))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
                _ctx.showCheckbox ? (openBlock(), createBlock(unref(ElCheckbox), {
                  key: 1,
                  "model-value": _ctx.checked,
                  indeterminate: _ctx.indeterminate,
                  disabled: _ctx.disabled,
                  onChange: handleCheckChange,
                  onClick: withModifiers(() => {
                  }, ["stop"])
                }, null, 8, ["model-value", "indeterminate", "disabled", "onClick"])) : createCommentVNode("v-if", true),
                createVNode(unref(ElNodeContent), {
                  node: { ..._ctx.node, expanded: _ctx.expanded }
                }, null, 8, ["node"])
              ], 6)
            ], 42, ["aria-expanded", "aria-disabled", "aria-checked", "data-key", "onClick", "onDragover", "onDragenter", "onDrop"]);
          };
        }
      });
      var ElTreeNode = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__file", "tree-node.vue"]]);
      const __default__$j = defineComponent({
        name: "ElTreeV2"
      });
      const _sfc_main$k = /* @__PURE__ */ defineComponent({
        ...__default__$j,
        props: treeProps,
        emits: treeEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const slots = useSlots();
          const treeNodeSize = computed(() => props2.itemSize);
          provide(ROOT_TREE_INJECTION_KEY, {
            ctx: {
              emit,
              slots
            },
            props: props2,
            instance: getCurrentInstance()
          });
          provide(formItemContextKey, void 0);
          const { t } = useLocale();
          const ns = useNamespace("tree");
          const {
            flattenTree,
            isNotEmpty,
            listRef,
            toggleExpand,
            isIndeterminate,
            isChecked,
            isDisabled,
            isCurrent,
            isForceHiddenExpandIcon,
            handleNodeClick,
            handleNodeDrop,
            handleNodeCheck,
            toggleCheckbox,
            getCurrentNode,
            getCurrentKey,
            setCurrentKey,
            getCheckedKeys,
            getCheckedNodes,
            getHalfCheckedKeys,
            getHalfCheckedNodes,
            setChecked,
            setCheckedKeys,
            filter: filter2,
            setData: setData2,
            getNode,
            expandNode,
            collapseNode,
            setExpandedKeys,
            scrollToNode,
            scrollTo
          } = useTree(props2, emit);
          expose({
            toggleCheckbox,
            getCurrentNode,
            getCurrentKey,
            setCurrentKey,
            getCheckedKeys,
            getCheckedNodes,
            getHalfCheckedKeys,
            getHalfCheckedNodes,
            setChecked,
            setCheckedKeys,
            filter: filter2,
            setData: setData2,
            getNode,
            expandNode,
            collapseNode,
            setExpandedKeys,
            scrollToNode,
            scrollTo
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b(), { [unref(ns).m("highlight-current")]: _ctx.highlightCurrent }]),
              role: "tree"
            }, [
              unref(isNotEmpty) ? (openBlock(), createBlock(unref(FixedSizeList$1), {
                key: 0,
                ref_key: "listRef",
                ref: listRef,
                "class-name": unref(ns).b("virtual-list"),
                data: unref(flattenTree),
                total: unref(flattenTree).length,
                height: _ctx.height,
                "item-size": unref(treeNodeSize),
                "perf-mode": _ctx.perfMode,
                "scrollbar-always-on": _ctx.scrollbarAlwaysOn
              }, {
                default: withCtx(({ data, index: index2, style }) => [
                  (openBlock(), createBlock(ElTreeNode, {
                    key: data[index2].key,
                    style: normalizeStyle(style),
                    node: data[index2],
                    expanded: data[index2].expanded,
                    "show-checkbox": _ctx.showCheckbox,
                    checked: unref(isChecked)(data[index2]),
                    indeterminate: unref(isIndeterminate)(data[index2]),
                    "item-size": unref(treeNodeSize),
                    disabled: unref(isDisabled)(data[index2]),
                    current: unref(isCurrent)(data[index2]),
                    "hidden-expand-icon": unref(isForceHiddenExpandIcon)(data[index2]),
                    onClick: unref(handleNodeClick),
                    onToggle: unref(toggleExpand),
                    onCheck: unref(handleNodeCheck),
                    onDrop: unref(handleNodeDrop)
                  }, null, 8, ["style", "node", "expanded", "show-checkbox", "checked", "indeterminate", "item-size", "disabled", "current", "hidden-expand-icon", "onClick", "onToggle", "onCheck", "onDrop"]))
                ]),
                _: 1
              }, 8, ["class-name", "data", "total", "height", "item-size", "perf-mode", "scrollbar-always-on"])) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(ns).e("empty-block"))
              }, [
                renderSlot(_ctx.$slots, "empty", {}, () => {
                  var _a;
                  return [
                    createElementVNode("span", {
                      class: normalizeClass(unref(ns).e("empty-text"))
                    }, toDisplayString((_a = _ctx.emptyText) != null ? _a : unref(t)("el.tree.emptyText")), 3)
                  ];
                })
              ], 2))
            ], 2);
          };
        }
      });
      var TreeV2 = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__file", "tree.vue"]]);
      const ElTreeV2 = exports("ElTreeV2", withInstall(TreeV2));
      const uploadContextKey = exports("uploadContextKey", Symbol("uploadContextKey"));
      const SCOPE$2 = "ElUpload";
      class UploadAjaxError extends Error {
        constructor(message2, status, method3, url) {
          super(message2);
          this.name = "UploadAjaxError";
          this.status = status;
          this.method = method3;
          this.url = url;
        }
      }
      function getError(action, option, xhr) {
        let msg;
        if (xhr.response) {
          msg = `${xhr.response.error || xhr.response}`;
        } else if (xhr.responseText) {
          msg = `${xhr.responseText}`;
        } else {
          msg = `fail to ${option.method} ${action} ${xhr.status}`;
        }
        return new UploadAjaxError(msg, xhr.status, option.method, action);
      }
      function getBody(xhr) {
        const text = xhr.responseText || xhr.response;
        if (!text) {
          return text;
        }
        try {
          return JSON.parse(text);
        } catch (e) {
          return text;
        }
      }
      const ajaxUpload = (option) => {
        if (typeof XMLHttpRequest === "undefined")
          throwError(SCOPE$2, "XMLHttpRequest is undefined");
        const xhr = new XMLHttpRequest();
        const action = option.action;
        if (xhr.upload) {
          xhr.upload.addEventListener("progress", (evt) => {
            const progressEvt = evt;
            progressEvt.percent = evt.total > 0 ? evt.loaded / evt.total * 100 : 0;
            option.onProgress(progressEvt);
          });
        }
        const formData = new FormData();
        if (option.data) {
          for (const [key, value] of Object.entries(option.data)) {
            if (isArray$1(value) && value.length)
              formData.append(key, ...value);
            else
              formData.append(key, value);
          }
        }
        formData.append(option.filename, option.file, option.file.name);
        xhr.addEventListener("error", () => {
          option.onError(getError(action, option, xhr));
        });
        xhr.addEventListener("load", () => {
          if (xhr.status < 200 || xhr.status >= 300) {
            return option.onError(getError(action, option, xhr));
          }
          option.onSuccess(getBody(xhr));
        });
        xhr.open(option.method, action, true);
        if (option.withCredentials && "withCredentials" in xhr) {
          xhr.withCredentials = true;
        }
        const headers = option.headers || {};
        if (headers instanceof Headers) {
          headers.forEach((value, key) => xhr.setRequestHeader(key, value));
        } else {
          for (const [key, value] of Object.entries(headers)) {
            if (isNil(value))
              continue;
            xhr.setRequestHeader(key, String(value));
          }
        }
        xhr.send(formData);
        return xhr;
      };
      const uploadListTypes = exports("uploadListTypes", ["text", "picture", "picture-card"]);
      let fileId = 1;
      const genFileId = exports("genFileId", () => Date.now() + fileId++);
      const uploadBaseProps = exports("uploadBaseProps", buildProps({
        action: {
          type: String,
          default: "#"
        },
        headers: {
          type: definePropType(Object)
        },
        method: {
          type: String,
          default: "post"
        },
        data: {
          type: definePropType([Object, Function, Promise]),
          default: () => mutable({})
        },
        multiple: Boolean,
        name: {
          type: String,
          default: "file"
        },
        drag: Boolean,
        withCredentials: Boolean,
        showFileList: {
          type: Boolean,
          default: true
        },
        accept: {
          type: String,
          default: ""
        },
        fileList: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        autoUpload: {
          type: Boolean,
          default: true
        },
        listType: {
          type: String,
          values: uploadListTypes,
          default: "text"
        },
        httpRequest: {
          type: definePropType(Function),
          default: ajaxUpload
        },
        disabled: Boolean,
        limit: Number
      }));
      const uploadProps = exports("uploadProps", buildProps({
        ...uploadBaseProps,
        beforeUpload: {
          type: definePropType(Function),
          default: NOOP
        },
        beforeRemove: {
          type: definePropType(Function)
        },
        onRemove: {
          type: definePropType(Function),
          default: NOOP
        },
        onChange: {
          type: definePropType(Function),
          default: NOOP
        },
        onPreview: {
          type: definePropType(Function),
          default: NOOP
        },
        onSuccess: {
          type: definePropType(Function),
          default: NOOP
        },
        onProgress: {
          type: definePropType(Function),
          default: NOOP
        },
        onError: {
          type: definePropType(Function),
          default: NOOP
        },
        onExceed: {
          type: definePropType(Function),
          default: NOOP
        },
        crossorigin: {
          type: definePropType(String)
        }
      }));
      const uploadListProps = exports("uploadListProps", buildProps({
        files: {
          type: definePropType(Array),
          default: () => mutable([])
        },
        disabled: Boolean,
        handlePreview: {
          type: definePropType(Function),
          default: NOOP
        },
        listType: {
          type: String,
          values: uploadListTypes,
          default: "text"
        },
        crossorigin: {
          type: definePropType(String)
        }
      }));
      const uploadListEmits = exports("uploadListEmits", {
        remove: (file) => !!file
      });
      const __default__$i = defineComponent({
        name: "ElUploadList"
      });
      const _sfc_main$j = /* @__PURE__ */ defineComponent({
        ...__default__$i,
        props: uploadListProps,
        emits: uploadListEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const { t } = useLocale();
          const nsUpload = useNamespace("upload");
          const nsIcon = useNamespace("icon");
          const nsList = useNamespace("list");
          const disabled = useFormDisabled();
          const focusing = ref(false);
          const containerKls = computed(() => [
            nsUpload.b("list"),
            nsUpload.bm("list", props2.listType),
            nsUpload.is("disabled", props2.disabled)
          ]);
          const handleRemove = (file) => {
            emit("remove", file);
          };
          return (_ctx, _cache) => {
            return openBlock(), createBlock(TransitionGroup, {
              tag: "ul",
              class: normalizeClass(unref(containerKls)),
              name: unref(nsList).b()
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.files, (file, index2) => {
                  return openBlock(), createElementBlock("li", {
                    key: file.uid || file.name,
                    class: normalizeClass([
                      unref(nsUpload).be("list", "item"),
                      unref(nsUpload).is(file.status),
                      { focusing: focusing.value }
                    ]),
                    tabindex: "0",
                    onKeydown: withKeys(($event) => !unref(disabled) && handleRemove(file), ["delete"]),
                    onFocus: ($event) => focusing.value = true,
                    onBlur: ($event) => focusing.value = false,
                    onClick: ($event) => focusing.value = false
                  }, [
                    renderSlot(_ctx.$slots, "default", {
                      file,
                      index: index2
                    }, () => [
                      _ctx.listType === "picture" || file.status !== "uploading" && _ctx.listType === "picture-card" ? (openBlock(), createElementBlock("img", {
                        key: 0,
                        class: normalizeClass(unref(nsUpload).be("list", "item-thumbnail")),
                        src: file.url,
                        crossorigin: _ctx.crossorigin,
                        alt: ""
                      }, null, 10, ["src", "crossorigin"])) : createCommentVNode("v-if", true),
                      file.status === "uploading" || _ctx.listType !== "picture-card" ? (openBlock(), createElementBlock("div", {
                        key: 1,
                        class: normalizeClass(unref(nsUpload).be("list", "item-info"))
                      }, [
                        createElementVNode("a", {
                          class: normalizeClass(unref(nsUpload).be("list", "item-name")),
                          onClick: withModifiers(($event) => _ctx.handlePreview(file), ["prevent"])
                        }, [
                          createVNode(unref(ElIcon), {
                            class: normalizeClass(unref(nsIcon).m("document"))
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(document_default$1))
                            ]),
                            _: 1
                          }, 8, ["class"]),
                          createElementVNode("span", {
                            class: normalizeClass(unref(nsUpload).be("list", "item-file-name")),
                            title: file.name
                          }, toDisplayString(file.name), 11, ["title"])
                        ], 10, ["onClick"]),
                        file.status === "uploading" ? (openBlock(), createBlock(unref(ElProgress), {
                          key: 0,
                          type: _ctx.listType === "picture-card" ? "circle" : "line",
                          "stroke-width": _ctx.listType === "picture-card" ? 6 : 2,
                          percentage: Number(file.percentage),
                          style: normalizeStyle(_ctx.listType === "picture-card" ? "" : "margin-top: 0.5rem")
                        }, null, 8, ["type", "stroke-width", "percentage", "style"])) : createCommentVNode("v-if", true)
                      ], 2)) : createCommentVNode("v-if", true),
                      createElementVNode("label", {
                        class: normalizeClass(unref(nsUpload).be("list", "item-status-label"))
                      }, [
                        _ctx.listType === "text" ? (openBlock(), createBlock(unref(ElIcon), {
                          key: 0,
                          class: normalizeClass([unref(nsIcon).m("upload-success"), unref(nsIcon).m("circle-check")])
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(circle_check_default$1))
                          ]),
                          _: 1
                        }, 8, ["class"])) : ["picture-card", "picture"].includes(_ctx.listType) ? (openBlock(), createBlock(unref(ElIcon), {
                          key: 1,
                          class: normalizeClass([unref(nsIcon).m("upload-success"), unref(nsIcon).m("check")])
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(check_default$1))
                          ]),
                          _: 1
                        }, 8, ["class"])) : createCommentVNode("v-if", true)
                      ], 2),
                      !unref(disabled) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 2,
                        class: normalizeClass(unref(nsIcon).m("close")),
                        onClick: ($event) => handleRemove(file)
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(close_default$1))
                        ]),
                        _: 2
                      }, 1032, ["class", "onClick"])) : createCommentVNode("v-if", true),
                      createCommentVNode(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
                      createCommentVNode(" This is a bug which needs to be fixed "),
                      createCommentVNode(" TODO: Fix the incorrect navigation interaction "),
                      !unref(disabled) ? (openBlock(), createElementBlock("i", {
                        key: 3,
                        class: normalizeClass(unref(nsIcon).m("close-tip"))
                      }, toDisplayString(unref(t)("el.upload.deleteTip")), 3)) : createCommentVNode("v-if", true),
                      _ctx.listType === "picture-card" ? (openBlock(), createElementBlock("span", {
                        key: 4,
                        class: normalizeClass(unref(nsUpload).be("list", "item-actions"))
                      }, [
                        createElementVNode("span", {
                          class: normalizeClass(unref(nsUpload).be("list", "item-preview")),
                          onClick: ($event) => _ctx.handlePreview(file)
                        }, [
                          createVNode(unref(ElIcon), {
                            class: normalizeClass(unref(nsIcon).m("zoom-in"))
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(zoom_in_default$1))
                            ]),
                            _: 1
                          }, 8, ["class"])
                        ], 10, ["onClick"]),
                        !unref(disabled) ? (openBlock(), createElementBlock("span", {
                          key: 0,
                          class: normalizeClass(unref(nsUpload).be("list", "item-delete")),
                          onClick: ($event) => handleRemove(file)
                        }, [
                          createVNode(unref(ElIcon), {
                            class: normalizeClass(unref(nsIcon).m("delete"))
                          }, {
                            default: withCtx(() => [
                              createVNode(unref(delete_default$1))
                            ]),
                            _: 1
                          }, 8, ["class"])
                        ], 10, ["onClick"])) : createCommentVNode("v-if", true)
                      ], 2)) : createCommentVNode("v-if", true)
                    ])
                  ], 42, ["onKeydown", "onFocus", "onBlur", "onClick"]);
                }), 128)),
                renderSlot(_ctx.$slots, "append")
              ]),
              _: 3
            }, 8, ["class", "name"]);
          };
        }
      });
      var UploadList = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__file", "upload-list.vue"]]);
      const uploadDraggerProps = exports("uploadDraggerProps", buildProps({
        disabled: Boolean
      }));
      const uploadDraggerEmits = exports("uploadDraggerEmits", {
        file: (file) => isArray$1(file)
      });
      const COMPONENT_NAME$1 = "ElUploadDrag";
      const __default__$h = defineComponent({
        name: COMPONENT_NAME$1
      });
      const _sfc_main$i = /* @__PURE__ */ defineComponent({
        ...__default__$h,
        props: uploadDraggerProps,
        emits: uploadDraggerEmits,
        setup(__props, { emit }) {
          const uploaderContext = inject(uploadContextKey);
          if (!uploaderContext) {
            throwError(COMPONENT_NAME$1, "usage: <el-upload><el-upload-dragger /></el-upload>");
          }
          const ns = useNamespace("upload");
          const dragover = ref(false);
          const disabled = useFormDisabled();
          const onDrop = (e) => {
            if (disabled.value)
              return;
            dragover.value = false;
            e.stopPropagation();
            const files = Array.from(e.dataTransfer.files);
            const items = e.dataTransfer.items || [];
            files.forEach((file, index2) => {
              var _a;
              const item = items[index2];
              const entry = (_a = item == null ? void 0 : item.webkitGetAsEntry) == null ? void 0 : _a.call(item);
              if (entry) {
                file.isDirectory = entry.isDirectory;
              }
            });
            emit("file", files);
          };
          const onDragover = () => {
            if (!disabled.value)
              dragover.value = true;
          };
          const onDragleave = (e) => {
            if (!e.currentTarget.contains(e.relatedTarget))
              dragover.value = false;
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b("dragger"), unref(ns).is("dragover", dragover.value)]),
              onDrop: withModifiers(onDrop, ["prevent"]),
              onDragover: withModifiers(onDragover, ["prevent"]),
              onDragleave: withModifiers(onDragleave, ["prevent"])
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 42, ["onDrop", "onDragover", "onDragleave"]);
          };
        }
      });
      var UploadDragger = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__file", "upload-dragger.vue"]]);
      const uploadContentProps = exports("uploadContentProps", buildProps({
        ...uploadBaseProps,
        beforeUpload: {
          type: definePropType(Function),
          default: NOOP
        },
        onRemove: {
          type: definePropType(Function),
          default: NOOP
        },
        onStart: {
          type: definePropType(Function),
          default: NOOP
        },
        onSuccess: {
          type: definePropType(Function),
          default: NOOP
        },
        onProgress: {
          type: definePropType(Function),
          default: NOOP
        },
        onError: {
          type: definePropType(Function),
          default: NOOP
        },
        onExceed: {
          type: definePropType(Function),
          default: NOOP
        }
      }));
      const __default__$g = defineComponent({
        name: "ElUploadContent",
        inheritAttrs: false
      });
      const _sfc_main$h = /* @__PURE__ */ defineComponent({
        ...__default__$g,
        props: uploadContentProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const ns = useNamespace("upload");
          const disabled = useFormDisabled();
          const requests = shallowRef({});
          const inputRef = shallowRef();
          const uploadFiles = (files) => {
            if (files.length === 0)
              return;
            const { autoUpload, limit, fileList, multiple, onStart, onExceed } = props2;
            if (limit && fileList.length + files.length > limit) {
              onExceed(files, fileList);
              return;
            }
            if (!multiple) {
              files = files.slice(0, 1);
            }
            for (const file of files) {
              const rawFile = file;
              rawFile.uid = genFileId();
              onStart(rawFile);
              if (autoUpload)
                upload(rawFile);
            }
          };
          const upload = async (rawFile) => {
            inputRef.value.value = "";
            if (!props2.beforeUpload) {
              return doUpload(rawFile);
            }
            let hookResult;
            let beforeData = {};
            try {
              const originData = props2.data;
              const beforeUploadPromise = props2.beforeUpload(rawFile);
              beforeData = isPlainObject$1(props2.data) ? cloneDeep(props2.data) : props2.data;
              hookResult = await beforeUploadPromise;
              if (isPlainObject$1(props2.data) && isEqual$1(originData, beforeData)) {
                beforeData = cloneDeep(props2.data);
              }
            } catch (e) {
              hookResult = false;
            }
            if (hookResult === false) {
              props2.onRemove(rawFile);
              return;
            }
            let file = rawFile;
            if (hookResult instanceof Blob) {
              if (hookResult instanceof File) {
                file = hookResult;
              } else {
                file = new File([hookResult], rawFile.name, {
                  type: rawFile.type
                });
              }
            }
            doUpload(Object.assign(file, {
              uid: rawFile.uid
            }), beforeData);
          };
          const resolveData = async (data, rawFile) => {
            if (isFunction$1(data)) {
              return data(rawFile);
            }
            return data;
          };
          const doUpload = async (rawFile, beforeData) => {
            const {
              headers,
              data,
              method: method3,
              withCredentials,
              name: filename,
              action,
              onProgress,
              onSuccess,
              onError,
              httpRequest
            } = props2;
            try {
              beforeData = await resolveData(beforeData != null ? beforeData : data, rawFile);
            } catch (e) {
              props2.onRemove(rawFile);
              return;
            }
            const { uid: uid2 } = rawFile;
            const options = {
              headers: headers || {},
              withCredentials,
              file: rawFile,
              data: beforeData,
              method: method3,
              filename,
              action,
              onProgress: (evt) => {
                onProgress(evt, rawFile);
              },
              onSuccess: (res) => {
                onSuccess(res, rawFile);
                delete requests.value[uid2];
              },
              onError: (err) => {
                onError(err, rawFile);
                delete requests.value[uid2];
              }
            };
            const request = httpRequest(options);
            requests.value[uid2] = request;
            if (request instanceof Promise) {
              request.then(options.onSuccess, options.onError);
            }
          };
          const handleChange = (e) => {
            const files = e.target.files;
            if (!files)
              return;
            uploadFiles(Array.from(files));
          };
          const handleClick = () => {
            if (!disabled.value) {
              inputRef.value.value = "";
              inputRef.value.click();
            }
          };
          const handleKeydown = () => {
            handleClick();
          };
          const abort = (file) => {
            const _reqs = entriesOf(requests.value).filter(file ? ([uid2]) => String(file.uid) === uid2 : () => true);
            _reqs.forEach(([uid2, req]) => {
              if (req instanceof XMLHttpRequest)
                req.abort();
              delete requests.value[uid2];
            });
          };
          expose({
            abort,
            upload
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([
                unref(ns).b(),
                unref(ns).m(_ctx.listType),
                unref(ns).is("drag", _ctx.drag),
                unref(ns).is("disabled", unref(disabled))
              ]),
              tabindex: unref(disabled) ? "-1" : "0",
              onClick: handleClick,
              onKeydown: withKeys(withModifiers(handleKeydown, ["self"]), ["enter", "space"])
            }, [
              _ctx.drag ? (openBlock(), createBlock(UploadDragger, {
                key: 0,
                disabled: unref(disabled),
                onFile: uploadFiles
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["disabled"])) : renderSlot(_ctx.$slots, "default", { key: 1 }),
              createElementVNode("input", {
                ref_key: "inputRef",
                ref: inputRef,
                class: normalizeClass(unref(ns).e("input")),
                name: _ctx.name,
                disabled: unref(disabled),
                multiple: _ctx.multiple,
                accept: _ctx.accept,
                type: "file",
                onChange: handleChange,
                onClick: withModifiers(() => {
                }, ["stop"])
              }, null, 42, ["name", "disabled", "multiple", "accept", "onClick"])
            ], 42, ["tabindex", "onKeydown"]);
          };
        }
      });
      var UploadContent = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__file", "upload-content.vue"]]);
      const SCOPE$1 = "ElUpload";
      const revokeFileObjectURL = (file) => {
        var _a;
        if ((_a = file.url) == null ? void 0 : _a.startsWith("blob:")) {
          URL.revokeObjectURL(file.url);
        }
      };
      const useHandlers = (props2, uploadRef) => {
        const uploadFiles = useVModel(props2, "fileList", void 0, { passive: true });
        const getFile = (rawFile) => uploadFiles.value.find((file) => file.uid === rawFile.uid);
        function abort(file) {
          var _a;
          (_a = uploadRef.value) == null ? void 0 : _a.abort(file);
        }
        function clearFiles(states = ["ready", "uploading", "success", "fail"]) {
          uploadFiles.value = uploadFiles.value.filter((row) => !states.includes(row.status));
        }
        function removeFile(file) {
          uploadFiles.value = uploadFiles.value.filter((uploadFile) => uploadFile.uid !== file.uid);
        }
        const handleError = (err, rawFile) => {
          const file = getFile(rawFile);
          if (!file)
            return;
          console.error(err);
          file.status = "fail";
          removeFile(file);
          props2.onError(err, file, uploadFiles.value);
          props2.onChange(file, uploadFiles.value);
        };
        const handleProgress = (evt, rawFile) => {
          const file = getFile(rawFile);
          if (!file)
            return;
          props2.onProgress(evt, file, uploadFiles.value);
          file.status = "uploading";
          file.percentage = Math.round(evt.percent);
        };
        const handleSuccess = (response, rawFile) => {
          const file = getFile(rawFile);
          if (!file)
            return;
          file.status = "success";
          file.response = response;
          props2.onSuccess(response, file, uploadFiles.value);
          props2.onChange(file, uploadFiles.value);
        };
        const handleStart = (file) => {
          if (isNil(file.uid))
            file.uid = genFileId();
          const uploadFile = {
            name: file.name,
            percentage: 0,
            status: "ready",
            size: file.size,
            raw: file,
            uid: file.uid
          };
          if (props2.listType === "picture-card" || props2.listType === "picture") {
            try {
              uploadFile.url = URL.createObjectURL(file);
            } catch (err) {
              debugWarn(SCOPE$1, err.message);
              props2.onError(err, uploadFile, uploadFiles.value);
            }
          }
          uploadFiles.value = [...uploadFiles.value, uploadFile];
          props2.onChange(uploadFile, uploadFiles.value);
        };
        const handleRemove = async (file) => {
          const uploadFile = file instanceof File ? getFile(file) : file;
          if (!uploadFile)
            throwError(SCOPE$1, "file to be removed not found");
          const doRemove = (file2) => {
            abort(file2);
            removeFile(file2);
            props2.onRemove(file2, uploadFiles.value);
            revokeFileObjectURL(file2);
          };
          if (props2.beforeRemove) {
            const before2 = await props2.beforeRemove(uploadFile, uploadFiles.value);
            if (before2 !== false)
              doRemove(uploadFile);
          } else {
            doRemove(uploadFile);
          }
        };
        function submit() {
          uploadFiles.value.filter(({ status }) => status === "ready").forEach(({ raw }) => {
            var _a;
            return raw && ((_a = uploadRef.value) == null ? void 0 : _a.upload(raw));
          });
        }
        watch(() => props2.listType, (val) => {
          if (val !== "picture-card" && val !== "picture") {
            return;
          }
          uploadFiles.value = uploadFiles.value.map((file) => {
            const { raw, url } = file;
            if (!url && raw) {
              try {
                file.url = URL.createObjectURL(raw);
              } catch (err) {
                props2.onError(err, file, uploadFiles.value);
              }
            }
            return file;
          });
        });
        watch(uploadFiles, (files) => {
          for (const file of files) {
            file.uid || (file.uid = genFileId());
            file.status || (file.status = "success");
          }
        }, { immediate: true, deep: true });
        return {
          uploadFiles,
          abort,
          clearFiles,
          handleError,
          handleProgress,
          handleStart,
          handleSuccess,
          handleRemove,
          submit,
          revokeFileObjectURL
        };
      };
      const __default__$f = defineComponent({
        name: "ElUpload"
      });
      const _sfc_main$g = /* @__PURE__ */ defineComponent({
        ...__default__$f,
        props: uploadProps,
        setup(__props, { expose }) {
          const props2 = __props;
          const disabled = useFormDisabled();
          const uploadRef = shallowRef();
          const {
            abort,
            submit,
            clearFiles,
            uploadFiles,
            handleStart,
            handleError,
            handleRemove,
            handleSuccess,
            handleProgress,
            revokeFileObjectURL: revokeFileObjectURL2
          } = useHandlers(props2, uploadRef);
          const isPictureCard = computed(() => props2.listType === "picture-card");
          const uploadContentProps2 = computed(() => ({
            ...props2,
            fileList: uploadFiles.value,
            onStart: handleStart,
            onProgress: handleProgress,
            onSuccess: handleSuccess,
            onError: handleError,
            onRemove: handleRemove
          }));
          onBeforeUnmount(() => {
            uploadFiles.value.forEach(revokeFileObjectURL2);
          });
          provide(uploadContextKey, {
            accept: toRef(props2, "accept")
          });
          expose({
            abort,
            submit,
            clearFiles,
            handleStart,
            handleRemove
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", null, [
              unref(isPictureCard) && _ctx.showFileList ? (openBlock(), createBlock(UploadList, {
                key: 0,
                disabled: unref(disabled),
                "list-type": _ctx.listType,
                files: unref(uploadFiles),
                crossorigin: _ctx.crossorigin,
                "handle-preview": _ctx.onPreview,
                onRemove: unref(handleRemove)
              }, createSlots({
                append: withCtx(() => [
                  createVNode(UploadContent, mergeProps({
                    ref_key: "uploadRef",
                    ref: uploadRef
                  }, unref(uploadContentProps2)), {
                    default: withCtx(() => [
                      _ctx.$slots.trigger ? renderSlot(_ctx.$slots, "trigger", { key: 0 }) : createCommentVNode("v-if", true),
                      !_ctx.$slots.trigger && _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 1 }) : createCommentVNode("v-if", true)
                    ]),
                    _: 3
                  }, 16)
                ]),
                _: 2
              }, [
                _ctx.$slots.file ? {
                  name: "default",
                  fn: withCtx(({ file, index: index2 }) => [
                    renderSlot(_ctx.$slots, "file", {
                      file,
                      index: index2
                    })
                  ])
                } : void 0
              ]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : createCommentVNode("v-if", true),
              !unref(isPictureCard) || unref(isPictureCard) && !_ctx.showFileList ? (openBlock(), createBlock(UploadContent, mergeProps({
                key: 1,
                ref_key: "uploadRef",
                ref: uploadRef
              }, unref(uploadContentProps2)), {
                default: withCtx(() => [
                  _ctx.$slots.trigger ? renderSlot(_ctx.$slots, "trigger", { key: 0 }) : createCommentVNode("v-if", true),
                  !_ctx.$slots.trigger && _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 1 }) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 16)) : createCommentVNode("v-if", true),
              _ctx.$slots.trigger ? renderSlot(_ctx.$slots, "default", { key: 2 }) : createCommentVNode("v-if", true),
              renderSlot(_ctx.$slots, "tip"),
              !unref(isPictureCard) && _ctx.showFileList ? (openBlock(), createBlock(UploadList, {
                key: 3,
                disabled: unref(disabled),
                "list-type": _ctx.listType,
                files: unref(uploadFiles),
                crossorigin: _ctx.crossorigin,
                "handle-preview": _ctx.onPreview,
                onRemove: unref(handleRemove)
              }, createSlots({
                _: 2
              }, [
                _ctx.$slots.file ? {
                  name: "default",
                  fn: withCtx(({ file, index: index2 }) => [
                    renderSlot(_ctx.$slots, "file", {
                      file,
                      index: index2
                    })
                  ])
                } : void 0
              ]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : createCommentVNode("v-if", true)
            ]);
          };
        }
      });
      var Upload = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__file", "upload.vue"]]);
      const ElUpload = exports("ElUpload", withInstall(Upload));
      const watermarkProps = exports("watermarkProps", buildProps({
        zIndex: {
          type: Number,
          default: 9
        },
        rotate: {
          type: Number,
          default: -22
        },
        width: Number,
        height: Number,
        image: String,
        content: {
          type: definePropType([String, Array]),
          default: "Element Plus"
        },
        font: {
          type: definePropType(Object)
        },
        gap: {
          type: definePropType(Array),
          default: () => [100, 100]
        },
        offset: {
          type: definePropType(Array)
        }
      }));
      function toLowercaseSeparator(key) {
        return key.replace(/([A-Z])/g, "-$1").toLowerCase();
      }
      function getStyleStr(style) {
        return Object.keys(style).map((key) => `${toLowercaseSeparator(key)}: ${style[key]};`).join(" ");
      }
      function getPixelRatio() {
        return window.devicePixelRatio || 1;
      }
      const reRendering = (mutation, watermarkElement) => {
        let flag = false;
        if (mutation.removedNodes.length && watermarkElement) {
          flag = Array.from(mutation.removedNodes).includes(watermarkElement);
        }
        if (mutation.type === "attributes" && mutation.target === watermarkElement) {
          flag = true;
        }
        return flag;
      };
      const FontGap = 3;
      const TEXT_ALIGN_RATIO_MAP = {
        left: [0, 0.5],
        start: [0, 0.5],
        center: [0.5, 0],
        right: [1, -0.5],
        end: [1, -0.5]
      };
      function prepareCanvas(width, height, ratio = 1) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        const realWidth = width * ratio;
        const realHeight = height * ratio;
        canvas.setAttribute("width", `${realWidth}px`);
        canvas.setAttribute("height", `${realHeight}px`);
        ctx.save();
        return [ctx, canvas, realWidth, realHeight];
      }
      function useClips() {
        function getClips(content, rotate, ratio, width, height, font, gapX, gapY, space) {
          const [ctx, canvas, contentWidth, contentHeight] = prepareCanvas(width, height, ratio);
          if (content instanceof HTMLImageElement) {
            ctx.drawImage(content, 0, 0, contentWidth, contentHeight);
          } else {
            const {
              color,
              fontSize,
              fontStyle,
              fontWeight,
              fontFamily,
              textAlign,
              textBaseline
            } = font;
            const mergedFontSize = Number(fontSize) * ratio;
            ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${height}px ${fontFamily}`;
            ctx.fillStyle = color;
            ctx.textAlign = textAlign;
            ctx.textBaseline = textBaseline;
            const contents = isArray$1(content) ? content : [content];
            contents == null ? void 0 : contents.forEach((item, index2) => {
              const [alignRatio, spaceRatio] = TEXT_ALIGN_RATIO_MAP[textAlign];
              ctx.fillText(item != null ? item : "", contentWidth * alignRatio + space * spaceRatio, index2 * (mergedFontSize + FontGap * ratio));
            });
          }
          const angle = Math.PI / 180 * Number(rotate);
          const maxSize = Math.max(width, height);
          const [rCtx, rCanvas, realMaxSize] = prepareCanvas(maxSize, maxSize, ratio);
          rCtx.translate(realMaxSize / 2, realMaxSize / 2);
          rCtx.rotate(angle);
          if (contentWidth > 0 && contentHeight > 0) {
            rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2);
          }
          function getRotatePos(x2, y) {
            const targetX = x2 * Math.cos(angle) - y * Math.sin(angle);
            const targetY = x2 * Math.sin(angle) + y * Math.cos(angle);
            return [targetX, targetY];
          }
          let left = 0;
          let right = 0;
          let top = 0;
          let bottom = 0;
          const halfWidth = contentWidth / 2;
          const halfHeight = contentHeight / 2;
          const points = [
            [0 - halfWidth, 0 - halfHeight],
            [0 + halfWidth, 0 - halfHeight],
            [0 + halfWidth, 0 + halfHeight],
            [0 - halfWidth, 0 + halfHeight]
          ];
          points.forEach(([x2, y]) => {
            const [targetX, targetY] = getRotatePos(x2, y);
            left = Math.min(left, targetX);
            right = Math.max(right, targetX);
            top = Math.min(top, targetY);
            bottom = Math.max(bottom, targetY);
          });
          const cutLeft = left + realMaxSize / 2;
          const cutTop = top + realMaxSize / 2;
          const cutWidth = right - left;
          const cutHeight = bottom - top;
          const realGapX = gapX * ratio;
          const realGapY = gapY * ratio;
          const filledWidth = (cutWidth + realGapX) * 2;
          const filledHeight = cutHeight + realGapY;
          const [fCtx, fCanvas] = prepareCanvas(filledWidth, filledHeight);
          function drawImg(targetX = 0, targetY = 0) {
            fCtx.drawImage(rCanvas, cutLeft, cutTop, cutWidth, cutHeight, targetX, targetY, cutWidth, cutHeight);
          }
          drawImg();
          drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2);
          drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2);
          return [fCanvas.toDataURL(), filledWidth / ratio, filledHeight / ratio];
        }
        return getClips;
      }
      const __default__$e = defineComponent({
        name: "ElWatermark"
      });
      const _sfc_main$f = /* @__PURE__ */ defineComponent({
        ...__default__$e,
        props: watermarkProps,
        setup(__props) {
          const props2 = __props;
          const style = {
            position: "relative"
          };
          const color = computed(() => {
            var _a, _b;
            return (_b = (_a = props2.font) == null ? void 0 : _a.color) != null ? _b : "rgba(0,0,0,.15)";
          });
          const fontSize = computed(() => {
            var _a, _b;
            return (_b = (_a = props2.font) == null ? void 0 : _a.fontSize) != null ? _b : 16;
          });
          const fontWeight = computed(() => {
            var _a, _b;
            return (_b = (_a = props2.font) == null ? void 0 : _a.fontWeight) != null ? _b : "normal";
          });
          const fontStyle = computed(() => {
            var _a, _b;
            return (_b = (_a = props2.font) == null ? void 0 : _a.fontStyle) != null ? _b : "normal";
          });
          const fontFamily = computed(() => {
            var _a, _b;
            return (_b = (_a = props2.font) == null ? void 0 : _a.fontFamily) != null ? _b : "sans-serif";
          });
          const textAlign = computed(() => {
            var _a, _b;
            return (_b = (_a = props2.font) == null ? void 0 : _a.textAlign) != null ? _b : "center";
          });
          const textBaseline = computed(() => {
            var _a, _b;
            return (_b = (_a = props2.font) == null ? void 0 : _a.textBaseline) != null ? _b : "hanging";
          });
          const gapX = computed(() => props2.gap[0]);
          const gapY = computed(() => props2.gap[1]);
          const gapXCenter = computed(() => gapX.value / 2);
          const gapYCenter = computed(() => gapY.value / 2);
          const offsetLeft = computed(() => {
            var _a, _b;
            return (_b = (_a = props2.offset) == null ? void 0 : _a[0]) != null ? _b : gapXCenter.value;
          });
          const offsetTop = computed(() => {
            var _a, _b;
            return (_b = (_a = props2.offset) == null ? void 0 : _a[1]) != null ? _b : gapYCenter.value;
          });
          const getMarkStyle = () => {
            const markStyle = {
              zIndex: props2.zIndex,
              position: "absolute",
              left: 0,
              top: 0,
              width: "100%",
              height: "100%",
              pointerEvents: "none",
              backgroundRepeat: "repeat"
            };
            let positionLeft = offsetLeft.value - gapXCenter.value;
            let positionTop = offsetTop.value - gapYCenter.value;
            if (positionLeft > 0) {
              markStyle.left = `${positionLeft}px`;
              markStyle.width = `calc(100% - ${positionLeft}px)`;
              positionLeft = 0;
            }
            if (positionTop > 0) {
              markStyle.top = `${positionTop}px`;
              markStyle.height = `calc(100% - ${positionTop}px)`;
              positionTop = 0;
            }
            markStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;
            return markStyle;
          };
          const containerRef = shallowRef(null);
          const watermarkRef = shallowRef();
          const stopObservation = ref(false);
          const destroyWatermark = () => {
            if (watermarkRef.value) {
              watermarkRef.value.remove();
              watermarkRef.value = void 0;
            }
          };
          const appendWatermark = (base64Url, markWidth) => {
            var _a;
            if (containerRef.value && watermarkRef.value) {
              stopObservation.value = true;
              watermarkRef.value.setAttribute("style", getStyleStr({
                ...getMarkStyle(),
                backgroundImage: `url('${base64Url}')`,
                backgroundSize: `${Math.floor(markWidth)}px`
              }));
              (_a = containerRef.value) == null ? void 0 : _a.append(watermarkRef.value);
              setTimeout(() => {
                stopObservation.value = false;
              });
            }
          };
          const getMarkSize = (ctx) => {
            let defaultWidth = 120;
            let defaultHeight = 64;
            let space = 0;
            const { image, content, width, height, rotate } = props2;
            if (!image && ctx.measureText) {
              ctx.font = `${Number(fontSize.value)}px ${fontFamily.value}`;
              const contents = isArray$1(content) ? content : [content];
              let maxWidth = 0;
              let maxHeight = 0;
              contents.forEach((item) => {
                const {
                  width: width2,
                  fontBoundingBoxAscent,
                  fontBoundingBoxDescent,
                  actualBoundingBoxAscent,
                  actualBoundingBoxDescent
                } = ctx.measureText(item);
                const height2 = isUndefined(fontBoundingBoxAscent) ? actualBoundingBoxAscent + actualBoundingBoxDescent : fontBoundingBoxAscent + fontBoundingBoxDescent;
                if (width2 > maxWidth)
                  maxWidth = Math.ceil(width2);
                if (height2 > maxHeight)
                  maxHeight = Math.ceil(height2);
              });
              defaultWidth = maxWidth;
              defaultHeight = maxHeight * contents.length + (contents.length - 1) * FontGap;
              const angle = Math.PI / 180 * Number(rotate);
              space = Math.ceil(Math.abs(Math.sin(angle) * defaultHeight) / 2);
              defaultWidth += space;
            }
            return [width != null ? width : defaultWidth, height != null ? height : defaultHeight, space];
          };
          const getClips = useClips();
          const renderWatermark = () => {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            const image = props2.image;
            const content = props2.content;
            const rotate = props2.rotate;
            if (ctx) {
              if (!watermarkRef.value) {
                watermarkRef.value = document.createElement("div");
              }
              const ratio = getPixelRatio();
              const [markWidth, markHeight, space] = getMarkSize(ctx);
              const drawCanvas = (drawContent) => {
                const [textClips, clipWidth] = getClips(drawContent || "", rotate, ratio, markWidth, markHeight, {
                  color: color.value,
                  fontSize: fontSize.value,
                  fontStyle: fontStyle.value,
                  fontWeight: fontWeight.value,
                  fontFamily: fontFamily.value,
                  textAlign: textAlign.value,
                  textBaseline: textBaseline.value
                }, gapX.value, gapY.value, space);
                appendWatermark(textClips, clipWidth);
              };
              if (image) {
                const img = new Image();
                img.onload = () => {
                  drawCanvas(img);
                };
                img.onerror = () => {
                  drawCanvas(content);
                };
                img.crossOrigin = "anonymous";
                img.referrerPolicy = "no-referrer";
                img.src = image;
              } else {
                drawCanvas(content);
              }
            }
          };
          onMounted(() => {
            renderWatermark();
          });
          watch(() => props2, () => {
            renderWatermark();
          }, {
            deep: true,
            flush: "post"
          });
          onBeforeUnmount(() => {
            destroyWatermark();
          });
          const onMutate = (mutations) => {
            if (stopObservation.value) {
              return;
            }
            mutations.forEach((mutation) => {
              if (reRendering(mutation, watermarkRef.value)) {
                destroyWatermark();
                renderWatermark();
              }
            });
          };
          useMutationObserver(containerRef, onMutate, {
            attributes: true,
            subtree: true,
            childList: true
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "containerRef",
              ref: containerRef,
              style: normalizeStyle([style])
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 4);
          };
        }
      });
      var Watermark = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__file", "watermark.vue"]]);
      const ElWatermark = exports("ElWatermark", withInstall(Watermark));
      const maskProps = buildProps({
        zIndex: {
          type: Number,
          default: 1001
        },
        visible: Boolean,
        fill: {
          type: String,
          default: "rgba(0,0,0,0.5)"
        },
        pos: {
          type: definePropType(Object)
        },
        targetAreaClickable: {
          type: Boolean,
          default: true
        }
      });
      const useTarget = (target2, open, gap, mergedMask, scrollIntoViewOptions) => {
        const posInfo = ref(null);
        const getTargetEl = () => {
          let targetEl;
          if (isString$1(target2.value)) {
            targetEl = document.querySelector(target2.value);
          } else if (isFunction$1(target2.value)) {
            targetEl = target2.value();
          } else {
            targetEl = target2.value;
          }
          return targetEl;
        };
        const updatePosInfo = () => {
          const targetEl = getTargetEl();
          if (!targetEl || !open.value) {
            posInfo.value = null;
            return;
          }
          if (!isInViewPort(targetEl)) {
            targetEl.scrollIntoView(scrollIntoViewOptions.value);
          }
          const { left, top, width, height } = targetEl.getBoundingClientRect();
          posInfo.value = {
            left,
            top,
            width,
            height,
            radius: 0
          };
        };
        onMounted(() => {
          watch([open, target2], () => {
            updatePosInfo();
          }, {
            immediate: true
          });
          window.addEventListener("resize", updatePosInfo);
        });
        onBeforeUnmount(() => {
          window.removeEventListener("resize", updatePosInfo);
        });
        const getGapOffset = (index2) => {
          var _a;
          return (_a = isArray$1(gap.value.offset) ? gap.value.offset[index2] : gap.value.offset) != null ? _a : 6;
        };
        const mergedPosInfo = computed(() => {
          var _a;
          if (!posInfo.value)
            return posInfo.value;
          const gapOffsetX = getGapOffset(0);
          const gapOffsetY = getGapOffset(1);
          const gapRadius = ((_a = gap.value) == null ? void 0 : _a.radius) || 2;
          return {
            left: posInfo.value.left - gapOffsetX,
            top: posInfo.value.top - gapOffsetY,
            width: posInfo.value.width + gapOffsetX * 2,
            height: posInfo.value.height + gapOffsetY * 2,
            radius: gapRadius
          };
        });
        const triggerTarget = computed(() => {
          const targetEl = getTargetEl();
          if (!mergedMask.value || !targetEl || !window.DOMRect) {
            return targetEl || void 0;
          }
          return {
            getBoundingClientRect() {
              var _a, _b, _c, _d;
              return window.DOMRect.fromRect({
                width: ((_a = mergedPosInfo.value) == null ? void 0 : _a.width) || 0,
                height: ((_b = mergedPosInfo.value) == null ? void 0 : _b.height) || 0,
                x: ((_c = mergedPosInfo.value) == null ? void 0 : _c.left) || 0,
                y: ((_d = mergedPosInfo.value) == null ? void 0 : _d.top) || 0
              });
            }
          };
        });
        return {
          mergedPosInfo,
          triggerTarget
        };
      };
      const tourKey = Symbol("ElTour");
      function isInViewPort(element) {
        const viewWidth = window.innerWidth || document.documentElement.clientWidth;
        const viewHeight = window.innerHeight || document.documentElement.clientHeight;
        const { top, right, bottom, left } = element.getBoundingClientRect();
        return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight;
      }
      const useFloating = (referenceRef, contentRef, arrowRef, placement, strategy, offset$1, zIndex2, showArrow) => {
        const x2 = ref();
        const y = ref();
        const middlewareData = ref({});
        const states = {
          x: x2,
          y,
          placement,
          strategy,
          middlewareData
        };
        const middleware = computed(() => {
          const _middleware = [
            offset(unref(offset$1)),
            flip(),
            shift(),
            overflowMiddleware()
          ];
          if (unref(showArrow) && unref(arrowRef)) {
            _middleware.push(arrow({
              element: unref(arrowRef)
            }));
          }
          return _middleware;
        });
        const update2 = async () => {
          if (!isClient)
            return;
          const referenceEl = unref(referenceRef);
          const contentEl = unref(contentRef);
          if (!referenceEl || !contentEl)
            return;
          const data = await computePosition(referenceEl, contentEl, {
            placement: unref(placement),
            strategy: unref(strategy),
            middleware: unref(middleware)
          });
          keysOf(states).forEach((key) => {
            states[key].value = data[key];
          });
        };
        const contentStyle = computed(() => {
          if (!unref(referenceRef)) {
            return {
              position: "fixed",
              top: "50%",
              left: "50%",
              transform: "translate3d(-50%, -50%, 0)",
              maxWidth: "100vw",
              zIndex: unref(zIndex2)
            };
          }
          const { overflow } = unref(middlewareData);
          return {
            position: unref(strategy),
            zIndex: unref(zIndex2),
            top: unref(y) != null ? `${unref(y)}px` : "",
            left: unref(x2) != null ? `${unref(x2)}px` : "",
            maxWidth: (overflow == null ? void 0 : overflow.maxWidth) ? `${overflow == null ? void 0 : overflow.maxWidth}px` : ""
          };
        });
        const arrowStyle = computed(() => {
          if (!unref(showArrow))
            return {};
          const { arrow: arrow2 } = unref(middlewareData);
          return {
            left: (arrow2 == null ? void 0 : arrow2.x) != null ? `${arrow2 == null ? void 0 : arrow2.x}px` : "",
            top: (arrow2 == null ? void 0 : arrow2.y) != null ? `${arrow2 == null ? void 0 : arrow2.y}px` : ""
          };
        });
        let cleanup;
        onMounted(() => {
          const referenceEl = unref(referenceRef);
          const contentEl = unref(contentRef);
          if (referenceEl && contentEl) {
            cleanup = autoUpdate(referenceEl, contentEl, update2);
          }
          watchEffect(() => {
            update2();
          });
        });
        onBeforeUnmount(() => {
          cleanup && cleanup();
        });
        return {
          update: update2,
          contentStyle,
          arrowStyle
        };
      };
      const overflowMiddleware = () => {
        return {
          name: "overflow",
          async fn(state) {
            const overflow = await detectOverflow(state);
            let overWidth = 0;
            if (overflow.left > 0)
              overWidth = overflow.left;
            if (overflow.right > 0)
              overWidth = overflow.right;
            const floatingWidth = state.rects.floating.width;
            return {
              data: {
                maxWidth: floatingWidth - overWidth
              }
            };
          }
        };
      };
      const __default__$d = defineComponent({
        name: "ElTourMask",
        inheritAttrs: false
      });
      const _sfc_main$e = /* @__PURE__ */ defineComponent({
        ...__default__$d,
        props: maskProps,
        setup(__props) {
          const props2 = __props;
          const { ns } = inject(tourKey);
          const radius = computed(() => {
            var _a, _b;
            return (_b = (_a = props2.pos) == null ? void 0 : _a.radius) != null ? _b : 2;
          });
          const roundInfo = computed(() => {
            const v2 = radius.value;
            const baseInfo = `a${v2},${v2} 0 0 1`;
            return {
              topRight: `${baseInfo} ${v2},${v2}`,
              bottomRight: `${baseInfo} ${-v2},${v2}`,
              bottomLeft: `${baseInfo} ${-v2},${-v2}`,
              topLeft: `${baseInfo} ${v2},${-v2}`
            };
          });
          const path = computed(() => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const info = roundInfo.value;
            const _path = `M${width},0 L0,0 L0,${height} L${width},${height} L${width},0 Z`;
            const _radius = radius.value;
            return props2.pos ? `${_path} M${props2.pos.left + _radius},${props2.pos.top} h${props2.pos.width - _radius * 2} ${info.topRight} v${props2.pos.height - _radius * 2} ${info.bottomRight} h${-props2.pos.width + _radius * 2} ${info.bottomLeft} v${-props2.pos.height + _radius * 2} ${info.topLeft} z` : _path;
          });
          const maskStyle = computed(() => ({
            position: "fixed",
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            zIndex: props2.zIndex,
            pointerEvents: props2.pos && props2.targetAreaClickable ? "none" : "auto"
          }));
          const pathStyle = computed(() => ({
            fill: props2.fill,
            pointerEvents: "auto",
            cursor: "auto"
          }));
          useLockscreen(toRef(props2, "visible"), {
            ns
          });
          return (_ctx, _cache) => {
            return _ctx.visible ? (openBlock(), createElementBlock("div", mergeProps({
              key: 0,
              class: unref(ns).e("mask"),
              style: unref(maskStyle)
            }, _ctx.$attrs), [
              (openBlock(), createElementBlock("svg", { style: {
                width: "100%",
                height: "100%"
              } }, [
                createElementVNode("path", {
                  class: normalizeClass(unref(ns).e("hollow")),
                  style: normalizeStyle(unref(pathStyle)),
                  d: unref(path)
                }, null, 14, ["d"])
              ]))
            ], 16)) : createCommentVNode("v-if", true);
          };
        }
      });
      var ElTourMask = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__file", "mask.vue"]]);
      const tourStrategies = exports("tourStrategies", ["absolute", "fixed"]);
      const tourPlacements = exports("tourPlacements", [
        "top-start",
        "top-end",
        "top",
        "bottom-start",
        "bottom-end",
        "bottom",
        "left-start",
        "left-end",
        "left",
        "right-start",
        "right-end",
        "right"
      ]);
      const tourContentProps = exports("tourContentProps", buildProps({
        placement: {
          type: definePropType(String),
          values: tourPlacements,
          default: "bottom"
        },
        reference: {
          type: definePropType(Object),
          default: null
        },
        strategy: {
          type: definePropType(String),
          values: tourStrategies,
          default: "absolute"
        },
        offset: {
          type: Number,
          default: 10
        },
        showArrow: Boolean,
        zIndex: {
          type: Number,
          default: 2001
        }
      }));
      const tourContentEmits = exports("tourContentEmits", {
        close: () => true
      });
      const __default__$c = defineComponent({
        name: "ElTourContent"
      });
      const _sfc_main$d = /* @__PURE__ */ defineComponent({
        ...__default__$c,
        props: tourContentProps,
        emits: tourContentEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const placement = ref(props2.placement);
          const strategy = ref(props2.strategy);
          const contentRef = ref(null);
          const arrowRef = ref(null);
          watch(() => props2.placement, () => {
            placement.value = props2.placement;
          });
          const { contentStyle, arrowStyle } = useFloating(toRef(props2, "reference"), contentRef, arrowRef, placement, strategy, toRef(props2, "offset"), toRef(props2, "zIndex"), toRef(props2, "showArrow"));
          const side = computed(() => {
            return placement.value.split("-")[0];
          });
          const { ns } = inject(tourKey);
          const onCloseRequested = () => {
            emit("close");
          };
          const onFocusoutPrevented = (event) => {
            if (event.detail.focusReason === "pointer") {
              event.preventDefault();
            }
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "contentRef",
              ref: contentRef,
              style: normalizeStyle(unref(contentStyle)),
              class: normalizeClass(unref(ns).e("content")),
              "data-side": unref(side),
              tabindex: "-1"
            }, [
              createVNode(unref(ElFocusTrap), {
                loop: "",
                trapped: "",
                "focus-start-el": "container",
                "focus-trap-el": contentRef.value || void 0,
                onReleaseRequested: onCloseRequested,
                onFocusoutPrevented
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["focus-trap-el"]),
              _ctx.showArrow ? (openBlock(), createElementBlock("span", {
                key: 0,
                ref_key: "arrowRef",
                ref: arrowRef,
                style: normalizeStyle(unref(arrowStyle)),
                class: normalizeClass(unref(ns).e("arrow"))
              }, null, 6)) : createCommentVNode("v-if", true)
            ], 14, ["data-side"]);
          };
        }
      });
      var ElTourContent = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__file", "content.vue"]]);
      var ElTourSteps = defineComponent({
        name: "ElTourSteps",
        props: {
          current: {
            type: Number,
            default: 0
          }
        },
        emits: ["update-total"],
        setup(props2, { slots, emit }) {
          let cacheTotal = 0;
          return () => {
            var _a, _b;
            const children = (_a = slots.default) == null ? void 0 : _a.call(slots);
            const result2 = [];
            let total2 = 0;
            function filterSteps(children2) {
              if (!isArray$1(children2))
                return;
              children2.forEach((item) => {
                var _a2;
                const name = (_a2 = (item == null ? void 0 : item.type) || {}) == null ? void 0 : _a2.name;
                if (name === "ElTourStep") {
                  result2.push(item);
                  total2 += 1;
                }
              });
            }
            if (children.length) {
              filterSteps(flattedChildren((_b = children[0]) == null ? void 0 : _b.children));
            }
            if (cacheTotal !== total2) {
              cacheTotal = total2;
              emit("update-total", total2);
            }
            if (result2.length) {
              return result2[props2.current];
            }
            return null;
          };
        }
      });
      const tourProps = exports("tourProps", buildProps({
        modelValue: Boolean,
        current: {
          type: Number,
          default: 0
        },
        showArrow: {
          type: Boolean,
          default: true
        },
        showClose: {
          type: Boolean,
          default: true
        },
        closeIcon: {
          type: iconPropType
        },
        placement: tourContentProps.placement,
        contentStyle: {
          type: definePropType([Object])
        },
        mask: {
          type: definePropType([Boolean, Object]),
          default: true
        },
        gap: {
          type: definePropType(Object),
          default: () => ({
            offset: 6,
            radius: 2
          })
        },
        zIndex: {
          type: Number
        },
        scrollIntoViewOptions: {
          type: definePropType([Boolean, Object]),
          default: () => ({
            block: "center"
          })
        },
        type: {
          type: definePropType(String)
        },
        appendTo: {
          type: teleportProps.to.type,
          default: "body"
        },
        closeOnPressEscape: {
          type: Boolean,
          default: true
        },
        targetAreaClickable: {
          type: Boolean,
          default: true
        }
      }));
      const tourEmits = exports("tourEmits", {
        [UPDATE_MODEL_EVENT]: (value) => isBoolean(value),
        ["update:current"]: (current) => isNumber(current),
        close: (current) => isNumber(current),
        finish: () => true,
        change: (current) => isNumber(current)
      });
      const __default__$b = defineComponent({
        name: "ElTour"
      });
      const _sfc_main$c = /* @__PURE__ */ defineComponent({
        ...__default__$b,
        props: tourProps,
        emits: tourEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const ns = useNamespace("tour");
          const total2 = ref(0);
          const currentStep = ref();
          const current = useVModel(props2, "current", emit, {
            passive: true
          });
          const currentTarget = computed(() => {
            var _a;
            return (_a = currentStep.value) == null ? void 0 : _a.target;
          });
          const kls = computed(() => [
            ns.b(),
            mergedType.value === "primary" ? ns.m("primary") : ""
          ]);
          const mergedPlacement = computed(() => {
            var _a;
            return ((_a = currentStep.value) == null ? void 0 : _a.placement) || props2.placement;
          });
          const mergedContentStyle = computed(() => {
            var _a, _b;
            return (_b = (_a = currentStep.value) == null ? void 0 : _a.contentStyle) != null ? _b : props2.contentStyle;
          });
          const mergedMask = computed(() => {
            var _a, _b;
            return (_b = (_a = currentStep.value) == null ? void 0 : _a.mask) != null ? _b : props2.mask;
          });
          const mergedShowMask = computed(() => !!mergedMask.value && props2.modelValue);
          const mergedMaskStyle = computed(() => isBoolean(mergedMask.value) ? void 0 : mergedMask.value);
          const mergedShowArrow = computed(() => {
            var _a, _b;
            return !!currentTarget.value && ((_b = (_a = currentStep.value) == null ? void 0 : _a.showArrow) != null ? _b : props2.showArrow);
          });
          const mergedScrollIntoViewOptions = computed(() => {
            var _a, _b;
            return (_b = (_a = currentStep.value) == null ? void 0 : _a.scrollIntoViewOptions) != null ? _b : props2.scrollIntoViewOptions;
          });
          const mergedType = computed(() => {
            var _a, _b;
            return (_b = (_a = currentStep.value) == null ? void 0 : _a.type) != null ? _b : props2.type;
          });
          const { nextZIndex } = useZIndex();
          const nowZIndex = nextZIndex();
          const mergedZIndex = computed(() => {
            var _a;
            return (_a = props2.zIndex) != null ? _a : nowZIndex;
          });
          const { mergedPosInfo: pos, triggerTarget } = useTarget(currentTarget, toRef(props2, "modelValue"), toRef(props2, "gap"), mergedMask, mergedScrollIntoViewOptions);
          watch(() => props2.modelValue, (val) => {
            if (!val) {
              current.value = 0;
            }
          });
          const onEscClose = () => {
            if (props2.closeOnPressEscape) {
              emit(UPDATE_MODEL_EVENT, false);
              emit("close", current.value);
            }
          };
          const onUpdateTotal = (val) => {
            total2.value = val;
          };
          const slots = useSlots();
          provide(tourKey, {
            currentStep,
            current,
            total: total2,
            showClose: toRef(props2, "showClose"),
            closeIcon: toRef(props2, "closeIcon"),
            mergedType,
            ns,
            slots,
            updateModelValue(modelValue) {
              emit(UPDATE_MODEL_EVENT, modelValue);
            },
            onClose() {
              emit("close", current.value);
            },
            onFinish() {
              emit("finish");
            },
            onChange() {
              emit(CHANGE_EVENT, current.value);
            }
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(unref(ElTeleport$1), { to: _ctx.appendTo }, {
                default: withCtx(() => {
                  var _a, _b;
                  return [
                    createElementVNode("div", mergeProps({ class: unref(kls) }, _ctx.$attrs), [
                      createVNode(ElTourMask, {
                        visible: unref(mergedShowMask),
                        fill: (_a = unref(mergedMaskStyle)) == null ? void 0 : _a.color,
                        style: normalizeStyle((_b = unref(mergedMaskStyle)) == null ? void 0 : _b.style),
                        pos: unref(pos),
                        "z-index": unref(mergedZIndex),
                        "target-area-clickable": _ctx.targetAreaClickable
                      }, null, 8, ["visible", "fill", "style", "pos", "z-index", "target-area-clickable"]),
                      _ctx.modelValue ? (openBlock(), createBlock(ElTourContent, {
                        key: unref(current),
                        reference: unref(triggerTarget),
                        placement: unref(mergedPlacement),
                        "show-arrow": unref(mergedShowArrow),
                        "z-index": unref(mergedZIndex),
                        style: normalizeStyle(unref(mergedContentStyle)),
                        onClose: onEscClose
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(ElTourSteps), {
                            current: unref(current),
                            onUpdateTotal
                          }, {
                            default: withCtx(() => [
                              renderSlot(_ctx.$slots, "default")
                            ]),
                            _: 3
                          }, 8, ["current"])
                        ]),
                        _: 3
                      }, 8, ["reference", "placement", "show-arrow", "z-index", "style"])) : createCommentVNode("v-if", true)
                    ], 16)
                  ];
                }),
                _: 3
              }, 8, ["to"]),
              createCommentVNode(" just for IDE "),
              createCommentVNode("v-if", true)
            ], 64);
          };
        }
      });
      var Tour = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__file", "tour.vue"]]);
      const tourStepProps = exports("tourStepProps", buildProps({
        target: {
          type: definePropType([String, Object, Function])
        },
        title: String,
        description: String,
        showClose: {
          type: Boolean,
          default: void 0
        },
        closeIcon: {
          type: iconPropType
        },
        showArrow: {
          type: Boolean,
          default: void 0
        },
        placement: tourContentProps.placement,
        mask: {
          type: definePropType([Boolean, Object]),
          default: void 0
        },
        contentStyle: {
          type: definePropType([Object])
        },
        prevButtonProps: {
          type: definePropType(Object)
        },
        nextButtonProps: {
          type: definePropType(Object)
        },
        scrollIntoViewOptions: {
          type: definePropType([Boolean, Object]),
          default: void 0
        },
        type: {
          type: definePropType(String)
        }
      }));
      const tourStepEmits = exports("tourStepEmits", {
        close: () => true
      });
      const __default__$a = defineComponent({
        name: "ElTourStep"
      });
      const _sfc_main$b = /* @__PURE__ */ defineComponent({
        ...__default__$a,
        props: tourStepProps,
        emits: tourStepEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const { Close } = CloseComponents;
          const { t } = useLocale();
          const {
            currentStep,
            current,
            total: total2,
            showClose,
            closeIcon,
            mergedType,
            ns,
            slots: tourSlots,
            updateModelValue,
            onClose: tourOnClose,
            onFinish: tourOnFinish,
            onChange
          } = inject(tourKey);
          watch(props2, (val) => {
            currentStep.value = val;
          }, {
            immediate: true
          });
          const mergedShowClose = computed(() => {
            var _a;
            return (_a = props2.showClose) != null ? _a : showClose.value;
          });
          const mergedCloseIcon = computed(() => {
            var _a, _b;
            return (_b = (_a = props2.closeIcon) != null ? _a : closeIcon.value) != null ? _b : Close;
          });
          const filterButtonProps = (btnProps) => {
            if (!btnProps)
              return;
            return omit(btnProps, ["children", "onClick"]);
          };
          const onPrev = () => {
            var _a, _b;
            current.value -= 1;
            if ((_a = props2.prevButtonProps) == null ? void 0 : _a.onClick) {
              (_b = props2.prevButtonProps) == null ? void 0 : _b.onClick();
            }
            onChange();
          };
          const onNext = () => {
            var _a;
            if (current.value >= total2.value - 1) {
              onFinish();
            } else {
              current.value += 1;
            }
            if ((_a = props2.nextButtonProps) == null ? void 0 : _a.onClick) {
              props2.nextButtonProps.onClick();
            }
            onChange();
          };
          const onFinish = () => {
            onClose();
            tourOnFinish();
          };
          const onClose = () => {
            updateModelValue(false);
            tourOnClose();
            emit("close");
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              unref(mergedShowClose) ? (openBlock(), createElementBlock("button", {
                key: 0,
                "aria-label": "Close",
                class: normalizeClass(unref(ns).e("closebtn")),
                type: "button",
                onClick: onClose
              }, [
                createVNode(unref(ElIcon), {
                  class: normalizeClass(unref(ns).e("close"))
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(mergedCloseIcon))))
                  ]),
                  _: 1
                }, 8, ["class"])
              ], 2)) : createCommentVNode("v-if", true),
              createElementVNode("header", {
                class: normalizeClass([unref(ns).e("header"), { "show-close": unref(showClose) }])
              }, [
                renderSlot(_ctx.$slots, "header", {}, () => [
                  createElementVNode("span", {
                    role: "heading",
                    class: normalizeClass(unref(ns).e("title"))
                  }, toDisplayString(_ctx.title), 3)
                ])
              ], 2),
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("body"))
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createElementVNode("span", null, toDisplayString(_ctx.description), 1)
                ])
              ], 2),
              createElementVNode("footer", {
                class: normalizeClass(unref(ns).e("footer"))
              }, [
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).b("indicators"))
                }, [
                  unref(tourSlots).indicators ? (openBlock(), createBlock(resolveDynamicComponent(unref(tourSlots).indicators), {
                    key: 0,
                    current: unref(current),
                    total: unref(total2)
                  }, null, 8, ["current", "total"])) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(total2), (item, index2) => {
                    return openBlock(), createElementBlock("span", {
                      key: item,
                      class: normalizeClass([unref(ns).b("indicator"), index2 === unref(current) ? "is-active" : ""])
                    }, null, 2);
                  }), 128))
                ], 2),
                createElementVNode("div", {
                  class: normalizeClass(unref(ns).b("buttons"))
                }, [
                  unref(current) > 0 ? (openBlock(), createBlock(unref(ElButton), mergeProps({
                    key: 0,
                    size: "small",
                    type: unref(mergedType)
                  }, filterButtonProps(_ctx.prevButtonProps), { onClick: onPrev }), {
                    default: withCtx(() => {
                      var _a, _b;
                      return [
                        createTextVNode(toDisplayString((_b = (_a = _ctx.prevButtonProps) == null ? void 0 : _a.children) != null ? _b : unref(t)("el.tour.previous")), 1)
                      ];
                    }),
                    _: 1
                  }, 16, ["type"])) : createCommentVNode("v-if", true),
                  unref(current) <= unref(total2) - 1 ? (openBlock(), createBlock(unref(ElButton), mergeProps({
                    key: 1,
                    size: "small",
                    type: unref(mergedType) === "primary" ? "default" : "primary"
                  }, filterButtonProps(_ctx.nextButtonProps), { onClick: onNext }), {
                    default: withCtx(() => {
                      var _a, _b;
                      return [
                        createTextVNode(toDisplayString((_b = (_a = _ctx.nextButtonProps) == null ? void 0 : _a.children) != null ? _b : unref(current) === unref(total2) - 1 ? unref(t)("el.tour.finish") : unref(t)("el.tour.next")), 1)
                      ];
                    }),
                    _: 1
                  }, 16, ["type"])) : createCommentVNode("v-if", true)
                ], 2)
              ], 2)
            ], 64);
          };
        }
      });
      var TourStep = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__file", "step.vue"]]);
      const ElTour = exports("ElTour", withInstall(Tour, {
        TourStep
      }));
      const ElTourStep = exports("ElTourStep", withNoopInstall(TourStep));
      const anchorProps = exports("anchorProps", buildProps({
        container: {
          type: definePropType([
            String,
            Object
          ])
        },
        offset: {
          type: Number,
          default: 0
        },
        bound: {
          type: Number,
          default: 15
        },
        duration: {
          type: Number,
          default: 300
        },
        marker: {
          type: Boolean,
          default: true
        },
        type: {
          type: definePropType(String),
          default: "default"
        },
        direction: {
          type: definePropType(String),
          default: "vertical"
        },
        selectScrollTop: Boolean
      }));
      const anchorEmits = exports("anchorEmits", {
        change: (href) => isString$1(href),
        click: (e, href) => e instanceof MouseEvent && (isString$1(href) || isUndefined(href))
      });
      const anchorKey = Symbol("anchor");
      const __default__$9 = defineComponent({
        name: "ElAnchor"
      });
      const _sfc_main$a = /* @__PURE__ */ defineComponent({
        ...__default__$9,
        props: anchorProps,
        emits: anchorEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const slots = useSlots();
          const currentAnchor = ref("");
          const markerStyle = ref({});
          const anchorRef = ref(null);
          const markerRef = ref(null);
          const containerEl = ref();
          const links = {};
          let isScrolling = false;
          let currentScrollTop = 0;
          const ns = useNamespace("anchor");
          const cls = computed(() => [
            ns.b(),
            props2.type === "underline" ? ns.m("underline") : "",
            ns.m(props2.direction)
          ]);
          const addLink = (state) => {
            links[state.href] = state.el;
          };
          const removeLink = (href) => {
            delete links[href];
          };
          const setCurrentAnchor = (href) => {
            const activeHref = currentAnchor.value;
            if (activeHref !== href) {
              currentAnchor.value = href;
              emit(CHANGE_EVENT, href);
            }
          };
          let clearAnimate = null;
          const scrollToAnchor = (href) => {
            if (!containerEl.value)
              return;
            const target2 = getElement(href);
            if (!target2)
              return;
            if (clearAnimate)
              clearAnimate();
            isScrolling = true;
            const scrollEle = getScrollElement(target2, containerEl.value);
            const distance = getOffsetTopDistance(target2, scrollEle);
            const max2 = scrollEle.scrollHeight - scrollEle.clientHeight;
            const to = Math.min(distance - props2.offset, max2);
            clearAnimate = animateScrollTo(containerEl.value, currentScrollTop, to, props2.duration, () => {
              setTimeout(() => {
                isScrolling = false;
              }, 20);
            });
          };
          const scrollTo = (href) => {
            if (href) {
              setCurrentAnchor(href);
              scrollToAnchor(href);
            }
          };
          const handleClick = (e, href) => {
            emit("click", e, href);
            scrollTo(href);
          };
          const handleScroll2 = throttleByRaf(() => {
            if (containerEl.value) {
              currentScrollTop = getScrollTop(containerEl.value);
            }
            const currentHref = getCurrentHref();
            if (isScrolling || isUndefined(currentHref))
              return;
            setCurrentAnchor(currentHref);
          });
          const getCurrentHref = () => {
            if (!containerEl.value)
              return;
            const scrollTop = getScrollTop(containerEl.value);
            const anchorTopList = [];
            for (const href of Object.keys(links)) {
              const target2 = getElement(href);
              if (!target2)
                continue;
              const scrollEle = getScrollElement(target2, containerEl.value);
              const distance = getOffsetTopDistance(target2, scrollEle);
              anchorTopList.push({
                top: distance - props2.offset - props2.bound,
                href
              });
            }
            anchorTopList.sort((prev, next) => prev.top - next.top);
            for (let i = 0; i < anchorTopList.length; i++) {
              const item = anchorTopList[i];
              const next = anchorTopList[i + 1];
              if (i === 0 && scrollTop === 0) {
                return props2.selectScrollTop ? item.href : "";
              }
              if (item.top <= scrollTop && (!next || next.top > scrollTop)) {
                return item.href;
              }
            }
          };
          const getContainer = () => {
            const el = getElement(props2.container);
            if (!el || isWindow$1(el)) {
              containerEl.value = window;
            } else {
              containerEl.value = el;
            }
          };
          useEventListener(containerEl, "scroll", handleScroll2);
          const updateMarkerStyle = () => {
            nextTick(() => {
              if (!anchorRef.value || !markerRef.value || !currentAnchor.value) {
                markerStyle.value = {};
                return;
              }
              const currentLinkEl = links[currentAnchor.value];
              if (!currentLinkEl) {
                markerStyle.value = {};
                return;
              }
              const anchorRect = anchorRef.value.getBoundingClientRect();
              const markerRect = markerRef.value.getBoundingClientRect();
              const linkRect = currentLinkEl.getBoundingClientRect();
              if (props2.direction === "horizontal") {
                const left = linkRect.left - anchorRect.left;
                markerStyle.value = {
                  left: `${left}px`,
                  width: `${linkRect.width}px`,
                  opacity: 1
                };
              } else {
                const top = linkRect.top - anchorRect.top + (linkRect.height - markerRect.height) / 2;
                markerStyle.value = {
                  top: `${top}px`,
                  opacity: 1
                };
              }
            });
          };
          watch(currentAnchor, updateMarkerStyle);
          watch(() => {
            var _a;
            return (_a = slots.default) == null ? void 0 : _a.call(slots);
          }, updateMarkerStyle);
          onMounted(() => {
            getContainer();
            const hash2 = decodeURIComponent(window.location.hash);
            const target2 = getElement(hash2);
            if (target2) {
              scrollTo(hash2);
            } else {
              handleScroll2();
            }
          });
          watch(() => props2.container, () => {
            getContainer();
          });
          provide(anchorKey, {
            ns,
            direction: props2.direction,
            currentAnchor,
            addLink,
            removeLink,
            handleClick
          });
          expose({
            scrollTo
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "anchorRef",
              ref: anchorRef,
              class: normalizeClass(unref(cls))
            }, [
              _ctx.marker ? (openBlock(), createElementBlock("div", {
                key: 0,
                ref_key: "markerRef",
                ref: markerRef,
                class: normalizeClass(unref(ns).e("marker")),
                style: normalizeStyle(markerStyle.value)
              }, null, 6)) : createCommentVNode("v-if", true),
              createElementVNode("div", {
                class: normalizeClass(unref(ns).e("list"))
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2)
            ], 2);
          };
        }
      });
      var Anchor = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__file", "anchor.vue"]]);
      const anchorLinkProps = buildProps({
        title: String,
        href: String
      });
      const __default__$8 = defineComponent({
        name: "ElAnchorLink"
      });
      const _sfc_main$9 = /* @__PURE__ */ defineComponent({
        ...__default__$8,
        props: anchorLinkProps,
        setup(__props) {
          const props2 = __props;
          const linkRef = ref(null);
          const {
            ns,
            direction: direction2,
            currentAnchor,
            addLink,
            removeLink,
            handleClick: contextHandleClick
          } = inject(anchorKey);
          const cls = computed(() => [
            ns.e("link"),
            ns.is("active", currentAnchor.value === props2.href)
          ]);
          const handleClick = (e) => {
            contextHandleClick(e, props2.href);
          };
          watch(() => props2.href, (val, oldVal) => {
            nextTick(() => {
              if (oldVal)
                removeLink(oldVal);
              if (val) {
                addLink({
                  href: val,
                  el: linkRef.value
                });
              }
            });
          });
          onMounted(() => {
            const { href } = props2;
            if (href) {
              addLink({
                href,
                el: linkRef.value
              });
            }
          });
          onBeforeUnmount(() => {
            const { href } = props2;
            if (href) {
              removeLink(href);
            }
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(unref(ns).e("item"))
            }, [
              createElementVNode("a", {
                ref_key: "linkRef",
                ref: linkRef,
                class: normalizeClass(unref(cls)),
                href: _ctx.href,
                onClick: handleClick
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.title), 1)
                ])
              ], 10, ["href"]),
              _ctx.$slots["sub-link"] && unref(direction2) === "vertical" ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).e("list"))
              }, [
                renderSlot(_ctx.$slots, "sub-link")
              ], 2)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var AnchorLink = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__file", "anchor-link.vue"]]);
      const ElAnchor = exports("ElAnchor", withInstall(Anchor, {
        AnchorLink
      }));
      const ElAnchorLink = exports("ElAnchorLink", withNoopInstall(AnchorLink));
      const defaultProps = exports("defaultProps", {
        label: "label",
        value: "value",
        disabled: "disabled"
      });
      const segmentedProps = exports("segmentedProps", buildProps({
        direction: {
          type: definePropType(String),
          default: "horizontal"
        },
        options: {
          type: definePropType(Array),
          default: () => []
        },
        modelValue: {
          type: [String, Number, Boolean],
          default: void 0
        },
        props: {
          type: definePropType(Object),
          default: () => defaultProps
        },
        block: Boolean,
        size: useSizeProp,
        disabled: Boolean,
        validateEvent: {
          type: Boolean,
          default: true
        },
        id: String,
        name: String,
        ...useAriaProps(["ariaLabel"])
      }));
      const segmentedEmits = exports("segmentedEmits", {
        [UPDATE_MODEL_EVENT]: (val) => isString$1(val) || isNumber(val) || isBoolean(val),
        [CHANGE_EVENT]: (val) => isString$1(val) || isNumber(val) || isBoolean(val)
      });
      const __default__$7 = defineComponent({
        name: "ElSegmented"
      });
      const _sfc_main$8 = /* @__PURE__ */ defineComponent({
        ...__default__$7,
        props: segmentedProps,
        emits: segmentedEmits,
        setup(__props, { emit }) {
          const props2 = __props;
          const ns = useNamespace("segmented");
          const segmentedId = useId();
          const segmentedSize = useFormSize();
          const _disabled = useFormDisabled();
          const { formItem } = useFormItem();
          const { inputId, isLabeledByFormItem } = useFormItemInputId(props2, {
            formItemContext: formItem
          });
          const segmentedRef = ref(null);
          const activeElement = useActiveElement();
          const state = reactive({
            isInit: false,
            width: 0,
            height: 0,
            translateX: 0,
            translateY: 0,
            focusVisible: false
          });
          const handleChange = (item) => {
            const value = getValue2(item);
            emit(UPDATE_MODEL_EVENT, value);
            emit(CHANGE_EVENT, value);
          };
          const aliasProps = computed(() => ({ ...defaultProps, ...props2.props }));
          const getValue2 = (item) => {
            return isObject$1(item) ? item[aliasProps.value.value] : item;
          };
          const getLabel = (item) => {
            return isObject$1(item) ? item[aliasProps.value.label] : item;
          };
          const getDisabled = (item) => {
            return !!(_disabled.value || (isObject$1(item) ? item[aliasProps.value.disabled] : false));
          };
          const getSelected = (item) => {
            return props2.modelValue === getValue2(item);
          };
          const getOption = (value) => {
            return props2.options.find((item) => getValue2(item) === value);
          };
          const getItemCls = (item) => {
            return [
              ns.e("item"),
              ns.is("selected", getSelected(item)),
              ns.is("disabled", getDisabled(item))
            ];
          };
          const updateSelect = () => {
            if (!segmentedRef.value)
              return;
            const selectedItem = segmentedRef.value.querySelector(".is-selected");
            const selectedItemInput = segmentedRef.value.querySelector(".is-selected input");
            if (!selectedItem || !selectedItemInput) {
              state.width = 0;
              state.height = 0;
              state.translateX = 0;
              state.translateY = 0;
              state.focusVisible = false;
              return;
            }
            state.isInit = true;
            if (props2.direction === "vertical") {
              state.height = selectedItem.offsetHeight;
              state.translateY = selectedItem.offsetTop;
            } else {
              state.width = selectedItem.offsetWidth;
              state.translateX = selectedItem.offsetLeft;
            }
            try {
              state.focusVisible = selectedItemInput.matches(":focus-visible");
            } catch (e) {
            }
          };
          const segmentedCls = computed(() => [
            ns.b(),
            ns.m(segmentedSize.value),
            ns.is("block", props2.block)
          ]);
          const selectedStyle = computed(() => ({
            width: props2.direction === "vertical" ? "100%" : `${state.width}px`,
            height: props2.direction === "vertical" ? `${state.height}px` : "100%",
            transform: props2.direction === "vertical" ? `translateY(${state.translateY}px)` : `translateX(${state.translateX}px)`,
            display: state.isInit ? "block" : "none"
          }));
          const selectedCls = computed(() => [
            ns.e("item-selected"),
            ns.is("disabled", getDisabled(getOption(props2.modelValue))),
            ns.is("focus-visible", state.focusVisible)
          ]);
          const name = computed(() => {
            return props2.name || segmentedId.value;
          });
          useResizeObserver(segmentedRef, updateSelect);
          watch(activeElement, updateSelect);
          watch(() => props2.modelValue, () => {
            var _a;
            updateSelect();
            if (props2.validateEvent) {
              (_a = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a.call(formItem, "change").catch((err) => debugWarn());
            }
          }, {
            flush: "post"
          });
          return (_ctx, _cache) => {
            return _ctx.options.length ? (openBlock(), createElementBlock("div", {
              key: 0,
              id: unref(inputId),
              ref_key: "segmentedRef",
              ref: segmentedRef,
              class: normalizeClass(unref(segmentedCls)),
              role: "radiogroup",
              "aria-label": !unref(isLabeledByFormItem) ? _ctx.ariaLabel || "segmented" : void 0,
              "aria-labelledby": unref(isLabeledByFormItem) ? unref(formItem).labelId : void 0
            }, [
              createElementVNode("div", {
                class: normalizeClass([unref(ns).e("group"), unref(ns).m(props2.direction)])
              }, [
                createElementVNode("div", {
                  style: normalizeStyle(unref(selectedStyle)),
                  class: normalizeClass(unref(selectedCls))
                }, null, 6),
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (item, index2) => {
                  return openBlock(), createElementBlock("label", {
                    key: index2,
                    class: normalizeClass(getItemCls(item))
                  }, [
                    createElementVNode("input", {
                      class: normalizeClass(unref(ns).e("item-input")),
                      type: "radio",
                      name: unref(name),
                      disabled: getDisabled(item),
                      checked: getSelected(item),
                      onChange: ($event) => handleChange(item)
                    }, null, 42, ["name", "disabled", "checked", "onChange"]),
                    createElementVNode("div", {
                      class: normalizeClass(unref(ns).e("item-label"))
                    }, [
                      renderSlot(_ctx.$slots, "default", { item }, () => [
                        createTextVNode(toDisplayString(getLabel(item)), 1)
                      ])
                    ], 2)
                  ], 2);
                }), 128))
              ], 2)
            ], 10, ["id", "aria-label", "aria-labelledby"])) : createCommentVNode("v-if", true);
          };
        }
      });
      var Segmented = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__file", "segmented.vue"]]);
      const ElSegmented = exports("ElSegmented", withInstall(Segmented));
      const filterOption = (pattern, option) => {
        const lowerCase2 = pattern.toLowerCase();
        const label = option.label || option.value;
        return label.toLowerCase().includes(lowerCase2);
      };
      const getMentionCtx = (inputEl, prefix, split2) => {
        const { selectionEnd } = inputEl;
        if (selectionEnd === null)
          return;
        const inputValue = inputEl.value;
        const prefixArray = castArray$1(prefix);
        let splitIndex = -1;
        let mentionCtx;
        for (let i = selectionEnd - 1; i >= 0; --i) {
          const char = inputValue[i];
          if (char === split2 || char === "\n" || char === "\r") {
            splitIndex = i;
            continue;
          }
          if (prefixArray.includes(char)) {
            const end = splitIndex === -1 ? selectionEnd : splitIndex;
            const pattern = inputValue.slice(i + 1, end);
            mentionCtx = {
              pattern,
              start: i + 1,
              end,
              prefix: char,
              prefixIndex: i,
              splitIndex,
              selectionEnd
            };
            break;
          }
        }
        return mentionCtx;
      };
      const getCursorPosition = (element, options = {
        debug: false,
        useSelectionEnd: false
      }) => {
        const selectionStart = element.selectionStart !== null ? element.selectionStart : 0;
        const selectionEnd = element.selectionEnd !== null ? element.selectionEnd : 0;
        const position = options.useSelectionEnd ? selectionEnd : selectionStart;
        const properties = [
          "direction",
          "boxSizing",
          "width",
          "height",
          "overflowX",
          "overflowY",
          "borderTopWidth",
          "borderRightWidth",
          "borderBottomWidth",
          "borderLeftWidth",
          "borderStyle",
          "paddingTop",
          "paddingRight",
          "paddingBottom",
          "paddingLeft",
          "fontStyle",
          "fontVariant",
          "fontWeight",
          "fontStretch",
          "fontSize",
          "fontSizeAdjust",
          "lineHeight",
          "fontFamily",
          "textAlign",
          "textTransform",
          "textIndent",
          "textDecoration",
          "letterSpacing",
          "wordSpacing",
          "tabSize",
          "MozTabSize"
        ];
        if (options.debug) {
          const el = document.querySelector("#input-textarea-caret-position-mirror-div");
          if (el == null ? void 0 : el.parentNode)
            el.parentNode.removeChild(el);
        }
        const div = document.createElement("div");
        div.id = "input-textarea-caret-position-mirror-div";
        document.body.appendChild(div);
        const style = div.style;
        const computed2 = window.getComputedStyle(element);
        const isInput = element.nodeName === "INPUT";
        style.whiteSpace = isInput ? "nowrap" : "pre-wrap";
        if (!isInput)
          style.wordWrap = "break-word";
        style.position = "absolute";
        if (!options.debug)
          style.visibility = "hidden";
        properties.forEach((prop) => {
          if (isInput && prop === "lineHeight") {
            if (computed2.boxSizing === "border-box") {
              const height = Number.parseInt(computed2.height);
              const outerHeight = Number.parseInt(computed2.paddingTop) + Number.parseInt(computed2.paddingBottom) + Number.parseInt(computed2.borderTopWidth) + Number.parseInt(computed2.borderBottomWidth);
              const targetHeight = outerHeight + Number.parseInt(computed2.lineHeight);
              if (height > targetHeight) {
                style.lineHeight = `${height - outerHeight}px`;
              } else if (height === targetHeight) {
                style.lineHeight = computed2.lineHeight;
              } else {
                style.lineHeight = "0";
              }
            } else {
              style.lineHeight = computed2.height;
            }
          } else {
            style[prop] = computed2[prop];
          }
        });
        if (isFirefox()) {
          if (element.scrollHeight > Number.parseInt(computed2.height)) {
            style.overflowY = "scroll";
          }
        } else {
          style.overflow = "hidden";
        }
        div.textContent = element.value.slice(0, Math.max(0, position));
        if (isInput && div.textContent) {
          div.textContent = div.textContent.replace(/\s/g, " ");
        }
        const span = document.createElement("span");
        span.textContent = element.value.slice(Math.max(0, position)) || ".";
        span.style.position = "relative";
        span.style.left = `${-element.scrollLeft}px`;
        span.style.top = `${-element.scrollTop}px`;
        div.appendChild(span);
        const relativePosition = {
          top: span.offsetTop + Number.parseInt(computed2.borderTopWidth),
          left: span.offsetLeft + Number.parseInt(computed2.borderLeftWidth),
          height: Number.parseInt(computed2.fontSize) * 1.5
        };
        if (options.debug) {
          span.style.backgroundColor = "#aaa";
        } else {
          document.body.removeChild(div);
        }
        if (relativePosition.left >= element.clientWidth) {
          relativePosition.left = element.clientWidth;
        }
        return relativePosition;
      };
      const mentionProps = exports("mentionProps", buildProps({
        ...inputProps,
        options: {
          type: definePropType(Array),
          default: () => []
        },
        prefix: {
          type: definePropType([String, Array]),
          default: "@",
          validator: (val) => {
            if (isString$1(val))
              return val.length === 1;
            return val.every((v2) => isString$1(v2) && v2.length === 1);
          }
        },
        split: {
          type: String,
          default: " ",
          validator: (val) => val.length === 1
        },
        filterOption: {
          type: definePropType([Boolean, Function]),
          default: () => filterOption,
          validator: (val) => {
            if (val === false)
              return true;
            return isFunction$1(val);
          }
        },
        placement: {
          type: definePropType(String),
          default: "bottom"
        },
        showArrow: Boolean,
        offset: {
          type: Number,
          default: 0
        },
        whole: Boolean,
        checkIsWhole: {
          type: definePropType(Function)
        },
        modelValue: String,
        loading: Boolean,
        popperClass: {
          type: String,
          default: ""
        },
        popperOptions: {
          type: definePropType(Object),
          default: () => ({})
        }
      }));
      const mentionEmits = exports("mentionEmits", {
        [UPDATE_MODEL_EVENT]: (value) => isString$1(value),
        "whole-remove": (pattern, prefix) => isString$1(pattern) && isString$1(prefix),
        input: (value) => isString$1(value),
        search: (pattern, prefix) => isString$1(pattern) && isString$1(prefix),
        select: (option, prefix) => isString$1(option.value) && isString$1(prefix),
        focus: (evt) => evt instanceof FocusEvent,
        blur: (evt) => evt instanceof FocusEvent
      });
      const mentionDropdownProps = buildProps({
        options: {
          type: definePropType(Array),
          default: () => []
        },
        loading: Boolean,
        disabled: Boolean,
        contentId: String,
        ariaLabel: String
      });
      const mentionDropdownEmits = {
        select: (option) => isString$1(option.value)
      };
      const __default__$6 = defineComponent({
        name: "ElMentionDropdown"
      });
      const _sfc_main$7 = /* @__PURE__ */ defineComponent({
        ...__default__$6,
        props: mentionDropdownProps,
        emits: mentionDropdownEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const ns = useNamespace("mention");
          const { t } = useLocale();
          const hoveringIndex = ref(-1);
          const scrollbarRef = ref();
          const optionRefs = ref();
          const dropdownRef = ref();
          const optionkls = (item, index2) => [
            ns.be("dropdown", "item"),
            ns.is("hovering", hoveringIndex.value === index2),
            ns.is("disabled", item.disabled || props2.disabled)
          ];
          const handleSelect = (item) => {
            if (item.disabled || props2.disabled)
              return;
            emit("select", item);
          };
          const handleMouseEnter = (index2) => {
            hoveringIndex.value = index2;
          };
          const filteredAllDisabled = computed(() => props2.disabled || props2.options.every((item) => item.disabled));
          const hoverOption = computed(() => props2.options[hoveringIndex.value]);
          const selectHoverOption = () => {
            if (!hoverOption.value)
              return;
            emit("select", hoverOption.value);
          };
          const navigateOptions = (direction2) => {
            const { options } = props2;
            if (options.length === 0 || filteredAllDisabled.value)
              return;
            if (direction2 === "next") {
              hoveringIndex.value++;
              if (hoveringIndex.value === options.length) {
                hoveringIndex.value = 0;
              }
            } else if (direction2 === "prev") {
              hoveringIndex.value--;
              if (hoveringIndex.value < 0) {
                hoveringIndex.value = options.length - 1;
              }
            }
            const option = options[hoveringIndex.value];
            if (option.disabled) {
              navigateOptions(direction2);
              return;
            }
            nextTick(() => scrollToOption(option));
          };
          const scrollToOption = (option) => {
            var _a, _b, _c, _d;
            const { options } = props2;
            const index2 = options.findIndex((item) => item.value === option.value);
            const target2 = (_a = optionRefs.value) == null ? void 0 : _a[index2];
            if (target2) {
              const menu = (_c = (_b = dropdownRef.value) == null ? void 0 : _b.querySelector) == null ? void 0 : _c.call(_b, `.${ns.be("dropdown", "wrap")}`);
              if (menu) {
                scrollIntoView(menu, target2);
              }
            }
            (_d = scrollbarRef.value) == null ? void 0 : _d.handleScroll();
          };
          const resetHoveringIndex = () => {
            if (filteredAllDisabled.value || props2.options.length === 0) {
              hoveringIndex.value = -1;
            } else {
              hoveringIndex.value = 0;
            }
          };
          watch(() => props2.options, resetHoveringIndex, {
            immediate: true
          });
          expose({
            hoveringIndex,
            navigateOptions,
            selectHoverOption,
            hoverOption
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "dropdownRef",
              ref: dropdownRef,
              class: normalizeClass(unref(ns).b("dropdown"))
            }, [
              _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).be("dropdown", "header"))
              }, [
                renderSlot(_ctx.$slots, "header")
              ], 2)) : createCommentVNode("v-if", true),
              withDirectives(createVNode(unref(ElScrollbar), {
                id: _ctx.contentId,
                ref_key: "scrollbarRef",
                ref: scrollbarRef,
                tag: "ul",
                "wrap-class": unref(ns).be("dropdown", "wrap"),
                "view-class": unref(ns).be("dropdown", "list"),
                role: "listbox",
                "aria-label": _ctx.ariaLabel,
                "aria-orientation": "vertical"
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (item, index2) => {
                    return openBlock(), createElementBlock("li", {
                      id: `${_ctx.contentId}-${index2}`,
                      ref_for: true,
                      ref_key: "optionRefs",
                      ref: optionRefs,
                      key: index2,
                      class: normalizeClass(optionkls(item, index2)),
                      role: "option",
                      "aria-disabled": item.disabled || _ctx.disabled || void 0,
                      "aria-selected": hoveringIndex.value === index2,
                      onMousemove: ($event) => handleMouseEnter(index2),
                      onClick: withModifiers(($event) => handleSelect(item), ["stop"])
                    }, [
                      renderSlot(_ctx.$slots, "label", {
                        item,
                        index: index2
                      }, () => {
                        var _a;
                        return [
                          createElementVNode("span", null, toDisplayString((_a = item.label) != null ? _a : item.value), 1)
                        ];
                      })
                    ], 42, ["id", "aria-disabled", "aria-selected", "onMousemove", "onClick"]);
                  }), 128))
                ]),
                _: 3
              }, 8, ["id", "wrap-class", "view-class", "aria-label"]), [
                [vShow, _ctx.options.length > 0 && !_ctx.loading]
              ]),
              _ctx.loading ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(ns).be("dropdown", "loading"))
              }, [
                renderSlot(_ctx.$slots, "loading", {}, () => [
                  createTextVNode(toDisplayString(unref(t)("el.mention.loading")), 1)
                ])
              ], 2)) : createCommentVNode("v-if", true),
              _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
                key: 2,
                class: normalizeClass(unref(ns).be("dropdown", "footer"))
              }, [
                renderSlot(_ctx.$slots, "footer")
              ], 2)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var ElMentionDropdown = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__file", "mention-dropdown.vue"]]);
      const __default__$5 = defineComponent({
        name: "ElMention",
        inheritAttrs: false
      });
      const _sfc_main$6 = /* @__PURE__ */ defineComponent({
        ...__default__$5,
        props: mentionProps,
        emits: mentionEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const passInputProps = computed(() => pick(props2, Object.keys(inputProps)));
          const ns = useNamespace("mention");
          const disabled = useFormDisabled();
          const contentId = useId();
          const elInputRef = ref();
          const tooltipRef = ref();
          const dropdownRef = ref();
          const visible = ref(false);
          const cursorStyle = ref();
          const mentionCtx = ref();
          const computedPlacement = computed(() => props2.showArrow ? props2.placement : `${props2.placement}-start`);
          const computedFallbackPlacements = computed(() => props2.showArrow ? ["bottom", "top"] : ["bottom-start", "top-start"]);
          const filteredOptions = computed(() => {
            const { filterOption: filterOption2, options } = props2;
            if (!mentionCtx.value || !filterOption2)
              return options;
            return options.filter((option) => filterOption2(mentionCtx.value.pattern, option));
          });
          const dropdownVisible = computed(() => {
            return visible.value && (!!filteredOptions.value.length || props2.loading);
          });
          const hoveringId = computed(() => {
            var _a;
            return `${contentId.value}-${(_a = dropdownRef.value) == null ? void 0 : _a.hoveringIndex}`;
          });
          const handleInputChange = (value) => {
            emit(UPDATE_MODEL_EVENT, value);
            emit(INPUT_EVENT, value);
            syncAfterCursorMove();
          };
          const handleInputKeyDown = (event) => {
            var _a, _b, _c, _d;
            if (!("code" in event) || ((_a = elInputRef.value) == null ? void 0 : _a.isComposing))
              return;
            switch (event.code) {
              case EVENT_CODE.left:
              case EVENT_CODE.right:
                syncAfterCursorMove();
                break;
              case EVENT_CODE.up:
              case EVENT_CODE.down:
                if (!visible.value)
                  return;
                event.preventDefault();
                (_b = dropdownRef.value) == null ? void 0 : _b.navigateOptions(event.code === EVENT_CODE.up ? "prev" : "next");
                break;
              case EVENT_CODE.enter:
              case EVENT_CODE.numpadEnter:
                if (!visible.value)
                  return;
                event.preventDefault();
                if ((_c = dropdownRef.value) == null ? void 0 : _c.hoverOption) {
                  (_d = dropdownRef.value) == null ? void 0 : _d.selectHoverOption();
                } else {
                  visible.value = false;
                }
                break;
              case EVENT_CODE.esc:
                if (!visible.value)
                  return;
                event.preventDefault();
                visible.value = false;
                break;
              case EVENT_CODE.backspace:
                if (props2.whole && mentionCtx.value) {
                  const { splitIndex, selectionEnd, pattern, prefixIndex, prefix } = mentionCtx.value;
                  const inputEl = getInputEl();
                  if (!inputEl)
                    return;
                  const inputValue = inputEl.value;
                  const matchOption = props2.options.find((item) => item.value === pattern);
                  const isWhole = isFunction$1(props2.checkIsWhole) ? props2.checkIsWhole(pattern, prefix) : matchOption;
                  if (isWhole && splitIndex !== -1 && splitIndex + 1 === selectionEnd) {
                    event.preventDefault();
                    const newValue = inputValue.slice(0, prefixIndex) + inputValue.slice(splitIndex + 1);
                    emit(UPDATE_MODEL_EVENT, newValue);
                    emit(INPUT_EVENT, newValue);
                    emit("whole-remove", pattern, prefix);
                    const newSelectionEnd = prefixIndex;
                    nextTick(() => {
                      inputEl.selectionStart = newSelectionEnd;
                      inputEl.selectionEnd = newSelectionEnd;
                      syncDropdownVisible();
                    });
                  }
                }
            }
          };
          const { wrapperRef } = useFocusController(elInputRef, {
            disabled,
            afterFocus() {
              syncAfterCursorMove();
            },
            beforeBlur(event) {
              var _a;
              return (_a = tooltipRef.value) == null ? void 0 : _a.isFocusInsideContent(event);
            },
            afterBlur() {
              visible.value = false;
            }
          });
          const handleInputMouseDown = () => {
            syncAfterCursorMove();
          };
          const handleSelect = (item) => {
            if (!mentionCtx.value)
              return;
            const inputEl = getInputEl();
            if (!inputEl)
              return;
            const inputValue = inputEl.value;
            const { split: split2 } = props2;
            const newEndPart = inputValue.slice(mentionCtx.value.end);
            const alreadySeparated = newEndPart.startsWith(split2);
            const newMiddlePart = `${item.value}${alreadySeparated ? "" : split2}`;
            const newValue = inputValue.slice(0, mentionCtx.value.start) + newMiddlePart + newEndPart;
            emit(UPDATE_MODEL_EVENT, newValue);
            emit(INPUT_EVENT, newValue);
            emit("select", item, mentionCtx.value.prefix);
            const newSelectionEnd = mentionCtx.value.start + newMiddlePart.length + (alreadySeparated ? 1 : 0);
            nextTick(() => {
              inputEl.selectionStart = newSelectionEnd;
              inputEl.selectionEnd = newSelectionEnd;
              inputEl.focus();
              syncDropdownVisible();
            });
          };
          const getInputEl = () => {
            var _a, _b;
            return props2.type === "textarea" ? (_a = elInputRef.value) == null ? void 0 : _a.textarea : (_b = elInputRef.value) == null ? void 0 : _b.input;
          };
          const syncAfterCursorMove = () => {
            setTimeout(() => {
              syncCursor();
              syncDropdownVisible();
              nextTick(() => {
                var _a;
                return (_a = tooltipRef.value) == null ? void 0 : _a.updatePopper();
              });
            }, 0);
          };
          const syncCursor = () => {
            const inputEl = getInputEl();
            if (!inputEl)
              return;
            const caretPosition = getCursorPosition(inputEl);
            const inputRect = inputEl.getBoundingClientRect();
            const elInputRect = elInputRef.value.$el.getBoundingClientRect();
            cursorStyle.value = {
              position: "absolute",
              width: 0,
              height: `${caretPosition.height}px`,
              left: `${caretPosition.left + inputRect.left - elInputRect.left}px`,
              top: `${caretPosition.top + inputRect.top - elInputRect.top}px`
            };
          };
          const syncDropdownVisible = () => {
            const inputEl = getInputEl();
            if (document.activeElement !== inputEl) {
              visible.value = false;
              return;
            }
            const { prefix, split: split2 } = props2;
            mentionCtx.value = getMentionCtx(inputEl, prefix, split2);
            if (mentionCtx.value && mentionCtx.value.splitIndex === -1) {
              visible.value = true;
              emit("search", mentionCtx.value.pattern, mentionCtx.value.prefix);
              return;
            }
            visible.value = false;
          };
          expose({
            input: elInputRef,
            tooltip: tooltipRef,
            dropdownVisible
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "wrapperRef",
              ref: wrapperRef,
              class: normalizeClass(unref(ns).b())
            }, [
              createVNode(unref(ElInput), mergeProps(mergeProps(unref(passInputProps), _ctx.$attrs), {
                ref_key: "elInputRef",
                ref: elInputRef,
                "model-value": _ctx.modelValue,
                disabled: unref(disabled),
                role: unref(dropdownVisible) ? "combobox" : void 0,
                "aria-activedescendant": unref(dropdownVisible) ? unref(hoveringId) || "" : void 0,
                "aria-controls": unref(dropdownVisible) ? unref(contentId) : void 0,
                "aria-expanded": unref(dropdownVisible) || void 0,
                "aria-label": _ctx.ariaLabel,
                "aria-autocomplete": unref(dropdownVisible) ? "none" : void 0,
                "aria-haspopup": unref(dropdownVisible) ? "listbox" : void 0,
                onInput: handleInputChange,
                onKeydown: handleInputKeyDown,
                onMousedown: handleInputMouseDown
              }), createSlots({
                _: 2
              }, [
                renderList(_ctx.$slots, (_2, name) => {
                  return {
                    name,
                    fn: withCtx((slotProps) => [
                      renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotProps)))
                    ])
                  };
                })
              ]), 1040, ["model-value", "disabled", "role", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label", "aria-autocomplete", "aria-haspopup"]),
              createVNode(unref(ElTooltip), {
                ref_key: "tooltipRef",
                ref: tooltipRef,
                visible: unref(dropdownVisible),
                "popper-class": [unref(ns).e("popper"), _ctx.popperClass],
                "popper-options": _ctx.popperOptions,
                placement: unref(computedPlacement),
                "fallback-placements": unref(computedFallbackPlacements),
                effect: "light",
                pure: "",
                offset: _ctx.offset,
                "show-arrow": _ctx.showArrow
              }, {
                default: withCtx(() => [
                  createElementVNode("div", {
                    style: normalizeStyle(cursorStyle.value)
                  }, null, 4)
                ]),
                content: withCtx(() => {
                  var _a;
                  return [
                    createVNode(ElMentionDropdown, {
                      ref_key: "dropdownRef",
                      ref: dropdownRef,
                      options: unref(filteredOptions),
                      disabled: unref(disabled),
                      loading: _ctx.loading,
                      "content-id": unref(contentId),
                      "aria-label": _ctx.ariaLabel,
                      onSelect: handleSelect,
                      onClick: withModifiers((_a = elInputRef.value) == null ? void 0 : _a.focus, ["stop"])
                    }, createSlots({
                      _: 2
                    }, [
                      renderList(_ctx.$slots, (_2, name) => {
                        return {
                          name,
                          fn: withCtx((slotProps) => [
                            renderSlot(_ctx.$slots, name, normalizeProps(guardReactiveProps(slotProps)))
                          ])
                        };
                      })
                    ]), 1032, ["options", "disabled", "loading", "content-id", "aria-label", "onClick"])
                  ];
                }),
                _: 3
              }, 8, ["visible", "popper-class", "popper-options", "placement", "fallback-placements", "offset", "show-arrow"])
            ], 2);
          };
        }
      });
      var Mention = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__file", "mention.vue"]]);
      const ElMention = exports("ElMention", withInstall(Mention));
      function useContainer(layout2) {
        const containerEl = ref();
        const { width, height } = useElementSize(containerEl);
        const containerSize = computed(() => {
          return layout2.value === "horizontal" ? width.value : height.value;
        });
        return { containerEl, containerSize };
      }
      function getPct(str) {
        return Number(str.slice(0, -1)) / 100;
      }
      function getPx(str) {
        return Number(str.slice(0, -2));
      }
      function isPct(itemSize2) {
        return isString$1(itemSize2) && itemSize2.endsWith("%");
      }
      function isPx(itemSize2) {
        return isString$1(itemSize2) && itemSize2.endsWith("px");
      }
      function useSize(panels, containerSize) {
        const propSizes = computed(() => panels.value.map((i) => i.size));
        const panelCounts = computed(() => panels.value.length);
        const percentSizes = ref([]);
        watch([propSizes, panelCounts, containerSize], () => {
          var _a;
          let ptgList = [];
          let emptyCount = 0;
          for (let i = 0; i < panelCounts.value; i += 1) {
            const itemSize2 = (_a = panels.value[i]) == null ? void 0 : _a.size;
            if (isPct(itemSize2)) {
              ptgList[i] = getPct(itemSize2);
            } else if (isPx(itemSize2)) {
              ptgList[i] = getPx(itemSize2) / containerSize.value;
            } else if (itemSize2 || itemSize2 === 0) {
              const num = Number(itemSize2);
              if (!Number.isNaN(num)) {
                ptgList[i] = num / containerSize.value;
              }
            } else {
              emptyCount += 1;
              ptgList[i] = void 0;
            }
          }
          const totalPtg = ptgList.reduce((acc, ptg) => acc + (ptg || 0), 0);
          if (totalPtg > 1 || !emptyCount) {
            const scale = 1 / totalPtg;
            ptgList = ptgList.map((ptg) => ptg === void 0 ? 0 : ptg * scale);
          } else {
            const avgRest = (1 - totalPtg) / emptyCount;
            ptgList = ptgList.map((ptg) => ptg === void 0 ? avgRest : ptg);
          }
          percentSizes.value = ptgList;
        });
        const ptg2px = (ptg) => ptg * containerSize.value;
        const pxSizes = computed(() => percentSizes.value.map(ptg2px));
        return { percentSizes, pxSizes };
      }
      function useResize(panels, containerSize, pxSizes) {
        const ptg2px = (ptg) => ptg * containerSize.value || 0;
        function getLimitSize(str, defaultLimit) {
          if (isPct(str)) {
            return ptg2px(getPct(str));
          } else if (isPx(str)) {
            return getPx(str);
          }
          return str != null ? str : defaultLimit;
        }
        const movingIndex = ref(null);
        let cachePxSizes = [];
        const limitSizes = computed(() => panels.value.map((item) => [item.min, item.max]));
        const onMoveStart = (index2) => {
          movingIndex.value = { index: index2, confirmed: false };
          cachePxSizes = pxSizes.value;
        };
        const onMoving = (index2, offset2) => {
          var _a, _b;
          let confirmedIndex = null;
          if ((!movingIndex.value || !movingIndex.value.confirmed) && offset2 !== 0) {
            if (offset2 > 0) {
              confirmedIndex = index2;
              movingIndex.value = { index: index2, confirmed: true };
            } else {
              for (let i = index2; i >= 0; i -= 1) {
                if (cachePxSizes[i] > 0) {
                  confirmedIndex = i;
                  movingIndex.value = { index: i, confirmed: true };
                  break;
                }
              }
            }
          }
          const mergedIndex = (_b = confirmedIndex != null ? confirmedIndex : (_a = movingIndex.value) == null ? void 0 : _a.index) != null ? _b : index2;
          const numSizes = [...cachePxSizes];
          const nextIndex = mergedIndex + 1;
          const startMinSize = getLimitSize(limitSizes.value[mergedIndex][0], 0);
          const endMinSize = getLimitSize(limitSizes.value[nextIndex][0], 0);
          const startMaxSize = getLimitSize(limitSizes.value[mergedIndex][1], containerSize.value || 0);
          const endMaxSize = getLimitSize(limitSizes.value[nextIndex][1], containerSize.value || 0);
          let mergedOffset = offset2;
          if (numSizes[mergedIndex] + mergedOffset < startMinSize) {
            mergedOffset = startMinSize - numSizes[mergedIndex];
          }
          if (numSizes[nextIndex] - mergedOffset < endMinSize) {
            mergedOffset = numSizes[nextIndex] - endMinSize;
          }
          if (numSizes[mergedIndex] + mergedOffset > startMaxSize) {
            mergedOffset = startMaxSize - numSizes[mergedIndex];
          }
          if (numSizes[nextIndex] - mergedOffset > endMaxSize) {
            mergedOffset = numSizes[nextIndex] - endMaxSize;
          }
          numSizes[mergedIndex] += mergedOffset;
          numSizes[nextIndex] -= mergedOffset;
          panels.value.forEach((panel, index22) => {
            panel.size = numSizes[index22];
          });
        };
        const onMoveEnd = () => {
          movingIndex.value = null;
          cachePxSizes = [];
        };
        const cacheCollapsedSize = [];
        const onCollapse = (index2, type) => {
          if (!cacheCollapsedSize.length) {
            cacheCollapsedSize.push(...pxSizes.value);
          }
          const currentSizes = pxSizes.value;
          const currentIndex = type === "start" ? index2 : index2 + 1;
          const targetIndex = type === "start" ? index2 + 1 : index2;
          const currentSize = currentSizes[currentIndex];
          const targetSize = currentSizes[targetIndex];
          if (currentSize !== 0 && targetSize !== 0) {
            currentSizes[currentIndex] = 0;
            currentSizes[targetIndex] += currentSize;
            cacheCollapsedSize[index2] = currentSize;
          } else {
            const totalSize = currentSize + targetSize;
            const targetCacheCollapsedSize = cacheCollapsedSize[index2];
            const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize;
            currentSizes[targetIndex] = targetCacheCollapsedSize;
            currentSizes[currentIndex] = currentCacheCollapsedSize;
          }
          panels.value.forEach((panel, index22) => {
            panel.size = currentSizes[index22];
          });
        };
        return { onMoveStart, onMoving, onMoveEnd, movingIndex, onCollapse };
      }
      const splitterProps = exports("splitterProps", buildProps({
        layout: {
          type: String,
          default: "horizontal",
          values: ["horizontal", "vertical"]
        }
      }));
      const splitterRootContextKey = Symbol("splitterRootContextKey");
      const __default__$4 = defineComponent({
        name: "ElSplitter"
      });
      const _sfc_main$5 = /* @__PURE__ */ defineComponent({
        ...__default__$4,
        props: splitterProps,
        emits: ["resizeStart", "resize", "resizeEnd", "collapse"],
        setup(__props, { emit: emits }) {
          const props2 = __props;
          const ns = useNamespace("splitter");
          const layout2 = toRef(props2, "layout");
          const { containerEl, containerSize } = useContainer(layout2);
          const {
            removeChild: unregisterPanel,
            children: panels,
            addChild: registerPanel,
            ChildrenSorter: PanelsSorter
          } = useOrderedChildren(getCurrentInstance(), "ElSplitterPanel");
          watch(panels, () => {
            panels.value.forEach((instance, index2) => {
              instance.setIndex(index2);
            });
          });
          const { percentSizes, pxSizes } = useSize(panels, containerSize);
          const { onMoveStart, onMoving, onMoveEnd, onCollapse, movingIndex } = useResize(panels, containerSize, pxSizes);
          const onResizeStart = (index2) => {
            onMoveStart(index2);
            emits("resizeStart", index2, pxSizes.value);
          };
          const onResize = (index2, offset2) => {
            onMoving(index2, offset2);
            emits("resize", index2, pxSizes.value);
          };
          const onResizeEnd = (index2) => {
            onMoveEnd();
            emits("resizeEnd", index2, pxSizes.value);
          };
          const onCollapsible = (index2, type) => {
            onCollapse(index2, type);
            emits("collapse", index2, type, pxSizes.value);
          };
          provide(splitterRootContextKey, reactive({
            panels,
            percentSizes,
            pxSizes,
            layout: layout2,
            movingIndex,
            containerSize,
            onMoveStart: onResizeStart,
            onMoving: onResize,
            onMoveEnd: onResizeEnd,
            onCollapse: onCollapsible,
            registerPanel,
            unregisterPanel
          }));
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              ref_key: "containerEl",
              ref: containerEl,
              class: normalizeClass([unref(ns).b(), unref(ns).e(unref(layout2))])
            }, [
              renderSlot(_ctx.$slots, "default"),
              createVNode(unref(PanelsSorter)),
              createCommentVNode(" Prevent iframe touch events from breaking "),
              unref(movingIndex) ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass([unref(ns).e("mask"), unref(ns).e(`mask-${unref(layout2)}`)])
              }, null, 2)) : createCommentVNode("v-if", true)
            ], 2);
          };
        }
      });
      var Splitter = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__file", "splitter.vue"]]);
      function getCollapsible(collapsible) {
        if (collapsible && isObject$1(collapsible)) {
          return collapsible;
        }
        return {
          start: !!collapsible,
          end: !!collapsible
        };
      }
      function isCollapsible(panel, size, nextPanel, nextSize) {
        if ((panel == null ? void 0 : panel.collapsible.end) && size > 0) {
          return true;
        }
        if ((nextPanel == null ? void 0 : nextPanel.collapsible.start) && nextSize === 0 && size > 0) {
          return true;
        }
        return false;
      }
      const __default__$3 = defineComponent({
        name: "ElSplitterBar"
      });
      const _sfc_main$4 = /* @__PURE__ */ defineComponent({
        ...__default__$3,
        props: {
          index: {
            type: Number,
            required: true
          },
          layout: {
            type: String,
            values: ["horizontal", "vertical"],
            default: "horizontal"
          },
          resizable: {
            type: Boolean,
            default: true
          },
          startCollapsible: {
            type: Boolean
          },
          endCollapsible: {
            type: Boolean
          }
        },
        emits: ["moveStart", "moving", "moveEnd", "collapse"],
        setup(__props, { emit }) {
          const props2 = __props;
          const ns = useNamespace("splitter-bar");
          const isHorizontal2 = computed(() => props2.layout === "horizontal");
          const barWrapStyles = computed(() => {
            if (isHorizontal2.value) {
              return { width: 0 };
            }
            return { height: 0 };
          });
          const draggerStyles = computed(() => {
            return {
              width: isHorizontal2.value ? "16px" : "100%",
              height: isHorizontal2.value ? "100%" : "16px",
              cursor: isHorizontal2.value ? "col-resize" : "row-resize",
              touchAction: "none"
            };
          });
          const draggerPseudoClass = computed(() => {
            const prefix = ns.e("dragger");
            return {
              [`${prefix}-horizontal`]: isHorizontal2.value,
              [`${prefix}-vertical`]: !isHorizontal2.value,
              [`${prefix}-active`]: !!startPos.value
            };
          });
          const startPos = ref(null);
          const onMousedown = (e) => {
            if (!props2.resizable)
              return;
            startPos.value = [e.pageX, e.pageY];
            emit("moveStart", props2.index);
            window.addEventListener("mouseup", onMouseUp);
            window.addEventListener("mousemove", onMouseMove);
          };
          const onTouchStart = (e) => {
            if (props2.resizable && e.touches.length === 1) {
              e.preventDefault();
              const touch = e.touches[0];
              startPos.value = [touch.pageX, touch.pageY];
              emit("moveStart", props2.index);
              window.addEventListener("touchend", onTouchEnd);
              window.addEventListener("touchmove", onTouchMove);
            }
          };
          const onMouseMove = (e) => {
            const { pageX, pageY } = e;
            const offsetX = pageX - startPos.value[0];
            const offsetY = pageY - startPos.value[1];
            const offset2 = isHorizontal2.value ? offsetX : offsetY;
            emit("moving", props2.index, offset2);
          };
          const onTouchMove = (e) => {
            if (e.touches.length === 1) {
              e.preventDefault();
              const touch = e.touches[0];
              const offsetX = touch.pageX - startPos.value[0];
              const offsetY = touch.pageY - startPos.value[1];
              const offset2 = isHorizontal2.value ? offsetX : offsetY;
              emit("moving", props2.index, offset2);
            }
          };
          const onMouseUp = () => {
            startPos.value = null;
            window.removeEventListener("mouseup", onMouseUp);
            window.removeEventListener("mousemove", onMouseMove);
            emit("moveEnd", props2.index);
          };
          const onTouchEnd = () => {
            startPos.value = null;
            window.removeEventListener("touchend", onTouchEnd);
            window.removeEventListener("touchmove", onTouchMove);
            emit("moveEnd", props2.index);
          };
          const StartIcon = computed(() => isHorizontal2.value ? arrow_left_default$1 : arrow_up_default$1);
          const EndIcon = computed(() => isHorizontal2.value ? arrow_right_default$1 : arrow_down_default$1);
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass([unref(ns).b()]),
              style: normalizeStyle(unref(barWrapStyles))
            }, [
              __props.startCollapsible ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass([unref(ns).e("collapse-icon"), unref(ns).e(`${__props.layout}-collapse-icon-start`)]),
                onClick: ($event) => emit("collapse", __props.index, "start")
              }, [
                renderSlot(_ctx.$slots, "start-collapsible", {}, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(unref(StartIcon)), { style: { "width": "12px", "height": "12px" } }))
                ])
              ], 10, ["onClick"])) : createCommentVNode("v-if", true),
              createElementVNode("div", {
                class: normalizeClass([
                  unref(ns).e("dragger"),
                  unref(draggerPseudoClass),
                  __props.resizable ? "" : unref(ns).e("disable")
                ]),
                style: normalizeStyle(unref(draggerStyles)),
                onMousedown,
                onTouchstart: onTouchStart
              }, null, 38),
              __props.endCollapsible ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass([unref(ns).e("collapse-icon"), unref(ns).e(`${__props.layout}-collapse-icon-end`)]),
                onClick: ($event) => emit("collapse", __props.index, "end")
              }, [
                renderSlot(_ctx.$slots, "end-collapsible", {}, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(unref(EndIcon)), { style: { "width": "12px", "height": "12px" } }))
                ])
              ], 10, ["onClick"])) : createCommentVNode("v-if", true)
            ], 6);
          };
        }
      });
      var SplitBar = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__file", "split-bar.vue"]]);
      const splitterPanelProps = exports("splitterPanelProps", buildProps({
        min: {
          type: [String, Number]
        },
        max: {
          type: [String, Number]
        },
        size: {
          type: [String, Number]
        },
        resizable: {
          type: Boolean,
          default: true
        },
        collapsible: Boolean
      }));
      const COMPONENT_NAME = "ElSplitterPanel";
      const __default__$2 = defineComponent({
        name: COMPONENT_NAME
      });
      const _sfc_main$3 = /* @__PURE__ */ defineComponent({
        ...__default__$2,
        props: splitterPanelProps,
        emits: ["update:size"],
        setup(__props, { emit: emits }) {
          const props2 = __props;
          const ns = useNamespace("splitter-panel");
          const splitterContext = inject(splitterRootContextKey);
          if (!splitterContext)
            throwError(COMPONENT_NAME, "usage: <el-splitter><el-splitter-panel /></el-splitter/>");
          const { panels, layout: layout2, containerSize, pxSizes } = toRefs(splitterContext);
          const {
            registerPanel,
            unregisterPanel,
            onCollapse,
            onMoveEnd,
            onMoveStart,
            onMoving
          } = splitterContext;
          const panelEl = ref();
          const instance = getCurrentInstance();
          const uid2 = instance.uid;
          const index2 = ref(0);
          const panel = computed(() => panels.value[index2.value]);
          const setIndex = (val) => {
            index2.value = val;
          };
          const panelSize = computed(() => {
            var _a;
            if (!panel.value)
              return 0;
            return (_a = pxSizes.value[index2.value]) != null ? _a : 0;
          });
          const nextSize = computed(() => {
            var _a;
            if (!panel.value)
              return 0;
            return (_a = pxSizes.value[index2.value + 1]) != null ? _a : 0;
          });
          const nextPanel = computed(() => {
            if (panel.value) {
              return panels.value[index2.value + 1];
            }
            return null;
          });
          const isResizable = computed(() => {
            var _a;
            if (!nextPanel.value)
              return false;
            return props2.resizable && ((_a = nextPanel.value) == null ? void 0 : _a.resizable) && (panelSize.value !== 0 || !props2.min) && (nextSize.value !== 0 || !nextPanel.value.min);
          });
          const isShowBar = computed(() => {
            if (!panel.value)
              return false;
            return index2.value !== panels.value.length - 1;
          });
          const startCollapsible = computed(() => isCollapsible(panel.value, panelSize.value, nextPanel.value, nextSize.value));
          const endCollapsible = computed(() => isCollapsible(nextPanel.value, nextSize.value, panel.value, panelSize.value));
          function sizeToPx(str) {
            if (isPct(str)) {
              return getPct(str) * containerSize.value || 0;
            } else if (isPx(str)) {
              return getPx(str);
            }
            return str != null ? str : 0;
          }
          let isSizeUpdating = false;
          watch(() => props2.size, () => {
            if (panel.value) {
              const size = sizeToPx(props2.size);
              const maxSize = sizeToPx(props2.max);
              const minSize = sizeToPx(props2.min);
              const finalSize = Math.min(Math.max(size, minSize || 0), maxSize || size);
              if (finalSize !== size) {
                isSizeUpdating = true;
                emits("update:size", finalSize);
              }
              panel.value.size = finalSize;
              nextTick(() => isSizeUpdating = false);
            }
          });
          watch(() => {
            var _a;
            return (_a = panel.value) == null ? void 0 : _a.size;
          }, (val) => {
            if (!isSizeUpdating && val !== props2.size) {
              emits("update:size", val);
            }
          });
          watch(() => props2.resizable, (val) => {
            if (panel.value) {
              panel.value.resizable = val;
            }
          });
          const _panel = reactive({
            el: panelEl.value,
            uid: uid2,
            getVnode: () => instance.vnode,
            setIndex,
            ...props2,
            collapsible: getCollapsible(props2.collapsible)
          });
          registerPanel(_panel);
          onBeforeUnmount(() => unregisterPanel(_panel));
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createElementVNode("div", mergeProps({
                ref_key: "panelEl",
                ref: panelEl,
                class: [unref(ns).b()],
                style: { flexBasis: `${unref(panelSize)}px` }
              }, _ctx.$attrs), [
                renderSlot(_ctx.$slots, "default")
              ], 16),
              unref(isShowBar) ? (openBlock(), createBlock(SplitBar, {
                key: 0,
                index: index2.value,
                layout: unref(layout2),
                resizable: unref(isResizable),
                "start-collapsible": unref(startCollapsible),
                "end-collapsible": unref(endCollapsible),
                onMoveStart: unref(onMoveStart),
                onMoving: unref(onMoving),
                onMoveEnd: unref(onMoveEnd),
                onCollapse: unref(onCollapse)
              }, {
                "start-collapsible": withCtx(() => [
                  renderSlot(_ctx.$slots, "start-collapsible")
                ]),
                "end-collapsible": withCtx(() => [
                  renderSlot(_ctx.$slots, "end-collapsible")
                ]),
                _: 3
              }, 8, ["index", "layout", "resizable", "start-collapsible", "end-collapsible", "onMoveStart", "onMoving", "onMoveEnd", "onCollapse"])) : createCommentVNode("v-if", true)
            ], 64);
          };
        }
      });
      var SplitPanel = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__file", "split-panel.vue"]]);
      const ElSplitter = exports("ElSplitter", withInstall(Splitter, {
        SplitPanel
      }));
      const ElSplitterPanel = exports("ElSplitterPanel", withNoopInstall(SplitPanel));
      var Components = [
        ElAffix,
        ElAlert,
        ElAutocomplete,
        ElAutoResizer,
        ElAvatar,
        ElBacktop,
        ElBadge,
        ElBreadcrumb,
        ElBreadcrumbItem,
        ElButton,
        ElButtonGroup$1,
        ElCalendar,
        ElCard,
        ElCarousel,
        ElCarouselItem,
        ElCascader,
        ElCascaderPanel,
        ElCheckTag,
        ElCheckbox,
        ElCheckboxButton,
        ElCheckboxGroup$1,
        ElCol,
        ElCollapse,
        ElCollapseItem,
        ElCollapseTransition,
        ElColorPicker,
        ElConfigProvider,
        ElContainer,
        ElAside,
        ElFooter,
        ElHeader,
        ElMain,
        ElDatePicker,
        ElDescriptions,
        ElDescriptionsItem,
        ElDialog,
        ElDivider,
        ElDrawer,
        ElDropdown,
        ElDropdownItem,
        ElDropdownMenu,
        ElEmpty,
        ElForm,
        ElFormItem,
        ElIcon,
        ElImage,
        ElImageViewer,
        ElInput,
        ElInputNumber,
        ElInputTag,
        ElLink,
        ElMenu,
        ElMenuItem,
        ElMenuItemGroup,
        ElSubMenu,
        ElPageHeader,
        ElPagination,
        ElPopconfirm,
        ElPopover,
        ElPopper,
        ElProgress,
        ElRadio,
        ElRadioButton,
        ElRadioGroup,
        ElRate,
        ElResult,
        ElRow,
        ElScrollbar,
        ElSelect,
        ElOption,
        ElOptionGroup,
        ElSelectV2,
        ElSkeleton,
        ElSkeletonItem,
        ElSlider,
        ElSpace,
        ElStatistic,
        ElCountdown,
        ElSteps,
        ElStep,
        ElSwitch,
        ElTable,
        ElTableColumn,
        ElTableV2,
        ElTabs,
        ElTabPane,
        ElTag,
        ElText,
        ElTimePicker,
        ElTimeSelect,
        ElTimeline,
        ElTimelineItem,
        ElTooltip,
        ElTooltipV2,
        ElTransfer,
        ElTree,
        ElTreeSelect,
        ElTreeV2,
        ElUpload,
        ElWatermark,
        ElTour,
        ElTourStep,
        ElAnchor,
        ElAnchorLink,
        ElSegmented,
        ElMention,
        ElSplitter,
        ElSplitterPanel
      ];
      const SCOPE = "ElInfiniteScroll";
      const CHECK_INTERVAL = 50;
      const DEFAULT_DELAY = 200;
      const DEFAULT_DISTANCE = 0;
      const attributes = {
        delay: {
          type: Number,
          default: DEFAULT_DELAY
        },
        distance: {
          type: Number,
          default: DEFAULT_DISTANCE
        },
        disabled: {
          type: Boolean,
          default: false
        },
        immediate: {
          type: Boolean,
          default: true
        }
      };
      const getScrollOptions = (el, instance) => {
        return Object.entries(attributes).reduce((acm, [name, option]) => {
          var _a, _b;
          const { type, default: defaultValue } = option;
          const attrVal = el.getAttribute(`infinite-scroll-${name}`);
          let value = (_b = (_a = instance[attrVal]) != null ? _a : attrVal) != null ? _b : defaultValue;
          value = value === "false" ? false : value;
          value = type(value);
          acm[name] = Number.isNaN(value) ? defaultValue : value;
          return acm;
        }, {});
      };
      const destroyObserver = (el) => {
        const { observer } = el[SCOPE];
        if (observer) {
          observer.disconnect();
          delete el[SCOPE].observer;
        }
      };
      const handleScroll = (el, cb) => {
        const { container, containerEl, instance, observer, lastScrollTop } = el[SCOPE];
        const { disabled, distance } = getScrollOptions(el, instance);
        const { clientHeight, scrollHeight, scrollTop } = containerEl;
        const delta = scrollTop - lastScrollTop;
        el[SCOPE].lastScrollTop = scrollTop;
        if (observer || disabled || delta < 0)
          return;
        let shouldTrigger = false;
        if (container === el) {
          shouldTrigger = scrollHeight - (clientHeight + scrollTop) <= distance;
        } else {
          const { clientTop, scrollHeight: height } = el;
          const offsetTop = getOffsetTopDistance(el, containerEl);
          shouldTrigger = scrollTop + clientHeight >= offsetTop + clientTop + height - distance;
        }
        if (shouldTrigger) {
          cb.call(instance);
        }
      };
      function checkFull(el, cb) {
        const { containerEl, instance } = el[SCOPE];
        const { disabled } = getScrollOptions(el, instance);
        if (disabled || containerEl.clientHeight === 0)
          return;
        if (containerEl.scrollHeight <= containerEl.clientHeight) {
          cb.call(instance);
        } else {
          destroyObserver(el);
        }
      }
      const InfiniteScroll = {
        async mounted(el, binding) {
          const { instance, value: cb } = binding;
          if (!isFunction$1(cb)) {
            throwError(SCOPE, "'v-infinite-scroll' binding value must be a function");
          }
          await nextTick();
          const { delay: delay2, immediate } = getScrollOptions(el, instance);
          const container = getScrollContainer(el, true);
          const containerEl = container === window ? document.documentElement : container;
          const onScroll = throttle(handleScroll.bind(null, el, cb), delay2);
          if (!container)
            return;
          el[SCOPE] = {
            instance,
            container,
            containerEl,
            delay: delay2,
            cb,
            onScroll,
            lastScrollTop: containerEl.scrollTop
          };
          if (immediate) {
            const observer = new MutationObserver(throttle(checkFull.bind(null, el, cb), CHECK_INTERVAL));
            el[SCOPE].observer = observer;
            observer.observe(el, { childList: true, subtree: true });
            checkFull(el, cb);
          }
          container.addEventListener("scroll", onScroll);
        },
        unmounted(el) {
          if (!el[SCOPE])
            return;
          const { container, onScroll } = el[SCOPE];
          container == null ? void 0 : container.removeEventListener("scroll", onScroll);
          destroyObserver(el);
        },
        async updated(el) {
          if (!el[SCOPE]) {
            await nextTick();
          } else {
            const { containerEl, cb, observer } = el[SCOPE];
            if (containerEl.clientHeight && observer) {
              checkFull(el, cb);
            }
          }
        }
      };
      var InfiniteScroll$1 = InfiniteScroll;
      const _InfiniteScroll = InfiniteScroll$1;
      _InfiniteScroll.install = (app) => {
        app.directive("InfiniteScroll", _InfiniteScroll);
      };
      const ElInfiniteScroll = exports("ElInfiniteScroll", _InfiniteScroll);
      function createLoadingComponent(options, appContext) {
        let afterLeaveTimer;
        const afterLeaveFlag = ref(false);
        const data = reactive({
          ...options,
          originalPosition: "",
          originalOverflow: "",
          visible: false
        });
        function setText(text) {
          data.text = text;
        }
        function destroySelf() {
          const target2 = data.parent;
          const ns = vm.ns;
          if (!target2.vLoadingAddClassList) {
            let loadingNumber = target2.getAttribute("loading-number");
            loadingNumber = Number.parseInt(loadingNumber) - 1;
            if (!loadingNumber) {
              removeClass(target2, ns.bm("parent", "relative"));
              target2.removeAttribute("loading-number");
            } else {
              target2.setAttribute("loading-number", loadingNumber.toString());
            }
            removeClass(target2, ns.bm("parent", "hidden"));
          }
          removeElLoadingChild();
          loadingInstance.unmount();
        }
        function removeElLoadingChild() {
          var _a, _b;
          (_b = (_a = vm.$el) == null ? void 0 : _a.parentNode) == null ? void 0 : _b.removeChild(vm.$el);
        }
        function close2() {
          var _a;
          if (options.beforeClose && !options.beforeClose())
            return;
          afterLeaveFlag.value = true;
          clearTimeout(afterLeaveTimer);
          afterLeaveTimer = setTimeout(handleAfterLeave, 400);
          data.visible = false;
          (_a = options.closed) == null ? void 0 : _a.call(options);
        }
        function handleAfterLeave() {
          if (!afterLeaveFlag.value)
            return;
          const target2 = data.parent;
          afterLeaveFlag.value = false;
          target2.vLoadingAddClassList = void 0;
          destroySelf();
        }
        const elLoadingComponent = defineComponent({
          name: "ElLoading",
          setup(_2, { expose }) {
            const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("loading");
            expose({
              ns,
              zIndex: zIndex2
            });
            return () => {
              const svg = data.spinner || data.svg;
              const spinner = h$1("svg", {
                class: "circular",
                viewBox: data.svgViewBox ? data.svgViewBox : "0 0 50 50",
                ...svg ? { innerHTML: svg } : {}
              }, [
                h$1("circle", {
                  class: "path",
                  cx: "25",
                  cy: "25",
                  r: "20",
                  fill: "none"
                })
              ]);
              const spinnerText = data.text ? h$1("p", { class: ns.b("text") }, [data.text]) : void 0;
              return h$1(Transition, {
                name: ns.b("fade"),
                onAfterLeave: handleAfterLeave
              }, {
                default: withCtx(() => [
                  withDirectives(createVNode("div", {
                    style: {
                      backgroundColor: data.background || ""
                    },
                    class: [
                      ns.b("mask"),
                      data.customClass,
                      data.fullscreen ? "is-fullscreen" : ""
                    ]
                  }, [
                    h$1("div", {
                      class: ns.b("spinner")
                    }, [spinner, spinnerText])
                  ]), [[vShow, data.visible]])
                ])
              });
            };
          }
        });
        const loadingInstance = createApp(elLoadingComponent);
        Object.assign(loadingInstance._context, appContext != null ? appContext : {});
        const vm = loadingInstance.mount(document.createElement("div"));
        return {
          ...toRefs(data),
          setText,
          removeElLoadingChild,
          close: close2,
          handleAfterLeave,
          vm,
          get $el() {
            return vm.$el;
          }
        };
      }
      let fullscreenInstance = void 0;
      const Loading = function(options = {}) {
        if (!isClient)
          return void 0;
        const resolved = resolveOptions(options);
        if (resolved.fullscreen && fullscreenInstance) {
          return fullscreenInstance;
        }
        const instance = createLoadingComponent({
          ...resolved,
          closed: () => {
            var _a;
            (_a = resolved.closed) == null ? void 0 : _a.call(resolved);
            if (resolved.fullscreen)
              fullscreenInstance = void 0;
          }
        }, Loading._context);
        addStyle(resolved, resolved.parent, instance);
        addClassList(resolved, resolved.parent, instance);
        resolved.parent.vLoadingAddClassList = () => addClassList(resolved, resolved.parent, instance);
        let loadingNumber = resolved.parent.getAttribute("loading-number");
        if (!loadingNumber) {
          loadingNumber = "1";
        } else {
          loadingNumber = `${Number.parseInt(loadingNumber) + 1}`;
        }
        resolved.parent.setAttribute("loading-number", loadingNumber);
        resolved.parent.appendChild(instance.$el);
        nextTick(() => instance.visible.value = resolved.visible);
        if (resolved.fullscreen) {
          fullscreenInstance = instance;
        }
        return instance;
      };
      const resolveOptions = (options) => {
        var _a, _b, _c, _d;
        let target2;
        if (isString$1(options.target)) {
          target2 = (_a = document.querySelector(options.target)) != null ? _a : document.body;
        } else {
          target2 = options.target || document.body;
        }
        return {
          parent: target2 === document.body || options.body ? document.body : target2,
          background: options.background || "",
          svg: options.svg || "",
          svgViewBox: options.svgViewBox || "",
          spinner: options.spinner || false,
          text: options.text || "",
          fullscreen: target2 === document.body && ((_b = options.fullscreen) != null ? _b : true),
          lock: (_c = options.lock) != null ? _c : false,
          customClass: options.customClass || "",
          visible: (_d = options.visible) != null ? _d : true,
          beforeClose: options.beforeClose,
          closed: options.closed,
          target: target2
        };
      };
      const addStyle = async (options, parent2, instance) => {
        const { nextZIndex } = instance.vm.zIndex || instance.vm._.exposed.zIndex;
        const maskStyle = {};
        if (options.fullscreen) {
          instance.originalPosition.value = getStyle(document.body, "position");
          instance.originalOverflow.value = getStyle(document.body, "overflow");
          maskStyle.zIndex = nextZIndex();
        } else if (options.parent === document.body) {
          instance.originalPosition.value = getStyle(document.body, "position");
          await nextTick();
          for (const property2 of ["top", "left"]) {
            const scroll = property2 === "top" ? "scrollTop" : "scrollLeft";
            maskStyle[property2] = `${options.target.getBoundingClientRect()[property2] + document.body[scroll] + document.documentElement[scroll] - Number.parseInt(getStyle(document.body, `margin-${property2}`), 10)}px`;
          }
          for (const property2 of ["height", "width"]) {
            maskStyle[property2] = `${options.target.getBoundingClientRect()[property2]}px`;
          }
        } else {
          instance.originalPosition.value = getStyle(parent2, "position");
        }
        for (const [key, value] of Object.entries(maskStyle)) {
          instance.$el.style[key] = value;
        }
      };
      const addClassList = (options, parent2, instance) => {
        const ns = instance.vm.ns || instance.vm._.exposed.ns;
        if (!["absolute", "fixed", "sticky"].includes(instance.originalPosition.value)) {
          addClass(parent2, ns.bm("parent", "relative"));
        } else {
          removeClass(parent2, ns.bm("parent", "relative"));
        }
        if (options.fullscreen && options.lock) {
          addClass(parent2, ns.bm("parent", "hidden"));
        } else {
          removeClass(parent2, ns.bm("parent", "hidden"));
        }
      };
      Loading._context = null;
      var Loading$1 = exports("ElLoadingService", Loading);
      const INSTANCE_KEY = Symbol("ElLoading");
      const getAttributeName = (name) => {
        return `element-loading-${hyphenate(name)}`;
      };
      const createInstance = (el, binding) => {
        var _a, _b, _c, _d;
        const vm = binding.instance;
        const getBindingProp = (key) => isObject$1(binding.value) ? binding.value[key] : void 0;
        const resolveExpression = (key) => {
          const data = isString$1(key) && (vm == null ? void 0 : vm[key]) || key;
          return ref(data);
        };
        const getProp2 = (name) => resolveExpression(getBindingProp(name) || el.getAttribute(getAttributeName(name)));
        const fullscreen = (_a = getBindingProp("fullscreen")) != null ? _a : binding.modifiers.fullscreen;
        const options = {
          text: getProp2("text"),
          svg: getProp2("svg"),
          svgViewBox: getProp2("svgViewBox"),
          spinner: getProp2("spinner"),
          background: getProp2("background"),
          customClass: getProp2("customClass"),
          fullscreen,
          target: (_b = getBindingProp("target")) != null ? _b : fullscreen ? void 0 : el,
          body: (_c = getBindingProp("body")) != null ? _c : binding.modifiers.body,
          lock: (_d = getBindingProp("lock")) != null ? _d : binding.modifiers.lock
        };
        const instance = Loading$1(options);
        instance._context = vLoading._context;
        el[INSTANCE_KEY] = {
          options,
          instance
        };
      };
      const updateOptions = (originalOptions, newOptions) => {
        for (const key of Object.keys(originalOptions)) {
          if (isRef(originalOptions[key]))
            originalOptions[key].value = newOptions[key];
        }
      };
      const vLoading = {
        mounted(el, binding) {
          if (binding.value) {
            createInstance(el, binding);
          }
        },
        updated(el, binding) {
          const instance = el[INSTANCE_KEY];
          if (!binding.value) {
            instance == null ? void 0 : instance.instance.close();
            el[INSTANCE_KEY] = null;
            return;
          }
          if (!instance)
            createInstance(el, binding);
          else {
            updateOptions(instance.options, isObject$1(binding.value) ? binding.value : {
              text: el.getAttribute(getAttributeName("text")),
              svg: el.getAttribute(getAttributeName("svg")),
              svgViewBox: el.getAttribute(getAttributeName("svgViewBox")),
              spinner: el.getAttribute(getAttributeName("spinner")),
              background: el.getAttribute(getAttributeName("background")),
              customClass: el.getAttribute(getAttributeName("customClass"))
            });
          }
        },
        unmounted(el) {
          var _a;
          (_a = el[INSTANCE_KEY]) == null ? void 0 : _a.instance.close();
          el[INSTANCE_KEY] = null;
        }
      };
      vLoading._context = null;
      var vLoading$1 = vLoading;
      exports({ ElLoadingDirective: vLoading$1, vLoading: vLoading$1 });
      const ElLoading = exports("ElLoading", {
        install(app) {
          Loading$1._context = app._context;
          vLoading$1._context = app._context;
          app.directive("loading", vLoading$1);
          app.config.globalProperties.$loading = Loading$1;
        },
        directive: vLoading$1,
        service: Loading$1
      });
      const messageTypes = exports("messageTypes", [
        "primary",
        "success",
        "info",
        "warning",
        "error"
      ]);
      const messageDefaults = exports("messageDefaults", mutable({
        customClass: "",
        dangerouslyUseHTMLString: false,
        duration: 3e3,
        icon: void 0,
        id: "",
        message: "",
        onClose: void 0,
        showClose: false,
        type: "info",
        plain: false,
        offset: 16,
        zIndex: 0,
        grouping: false,
        repeatNum: 1,
        appendTo: isClient ? document.body : void 0
      }));
      const messageProps = exports("messageProps", buildProps({
        customClass: {
          type: String,
          default: messageDefaults.customClass
        },
        dangerouslyUseHTMLString: {
          type: Boolean,
          default: messageDefaults.dangerouslyUseHTMLString
        },
        duration: {
          type: Number,
          default: messageDefaults.duration
        },
        icon: {
          type: iconPropType,
          default: messageDefaults.icon
        },
        id: {
          type: String,
          default: messageDefaults.id
        },
        message: {
          type: definePropType([
            String,
            Object,
            Function
          ]),
          default: messageDefaults.message
        },
        onClose: {
          type: definePropType(Function),
          default: messageDefaults.onClose
        },
        showClose: {
          type: Boolean,
          default: messageDefaults.showClose
        },
        type: {
          type: String,
          values: messageTypes,
          default: messageDefaults.type
        },
        plain: {
          type: Boolean,
          default: messageDefaults.plain
        },
        offset: {
          type: Number,
          default: messageDefaults.offset
        },
        zIndex: {
          type: Number,
          default: messageDefaults.zIndex
        },
        grouping: {
          type: Boolean,
          default: messageDefaults.grouping
        },
        repeatNum: {
          type: Number,
          default: messageDefaults.repeatNum
        }
      }));
      const messageEmits = exports("messageEmits", {
        destroy: () => true
      });
      const instances = shallowReactive([]);
      const getInstance = (id) => {
        const idx = instances.findIndex((instance) => instance.id === id);
        const current = instances[idx];
        let prev;
        if (idx > 0) {
          prev = instances[idx - 1];
        }
        return { current, prev };
      };
      const getLastOffset = (id) => {
        const { prev } = getInstance(id);
        if (!prev)
          return 0;
        return prev.vm.exposed.bottom.value;
      };
      const getOffsetOrSpace = (id, offset2) => {
        const idx = instances.findIndex((instance) => instance.id === id);
        return idx > 0 ? 16 : offset2;
      };
      const __default__$1 = defineComponent({
        name: "ElMessage"
      });
      const _sfc_main$2 = /* @__PURE__ */ defineComponent({
        ...__default__$1,
        props: messageProps,
        emits: messageEmits,
        setup(__props, { expose, emit }) {
          const props2 = __props;
          const { Close } = TypeComponents;
          const isStartTransition = ref(false);
          const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("message");
          const { currentZIndex, nextZIndex } = zIndex2;
          const messageRef = ref();
          const visible = ref(false);
          const height = ref(0);
          let stopTimer = void 0;
          const badgeType = computed(() => props2.type ? props2.type === "error" ? "danger" : props2.type : "info");
          const typeClass = computed(() => {
            const type = props2.type;
            return { [ns.bm("icon", type)]: type && TypeComponentsMap[type] };
          });
          const iconComponent = computed(() => props2.icon || TypeComponentsMap[props2.type] || "");
          const lastOffset = computed(() => getLastOffset(props2.id));
          const offset2 = computed(() => getOffsetOrSpace(props2.id, props2.offset) + lastOffset.value);
          const bottom = computed(() => height.value + offset2.value);
          const customStyle = computed(() => ({
            top: `${offset2.value}px`,
            zIndex: currentZIndex.value
          }));
          function startTimer() {
            if (props2.duration === 0)
              return;
            ({ stop: stopTimer } = useTimeoutFn(() => {
              close2();
            }, props2.duration));
          }
          function clearTimer() {
            stopTimer == null ? void 0 : stopTimer();
          }
          function close2() {
            visible.value = false;
            nextTick(() => {
              var _a;
              if (!isStartTransition.value) {
                (_a = props2.onClose) == null ? void 0 : _a.call(props2);
                emit("destroy");
              }
            });
          }
          function keydown({ code }) {
            if (code === EVENT_CODE.esc) {
              close2();
            }
          }
          onMounted(() => {
            startTimer();
            nextZIndex();
            visible.value = true;
          });
          watch(() => props2.repeatNum, () => {
            clearTimer();
            startTimer();
          });
          useEventListener(document, "keydown", keydown);
          useResizeObserver(messageRef, () => {
            height.value = messageRef.value.getBoundingClientRect().height;
          });
          expose({
            visible,
            bottom,
            close: close2
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              onBeforeEnter: ($event) => isStartTransition.value = true,
              onBeforeLeave: _ctx.onClose,
              onAfterLeave: ($event) => _ctx.$emit("destroy"),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createElementVNode("div", {
                  id: _ctx.id,
                  ref_key: "messageRef",
                  ref: messageRef,
                  class: normalizeClass([
                    unref(ns).b(),
                    { [unref(ns).m(_ctx.type)]: _ctx.type },
                    unref(ns).is("closable", _ctx.showClose),
                    unref(ns).is("plain", _ctx.plain),
                    _ctx.customClass
                  ]),
                  style: normalizeStyle(unref(customStyle)),
                  role: "alert",
                  onMouseenter: clearTimer,
                  onMouseleave: startTimer
                }, [
                  _ctx.repeatNum > 1 ? (openBlock(), createBlock(unref(ElBadge), {
                    key: 0,
                    value: _ctx.repeatNum,
                    type: unref(badgeType),
                    class: normalizeClass(unref(ns).e("badge"))
                  }, null, 8, ["value", "type", "class"])) : createCommentVNode("v-if", true),
                  unref(iconComponent) ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass([unref(ns).e("icon"), unref(typeClass)])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  renderSlot(_ctx.$slots, "default", {}, () => [
                    !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", {
                      key: 0,
                      class: normalizeClass(unref(ns).e("content"))
                    }, toDisplayString(_ctx.message), 3)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                      createElementVNode("p", {
                        class: normalizeClass(unref(ns).e("content")),
                        innerHTML: _ctx.message
                      }, null, 10, ["innerHTML"])
                    ], 2112))
                  ]),
                  _ctx.showClose ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 2,
                    class: normalizeClass(unref(ns).e("closeBtn")),
                    onClick: withModifiers(close2, ["stop"])
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(Close))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                ], 46, ["id"]), [
                  [vShow, visible.value]
                ])
              ]),
              _: 3
            }, 8, ["name", "onBeforeEnter", "onBeforeLeave", "onAfterLeave"]);
          };
        }
      });
      var MessageConstructor = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__file", "message.vue"]]);
      let seed$1 = 1;
      const normalizeOptions = (params) => {
        const options = !params || isString$1(params) || isVNode(params) || isFunction$1(params) ? { message: params } : params;
        const normalized = {
          ...messageDefaults,
          ...options
        };
        if (!normalized.appendTo) {
          normalized.appendTo = document.body;
        } else if (isString$1(normalized.appendTo)) {
          let appendTo = document.querySelector(normalized.appendTo);
          if (!isElement$2(appendTo)) {
            appendTo = document.body;
          }
          normalized.appendTo = appendTo;
        }
        if (isBoolean(messageConfig.grouping) && !normalized.grouping) {
          normalized.grouping = messageConfig.grouping;
        }
        if (isNumber(messageConfig.duration) && normalized.duration === 3e3) {
          normalized.duration = messageConfig.duration;
        }
        if (isNumber(messageConfig.offset) && normalized.offset === 16) {
          normalized.offset = messageConfig.offset;
        }
        if (isBoolean(messageConfig.showClose) && !normalized.showClose) {
          normalized.showClose = messageConfig.showClose;
        }
        if (isBoolean(messageConfig.plain) && !normalized.plain) {
          normalized.plain = messageConfig.plain;
        }
        return normalized;
      };
      const closeMessage = (instance) => {
        const idx = instances.indexOf(instance);
        if (idx === -1)
          return;
        instances.splice(idx, 1);
        const { handler } = instance;
        handler.close();
      };
      const createMessage = ({ appendTo, ...options }, context) => {
        const id = `message_${seed$1++}`;
        const userOnClose = options.onClose;
        const container = document.createElement("div");
        const props2 = {
          ...options,
          id,
          onClose: () => {
            userOnClose == null ? void 0 : userOnClose();
            closeMessage(instance);
          },
          onDestroy: () => {
            render(null, container);
          }
        };
        const vnode = createVNode(MessageConstructor, props2, isFunction$1(props2.message) || isVNode(props2.message) ? {
          default: isFunction$1(props2.message) ? props2.message : () => props2.message
        } : null);
        vnode.appContext = context || message._context;
        render(vnode, container);
        appendTo.appendChild(container.firstElementChild);
        const vm = vnode.component;
        const handler = {
          close: () => {
            vm.exposed.close();
          }
        };
        const instance = {
          id,
          vnode,
          vm,
          handler,
          props: vnode.component.props
        };
        return instance;
      };
      const message = (options = {}, context) => {
        if (!isClient)
          return { close: () => void 0 };
        const normalized = normalizeOptions(options);
        if (normalized.grouping && instances.length) {
          const instance2 = instances.find(({ vnode: vm }) => {
            var _a;
            return ((_a = vm.props) == null ? void 0 : _a.message) === normalized.message;
          });
          if (instance2) {
            instance2.props.repeatNum += 1;
            instance2.props.type = normalized.type;
            return instance2.handler;
          }
        }
        if (isNumber(messageConfig.max) && instances.length >= messageConfig.max) {
          return { close: () => void 0 };
        }
        const instance = createMessage(normalized, context);
        instances.push(instance);
        return instance.handler;
      };
      messageTypes.forEach((type) => {
        message[type] = (options = {}, appContext) => {
          const normalized = normalizeOptions(options);
          return message({ ...normalized, type }, appContext);
        };
      });
      function closeAll$1(type) {
        const instancesToClose = [...instances];
        for (const instance of instancesToClose) {
          if (!type || type === instance.props.type) {
            instance.handler.close();
          }
        }
      }
      message.closeAll = closeAll$1;
      message._context = null;
      var Message = message;
      const ElMessage = exports("ElMessage", withInstallFunction(Message, "$message"));
      const _sfc_main$1 = defineComponent({
        name: "ElMessageBox",
        directives: {
          TrapFocus
        },
        components: {
          ElButton,
          ElFocusTrap,
          ElInput,
          ElOverlay,
          ElIcon,
          ...TypeComponents
        },
        inheritAttrs: false,
        props: {
          buttonSize: {
            type: String,
            validator: isValidComponentSize
          },
          modal: {
            type: Boolean,
            default: true
          },
          lockScroll: {
            type: Boolean,
            default: true
          },
          showClose: {
            type: Boolean,
            default: true
          },
          closeOnClickModal: {
            type: Boolean,
            default: true
          },
          closeOnPressEscape: {
            type: Boolean,
            default: true
          },
          closeOnHashChange: {
            type: Boolean,
            default: true
          },
          center: Boolean,
          draggable: Boolean,
          overflow: Boolean,
          roundButton: Boolean,
          container: {
            type: String,
            default: "body"
          },
          boxType: {
            type: String,
            default: ""
          }
        },
        emits: ["vanish", "action"],
        setup(props2, { emit }) {
          const {
            locale,
            zIndex: zIndex2,
            ns,
            size: btnSize
          } = useGlobalComponentSettings("message-box", computed(() => props2.buttonSize));
          const { t } = locale;
          const { nextZIndex } = zIndex2;
          const visible = ref(false);
          const state = reactive({
            autofocus: true,
            beforeClose: null,
            callback: null,
            cancelButtonText: "",
            cancelButtonClass: "",
            confirmButtonText: "",
            confirmButtonClass: "",
            customClass: "",
            customStyle: {},
            dangerouslyUseHTMLString: false,
            distinguishCancelAndClose: false,
            icon: "",
            closeIcon: "",
            inputPattern: null,
            inputPlaceholder: "",
            inputType: "text",
            inputValue: "",
            inputValidator: void 0,
            inputErrorMessage: "",
            message: "",
            modalFade: true,
            modalClass: "",
            showCancelButton: false,
            showConfirmButton: true,
            type: "",
            title: void 0,
            showInput: false,
            action: "",
            confirmButtonLoading: false,
            cancelButtonLoading: false,
            confirmButtonLoadingIcon: markRaw(loading_default$1),
            cancelButtonLoadingIcon: markRaw(loading_default$1),
            confirmButtonDisabled: false,
            editorErrorMessage: "",
            validateError: false,
            zIndex: nextZIndex()
          });
          const typeClass = computed(() => {
            const type = state.type;
            return { [ns.bm("icon", type)]: type && TypeComponentsMap[type] };
          });
          const contentId = useId();
          const inputId = useId();
          const iconComponent = computed(() => {
            const type = state.type;
            return state.icon || type && TypeComponentsMap[type] || "";
          });
          const hasMessage = computed(() => !!state.message);
          const rootRef = ref();
          const headerRef = ref();
          const focusStartRef = ref();
          const inputRef = ref();
          const confirmRef = ref();
          const confirmButtonClasses = computed(() => state.confirmButtonClass);
          watch(() => state.inputValue, async (val) => {
            await nextTick();
            if (props2.boxType === "prompt" && val) {
              validate();
            }
          }, { immediate: true });
          watch(() => visible.value, (val) => {
            var _a, _b;
            if (val) {
              if (props2.boxType !== "prompt") {
                if (state.autofocus) {
                  focusStartRef.value = (_b = (_a = confirmRef.value) == null ? void 0 : _a.$el) != null ? _b : rootRef.value;
                } else {
                  focusStartRef.value = rootRef.value;
                }
              }
              state.zIndex = nextZIndex();
            }
            if (props2.boxType !== "prompt")
              return;
            if (val) {
              nextTick().then(() => {
                var _a2;
                if (inputRef.value && inputRef.value.$el) {
                  if (state.autofocus) {
                    focusStartRef.value = (_a2 = getInputElement()) != null ? _a2 : rootRef.value;
                  } else {
                    focusStartRef.value = rootRef.value;
                  }
                }
              });
            } else {
              state.editorErrorMessage = "";
              state.validateError = false;
            }
          });
          const draggable2 = computed(() => props2.draggable);
          const overflow = computed(() => props2.overflow);
          useDraggable(rootRef, headerRef, draggable2, overflow);
          onMounted(async () => {
            await nextTick();
            if (props2.closeOnHashChange) {
              window.addEventListener("hashchange", doClose);
            }
          });
          onBeforeUnmount(() => {
            if (props2.closeOnHashChange) {
              window.removeEventListener("hashchange", doClose);
            }
          });
          function doClose() {
            if (!visible.value)
              return;
            visible.value = false;
            nextTick(() => {
              if (state.action)
                emit("action", state.action);
            });
          }
          const handleWrapperClick = () => {
            if (props2.closeOnClickModal) {
              handleAction(state.distinguishCancelAndClose ? "close" : "cancel");
            }
          };
          const overlayEvent = useSameTarget(handleWrapperClick);
          const handleInputEnter = (e) => {
            if (state.inputType !== "textarea") {
              e.preventDefault();
              return handleAction("confirm");
            }
          };
          const handleAction = (action) => {
            var _a;
            if (props2.boxType === "prompt" && action === "confirm" && !validate()) {
              return;
            }
            state.action = action;
            if (state.beforeClose) {
              (_a = state.beforeClose) == null ? void 0 : _a.call(state, action, state, doClose);
            } else {
              doClose();
            }
          };
          const validate = () => {
            if (props2.boxType === "prompt") {
              const inputPattern = state.inputPattern;
              if (inputPattern && !inputPattern.test(state.inputValue || "")) {
                state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
                state.validateError = true;
                return false;
              }
              const inputValidator = state.inputValidator;
              if (isFunction$1(inputValidator)) {
                const validateResult = inputValidator(state.inputValue);
                if (validateResult === false) {
                  state.editorErrorMessage = state.inputErrorMessage || t("el.messagebox.error");
                  state.validateError = true;
                  return false;
                }
                if (isString$1(validateResult)) {
                  state.editorErrorMessage = validateResult;
                  state.validateError = true;
                  return false;
                }
              }
            }
            state.editorErrorMessage = "";
            state.validateError = false;
            return true;
          };
          const getInputElement = () => {
            var _a, _b;
            const inputRefs = (_a = inputRef.value) == null ? void 0 : _a.$refs;
            return (_b = inputRefs == null ? void 0 : inputRefs.input) != null ? _b : inputRefs == null ? void 0 : inputRefs.textarea;
          };
          const handleClose = () => {
            handleAction("close");
          };
          const onCloseRequested = () => {
            if (props2.closeOnPressEscape) {
              handleClose();
            }
          };
          if (props2.lockScroll) {
            useLockscreen(visible);
          }
          return {
            ...toRefs(state),
            ns,
            overlayEvent,
            visible,
            hasMessage,
            typeClass,
            contentId,
            inputId,
            btnSize,
            iconComponent,
            confirmButtonClasses,
            rootRef,
            focusStartRef,
            headerRef,
            inputRef,
            confirmRef,
            doClose,
            handleClose,
            onCloseRequested,
            handleWrapperClick,
            handleInputEnter,
            handleAction,
            t
          };
        }
      });
      function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_el_icon = resolveComponent("el-icon");
        const _component_el_input = resolveComponent("el-input");
        const _component_el_button = resolveComponent("el-button");
        const _component_el_focus_trap = resolveComponent("el-focus-trap");
        const _component_el_overlay = resolveComponent("el-overlay");
        return openBlock(), createBlock(Transition, {
          name: "fade-in-linear",
          onAfterLeave: ($event) => _ctx.$emit("vanish"),
          persisted: ""
        }, {
          default: withCtx(() => [
            withDirectives(createVNode(_component_el_overlay, {
              "z-index": _ctx.zIndex,
              "overlay-class": [_ctx.ns.is("message-box"), _ctx.modalClass],
              mask: _ctx.modal
            }, {
              default: withCtx(() => [
                createElementVNode("div", {
                  role: "dialog",
                  "aria-label": _ctx.title,
                  "aria-modal": "true",
                  "aria-describedby": !_ctx.showInput ? _ctx.contentId : void 0,
                  class: normalizeClass(`${_ctx.ns.namespace.value}-overlay-message-box`),
                  onClick: _ctx.overlayEvent.onClick,
                  onMousedown: _ctx.overlayEvent.onMousedown,
                  onMouseup: _ctx.overlayEvent.onMouseup
                }, [
                  createVNode(_component_el_focus_trap, {
                    loop: "",
                    trapped: _ctx.visible,
                    "focus-trap-el": _ctx.rootRef,
                    "focus-start-el": _ctx.focusStartRef,
                    onReleaseRequested: _ctx.onCloseRequested
                  }, {
                    default: withCtx(() => [
                      createElementVNode("div", {
                        ref: "rootRef",
                        class: normalizeClass([
                          _ctx.ns.b(),
                          _ctx.customClass,
                          _ctx.ns.is("draggable", _ctx.draggable),
                          { [_ctx.ns.m("center")]: _ctx.center }
                        ]),
                        style: normalizeStyle(_ctx.customStyle),
                        tabindex: "-1",
                        onClick: withModifiers(() => {
                        }, ["stop"])
                      }, [
                        _ctx.title !== null && _ctx.title !== void 0 ? (openBlock(), createElementBlock("div", {
                          key: 0,
                          ref: "headerRef",
                          class: normalizeClass([_ctx.ns.e("header"), { "show-close": _ctx.showClose }])
                        }, [
                          createElementVNode("div", {
                            class: normalizeClass(_ctx.ns.e("title"))
                          }, [
                            _ctx.iconComponent && _ctx.center ? (openBlock(), createBlock(_component_el_icon, {
                              key: 0,
                              class: normalizeClass([_ctx.ns.e("status"), _ctx.typeClass])
                            }, {
                              default: withCtx(() => [
                                (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                              ]),
                              _: 1
                            }, 8, ["class"])) : createCommentVNode("v-if", true),
                            createElementVNode("span", null, toDisplayString(_ctx.title), 1)
                          ], 2),
                          _ctx.showClose ? (openBlock(), createElementBlock("button", {
                            key: 0,
                            type: "button",
                            class: normalizeClass(_ctx.ns.e("headerbtn")),
                            "aria-label": _ctx.t("el.messagebox.close"),
                            onClick: ($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel"),
                            onKeydown: withKeys(withModifiers(($event) => _ctx.handleAction(_ctx.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"])
                          }, [
                            createVNode(_component_el_icon, {
                              class: normalizeClass(_ctx.ns.e("close"))
                            }, {
                              default: withCtx(() => [
                                (openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon || "close")))
                              ]),
                              _: 1
                            }, 8, ["class"])
                          ], 42, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("v-if", true)
                        ], 2)) : createCommentVNode("v-if", true),
                        createElementVNode("div", {
                          id: _ctx.contentId,
                          class: normalizeClass(_ctx.ns.e("content"))
                        }, [
                          createElementVNode("div", {
                            class: normalizeClass(_ctx.ns.e("container"))
                          }, [
                            _ctx.iconComponent && !_ctx.center && _ctx.hasMessage ? (openBlock(), createBlock(_component_el_icon, {
                              key: 0,
                              class: normalizeClass([_ctx.ns.e("status"), _ctx.typeClass])
                            }, {
                              default: withCtx(() => [
                                (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                              ]),
                              _: 1
                            }, 8, ["class"])) : createCommentVNode("v-if", true),
                            _ctx.hasMessage ? (openBlock(), createElementBlock("div", {
                              key: 1,
                              class: normalizeClass(_ctx.ns.e("message"))
                            }, [
                              renderSlot(_ctx.$slots, "default", {}, () => [
                                !_ctx.dangerouslyUseHTMLString ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.showInput ? "label" : "p"), {
                                  key: 0,
                                  for: _ctx.showInput ? _ctx.inputId : void 0,
                                  textContent: toDisplayString(_ctx.message)
                                }, null, 8, ["for", "textContent"])) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.showInput ? "label" : "p"), {
                                  key: 1,
                                  for: _ctx.showInput ? _ctx.inputId : void 0,
                                  innerHTML: _ctx.message
                                }, null, 8, ["for", "innerHTML"]))
                              ])
                            ], 2)) : createCommentVNode("v-if", true)
                          ], 2),
                          withDirectives(createElementVNode("div", {
                            class: normalizeClass(_ctx.ns.e("input"))
                          }, [
                            createVNode(_component_el_input, {
                              id: _ctx.inputId,
                              ref: "inputRef",
                              modelValue: _ctx.inputValue,
                              "onUpdate:modelValue": ($event) => _ctx.inputValue = $event,
                              type: _ctx.inputType,
                              placeholder: _ctx.inputPlaceholder,
                              "aria-invalid": _ctx.validateError,
                              class: normalizeClass({ invalid: _ctx.validateError }),
                              onKeydown: withKeys(_ctx.handleInputEnter, ["enter"])
                            }, null, 8, ["id", "modelValue", "onUpdate:modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]),
                            createElementVNode("div", {
                              class: normalizeClass(_ctx.ns.e("errormsg")),
                              style: normalizeStyle({
                                visibility: !!_ctx.editorErrorMessage ? "visible" : "hidden"
                              })
                            }, toDisplayString(_ctx.editorErrorMessage), 7)
                          ], 2), [
                            [vShow, _ctx.showInput]
                          ])
                        ], 10, ["id"]),
                        createElementVNode("div", {
                          class: normalizeClass(_ctx.ns.e("btns"))
                        }, [
                          _ctx.showCancelButton ? (openBlock(), createBlock(_component_el_button, {
                            key: 0,
                            loading: _ctx.cancelButtonLoading,
                            "loading-icon": _ctx.cancelButtonLoadingIcon,
                            class: normalizeClass([_ctx.cancelButtonClass]),
                            round: _ctx.roundButton,
                            size: _ctx.btnSize,
                            onClick: ($event) => _ctx.handleAction("cancel"),
                            onKeydown: withKeys(withModifiers(($event) => _ctx.handleAction("cancel"), ["prevent"]), ["enter"])
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(_ctx.cancelButtonText || _ctx.t("el.messagebox.cancel")), 1)
                            ]),
                            _: 1
                          }, 8, ["loading", "loading-icon", "class", "round", "size", "onClick", "onKeydown"])) : createCommentVNode("v-if", true),
                          withDirectives(createVNode(_component_el_button, {
                            ref: "confirmRef",
                            type: "primary",
                            loading: _ctx.confirmButtonLoading,
                            "loading-icon": _ctx.confirmButtonLoadingIcon,
                            class: normalizeClass([_ctx.confirmButtonClasses]),
                            round: _ctx.roundButton,
                            disabled: _ctx.confirmButtonDisabled,
                            size: _ctx.btnSize,
                            onClick: ($event) => _ctx.handleAction("confirm"),
                            onKeydown: withKeys(withModifiers(($event) => _ctx.handleAction("confirm"), ["prevent"]), ["enter"])
                          }, {
                            default: withCtx(() => [
                              createTextVNode(toDisplayString(_ctx.confirmButtonText || _ctx.t("el.messagebox.confirm")), 1)
                            ]),
                            _: 1
                          }, 8, ["loading", "loading-icon", "class", "round", "disabled", "size", "onClick", "onKeydown"]), [
                            [vShow, _ctx.showConfirmButton]
                          ])
                        ], 2)
                      ], 14, ["onClick"])
                    ]),
                    _: 3
                  }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
                ], 42, ["aria-label", "aria-describedby", "onClick", "onMousedown", "onMouseup"])
              ]),
              _: 3
            }, 8, ["z-index", "overlay-class", "mask"]), [
              [vShow, _ctx.visible]
            ])
          ]),
          _: 3
        }, 8, ["onAfterLeave"]);
      }
      var MessageBoxConstructor = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render], ["__file", "index.vue"]]);
      const messageInstance = /* @__PURE__ */ new Map();
      const getAppendToElement = (props2) => {
        let appendTo = document.body;
        if (props2.appendTo) {
          if (isString$1(props2.appendTo)) {
            appendTo = document.querySelector(props2.appendTo);
          }
          if (isElement$2(props2.appendTo)) {
            appendTo = props2.appendTo;
          }
          if (!isElement$2(appendTo)) {
            appendTo = document.body;
          }
        }
        return appendTo;
      };
      const initInstance = (props2, container, appContext = null) => {
        const vnode = createVNode(MessageBoxConstructor, props2, isFunction$1(props2.message) || isVNode(props2.message) ? {
          default: isFunction$1(props2.message) ? props2.message : () => props2.message
        } : null);
        vnode.appContext = appContext;
        render(vnode, container);
        getAppendToElement(props2).appendChild(container.firstElementChild);
        return vnode.component;
      };
      const genContainer = () => {
        return document.createElement("div");
      };
      const showMessage = (options, appContext) => {
        const container = genContainer();
        options.onVanish = () => {
          render(null, container);
          messageInstance.delete(vm);
        };
        options.onAction = (action) => {
          const currentMsg = messageInstance.get(vm);
          let resolve;
          if (options.showInput) {
            resolve = { value: vm.inputValue, action };
          } else {
            resolve = action;
          }
          if (options.callback) {
            options.callback(resolve, instance.proxy);
          } else {
            if (action === "cancel" || action === "close") {
              if (options.distinguishCancelAndClose && action !== "cancel") {
                currentMsg.reject("close");
              } else {
                currentMsg.reject("cancel");
              }
            } else {
              currentMsg.resolve(resolve);
            }
          }
        };
        const instance = initInstance(options, container, appContext);
        const vm = instance.proxy;
        for (const prop in options) {
          if (hasOwn(options, prop) && !hasOwn(vm.$props, prop)) {
            if (prop === "closeIcon" && isObject$1(options[prop])) {
              vm[prop] = markRaw(options[prop]);
            } else {
              vm[prop] = options[prop];
            }
          }
        }
        vm.visible = true;
        return vm;
      };
      function MessageBox(options, appContext = null) {
        if (!isClient)
          return Promise.reject();
        let callback;
        if (isString$1(options) || isVNode(options)) {
          options = {
            message: options
          };
        } else {
          callback = options.callback;
        }
        return new Promise((resolve, reject2) => {
          const vm = showMessage(options, appContext != null ? appContext : MessageBox._context);
          messageInstance.set(vm, {
            options,
            callback,
            resolve,
            reject: reject2
          });
        });
      }
      const MESSAGE_BOX_VARIANTS = ["alert", "confirm", "prompt"];
      const MESSAGE_BOX_DEFAULT_OPTS = {
        alert: { closeOnPressEscape: false, closeOnClickModal: false },
        confirm: { showCancelButton: true },
        prompt: { showCancelButton: true, showInput: true }
      };
      MESSAGE_BOX_VARIANTS.forEach((boxType) => {
        MessageBox[boxType] = messageBoxFactory(boxType);
      });
      function messageBoxFactory(boxType) {
        return (message2, title, options, appContext) => {
          let titleOrOpts = "";
          if (isObject$1(title)) {
            options = title;
            titleOrOpts = "";
          } else if (isUndefined(title)) {
            titleOrOpts = "";
          } else {
            titleOrOpts = title;
          }
          return MessageBox(Object.assign({
            title: titleOrOpts,
            message: message2,
            type: "",
            ...MESSAGE_BOX_DEFAULT_OPTS[boxType]
          }, options, {
            boxType
          }), appContext);
        };
      }
      MessageBox.close = () => {
        messageInstance.forEach((_2, vm) => {
          vm.doClose();
        });
        messageInstance.clear();
      };
      MessageBox._context = null;
      const _MessageBox = MessageBox;
      _MessageBox.install = (app) => {
        _MessageBox._context = app._context;
        app.config.globalProperties.$msgbox = _MessageBox;
        app.config.globalProperties.$messageBox = _MessageBox;
        app.config.globalProperties.$alert = _MessageBox.alert;
        app.config.globalProperties.$confirm = _MessageBox.confirm;
        app.config.globalProperties.$prompt = _MessageBox.prompt;
      };
      const ElMessageBox = exports("ElMessageBox", _MessageBox);
      const notificationTypes = exports("notificationTypes", [
        "primary",
        "success",
        "info",
        "warning",
        "error"
      ]);
      const notificationProps = exports("notificationProps", buildProps({
        customClass: {
          type: String,
          default: ""
        },
        dangerouslyUseHTMLString: Boolean,
        duration: {
          type: Number,
          default: 4500
        },
        icon: {
          type: iconPropType
        },
        id: {
          type: String,
          default: ""
        },
        message: {
          type: definePropType([
            String,
            Object,
            Function
          ]),
          default: ""
        },
        offset: {
          type: Number,
          default: 0
        },
        onClick: {
          type: definePropType(Function),
          default: () => void 0
        },
        onClose: {
          type: definePropType(Function),
          required: true
        },
        position: {
          type: String,
          values: ["top-right", "top-left", "bottom-right", "bottom-left"],
          default: "top-right"
        },
        showClose: {
          type: Boolean,
          default: true
        },
        title: {
          type: String,
          default: ""
        },
        type: {
          type: String,
          values: [...notificationTypes, ""],
          default: ""
        },
        zIndex: Number,
        closeIcon: {
          type: iconPropType,
          default: close_default$1
        }
      }));
      const notificationEmits = exports("notificationEmits", {
        destroy: () => true
      });
      const __default__ = defineComponent({
        name: "ElNotification"
      });
      const _sfc_main$2B = /* @__PURE__ */ defineComponent({
        ...__default__,
        props: notificationProps,
        emits: notificationEmits,
        setup(__props, { expose }) {
          const props2 = __props;
          const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("notification");
          const { nextZIndex, currentZIndex } = zIndex2;
          const visible = ref(false);
          let timer = void 0;
          const typeClass = computed(() => {
            const type = props2.type;
            return type && TypeComponentsMap[props2.type] ? ns.m(type) : "";
          });
          const iconComponent = computed(() => {
            if (!props2.type)
              return props2.icon;
            return TypeComponentsMap[props2.type] || props2.icon;
          });
          const horizontalClass = computed(() => props2.position.endsWith("right") ? "right" : "left");
          const verticalProperty = computed(() => props2.position.startsWith("top") ? "top" : "bottom");
          const positionStyle = computed(() => {
            var _a;
            return {
              [verticalProperty.value]: `${props2.offset}px`,
              zIndex: (_a = props2.zIndex) != null ? _a : currentZIndex.value
            };
          });
          function startTimer() {
            if (props2.duration > 0) {
              ({ stop: timer } = useTimeoutFn(() => {
                if (visible.value)
                  close2();
              }, props2.duration));
            }
          }
          function clearTimer() {
            timer == null ? void 0 : timer();
          }
          function close2() {
            visible.value = false;
          }
          function onKeydown({ code }) {
            if (code === EVENT_CODE.delete || code === EVENT_CODE.backspace) {
              clearTimer();
            } else if (code === EVENT_CODE.esc) {
              if (visible.value) {
                close2();
              }
            } else {
              startTimer();
            }
          }
          onMounted(() => {
            startTimer();
            nextZIndex();
            visible.value = true;
          });
          useEventListener(document, "keydown", onKeydown);
          expose({
            visible,
            close: close2
          });
          return (_ctx, _cache) => {
            return openBlock(), createBlock(Transition, {
              name: unref(ns).b("fade"),
              onBeforeLeave: _ctx.onClose,
              onAfterLeave: ($event) => _ctx.$emit("destroy"),
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createElementVNode("div", {
                  id: _ctx.id,
                  class: normalizeClass([unref(ns).b(), _ctx.customClass, unref(horizontalClass)]),
                  style: normalizeStyle(unref(positionStyle)),
                  role: "alert",
                  onMouseenter: clearTimer,
                  onMouseleave: startTimer,
                  onClick: _ctx.onClick
                }, [
                  unref(iconComponent) ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass([unref(ns).e("icon"), unref(typeClass)])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  createElementVNode("div", {
                    class: normalizeClass(unref(ns).e("group"))
                  }, [
                    createElementVNode("h2", {
                      class: normalizeClass(unref(ns).e("title")),
                      textContent: toDisplayString(_ctx.title)
                    }, null, 10, ["textContent"]),
                    withDirectives(createElementVNode("div", {
                      class: normalizeClass(unref(ns).e("content")),
                      style: normalizeStyle(!!_ctx.title ? void 0 : { margin: 0 })
                    }, [
                      renderSlot(_ctx.$slots, "default", {}, () => [
                        !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", { key: 0 }, toDisplayString(_ctx.message), 1)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                          createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                          createElementVNode("p", { innerHTML: _ctx.message }, null, 8, ["innerHTML"])
                        ], 2112))
                      ])
                    ], 6), [
                      [vShow, _ctx.message]
                    ]),
                    _ctx.showClose ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(unref(ns).e("closeBtn")),
                      onClick: withModifiers(close2, ["stop"])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon)))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 46, ["id", "onClick"]), [
                  [vShow, visible.value]
                ])
              ]),
              _: 3
            }, 8, ["name", "onBeforeLeave", "onAfterLeave"]);
          };
        }
      });
      var NotificationConstructor = /* @__PURE__ */ _export_sfc(_sfc_main$2B, [["__file", "notification.vue"]]);
      const notifications = {
        "top-left": [],
        "top-right": [],
        "bottom-left": [],
        "bottom-right": []
      };
      const GAP_SIZE = 16;
      let seed = 1;
      const notify = function(options = {}, context) {
        if (!isClient)
          return { close: () => void 0 };
        if (isString$1(options) || isVNode(options)) {
          options = { message: options };
        }
        const position = options.position || "top-right";
        let verticalOffset = options.offset || 0;
        notifications[position].forEach(({ vm: vm2 }) => {
          var _a;
          verticalOffset += (((_a = vm2.el) == null ? void 0 : _a.offsetHeight) || 0) + GAP_SIZE;
        });
        verticalOffset += GAP_SIZE;
        const id = `notification_${seed++}`;
        const userOnClose = options.onClose;
        const props2 = {
          ...options,
          offset: verticalOffset,
          id,
          onClose: () => {
            close(id, position, userOnClose);
          }
        };
        let appendTo = document.body;
        if (isElement$2(options.appendTo)) {
          appendTo = options.appendTo;
        } else if (isString$1(options.appendTo)) {
          appendTo = document.querySelector(options.appendTo);
        }
        if (!isElement$2(appendTo)) {
          appendTo = document.body;
        }
        const container = document.createElement("div");
        const vm = createVNode(NotificationConstructor, props2, isFunction$1(props2.message) ? props2.message : isVNode(props2.message) ? () => props2.message : null);
        vm.appContext = isUndefined(context) ? notify._context : context;
        vm.props.onDestroy = () => {
          render(null, container);
        };
        render(vm, container);
        notifications[position].push({ vm });
        appendTo.appendChild(container.firstElementChild);
        return {
          close: () => {
            vm.component.exposed.visible.value = false;
          }
        };
      };
      notificationTypes.forEach((type) => {
        notify[type] = (options = {}, appContext) => {
          if (isString$1(options) || isVNode(options)) {
            options = {
              message: options
            };
          }
          return notify({ ...options, type }, appContext);
        };
      });
      function close(id, position, userOnClose) {
        const orientedNotifications = notifications[position];
        const idx = orientedNotifications.findIndex(({ vm: vm2 }) => {
          var _a;
          return ((_a = vm2.component) == null ? void 0 : _a.props.id) === id;
        });
        if (idx === -1)
          return;
        const { vm } = orientedNotifications[idx];
        if (!vm)
          return;
        userOnClose == null ? void 0 : userOnClose(vm);
        const removedHeight = vm.el.offsetHeight;
        const verticalPos = position.split("-")[0];
        orientedNotifications.splice(idx, 1);
        const len = orientedNotifications.length;
        if (len < 1)
          return;
        for (let i = idx; i < len; i++) {
          const { el, component: component2 } = orientedNotifications[i].vm;
          const pos = Number.parseInt(el.style[verticalPos], 10) - removedHeight - GAP_SIZE;
          component2.props.offset = pos;
        }
      }
      function closeAll() {
        for (const orientedNotifications of Object.values(notifications)) {
          orientedNotifications.forEach(({ vm }) => {
            vm.component.exposed.visible.value = false;
          });
        }
      }
      function updateOffsets(position = "top-right") {
        var _a, _b, _c;
        let verticalOffset = ((_b = (_a = notifications[position][0]) == null ? void 0 : _a.vm.props) == null ? void 0 : _b.offset) || 0;
        for (const { vm } of notifications[position]) {
          vm.component.props.offset = verticalOffset;
          verticalOffset += (((_c = vm.el) == null ? void 0 : _c.offsetHeight) || 0) + GAP_SIZE;
        }
      }
      notify.closeAll = closeAll;
      notify.updateOffsets = updateOffsets;
      notify._context = null;
      var Notify = notify;
      const ElNotification = exports("ElNotification", withInstallFunction(Notify, "$notify"));
      var Plugins = [
        ElInfiniteScroll,
        ElLoading,
        ElMessage,
        ElMessageBox,
        ElNotification,
        ElPopoverDirective
      ];
      var installer = makeInstaller([...Components, ...Plugins]);
      const install = exports("install", installer.install);
      const version = exports("version", installer.version);
      /*! Element Plus Icons Vue v2.3.2 */
      const _defineComponent = window["Vue"].defineComponent;
      const _createElementVNode = window["Vue"].createElementVNode;
      const _openBlock = window["Vue"].openBlock;
      const _createElementBlock = window["Vue"].createElementBlock;
      var _sfc_main = /* @__PURE__ */ _defineComponent({
        name: "AddLocation",
        __name: "add-location",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock(), _createElementBlock("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode("path", {
              fill: "currentColor",
              d: "M288 896h448q32 0 32 32t-32 32H288q-32 0-32-32t32-32"
            }),
            _createElementVNode("path", {
              fill: "currentColor",
              d: "M800 416a288 288 0 1 0-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416M512 960C277.312 746.688 160 565.312 160 416a352 352 0 0 1 704 0c0 149.312-117.312 330.688-352 544"
            }),
            _createElementVNode("path", {
              fill: "currentColor",
              d: "M544 384h96a32 32 0 1 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96v-96a32 32 0 0 1 64 0z"
            })
          ]));
        }
      }), add_location_default = _sfc_main;
      const _defineComponent2 = window["Vue"].defineComponent;
      const _createElementVNode2 = window["Vue"].createElementVNode;
      const _openBlock2 = window["Vue"].openBlock;
      const _createElementBlock2 = window["Vue"].createElementBlock;
      var _sfc_main2 = /* @__PURE__ */ _defineComponent2({
        name: "Aim",
        __name: "aim",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock2(), _createElementBlock2("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode2("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            _createElementVNode2("path", {
              fill: "currentColor",
              d: "M512 96a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V128a32 32 0 0 1 32-32m0 576a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V704a32 32 0 0 1 32-32M96 512a32 32 0 0 1 32-32h192a32 32 0 0 1 0 64H128a32 32 0 0 1-32-32m576 0a32 32 0 0 1 32-32h192a32 32 0 1 1 0 64H704a32 32 0 0 1-32-32"
            })
          ]));
        }
      }), aim_default = _sfc_main2;
      const _defineComponent3 = window["Vue"].defineComponent;
      const _createElementVNode3 = window["Vue"].createElementVNode;
      const _openBlock3 = window["Vue"].openBlock;
      const _createElementBlock3 = window["Vue"].createElementBlock;
      var _sfc_main3 = /* @__PURE__ */ _defineComponent3({
        name: "AlarmClock",
        __name: "alarm-clock",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock3(), _createElementBlock3("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode3("path", {
              fill: "currentColor",
              d: "M512 832a320 320 0 1 0 0-640 320 320 0 0 0 0 640m0 64a384 384 0 1 1 0-768 384 384 0 0 1 0 768"
            }),
            _createElementVNode3("path", {
              fill: "currentColor",
              d: "m292.288 824.576 55.424 32-48 83.136a32 32 0 1 1-55.424-32zm439.424 0-55.424 32 48 83.136a32 32 0 1 0 55.424-32zM512 512h160a32 32 0 1 1 0 64H480a32 32 0 0 1-32-32V320a32 32 0 0 1 64 0zM90.496 312.256A160 160 0 0 1 312.32 90.496l-46.848 46.848a96 96 0 0 0-128 128L90.56 312.256zm835.264 0A160 160 0 0 0 704 90.496l46.848 46.848a96 96 0 0 1 128 128z"
            })
          ]));
        }
      }), alarm_clock_default = _sfc_main3;
      const _defineComponent4 = window["Vue"].defineComponent;
      const _createElementVNode4 = window["Vue"].createElementVNode;
      const _openBlock4 = window["Vue"].openBlock;
      const _createElementBlock4 = window["Vue"].createElementBlock;
      var _sfc_main4 = /* @__PURE__ */ _defineComponent4({
        name: "Apple",
        __name: "apple",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock4(), _createElementBlock4("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode4("path", {
              fill: "currentColor",
              d: "M599.872 203.776a189.4 189.4 0 0 1 64.384-4.672l2.624.128c31.168 1.024 51.2 4.096 79.488 16.32 37.632 16.128 74.496 45.056 111.488 89.344 96.384 115.264 82.752 372.8-34.752 521.728-7.68 9.728-32 41.6-30.72 39.936a427 427 0 0 1-30.08 35.776c-31.232 32.576-65.28 49.216-110.08 50.048-31.36.64-53.568-5.312-84.288-18.752l-6.528-2.88c-20.992-9.216-30.592-11.904-47.296-11.904-18.112 0-28.608 2.88-51.136 12.672l-6.464 2.816c-28.416 12.224-48.32 18.048-76.16 19.2-74.112 2.752-116.928-38.08-180.672-132.16-96.64-142.08-132.608-349.312-55.04-486.4 46.272-81.92 129.92-133.632 220.672-135.04 32.832-.576 60.288 6.848 99.648 22.72 27.136 10.88 34.752 13.76 37.376 14.272 16.256-20.16 27.776-36.992 34.56-50.24 13.568-26.304 27.2-59.968 40.704-100.8a32 32 0 1 1 60.8 20.224c-12.608 37.888-25.408 70.4-38.528 97.664m-51.52 78.08c-14.528 17.792-31.808 37.376-51.904 58.816a32 32 0 1 1-46.72-43.776l12.288-13.248c-28.032-11.2-61.248-26.688-95.68-26.112-70.4 1.088-135.296 41.6-171.648 105.792C121.6 492.608 176 684.16 247.296 788.992c34.816 51.328 76.352 108.992 130.944 106.944 52.48-2.112 72.32-34.688 135.872-34.688s81.28 34.688 136.96 33.536c56.448-1.088 75.776-39.04 126.848-103.872 107.904-136.768 107.904-362.752 35.776-449.088-72.192-86.272-124.672-84.096-151.68-85.12-41.472-4.288-81.6 12.544-113.664 25.152"
            })
          ]));
        }
      }), apple_default = _sfc_main4;
      const _defineComponent5 = window["Vue"].defineComponent;
      const _createElementVNode5 = window["Vue"].createElementVNode;
      const _openBlock5 = window["Vue"].openBlock;
      const _createElementBlock5 = window["Vue"].createElementBlock;
      var _sfc_main5 = /* @__PURE__ */ _defineComponent5({
        name: "ArrowDownBold",
        __name: "arrow-down-bold",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock5(), _createElementBlock5("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode5("path", {
              fill: "currentColor",
              d: "M104.704 338.752a64 64 0 0 1 90.496 0l316.8 316.8 316.8-316.8a64 64 0 0 1 90.496 90.496L557.248 791.296a64 64 0 0 1-90.496 0L104.704 429.248a64 64 0 0 1 0-90.496"
            })
          ]));
        }
      }), arrow_down_bold_default = _sfc_main5;
      const _defineComponent6 = window["Vue"].defineComponent;
      const _createElementVNode6 = window["Vue"].createElementVNode;
      const _openBlock6 = window["Vue"].openBlock;
      const _createElementBlock6 = window["Vue"].createElementBlock;
      var _sfc_main6 = /* @__PURE__ */ _defineComponent6({
        name: "ArrowDown",
        __name: "arrow-down",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock6(), _createElementBlock6("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode6("path", {
              fill: "currentColor",
              d: "M831.872 340.864 512 652.672 192.128 340.864a30.59 30.59 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.59 30.59 0 0 0-42.752 0z"
            })
          ]));
        }
      }), arrow_down_default = _sfc_main6;
      const _defineComponent7 = window["Vue"].defineComponent;
      const _createElementVNode7 = window["Vue"].createElementVNode;
      const _openBlock7 = window["Vue"].openBlock;
      const _createElementBlock7 = window["Vue"].createElementBlock;
      var _sfc_main7 = /* @__PURE__ */ _defineComponent7({
        name: "ArrowLeftBold",
        __name: "arrow-left-bold",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock7(), _createElementBlock7("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode7("path", {
              fill: "currentColor",
              d: "M685.248 104.704a64 64 0 0 1 0 90.496L368.448 512l316.8 316.8a64 64 0 0 1-90.496 90.496L232.704 557.248a64 64 0 0 1 0-90.496l362.048-362.048a64 64 0 0 1 90.496 0"
            })
          ]));
        }
      }), arrow_left_bold_default = _sfc_main7;
      const _defineComponent8 = window["Vue"].defineComponent;
      const _createElementVNode8 = window["Vue"].createElementVNode;
      const _openBlock8 = window["Vue"].openBlock;
      const _createElementBlock8 = window["Vue"].createElementBlock;
      var _sfc_main8 = /* @__PURE__ */ _defineComponent8({
        name: "ArrowLeft",
        __name: "arrow-left",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock8(), _createElementBlock8("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode8("path", {
              fill: "currentColor",
              d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.59 30.59 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.59 30.59 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0"
            })
          ]));
        }
      }), arrow_left_default = _sfc_main8;
      const _defineComponent9 = window["Vue"].defineComponent;
      const _createElementVNode9 = window["Vue"].createElementVNode;
      const _openBlock9 = window["Vue"].openBlock;
      const _createElementBlock9 = window["Vue"].createElementBlock;
      var _sfc_main9 = /* @__PURE__ */ _defineComponent9({
        name: "ArrowRightBold",
        __name: "arrow-right-bold",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock9(), _createElementBlock9("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode9("path", {
              fill: "currentColor",
              d: "M338.752 104.704a64 64 0 0 0 0 90.496l316.8 316.8-316.8 316.8a64 64 0 0 0 90.496 90.496l362.048-362.048a64 64 0 0 0 0-90.496L429.248 104.704a64 64 0 0 0-90.496 0"
            })
          ]));
        }
      }), arrow_right_bold_default = _sfc_main9;
      const _defineComponent10 = window["Vue"].defineComponent;
      const _createElementVNode10 = window["Vue"].createElementVNode;
      const _openBlock10 = window["Vue"].openBlock;
      const _createElementBlock10 = window["Vue"].createElementBlock;
      var _sfc_main10 = /* @__PURE__ */ _defineComponent10({
        name: "ArrowRight",
        __name: "arrow-right",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock10(), _createElementBlock10("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode10("path", {
              fill: "currentColor",
              d: "M340.864 149.312a30.59 30.59 0 0 0 0 42.752L652.736 512 340.864 831.872a30.59 30.59 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
            })
          ]));
        }
      }), arrow_right_default = _sfc_main10;
      const _defineComponent11 = window["Vue"].defineComponent;
      const _createElementVNode11 = window["Vue"].createElementVNode;
      const _openBlock11 = window["Vue"].openBlock;
      const _createElementBlock11 = window["Vue"].createElementBlock;
      var _sfc_main11 = /* @__PURE__ */ _defineComponent11({
        name: "ArrowUpBold",
        __name: "arrow-up-bold",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock11(), _createElementBlock11("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode11("path", {
              fill: "currentColor",
              d: "M104.704 685.248a64 64 0 0 0 90.496 0l316.8-316.8 316.8 316.8a64 64 0 0 0 90.496-90.496L557.248 232.704a64 64 0 0 0-90.496 0L104.704 594.752a64 64 0 0 0 0 90.496"
            })
          ]));
        }
      }), arrow_up_bold_default = _sfc_main11;
      const _defineComponent12 = window["Vue"].defineComponent;
      const _createElementVNode12 = window["Vue"].createElementVNode;
      const _openBlock12 = window["Vue"].openBlock;
      const _createElementBlock12 = window["Vue"].createElementBlock;
      var _sfc_main12 = /* @__PURE__ */ _defineComponent12({
        name: "ArrowUp",
        __name: "arrow-up",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock12(), _createElementBlock12("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode12("path", {
              fill: "currentColor",
              d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
            })
          ]));
        }
      }), arrow_up_default = _sfc_main12;
      const _defineComponent13 = window["Vue"].defineComponent;
      const _createElementVNode13 = window["Vue"].createElementVNode;
      const _openBlock13 = window["Vue"].openBlock;
      const _createElementBlock13 = window["Vue"].createElementBlock;
      var _sfc_main13 = /* @__PURE__ */ _defineComponent13({
        name: "Avatar",
        __name: "avatar",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock13(), _createElementBlock13("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode13("path", {
              fill: "currentColor",
              d: "M628.736 528.896A416 416 0 0 1 928 928H96a415.87 415.87 0 0 1 299.264-399.104L512 704zM720 304a208 208 0 1 1-416 0 208 208 0 0 1 416 0"
            })
          ]));
        }
      }), avatar_default = _sfc_main13;
      const _defineComponent14 = window["Vue"].defineComponent;
      const _createElementVNode14 = window["Vue"].createElementVNode;
      const _openBlock14 = window["Vue"].openBlock;
      const _createElementBlock14 = window["Vue"].createElementBlock;
      var _sfc_main14 = /* @__PURE__ */ _defineComponent14({
        name: "Back",
        __name: "back",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock14(), _createElementBlock14("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode14("path", {
              fill: "currentColor",
              d: "M224 480h640a32 32 0 1 1 0 64H224a32 32 0 0 1 0-64"
            }),
            _createElementVNode14("path", {
              fill: "currentColor",
              d: "m237.248 512 265.408 265.344a32 32 0 0 1-45.312 45.312l-288-288a32 32 0 0 1 0-45.312l288-288a32 32 0 1 1 45.312 45.312z"
            })
          ]));
        }
      }), back_default = _sfc_main14;
      const _defineComponent15 = window["Vue"].defineComponent;
      const _createElementVNode15 = window["Vue"].createElementVNode;
      const _openBlock15 = window["Vue"].openBlock;
      const _createElementBlock15 = window["Vue"].createElementBlock;
      var _sfc_main15 = /* @__PURE__ */ _defineComponent15({
        name: "Baseball",
        __name: "baseball",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock15(), _createElementBlock15("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode15("path", {
              fill: "currentColor",
              d: "M195.2 828.8a448 448 0 1 1 633.6-633.6 448 448 0 0 1-633.6 633.6m45.248-45.248a384 384 0 1 0 543.104-543.104 384 384 0 0 0-543.104 543.104"
            }),
            _createElementVNode15("path", {
              fill: "currentColor",
              d: "M497.472 96.896c22.784 4.672 44.416 9.472 64.896 14.528a256.128 256.128 0 0 0 350.208 350.208c5.056 20.48 9.856 42.112 14.528 64.896A320.128 320.128 0 0 1 497.472 96.896M108.48 491.904a320.128 320.128 0 0 1 423.616 423.68c-23.04-3.648-44.992-7.424-65.728-11.52a256.128 256.128 0 0 0-346.496-346.432 1737 1737 0 0 1-11.392-65.728"
            })
          ]));
        }
      }), baseball_default = _sfc_main15;
      const _defineComponent16 = window["Vue"].defineComponent;
      const _createElementVNode16 = window["Vue"].createElementVNode;
      const _openBlock16 = window["Vue"].openBlock;
      const _createElementBlock16 = window["Vue"].createElementBlock;
      var _sfc_main16 = /* @__PURE__ */ _defineComponent16({
        name: "Basketball",
        __name: "basketball",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock16(), _createElementBlock16("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode16("path", {
              fill: "currentColor",
              d: "M778.752 788.224a382.46 382.46 0 0 0 116.032-245.632 256.51 256.51 0 0 0-241.728-13.952 762.9 762.9 0 0 1 125.696 259.584m-55.04 44.224a699.65 699.65 0 0 0-125.056-269.632 256.13 256.13 0 0 0-56.064 331.968 382.7 382.7 0 0 0 181.12-62.336m-254.08 61.248A320.13 320.13 0 0 1 557.76 513.6a716 716 0 0 0-48.192-48.128 320.13 320.13 0 0 1-379.264 88.384 382.4 382.4 0 0 0 110.144 229.696 382.4 382.4 0 0 0 229.184 110.08zM129.28 481.088a256.13 256.13 0 0 0 331.072-56.448 699.65 699.65 0 0 0-268.8-124.352 382.66 382.66 0 0 0-62.272 180.8m106.56-235.84a762.9 762.9 0 0 1 258.688 125.056 256.51 256.51 0 0 0-13.44-241.088A382.46 382.46 0 0 0 235.84 245.248m318.08-114.944c40.576 89.536 37.76 193.92-8.448 281.344a780 780 0 0 1 66.176 66.112 320.83 320.83 0 0 1 282.112-8.128 382.4 382.4 0 0 0-110.144-229.12 382.4 382.4 0 0 0-229.632-110.208zM828.8 828.8a448 448 0 1 1-633.6-633.6 448 448 0 0 1 633.6 633.6"
            })
          ]));
        }
      }), basketball_default = _sfc_main16;
      const _defineComponent17 = window["Vue"].defineComponent;
      const _createElementVNode17 = window["Vue"].createElementVNode;
      const _openBlock17 = window["Vue"].openBlock;
      const _createElementBlock17 = window["Vue"].createElementBlock;
      var _sfc_main17 = /* @__PURE__ */ _defineComponent17({
        name: "BellFilled",
        __name: "bell-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock17(), _createElementBlock17("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode17("path", {
              fill: "currentColor",
              d: "M640 832a128 128 0 0 1-256 0zm192-64H134.4a38.4 38.4 0 0 1 0-76.8H192V448c0-154.88 110.08-284.16 256.32-313.6a64 64 0 1 1 127.36 0A320.13 320.13 0 0 1 832 448v243.2h57.6a38.4 38.4 0 0 1 0 76.8z"
            })
          ]));
        }
      }), bell_filled_default = _sfc_main17;
      const _defineComponent18 = window["Vue"].defineComponent;
      const _createElementVNode18 = window["Vue"].createElementVNode;
      const _openBlock18 = window["Vue"].openBlock;
      const _createElementBlock18 = window["Vue"].createElementBlock;
      var _sfc_main18 = /* @__PURE__ */ _defineComponent18({
        name: "Bell",
        __name: "bell",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock18(), _createElementBlock18("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode18("path", {
              fill: "currentColor",
              d: "M512 64a64 64 0 0 1 64 64v64H448v-64a64 64 0 0 1 64-64"
            }),
            _createElementVNode18("path", {
              fill: "currentColor",
              d: "M256 768h512V448a256 256 0 1 0-512 0zm256-640a320 320 0 0 1 320 320v384H192V448a320 320 0 0 1 320-320"
            }),
            _createElementVNode18("path", {
              fill: "currentColor",
              d: "M96 768h832q32 0 32 32t-32 32H96q-32 0-32-32t32-32m352 128h128a64 64 0 0 1-128 0"
            })
          ]));
        }
      }), bell_default = _sfc_main18;
      const _defineComponent19 = window["Vue"].defineComponent;
      const _createElementVNode19 = window["Vue"].createElementVNode;
      const _openBlock19 = window["Vue"].openBlock;
      const _createElementBlock19 = window["Vue"].createElementBlock;
      var _sfc_main19 = /* @__PURE__ */ _defineComponent19({
        name: "Bicycle",
        __name: "bicycle",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock19(), _createElementBlock19("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode19("path", {
              fill: "currentColor",
              d: "M256 832a128 128 0 1 0 0-256 128 128 0 0 0 0 256m0 64a192 192 0 1 1 0-384 192 192 0 0 1 0 384"
            }),
            _createElementVNode19("path", {
              fill: "currentColor",
              d: "M288 672h320q32 0 32 32t-32 32H288q-32 0-32-32t32-32"
            }),
            _createElementVNode19("path", {
              fill: "currentColor",
              d: "M768 832a128 128 0 1 0 0-256 128 128 0 0 0 0 256m0 64a192 192 0 1 1 0-384 192 192 0 0 1 0 384"
            }),
            _createElementVNode19("path", {
              fill: "currentColor",
              d: "M480 192a32 32 0 0 1 0-64h160a32 32 0 0 1 31.04 24.256l96 384a32 32 0 0 1-62.08 15.488L615.04 192zM96 384a32 32 0 0 1 0-64h128a32 32 0 0 1 30.336 21.888l64 192a32 32 0 1 1-60.672 20.224L200.96 384z"
            }),
            _createElementVNode19("path", {
              fill: "currentColor",
              d: "m373.376 599.808-42.752-47.616 320-288 42.752 47.616z"
            })
          ]));
        }
      }), bicycle_default = _sfc_main19;
      const _defineComponent20 = window["Vue"].defineComponent;
      const _createElementVNode20 = window["Vue"].createElementVNode;
      const _openBlock20 = window["Vue"].openBlock;
      const _createElementBlock20 = window["Vue"].createElementBlock;
      var _sfc_main20 = /* @__PURE__ */ _defineComponent20({
        name: "BottomLeft",
        __name: "bottom-left",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock20(), _createElementBlock20("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode20("path", {
              fill: "currentColor",
              d: "M256 768h416a32 32 0 1 1 0 64H224a32 32 0 0 1-32-32V352a32 32 0 0 1 64 0z"
            }),
            _createElementVNode20("path", {
              fill: "currentColor",
              d: "M246.656 822.656a32 32 0 0 1-45.312-45.312l544-544a32 32 0 0 1 45.312 45.312z"
            })
          ]));
        }
      }), bottom_left_default = _sfc_main20;
      const _defineComponent21 = window["Vue"].defineComponent;
      const _createElementVNode21 = window["Vue"].createElementVNode;
      const _openBlock21 = window["Vue"].openBlock;
      const _createElementBlock21 = window["Vue"].createElementBlock;
      var _sfc_main21 = /* @__PURE__ */ _defineComponent21({
        name: "BottomRight",
        __name: "bottom-right",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock21(), _createElementBlock21("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode21("path", {
              fill: "currentColor",
              d: "M352 768a32 32 0 1 0 0 64h448a32 32 0 0 0 32-32V352a32 32 0 0 0-64 0v416z"
            }),
            _createElementVNode21("path", {
              fill: "currentColor",
              d: "M777.344 822.656a32 32 0 0 0 45.312-45.312l-544-544a32 32 0 0 0-45.312 45.312z"
            })
          ]));
        }
      }), bottom_right_default = _sfc_main21;
      const _defineComponent22 = window["Vue"].defineComponent;
      const _createElementVNode22 = window["Vue"].createElementVNode;
      const _openBlock22 = window["Vue"].openBlock;
      const _createElementBlock22 = window["Vue"].createElementBlock;
      var _sfc_main22 = /* @__PURE__ */ _defineComponent22({
        name: "Bottom",
        __name: "bottom",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock22(), _createElementBlock22("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode22("path", {
              fill: "currentColor",
              d: "M544 805.888V168a32 32 0 1 0-64 0v637.888L246.656 557.952a30.72 30.72 0 0 0-45.312 0 35.52 35.52 0 0 0 0 48.064l288 306.048a30.72 30.72 0 0 0 45.312 0l288-306.048a35.52 35.52 0 0 0 0-48 30.72 30.72 0 0 0-45.312 0L544 805.824z"
            })
          ]));
        }
      }), bottom_default = _sfc_main22;
      const _defineComponent23 = window["Vue"].defineComponent;
      const _createElementVNode23 = window["Vue"].createElementVNode;
      const _openBlock23 = window["Vue"].openBlock;
      const _createElementBlock23 = window["Vue"].createElementBlock;
      var _sfc_main23 = /* @__PURE__ */ _defineComponent23({
        name: "Bowl",
        __name: "bowl",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock23(), _createElementBlock23("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode23("path", {
              fill: "currentColor",
              d: "M714.432 704a351.74 351.74 0 0 0 148.16-256H161.408a351.74 351.74 0 0 0 148.16 256zM288 766.592A415.68 415.68 0 0 1 96 416a32 32 0 0 1 32-32h768a32 32 0 0 1 32 32 415.68 415.68 0 0 1-192 350.592V832a64 64 0 0 1-64 64H352a64 64 0 0 1-64-64zM493.248 320h-90.496l254.4-254.4a32 32 0 1 1 45.248 45.248zm187.328 0h-128l269.696-155.712a32 32 0 0 1 32 55.424zM352 768v64h320v-64z"
            })
          ]));
        }
      }), bowl_default = _sfc_main23;
      const _defineComponent24 = window["Vue"].defineComponent;
      const _createElementVNode24 = window["Vue"].createElementVNode;
      const _openBlock24 = window["Vue"].openBlock;
      const _createElementBlock24 = window["Vue"].createElementBlock;
      var _sfc_main24 = /* @__PURE__ */ _defineComponent24({
        name: "Box",
        __name: "box",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock24(), _createElementBlock24("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode24("path", {
              fill: "currentColor",
              d: "M317.056 128 128 344.064V896h768V344.064L706.944 128zm-14.528-64h418.944a32 32 0 0 1 24.064 10.88l206.528 236.096A32 32 0 0 1 960 332.032V928a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V332.032a32 32 0 0 1 7.936-21.12L278.4 75.008A32 32 0 0 1 302.528 64"
            }),
            _createElementVNode24("path", {
              fill: "currentColor",
              d: "M64 320h896v64H64z"
            }),
            _createElementVNode24("path", {
              fill: "currentColor",
              d: "M448 327.872V640h128V327.872L526.08 128h-28.16zM448 64h128l64 256v352a32 32 0 0 1-32 32H416a32 32 0 0 1-32-32V320z"
            })
          ]));
        }
      }), box_default = _sfc_main24;
      const _defineComponent25 = window["Vue"].defineComponent;
      const _createElementVNode25 = window["Vue"].createElementVNode;
      const _openBlock25 = window["Vue"].openBlock;
      const _createElementBlock25 = window["Vue"].createElementBlock;
      var _sfc_main25 = /* @__PURE__ */ _defineComponent25({
        name: "Briefcase",
        __name: "briefcase",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock25(), _createElementBlock25("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode25("path", {
              fill: "currentColor",
              d: "M320 320V128h384v192h192v192H128V320zM128 576h768v320H128zm256-256h256.064V192H384z"
            })
          ]));
        }
      }), briefcase_default = _sfc_main25;
      const _defineComponent26 = window["Vue"].defineComponent;
      const _createElementVNode26 = window["Vue"].createElementVNode;
      const _openBlock26 = window["Vue"].openBlock;
      const _createElementBlock26 = window["Vue"].createElementBlock;
      var _sfc_main26 = /* @__PURE__ */ _defineComponent26({
        name: "BrushFilled",
        __name: "brush-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock26(), _createElementBlock26("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode26("path", {
              fill: "currentColor",
              d: "M608 704v160a96 96 0 0 1-192 0V704h-96a128 128 0 0 1-128-128h640a128 128 0 0 1-128 128zM192 512V128.064h640V512z"
            })
          ]));
        }
      }), brush_filled_default = _sfc_main26;
      const _defineComponent27 = window["Vue"].defineComponent;
      const _createElementVNode27 = window["Vue"].createElementVNode;
      const _openBlock27 = window["Vue"].openBlock;
      const _createElementBlock27 = window["Vue"].createElementBlock;
      var _sfc_main27 = /* @__PURE__ */ _defineComponent27({
        name: "Brush",
        __name: "brush",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock27(), _createElementBlock27("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode27("path", {
              fill: "currentColor",
              d: "M896 448H128v192a64 64 0 0 0 64 64h192v192h256V704h192a64 64 0 0 0 64-64zm-770.752-64c0-47.552 5.248-90.24 15.552-128 14.72-54.016 42.496-107.392 83.2-160h417.28l-15.36 70.336L736 96h211.2c-24.832 42.88-41.92 96.256-51.2 160a664 664 0 0 0-6.144 128H960v256a128 128 0 0 1-128 128H704v160a32 32 0 0 1-32 32H352a32 32 0 0 1-32-32V768H192A128 128 0 0 1 64 640V384zm64 0h636.544c-2.048-45.824.256-91.584 6.848-137.216 4.48-30.848 10.688-59.776 18.688-86.784h-96.64l-221.12 141.248L561.92 160H256.512c-25.856 37.888-43.776 75.456-53.952 112.832-8.768 32.064-13.248 69.12-13.312 111.168"
            })
          ]));
        }
      }), brush_default = _sfc_main27;
      const _defineComponent28 = window["Vue"].defineComponent;
      const _createElementVNode28 = window["Vue"].createElementVNode;
      const _openBlock28 = window["Vue"].openBlock;
      const _createElementBlock28 = window["Vue"].createElementBlock;
      var _sfc_main28 = /* @__PURE__ */ _defineComponent28({
        name: "Burger",
        __name: "burger",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock28(), _createElementBlock28("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode28("path", {
              fill: "currentColor",
              d: "M160 512a32 32 0 0 0-32 32v64a32 32 0 0 0 30.08 32H864a32 32 0 0 0 32-32v-64a32 32 0 0 0-32-32zm736-58.56A96 96 0 0 1 960 544v64a96 96 0 0 1-51.968 85.312L855.36 833.6a96 96 0 0 1-89.856 62.272H258.496A96 96 0 0 1 168.64 833.6l-52.608-140.224A96 96 0 0 1 64 608v-64a96 96 0 0 1 64-90.56V448a384 384 0 1 1 768 5.44M832 448a320 320 0 0 0-640 0zM512 704H188.352l40.192 107.136a32 32 0 0 0 29.952 20.736h507.008a32 32 0 0 0 29.952-20.736L835.648 704z"
            })
          ]));
        }
      }), burger_default = _sfc_main28;
      const _defineComponent29 = window["Vue"].defineComponent;
      const _createElementVNode29 = window["Vue"].createElementVNode;
      const _openBlock29 = window["Vue"].openBlock;
      const _createElementBlock29 = window["Vue"].createElementBlock;
      var _sfc_main29 = /* @__PURE__ */ _defineComponent29({
        name: "Calendar",
        __name: "calendar",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock29(), _createElementBlock29("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode29("path", {
              fill: "currentColor",
              d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64"
            })
          ]));
        }
      }), calendar_default = _sfc_main29;
      const _defineComponent30 = window["Vue"].defineComponent;
      const _createElementVNode30 = window["Vue"].createElementVNode;
      const _openBlock30 = window["Vue"].openBlock;
      const _createElementBlock30 = window["Vue"].createElementBlock;
      var _sfc_main30 = /* @__PURE__ */ _defineComponent30({
        name: "CameraFilled",
        __name: "camera-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock30(), _createElementBlock30("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode30("path", {
              fill: "currentColor",
              d: "M160 224a64 64 0 0 0-64 64v512a64 64 0 0 0 64 64h704a64 64 0 0 0 64-64V288a64 64 0 0 0-64-64H748.416l-46.464-92.672A64 64 0 0 0 644.736 96H379.328a64 64 0 0 0-57.216 35.392L275.776 224zm352 435.2a115.2 115.2 0 1 0 0-230.4 115.2 115.2 0 0 0 0 230.4m0 140.8a256 256 0 1 1 0-512 256 256 0 0 1 0 512"
            })
          ]));
        }
      }), camera_filled_default = _sfc_main30;
      const _defineComponent31 = window["Vue"].defineComponent;
      const _createElementVNode31 = window["Vue"].createElementVNode;
      const _openBlock31 = window["Vue"].openBlock;
      const _createElementBlock31 = window["Vue"].createElementBlock;
      var _sfc_main31 = /* @__PURE__ */ _defineComponent31({
        name: "Camera",
        __name: "camera",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock31(), _createElementBlock31("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode31("path", {
              fill: "currentColor",
              d: "M896 256H128v576h768zm-199.424-64-32.064-64h-304.96l-32 64zM96 192h160l46.336-92.608A64 64 0 0 1 359.552 64h304.96a64 64 0 0 1 57.216 35.328L768.192 192H928a32 32 0 0 1 32 32v640a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V224a32 32 0 0 1 32-32m416 512a160 160 0 1 0 0-320 160 160 0 0 0 0 320m0 64a224 224 0 1 1 0-448 224 224 0 0 1 0 448"
            })
          ]));
        }
      }), camera_default = _sfc_main31;
      const _defineComponent32 = window["Vue"].defineComponent;
      const _createElementVNode32 = window["Vue"].createElementVNode;
      const _openBlock32 = window["Vue"].openBlock;
      const _createElementBlock32 = window["Vue"].createElementBlock;
      var _sfc_main32 = /* @__PURE__ */ _defineComponent32({
        name: "CaretBottom",
        __name: "caret-bottom",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock32(), _createElementBlock32("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode32("path", {
              fill: "currentColor",
              d: "m192 384 320 384 320-384z"
            })
          ]));
        }
      }), caret_bottom_default = _sfc_main32;
      const _defineComponent33 = window["Vue"].defineComponent;
      const _createElementVNode33 = window["Vue"].createElementVNode;
      const _openBlock33 = window["Vue"].openBlock;
      const _createElementBlock33 = window["Vue"].createElementBlock;
      var _sfc_main33 = /* @__PURE__ */ _defineComponent33({
        name: "CaretLeft",
        __name: "caret-left",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock33(), _createElementBlock33("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode33("path", {
              fill: "currentColor",
              d: "M672 192 288 511.936 672 832z"
            })
          ]));
        }
      }), caret_left_default = _sfc_main33;
      const _defineComponent34 = window["Vue"].defineComponent;
      const _createElementVNode34 = window["Vue"].createElementVNode;
      const _openBlock34 = window["Vue"].openBlock;
      const _createElementBlock34 = window["Vue"].createElementBlock;
      var _sfc_main34 = /* @__PURE__ */ _defineComponent34({
        name: "CaretRight",
        __name: "caret-right",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock34(), _createElementBlock34("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode34("path", {
              fill: "currentColor",
              d: "M384 192v640l384-320.064z"
            })
          ]));
        }
      }), caret_right_default = _sfc_main34;
      const _defineComponent35 = window["Vue"].defineComponent;
      const _createElementVNode35 = window["Vue"].createElementVNode;
      const _openBlock35 = window["Vue"].openBlock;
      const _createElementBlock35 = window["Vue"].createElementBlock;
      var _sfc_main35 = /* @__PURE__ */ _defineComponent35({
        name: "CaretTop",
        __name: "caret-top",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock35(), _createElementBlock35("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode35("path", {
              fill: "currentColor",
              d: "M512 320 192 704h639.936z"
            })
          ]));
        }
      }), caret_top_default = _sfc_main35;
      const _defineComponent36 = window["Vue"].defineComponent;
      const _createElementVNode36 = window["Vue"].createElementVNode;
      const _openBlock36 = window["Vue"].openBlock;
      const _createElementBlock36 = window["Vue"].createElementBlock;
      var _sfc_main36 = /* @__PURE__ */ _defineComponent36({
        name: "Cellphone",
        __name: "cellphone",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock36(), _createElementBlock36("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode36("path", {
              fill: "currentColor",
              d: "M256 128a64 64 0 0 0-64 64v640a64 64 0 0 0 64 64h512a64 64 0 0 0 64-64V192a64 64 0 0 0-64-64zm0-64h512a128 128 0 0 1 128 128v640a128 128 0 0 1-128 128H256a128 128 0 0 1-128-128V192A128 128 0 0 1 256 64m128 128h256a32 32 0 1 1 0 64H384a32 32 0 0 1 0-64m128 640a64 64 0 1 1 0-128 64 64 0 0 1 0 128"
            })
          ]));
        }
      }), cellphone_default = _sfc_main36;
      const _defineComponent37 = window["Vue"].defineComponent;
      const _createElementVNode37 = window["Vue"].createElementVNode;
      const _openBlock37 = window["Vue"].openBlock;
      const _createElementBlock37 = window["Vue"].createElementBlock;
      var _sfc_main37 = /* @__PURE__ */ _defineComponent37({
        name: "ChatDotRound",
        __name: "chat-dot-round",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock37(), _createElementBlock37("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode37("path", {
              fill: "currentColor",
              d: "m174.72 855.68 135.296-45.12 23.68 11.84C388.096 849.536 448.576 864 512 864c211.84 0 384-166.784 384-352S723.84 160 512 160 128 326.784 128 512c0 69.12 24.96 139.264 70.848 199.232l22.08 28.8-46.272 115.584zm-45.248 82.56A32 32 0 0 1 89.6 896l58.368-145.92C94.72 680.32 64 596.864 64 512 64 299.904 256 96 512 96s448 203.904 448 416-192 416-448 416a461.06 461.06 0 0 1-206.912-48.384l-175.616 58.56z"
            }),
            _createElementVNode37("path", {
              fill: "currentColor",
              d: "M512 563.2a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4m192 0a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4m-384 0a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4"
            })
          ]));
        }
      }), chat_dot_round_default = _sfc_main37;
      const _defineComponent38 = window["Vue"].defineComponent;
      const _createElementVNode38 = window["Vue"].createElementVNode;
      const _openBlock38 = window["Vue"].openBlock;
      const _createElementBlock38 = window["Vue"].createElementBlock;
      var _sfc_main38 = /* @__PURE__ */ _defineComponent38({
        name: "ChatDotSquare",
        __name: "chat-dot-square",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock38(), _createElementBlock38("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode38("path", {
              fill: "currentColor",
              d: "M273.536 736H800a64 64 0 0 0 64-64V256a64 64 0 0 0-64-64H224a64 64 0 0 0-64 64v570.88zM296 800 147.968 918.4A32 32 0 0 1 96 893.44V256a128 128 0 0 1 128-128h576a128 128 0 0 1 128 128v416a128 128 0 0 1-128 128z"
            }),
            _createElementVNode38("path", {
              fill: "currentColor",
              d: "M512 499.2a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4m192 0a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4m-384 0a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4"
            })
          ]));
        }
      }), chat_dot_square_default = _sfc_main38;
      const _defineComponent39 = window["Vue"].defineComponent;
      const _createElementVNode39 = window["Vue"].createElementVNode;
      const _openBlock39 = window["Vue"].openBlock;
      const _createElementBlock39 = window["Vue"].createElementBlock;
      var _sfc_main39 = /* @__PURE__ */ _defineComponent39({
        name: "ChatLineRound",
        __name: "chat-line-round",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock39(), _createElementBlock39("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode39("path", {
              fill: "currentColor",
              d: "m174.72 855.68 135.296-45.12 23.68 11.84C388.096 849.536 448.576 864 512 864c211.84 0 384-166.784 384-352S723.84 160 512 160 128 326.784 128 512c0 69.12 24.96 139.264 70.848 199.232l22.08 28.8-46.272 115.584zm-45.248 82.56A32 32 0 0 1 89.6 896l58.368-145.92C94.72 680.32 64 596.864 64 512 64 299.904 256 96 512 96s448 203.904 448 416-192 416-448 416a461.06 461.06 0 0 1-206.912-48.384l-175.616 58.56z"
            }),
            _createElementVNode39("path", {
              fill: "currentColor",
              d: "M352 576h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32m32-192h256q32 0 32 32t-32 32H384q-32 0-32-32t32-32"
            })
          ]));
        }
      }), chat_line_round_default = _sfc_main39;
      const _defineComponent40 = window["Vue"].defineComponent;
      const _createElementVNode40 = window["Vue"].createElementVNode;
      const _openBlock40 = window["Vue"].openBlock;
      const _createElementBlock40 = window["Vue"].createElementBlock;
      var _sfc_main40 = /* @__PURE__ */ _defineComponent40({
        name: "ChatLineSquare",
        __name: "chat-line-square",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock40(), _createElementBlock40("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode40("path", {
              fill: "currentColor",
              d: "M160 826.88 273.536 736H800a64 64 0 0 0 64-64V256a64 64 0 0 0-64-64H224a64 64 0 0 0-64 64zM296 800 147.968 918.4A32 32 0 0 1 96 893.44V256a128 128 0 0 1 128-128h576a128 128 0 0 1 128 128v416a128 128 0 0 1-128 128z"
            }),
            _createElementVNode40("path", {
              fill: "currentColor",
              d: "M352 512h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32m0-192h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32"
            })
          ]));
        }
      }), chat_line_square_default = _sfc_main40;
      const _defineComponent41 = window["Vue"].defineComponent;
      const _createElementVNode41 = window["Vue"].createElementVNode;
      const _openBlock41 = window["Vue"].openBlock;
      const _createElementBlock41 = window["Vue"].createElementBlock;
      var _sfc_main41 = /* @__PURE__ */ _defineComponent41({
        name: "ChatRound",
        __name: "chat-round",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock41(), _createElementBlock41("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode41("path", {
              fill: "currentColor",
              d: "m174.72 855.68 130.048-43.392 23.424 11.392C382.4 849.984 444.352 864 512 864c223.744 0 384-159.872 384-352 0-192.832-159.104-352-384-352S128 319.168 128 512a341.12 341.12 0 0 0 69.248 204.288l21.632 28.8-44.16 110.528zm-45.248 82.56A32 32 0 0 1 89.6 896l56.512-141.248A405.12 405.12 0 0 1 64 512C64 299.904 235.648 96 512 96s448 203.904 448 416-173.44 416-448 416c-79.68 0-150.848-17.152-211.712-46.72l-170.88 56.96z"
            })
          ]));
        }
      }), chat_round_default = _sfc_main41;
      const _defineComponent42 = window["Vue"].defineComponent;
      const _createElementVNode42 = window["Vue"].createElementVNode;
      const _openBlock42 = window["Vue"].openBlock;
      const _createElementBlock42 = window["Vue"].createElementBlock;
      var _sfc_main42 = /* @__PURE__ */ _defineComponent42({
        name: "ChatSquare",
        __name: "chat-square",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock42(), _createElementBlock42("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode42("path", {
              fill: "currentColor",
              d: "M273.536 736H800a64 64 0 0 0 64-64V256a64 64 0 0 0-64-64H224a64 64 0 0 0-64 64v570.88zM296 800 147.968 918.4A32 32 0 0 1 96 893.44V256a128 128 0 0 1 128-128h576a128 128 0 0 1 128 128v416a128 128 0 0 1-128 128z"
            })
          ]));
        }
      }), chat_square_default = _sfc_main42;
      const _defineComponent43 = window["Vue"].defineComponent;
      const _createElementVNode43 = window["Vue"].createElementVNode;
      const _openBlock43 = window["Vue"].openBlock;
      const _createElementBlock43 = window["Vue"].createElementBlock;
      var _sfc_main43 = /* @__PURE__ */ _defineComponent43({
        name: "Check",
        __name: "check",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock43(), _createElementBlock43("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode43("path", {
              fill: "currentColor",
              d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
            })
          ]));
        }
      }), check_default = _sfc_main43;
      const _defineComponent44 = window["Vue"].defineComponent;
      const _createElementVNode44 = window["Vue"].createElementVNode;
      const _openBlock44 = window["Vue"].openBlock;
      const _createElementBlock44 = window["Vue"].createElementBlock;
      var _sfc_main44 = /* @__PURE__ */ _defineComponent44({
        name: "Checked",
        __name: "checked",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock44(), _createElementBlock44("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode44("path", {
              fill: "currentColor",
              d: "M704 192h160v736H160V192h160.064v64H704zM311.616 537.28l-45.312 45.248L447.36 763.52l316.8-316.8-45.312-45.184L447.36 673.024zM384 192V96h256v96z"
            })
          ]));
        }
      }), checked_default = _sfc_main44;
      const _defineComponent45 = window["Vue"].defineComponent;
      const _createElementVNode45 = window["Vue"].createElementVNode;
      const _openBlock45 = window["Vue"].openBlock;
      const _createElementBlock45 = window["Vue"].createElementBlock;
      var _sfc_main45 = /* @__PURE__ */ _defineComponent45({
        name: "Cherry",
        __name: "cherry",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock45(), _createElementBlock45("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode45("path", {
              fill: "currentColor",
              d: "M261.056 449.6c13.824-69.696 34.88-128.96 63.36-177.728 23.744-40.832 61.12-88.64 112.256-143.872H320a32 32 0 0 1 0-64h384a32 32 0 1 1 0 64H554.752c14.912 39.168 41.344 86.592 79.552 141.76 47.36 68.48 84.8 106.752 106.304 114.304a224 224 0 1 1-84.992 14.784c-22.656-22.912-47.04-53.76-73.92-92.608-38.848-56.128-67.008-105.792-84.352-149.312-55.296 58.24-94.528 107.52-117.76 147.2-23.168 39.744-41.088 88.768-53.568 147.072a224.064 224.064 0 1 1-64.96-1.6M288 832a160 160 0 1 0 0-320 160 160 0 0 0 0 320m448-64a160 160 0 1 0 0-320 160 160 0 0 0 0 320"
            })
          ]));
        }
      }), cherry_default = _sfc_main45;
      const _defineComponent46 = window["Vue"].defineComponent;
      const _createElementVNode46 = window["Vue"].createElementVNode;
      const _openBlock46 = window["Vue"].openBlock;
      const _createElementBlock46 = window["Vue"].createElementBlock;
      var _sfc_main46 = /* @__PURE__ */ _defineComponent46({
        name: "Chicken",
        __name: "chicken",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock46(), _createElementBlock46("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode46("path", {
              fill: "currentColor",
              d: "M349.952 716.992 478.72 588.16a106.7 106.7 0 0 1-26.176-19.072 106.7 106.7 0 0 1-19.072-26.176L304.704 671.744c.768 3.072 1.472 6.144 2.048 9.216l2.048 31.936 31.872 1.984c3.136.64 6.208 1.28 9.28 2.112m57.344 33.152a128 128 0 1 1-216.32 114.432l-1.92-32-32-1.92a128 128 0 1 1 114.432-216.32L416.64 469.248c-2.432-101.44 58.112-239.104 149.056-330.048 107.328-107.328 231.296-85.504 316.8 0 85.44 85.44 107.328 209.408 0 316.8-91.008 90.88-228.672 151.424-330.112 149.056L407.296 750.08zm90.496-226.304c49.536 49.536 233.344-7.04 339.392-113.088 78.208-78.208 63.232-163.072 0-226.304-63.168-63.232-148.032-78.208-226.24 0C504.896 290.496 448.32 474.368 497.792 523.84M244.864 708.928a64 64 0 1 0-59.84 59.84l56.32-3.52zm8.064 127.68a64 64 0 1 0 59.84-59.84l-56.32 3.52z"
            })
          ]));
        }
      }), chicken_default = _sfc_main46;
      const _defineComponent47 = window["Vue"].defineComponent;
      const _createElementVNode47 = window["Vue"].createElementVNode;
      const _openBlock47 = window["Vue"].openBlock;
      const _createElementBlock47 = window["Vue"].createElementBlock;
      var _sfc_main47 = /* @__PURE__ */ _defineComponent47({
        name: "ChromeFilled",
        __name: "chrome-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock47(), _createElementBlock47("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            "xml:space": "preserve",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode47("path", {
              fill: "currentColor",
              d: "M938.67 512.01c0-44.59-6.82-87.6-19.54-128H682.67a212.37 212.37 0 0 1 42.67 128c.06 38.71-10.45 76.7-30.42 109.87l-182.91 316.8c235.65-.01 426.66-191.02 426.66-426.67"
            }),
            _createElementVNode47("path", {
              fill: "currentColor",
              d: "M576.79 401.63a127.9 127.9 0 0 0-63.56-17.6c-22.36-.22-44.39 5.43-63.89 16.38s-35.79 26.82-47.25 46.02a128 128 0 0 0-2.16 127.44l1.24 2.13a127.9 127.9 0 0 0 46.36 46.61 127.9 127.9 0 0 0 63.38 17.44c22.29.2 44.24-5.43 63.68-16.33a127.94 127.94 0 0 0 47.16-45.79v-.01l1.11-1.92a127.98 127.98 0 0 0 .29-127.46 127.96 127.96 0 0 0-46.36-46.91"
            }),
            _createElementVNode47("path", {
              fill: "currentColor",
              d: "M394.45 333.96A213.34 213.34 0 0 1 512 298.67h369.58A426.5 426.5 0 0 0 512 85.34a425.6 425.6 0 0 0-171.74 35.98 425.6 425.6 0 0 0-142.62 102.22l118.14 204.63a213.4 213.4 0 0 1 78.67-94.21m117.56 604.72H512zm-97.25-236.73a213.3 213.3 0 0 1-89.54-86.81L142.48 298.6c-36.35 62.81-57.13 135.68-57.13 213.42 0 203.81 142.93 374.22 333.95 416.55h.04l118.19-204.71a213.3 213.3 0 0 1-122.77-21.91"
            })
          ]));
        }
      }), chrome_filled_default = _sfc_main47;
      const _defineComponent48 = window["Vue"].defineComponent;
      const _createElementVNode48 = window["Vue"].createElementVNode;
      const _openBlock48 = window["Vue"].openBlock;
      const _createElementBlock48 = window["Vue"].createElementBlock;
      var _sfc_main48 = /* @__PURE__ */ _defineComponent48({
        name: "CircleCheckFilled",
        __name: "circle-check-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock48(), _createElementBlock48("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode48("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.27 38.27 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
            })
          ]));
        }
      }), circle_check_filled_default = _sfc_main48;
      const _defineComponent49 = window["Vue"].defineComponent;
      const _createElementVNode49 = window["Vue"].createElementVNode;
      const _openBlock49 = window["Vue"].openBlock;
      const _createElementBlock49 = window["Vue"].createElementBlock;
      var _sfc_main49 = /* @__PURE__ */ _defineComponent49({
        name: "CircleCheck",
        __name: "circle-check",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock49(), _createElementBlock49("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode49("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            _createElementVNode49("path", {
              fill: "currentColor",
              d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752z"
            })
          ]));
        }
      }), circle_check_default = _sfc_main49;
      const _defineComponent50 = window["Vue"].defineComponent;
      const _createElementVNode50 = window["Vue"].createElementVNode;
      const _openBlock50 = window["Vue"].openBlock;
      const _createElementBlock50 = window["Vue"].createElementBlock;
      var _sfc_main50 = /* @__PURE__ */ _defineComponent50({
        name: "CircleCloseFilled",
        __name: "circle-close-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock50(), _createElementBlock50("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode50("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
            })
          ]));
        }
      }), circle_close_filled_default = _sfc_main50;
      const _defineComponent51 = window["Vue"].defineComponent;
      const _createElementVNode51 = window["Vue"].createElementVNode;
      const _openBlock51 = window["Vue"].openBlock;
      const _createElementBlock51 = window["Vue"].createElementBlock;
      var _sfc_main51 = /* @__PURE__ */ _defineComponent51({
        name: "CircleClose",
        __name: "circle-close",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock51(), _createElementBlock51("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode51("path", {
              fill: "currentColor",
              d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
            }),
            _createElementVNode51("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            })
          ]));
        }
      }), circle_close_default = _sfc_main51;
      const _defineComponent52 = window["Vue"].defineComponent;
      const _createElementVNode52 = window["Vue"].createElementVNode;
      const _openBlock52 = window["Vue"].openBlock;
      const _createElementBlock52 = window["Vue"].createElementBlock;
      var _sfc_main52 = /* @__PURE__ */ _defineComponent52({
        name: "CirclePlusFilled",
        __name: "circle-plus-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock52(), _createElementBlock52("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode52("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-38.4 409.6H326.4a38.4 38.4 0 1 0 0 76.8h147.2v147.2a38.4 38.4 0 0 0 76.8 0V550.4h147.2a38.4 38.4 0 0 0 0-76.8H550.4V326.4a38.4 38.4 0 1 0-76.8 0z"
            })
          ]));
        }
      }), circle_plus_filled_default = _sfc_main52;
      const _defineComponent53 = window["Vue"].defineComponent;
      const _createElementVNode53 = window["Vue"].createElementVNode;
      const _openBlock53 = window["Vue"].openBlock;
      const _createElementBlock53 = window["Vue"].createElementBlock;
      var _sfc_main53 = /* @__PURE__ */ _defineComponent53({
        name: "CirclePlus",
        __name: "circle-plus",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock53(), _createElementBlock53("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode53("path", {
              fill: "currentColor",
              d: "M352 480h320a32 32 0 1 1 0 64H352a32 32 0 0 1 0-64"
            }),
            _createElementVNode53("path", {
              fill: "currentColor",
              d: "M480 672V352a32 32 0 1 1 64 0v320a32 32 0 0 1-64 0"
            }),
            _createElementVNode53("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            })
          ]));
        }
      }), circle_plus_default = _sfc_main53;
      const _defineComponent54 = window["Vue"].defineComponent;
      const _createElementVNode54 = window["Vue"].createElementVNode;
      const _openBlock54 = window["Vue"].openBlock;
      const _createElementBlock54 = window["Vue"].createElementBlock;
      var _sfc_main54 = /* @__PURE__ */ _defineComponent54({
        name: "Clock",
        __name: "clock",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock54(), _createElementBlock54("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode54("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            _createElementVNode54("path", {
              fill: "currentColor",
              d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32"
            }),
            _createElementVNode54("path", {
              fill: "currentColor",
              d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32"
            })
          ]));
        }
      }), clock_default = _sfc_main54;
      const _defineComponent55 = window["Vue"].defineComponent;
      const _createElementVNode55 = window["Vue"].createElementVNode;
      const _openBlock55 = window["Vue"].openBlock;
      const _createElementBlock55 = window["Vue"].createElementBlock;
      var _sfc_main55 = /* @__PURE__ */ _defineComponent55({
        name: "CloseBold",
        __name: "close-bold",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock55(), _createElementBlock55("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode55("path", {
              fill: "currentColor",
              d: "M195.2 195.2a64 64 0 0 1 90.496 0L512 421.504 738.304 195.2a64 64 0 0 1 90.496 90.496L602.496 512 828.8 738.304a64 64 0 0 1-90.496 90.496L512 602.496 285.696 828.8a64 64 0 0 1-90.496-90.496L421.504 512 195.2 285.696a64 64 0 0 1 0-90.496"
            })
          ]));
        }
      }), close_bold_default = _sfc_main55;
      const _defineComponent56 = window["Vue"].defineComponent;
      const _createElementVNode56 = window["Vue"].createElementVNode;
      const _openBlock56 = window["Vue"].openBlock;
      const _createElementBlock56 = window["Vue"].createElementBlock;
      var _sfc_main56 = /* @__PURE__ */ _defineComponent56({
        name: "Close",
        __name: "close",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock56(), _createElementBlock56("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode56("path", {
              fill: "currentColor",
              d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
            })
          ]));
        }
      }), close_default = _sfc_main56;
      const _defineComponent57 = window["Vue"].defineComponent;
      const _createElementVNode57 = window["Vue"].createElementVNode;
      const _openBlock57 = window["Vue"].openBlock;
      const _createElementBlock57 = window["Vue"].createElementBlock;
      var _sfc_main57 = /* @__PURE__ */ _defineComponent57({
        name: "Cloudy",
        __name: "cloudy",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock57(), _createElementBlock57("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode57("path", {
              fill: "currentColor",
              d: "M598.4 831.872H328.192a256 256 0 0 1-34.496-510.528A352 352 0 1 1 598.4 831.872m-271.36-64h272.256a288 288 0 1 0-248.512-417.664L335.04 381.44l-34.816 3.584a192 192 0 0 0 26.88 382.848z"
            })
          ]));
        }
      }), cloudy_default = _sfc_main57;
      const _defineComponent58 = window["Vue"].defineComponent;
      const _createElementVNode58 = window["Vue"].createElementVNode;
      const _openBlock58 = window["Vue"].openBlock;
      const _createElementBlock58 = window["Vue"].createElementBlock;
      var _sfc_main58 = /* @__PURE__ */ _defineComponent58({
        name: "CoffeeCup",
        __name: "coffee-cup",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock58(), _createElementBlock58("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode58("path", {
              fill: "currentColor",
              d: "M768 192a192 192 0 1 1-8 383.808A256.13 256.13 0 0 1 512 768H320A256 256 0 0 1 64 512V160a32 32 0 0 1 32-32h640a32 32 0 0 1 32 32zm0 64v256a128 128 0 1 0 0-256M96 832h640a32 32 0 1 1 0 64H96a32 32 0 1 1 0-64m32-640v320a192 192 0 0 0 192 192h192a192 192 0 0 0 192-192V192z"
            })
          ]));
        }
      }), coffee_cup_default = _sfc_main58;
      const _defineComponent59 = window["Vue"].defineComponent;
      const _createElementVNode59 = window["Vue"].createElementVNode;
      const _openBlock59 = window["Vue"].openBlock;
      const _createElementBlock59 = window["Vue"].createElementBlock;
      var _sfc_main59 = /* @__PURE__ */ _defineComponent59({
        name: "Coffee",
        __name: "coffee",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock59(), _createElementBlock59("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode59("path", {
              fill: "currentColor",
              d: "M822.592 192h14.272a32 32 0 0 1 31.616 26.752l21.312 128A32 32 0 0 1 858.24 384h-49.344l-39.04 546.304A32 32 0 0 1 737.92 960H285.824a32 32 0 0 1-32-29.696L214.912 384H165.76a32 32 0 0 1-31.552-37.248l21.312-128A32 32 0 0 1 187.136 192h14.016l-6.72-93.696A32 32 0 0 1 226.368 64h571.008a32 32 0 0 1 31.936 34.304zm-64.128 0 4.544-64H260.736l4.544 64zm-548.16 128H820.48l-10.688-64H214.208l-10.688 64zm68.736 64 36.544 512H708.16l36.544-512z"
            })
          ]));
        }
      }), coffee_default = _sfc_main59;
      const _defineComponent60 = window["Vue"].defineComponent;
      const _createElementVNode60 = window["Vue"].createElementVNode;
      const _openBlock60 = window["Vue"].openBlock;
      const _createElementBlock60 = window["Vue"].createElementBlock;
      var _sfc_main60 = /* @__PURE__ */ _defineComponent60({
        name: "Coin",
        __name: "coin",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock60(), _createElementBlock60("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode60("path", {
              fill: "currentColor",
              d: "m161.92 580.736 29.888 58.88C171.328 659.776 160 681.728 160 704c0 82.304 155.328 160 352 160s352-77.696 352-160c0-22.272-11.392-44.16-31.808-64.32l30.464-58.432C903.936 615.808 928 657.664 928 704c0 129.728-188.544 224-416 224S96 833.728 96 704c0-46.592 24.32-88.576 65.92-123.264"
            }),
            _createElementVNode60("path", {
              fill: "currentColor",
              d: "m161.92 388.736 29.888 58.88C171.328 467.84 160 489.792 160 512c0 82.304 155.328 160 352 160s352-77.696 352-160c0-22.272-11.392-44.16-31.808-64.32l30.464-58.432C903.936 423.808 928 465.664 928 512c0 129.728-188.544 224-416 224S96 641.728 96 512c0-46.592 24.32-88.576 65.92-123.264"
            }),
            _createElementVNode60("path", {
              fill: "currentColor",
              d: "M512 544c-227.456 0-416-94.272-416-224S284.544 96 512 96s416 94.272 416 224-188.544 224-416 224m0-64c196.672 0 352-77.696 352-160S708.672 160 512 160s-352 77.696-352 160 155.328 160 352 160"
            })
          ]));
        }
      }), coin_default = _sfc_main60;
      const _defineComponent61 = window["Vue"].defineComponent;
      const _createElementVNode61 = window["Vue"].createElementVNode;
      const _openBlock61 = window["Vue"].openBlock;
      const _createElementBlock61 = window["Vue"].createElementBlock;
      var _sfc_main61 = /* @__PURE__ */ _defineComponent61({
        name: "ColdDrink",
        __name: "cold-drink",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock61(), _createElementBlock61("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode61("path", {
              fill: "currentColor",
              d: "M768 64a192 192 0 1 1-69.952 370.88L480 725.376V896h96a32 32 0 1 1 0 64H320a32 32 0 1 1 0-64h96V725.376L76.8 273.536a64 64 0 0 1-12.8-38.4v-10.688a32 32 0 0 1 32-32h71.808l-65.536-83.84a32 32 0 0 1 50.432-39.424l96.256 123.264h337.728A192.06 192.06 0 0 1 768 64M656.896 192.448H800a32 32 0 0 1 32 32v10.624a64 64 0 0 1-12.8 38.4l-80.448 107.2a128 128 0 1 0-81.92-188.16v-.064zm-357.888 64 129.472 165.76a32 32 0 0 1-50.432 39.36l-160.256-205.12H144l304 404.928 304-404.928z"
            })
          ]));
        }
      }), cold_drink_default = _sfc_main61;
      const _defineComponent62 = window["Vue"].defineComponent;
      const _createElementVNode62 = window["Vue"].createElementVNode;
      const _openBlock62 = window["Vue"].openBlock;
      const _createElementBlock62 = window["Vue"].createElementBlock;
      var _sfc_main62 = /* @__PURE__ */ _defineComponent62({
        name: "CollectionTag",
        __name: "collection-tag",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock62(), _createElementBlock62("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode62("path", {
              fill: "currentColor",
              d: "M256 128v698.88l196.032-156.864a96 96 0 0 1 119.936 0L768 826.816V128zm-32-64h576a32 32 0 0 1 32 32v797.44a32 32 0 0 1-51.968 24.96L531.968 720a32 32 0 0 0-39.936 0L243.968 918.4A32 32 0 0 1 192 893.44V96a32 32 0 0 1 32-32"
            })
          ]));
        }
      }), collection_tag_default = _sfc_main62;
      const _defineComponent63 = window["Vue"].defineComponent;
      const _createElementVNode63 = window["Vue"].createElementVNode;
      const _openBlock63 = window["Vue"].openBlock;
      const _createElementBlock63 = window["Vue"].createElementBlock;
      var _sfc_main63 = /* @__PURE__ */ _defineComponent63({
        name: "Collection",
        __name: "collection",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock63(), _createElementBlock63("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode63("path", {
              fill: "currentColor",
              d: "M192 736h640V128H256a64 64 0 0 0-64 64zm64-672h608a32 32 0 0 1 32 32v672a32 32 0 0 1-32 32H160l-32 57.536V192A128 128 0 0 1 256 64"
            }),
            _createElementVNode63("path", {
              fill: "currentColor",
              d: "M240 800a48 48 0 1 0 0 96h592v-96zm0-64h656v160a64 64 0 0 1-64 64H240a112 112 0 0 1 0-224m144-608v250.88l96-76.8 96 76.8V128zm-64-64h320v381.44a32 32 0 0 1-51.968 24.96L480 384l-108.032 86.4A32 32 0 0 1 320 445.44z"
            })
          ]));
        }
      }), collection_default = _sfc_main63;
      const _defineComponent64 = window["Vue"].defineComponent;
      const _createElementVNode64 = window["Vue"].createElementVNode;
      const _openBlock64 = window["Vue"].openBlock;
      const _createElementBlock64 = window["Vue"].createElementBlock;
      var _sfc_main64 = /* @__PURE__ */ _defineComponent64({
        name: "Comment",
        __name: "comment",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock64(), _createElementBlock64("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode64("path", {
              fill: "currentColor",
              d: "M736 504a56 56 0 1 1 0-112 56 56 0 0 1 0 112m-224 0a56 56 0 1 1 0-112 56 56 0 0 1 0 112m-224 0a56 56 0 1 1 0-112 56 56 0 0 1 0 112M128 128v640h192v160l224-160h352V128z"
            })
          ]));
        }
      }), comment_default = _sfc_main64;
      const _defineComponent65 = window["Vue"].defineComponent;
      const _createElementVNode65 = window["Vue"].createElementVNode;
      const _openBlock65 = window["Vue"].openBlock;
      const _createElementBlock65 = window["Vue"].createElementBlock;
      var _sfc_main65 = /* @__PURE__ */ _defineComponent65({
        name: "Compass",
        __name: "compass",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock65(), _createElementBlock65("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode65("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            _createElementVNode65("path", {
              fill: "currentColor",
              d: "M725.888 315.008C676.48 428.672 624 513.28 568.576 568.64c-55.424 55.424-139.968 107.904-253.568 157.312a12.8 12.8 0 0 1-16.896-16.832c49.536-113.728 102.016-198.272 157.312-253.632 55.36-55.296 139.904-107.776 253.632-157.312a12.8 12.8 0 0 1 16.832 16.832"
            })
          ]));
        }
      }), compass_default = _sfc_main65;
      const _defineComponent66 = window["Vue"].defineComponent;
      const _createElementVNode66 = window["Vue"].createElementVNode;
      const _openBlock66 = window["Vue"].openBlock;
      const _createElementBlock66 = window["Vue"].createElementBlock;
      var _sfc_main66 = /* @__PURE__ */ _defineComponent66({
        name: "Connection",
        __name: "connection",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock66(), _createElementBlock66("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode66("path", {
              fill: "currentColor",
              d: "M640 384v64H448a128 128 0 0 0-128 128v128a128 128 0 0 0 128 128h320a128 128 0 0 0 128-128V576a128 128 0 0 0-64-110.848V394.88c74.56 26.368 128 97.472 128 181.056v128a192 192 0 0 1-192 192H448a192 192 0 0 1-192-192V576a192 192 0 0 1 192-192z"
            }),
            _createElementVNode66("path", {
              fill: "currentColor",
              d: "M384 640v-64h192a128 128 0 0 0 128-128V320a128 128 0 0 0-128-128H256a128 128 0 0 0-128 128v128a128 128 0 0 0 64 110.848v70.272A192.06 192.06 0 0 1 64 448V320a192 192 0 0 1 192-192h320a192 192 0 0 1 192 192v128a192 192 0 0 1-192 192z"
            })
          ]));
        }
      }), connection_default = _sfc_main66;
      const _defineComponent67 = window["Vue"].defineComponent;
      const _createElementVNode67 = window["Vue"].createElementVNode;
      const _openBlock67 = window["Vue"].openBlock;
      const _createElementBlock67 = window["Vue"].createElementBlock;
      var _sfc_main67 = /* @__PURE__ */ _defineComponent67({
        name: "Coordinate",
        __name: "coordinate",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock67(), _createElementBlock67("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode67("path", {
              fill: "currentColor",
              d: "M480 512h64v320h-64z"
            }),
            _createElementVNode67("path", {
              fill: "currentColor",
              d: "M192 896h640a64 64 0 0 0-64-64H256a64 64 0 0 0-64 64m64-128h512a128 128 0 0 1 128 128v64H128v-64a128 128 0 0 1 128-128m256-256a192 192 0 1 0 0-384 192 192 0 0 0 0 384m0 64a256 256 0 1 1 0-512 256 256 0 0 1 0 512"
            })
          ]));
        }
      }), coordinate_default = _sfc_main67;
      const _defineComponent68 = window["Vue"].defineComponent;
      const _createElementVNode68 = window["Vue"].createElementVNode;
      const _openBlock68 = window["Vue"].openBlock;
      const _createElementBlock68 = window["Vue"].createElementBlock;
      var _sfc_main68 = /* @__PURE__ */ _defineComponent68({
        name: "CopyDocument",
        __name: "copy-document",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock68(), _createElementBlock68("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode68("path", {
              fill: "currentColor",
              d: "M768 832a128 128 0 0 1-128 128H192A128 128 0 0 1 64 832V384a128 128 0 0 1 128-128v64a64 64 0 0 0-64 64v448a64 64 0 0 0 64 64h448a64 64 0 0 0 64-64z"
            }),
            _createElementVNode68("path", {
              fill: "currentColor",
              d: "M384 128a64 64 0 0 0-64 64v448a64 64 0 0 0 64 64h448a64 64 0 0 0 64-64V192a64 64 0 0 0-64-64zm0-64h448a128 128 0 0 1 128 128v448a128 128 0 0 1-128 128H384a128 128 0 0 1-128-128V192A128 128 0 0 1 384 64"
            })
          ]));
        }
      }), copy_document_default = _sfc_main68;
      const _defineComponent69 = window["Vue"].defineComponent;
      const _createElementVNode69 = window["Vue"].createElementVNode;
      const _openBlock69 = window["Vue"].openBlock;
      const _createElementBlock69 = window["Vue"].createElementBlock;
      var _sfc_main69 = /* @__PURE__ */ _defineComponent69({
        name: "Cpu",
        __name: "cpu",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock69(), _createElementBlock69("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode69("path", {
              fill: "currentColor",
              d: "M320 256a64 64 0 0 0-64 64v384a64 64 0 0 0 64 64h384a64 64 0 0 0 64-64V320a64 64 0 0 0-64-64zm0-64h384a128 128 0 0 1 128 128v384a128 128 0 0 1-128 128H320a128 128 0 0 1-128-128V320a128 128 0 0 1 128-128"
            }),
            _createElementVNode69("path", {
              fill: "currentColor",
              d: "M512 64a32 32 0 0 1 32 32v128h-64V96a32 32 0 0 1 32-32m160 0a32 32 0 0 1 32 32v128h-64V96a32 32 0 0 1 32-32m-320 0a32 32 0 0 1 32 32v128h-64V96a32 32 0 0 1 32-32m160 896a32 32 0 0 1-32-32V800h64v128a32 32 0 0 1-32 32m160 0a32 32 0 0 1-32-32V800h64v128a32 32 0 0 1-32 32m-320 0a32 32 0 0 1-32-32V800h64v128a32 32 0 0 1-32 32M64 512a32 32 0 0 1 32-32h128v64H96a32 32 0 0 1-32-32m0-160a32 32 0 0 1 32-32h128v64H96a32 32 0 0 1-32-32m0 320a32 32 0 0 1 32-32h128v64H96a32 32 0 0 1-32-32m896-160a32 32 0 0 1-32 32H800v-64h128a32 32 0 0 1 32 32m0-160a32 32 0 0 1-32 32H800v-64h128a32 32 0 0 1 32 32m0 320a32 32 0 0 1-32 32H800v-64h128a32 32 0 0 1 32 32"
            })
          ]));
        }
      }), cpu_default = _sfc_main69;
      const _defineComponent70 = window["Vue"].defineComponent;
      const _createElementVNode70 = window["Vue"].createElementVNode;
      const _openBlock70 = window["Vue"].openBlock;
      const _createElementBlock70 = window["Vue"].createElementBlock;
      var _sfc_main70 = /* @__PURE__ */ _defineComponent70({
        name: "CreditCard",
        __name: "credit-card",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock70(), _createElementBlock70("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode70("path", {
              fill: "currentColor",
              d: "M896 324.096c0-42.368-2.496-55.296-9.536-68.48a52.35 52.35 0 0 0-22.144-22.08c-13.12-7.04-26.048-9.536-68.416-9.536H228.096c-42.368 0-55.296 2.496-68.48 9.536a52.35 52.35 0 0 0-22.08 22.144c-7.04 13.12-9.536 26.048-9.536 68.416v375.808c0 42.368 2.496 55.296 9.536 68.48a52.35 52.35 0 0 0 22.144 22.08c13.12 7.04 26.048 9.536 68.416 9.536h567.808c42.368 0 55.296-2.496 68.48-9.536a52.35 52.35 0 0 0 22.08-22.144c7.04-13.12 9.536-26.048 9.536-68.416zm64 0v375.808c0 57.088-5.952 77.76-17.088 98.56-11.136 20.928-27.52 37.312-48.384 48.448S852.928 864 795.968 864H228.032c-57.088 0-77.76-5.952-98.56-17.088a116.3 116.3 0 0 1-48.448-48.384c-11.136-20.864-17.088-41.6-17.088-98.56V324.032c0-57.088 5.952-77.76 17.088-98.56 11.136-20.928 27.52-37.312 48.384-48.448s41.6-17.088 98.56-17.088H795.84c57.088 0 77.76 5.952 98.56 17.088 20.928 11.136 37.312 27.52 48.448 48.384s17.088 41.6 17.088 98.56z"
            }),
            _createElementVNode70("path", {
              fill: "currentColor",
              d: "M64 320h896v64H64zm0 128h896v64H64zm128 192h256v64H192z"
            })
          ]));
        }
      }), credit_card_default = _sfc_main70;
      const _defineComponent71 = window["Vue"].defineComponent;
      const _createElementVNode71 = window["Vue"].createElementVNode;
      const _openBlock71 = window["Vue"].openBlock;
      const _createElementBlock71 = window["Vue"].createElementBlock;
      var _sfc_main71 = /* @__PURE__ */ _defineComponent71({
        name: "Crop",
        __name: "crop",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock71(), _createElementBlock71("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode71("path", {
              fill: "currentColor",
              d: "M256 768h672a32 32 0 1 1 0 64H224a32 32 0 0 1-32-32V96a32 32 0 0 1 64 0z"
            }),
            _createElementVNode71("path", {
              fill: "currentColor",
              d: "M832 224v704a32 32 0 1 1-64 0V256H96a32 32 0 0 1 0-64h704a32 32 0 0 1 32 32"
            })
          ]));
        }
      }), crop_default = _sfc_main71;
      const _defineComponent72 = window["Vue"].defineComponent;
      const _createElementVNode72 = window["Vue"].createElementVNode;
      const _openBlock72 = window["Vue"].openBlock;
      const _createElementBlock72 = window["Vue"].createElementBlock;
      var _sfc_main72 = /* @__PURE__ */ _defineComponent72({
        name: "DArrowLeft",
        __name: "d-arrow-left",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock72(), _createElementBlock72("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode72("path", {
              fill: "currentColor",
              d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.59 30.59 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.59 30.59 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672zm256 0a29.12 29.12 0 0 1 41.728 0 30.59 30.59 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.59 30.59 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672z"
            })
          ]));
        }
      }), d_arrow_left_default = _sfc_main72;
      const _defineComponent73 = window["Vue"].defineComponent;
      const _createElementVNode73 = window["Vue"].createElementVNode;
      const _openBlock73 = window["Vue"].openBlock;
      const _createElementBlock73 = window["Vue"].createElementBlock;
      var _sfc_main73 = /* @__PURE__ */ _defineComponent73({
        name: "DArrowRight",
        __name: "d-arrow-right",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock73(), _createElementBlock73("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode73("path", {
              fill: "currentColor",
              d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.59 30.59 0 0 1 0-42.752L764.736 512 452.864 192a30.59 30.59 0 0 1 0-42.688m-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.59 30.59 0 0 1 0-42.752L508.736 512 196.864 192a30.59 30.59 0 0 1 0-42.688"
            })
          ]));
        }
      }), d_arrow_right_default = _sfc_main73;
      const _defineComponent74 = window["Vue"].defineComponent;
      const _createElementVNode74 = window["Vue"].createElementVNode;
      const _openBlock74 = window["Vue"].openBlock;
      const _createElementBlock74 = window["Vue"].createElementBlock;
      var _sfc_main74 = /* @__PURE__ */ _defineComponent74({
        name: "DCaret",
        __name: "d-caret",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock74(), _createElementBlock74("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode74("path", {
              fill: "currentColor",
              d: "m512 128 288 320H224zM224 576h576L512 896z"
            })
          ]));
        }
      }), d_caret_default = _sfc_main74;
      const _defineComponent75 = window["Vue"].defineComponent;
      const _createElementVNode75 = window["Vue"].createElementVNode;
      const _openBlock75 = window["Vue"].openBlock;
      const _createElementBlock75 = window["Vue"].createElementBlock;
      var _sfc_main75 = /* @__PURE__ */ _defineComponent75({
        name: "DataAnalysis",
        __name: "data-analysis",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock75(), _createElementBlock75("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode75("path", {
              fill: "currentColor",
              d: "m665.216 768 110.848 192h-73.856L591.36 768H433.024L322.176 960H248.32l110.848-192H160a32 32 0 0 1-32-32V192H64a32 32 0 0 1 0-64h896a32 32 0 1 1 0 64h-64v544a32 32 0 0 1-32 32zM832 192H192v512h640zM352 448a32 32 0 0 1 32 32v64a32 32 0 0 1-64 0v-64a32 32 0 0 1 32-32m160-64a32 32 0 0 1 32 32v128a32 32 0 0 1-64 0V416a32 32 0 0 1 32-32m160-64a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V352a32 32 0 0 1 32-32"
            })
          ]));
        }
      }), data_analysis_default = _sfc_main75;
      const _defineComponent76 = window["Vue"].defineComponent;
      const _createElementVNode76 = window["Vue"].createElementVNode;
      const _openBlock76 = window["Vue"].openBlock;
      const _createElementBlock76 = window["Vue"].createElementBlock;
      var _sfc_main76 = /* @__PURE__ */ _defineComponent76({
        name: "DataBoard",
        __name: "data-board",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock76(), _createElementBlock76("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode76("path", {
              fill: "currentColor",
              d: "M32 128h960v64H32z"
            }),
            _createElementVNode76("path", {
              fill: "currentColor",
              d: "M192 192v512h640V192zm-64-64h768v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32z"
            }),
            _createElementVNode76("path", {
              fill: "currentColor",
              d: "M322.176 960H248.32l144.64-250.56 55.424 32zm453.888 0h-73.856L576 741.44l55.424-32z"
            })
          ]));
        }
      }), data_board_default = _sfc_main76;
      const _defineComponent77 = window["Vue"].defineComponent;
      const _createElementVNode77 = window["Vue"].createElementVNode;
      const _openBlock77 = window["Vue"].openBlock;
      const _createElementBlock77 = window["Vue"].createElementBlock;
      var _sfc_main77 = /* @__PURE__ */ _defineComponent77({
        name: "DataLine",
        __name: "data-line",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock77(), _createElementBlock77("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode77("path", {
              fill: "currentColor",
              d: "M359.168 768H160a32 32 0 0 1-32-32V192H64a32 32 0 0 1 0-64h896a32 32 0 1 1 0 64h-64v544a32 32 0 0 1-32 32H665.216l110.848 192h-73.856L591.36 768H433.024L322.176 960H248.32zM832 192H192v512h640zM342.656 534.656a32 32 0 1 1-45.312-45.312L444.992 341.76l125.44 94.08L679.04 300.032a32 32 0 1 1 49.92 39.936L581.632 524.224 451.008 426.24 342.656 534.592z"
            })
          ]));
        }
      }), data_line_default = _sfc_main77;
      const _defineComponent78 = window["Vue"].defineComponent;
      const _createElementVNode78 = window["Vue"].createElementVNode;
      const _openBlock78 = window["Vue"].openBlock;
      const _createElementBlock78 = window["Vue"].createElementBlock;
      var _sfc_main78 = /* @__PURE__ */ _defineComponent78({
        name: "DeleteFilled",
        __name: "delete-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock78(), _createElementBlock78("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode78("path", {
              fill: "currentColor",
              d: "M352 192V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64H96a32 32 0 0 1 0-64zm64 0h192v-64H416zM192 960a32 32 0 0 1-32-32V256h704v672a32 32 0 0 1-32 32zm224-192a32 32 0 0 0 32-32V416a32 32 0 0 0-64 0v320a32 32 0 0 0 32 32m192 0a32 32 0 0 0 32-32V416a32 32 0 0 0-64 0v320a32 32 0 0 0 32 32"
            })
          ]));
        }
      }), delete_filled_default = _sfc_main78;
      const _defineComponent79 = window["Vue"].defineComponent;
      const _createElementVNode79 = window["Vue"].createElementVNode;
      const _openBlock79 = window["Vue"].openBlock;
      const _createElementBlock79 = window["Vue"].createElementBlock;
      var _sfc_main79 = /* @__PURE__ */ _defineComponent79({
        name: "DeleteLocation",
        __name: "delete-location",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock79(), _createElementBlock79("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode79("path", {
              fill: "currentColor",
              d: "M288 896h448q32 0 32 32t-32 32H288q-32 0-32-32t32-32"
            }),
            _createElementVNode79("path", {
              fill: "currentColor",
              d: "M800 416a288 288 0 1 0-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416M512 960C277.312 746.688 160 565.312 160 416a352 352 0 0 1 704 0c0 149.312-117.312 330.688-352 544"
            }),
            _createElementVNode79("path", {
              fill: "currentColor",
              d: "M384 384h256q32 0 32 32t-32 32H384q-32 0-32-32t32-32"
            })
          ]));
        }
      }), delete_location_default = _sfc_main79;
      const _defineComponent80 = window["Vue"].defineComponent;
      const _createElementVNode80 = window["Vue"].createElementVNode;
      const _openBlock80 = window["Vue"].openBlock;
      const _createElementBlock80 = window["Vue"].createElementBlock;
      var _sfc_main80 = /* @__PURE__ */ _defineComponent80({
        name: "Delete",
        __name: "delete",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock80(), _createElementBlock80("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode80("path", {
              fill: "currentColor",
              d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32zm448-64v-64H416v64zM224 896h576V256H224zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32m192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32"
            })
          ]));
        }
      }), delete_default = _sfc_main80;
      const _defineComponent81 = window["Vue"].defineComponent;
      const _createElementVNode81 = window["Vue"].createElementVNode;
      const _openBlock81 = window["Vue"].openBlock;
      const _createElementBlock81 = window["Vue"].createElementBlock;
      var _sfc_main81 = /* @__PURE__ */ _defineComponent81({
        name: "Dessert",
        __name: "dessert",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock81(), _createElementBlock81("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode81("path", {
              fill: "currentColor",
              d: "M128 416v-48a144 144 0 0 1 168.64-141.888 224.128 224.128 0 0 1 430.72 0A144 144 0 0 1 896 368v48a384 384 0 0 1-352 382.72V896h-64v-97.28A384 384 0 0 1 128 416m287.104-32.064h193.792a143.81 143.81 0 0 1 58.88-132.736 160.064 160.064 0 0 0-311.552 0 143.81 143.81 0 0 1 58.88 132.8zm-72.896 0a72 72 0 1 0-140.48 0zm339.584 0h140.416a72 72 0 1 0-140.48 0zM512 736a320 320 0 0 0 318.4-288.064H193.6A320 320 0 0 0 512 736M384 896.064h256a32 32 0 1 1 0 64H384a32 32 0 1 1 0-64"
            })
          ]));
        }
      }), dessert_default = _sfc_main81;
      const _defineComponent82 = window["Vue"].defineComponent;
      const _createElementVNode82 = window["Vue"].createElementVNode;
      const _openBlock82 = window["Vue"].openBlock;
      const _createElementBlock82 = window["Vue"].createElementBlock;
      var _sfc_main82 = /* @__PURE__ */ _defineComponent82({
        name: "Discount",
        __name: "discount",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock82(), _createElementBlock82("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode82("path", {
              fill: "currentColor",
              d: "M224 704h576V318.336L552.512 115.84a64 64 0 0 0-81.024 0L224 318.336zm0 64v128h576V768zM593.024 66.304l259.2 212.096A32 32 0 0 1 864 303.168V928a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V303.168a32 32 0 0 1 11.712-24.768l259.2-212.096a128 128 0 0 1 162.112 0"
            }),
            _createElementVNode82("path", {
              fill: "currentColor",
              d: "M512 448a64 64 0 1 0 0-128 64 64 0 0 0 0 128m0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256"
            })
          ]));
        }
      }), discount_default = _sfc_main82;
      const _defineComponent83 = window["Vue"].defineComponent;
      const _createElementVNode83 = window["Vue"].createElementVNode;
      const _openBlock83 = window["Vue"].openBlock;
      const _createElementBlock83 = window["Vue"].createElementBlock;
      var _sfc_main83 = /* @__PURE__ */ _defineComponent83({
        name: "DishDot",
        __name: "dish-dot",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock83(), _createElementBlock83("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode83("path", {
              fill: "currentColor",
              d: "m384.064 274.56.064-50.688A128 128 0 0 1 512.128 96c70.528 0 127.68 57.152 127.68 127.68v50.752A448.19 448.19 0 0 1 955.392 768H68.544A448.19 448.19 0 0 1 384 274.56zM96 832h832a32 32 0 1 1 0 64H96a32 32 0 1 1 0-64m32-128h768a384 384 0 1 0-768 0m447.808-448v-32.32a63.68 63.68 0 0 0-63.68-63.68 64 64 0 0 0-64 63.936V256z"
            })
          ]));
        }
      }), dish_dot_default = _sfc_main83;
      const _defineComponent84 = window["Vue"].defineComponent;
      const _createElementVNode84 = window["Vue"].createElementVNode;
      const _openBlock84 = window["Vue"].openBlock;
      const _createElementBlock84 = window["Vue"].createElementBlock;
      var _sfc_main84 = /* @__PURE__ */ _defineComponent84({
        name: "Dish",
        __name: "dish",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock84(), _createElementBlock84("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode84("path", {
              fill: "currentColor",
              d: "M480 257.152V192h-96a32 32 0 0 1 0-64h256a32 32 0 1 1 0 64h-96v65.152A448 448 0 0 1 955.52 768H68.48A448 448 0 0 1 480 257.152M128 704h768a384 384 0 1 0-768 0M96 832h832a32 32 0 1 1 0 64H96a32 32 0 1 1 0-64"
            })
          ]));
        }
      }), dish_default = _sfc_main84;
      const _defineComponent85 = window["Vue"].defineComponent;
      const _createElementVNode85 = window["Vue"].createElementVNode;
      const _openBlock85 = window["Vue"].openBlock;
      const _createElementBlock85 = window["Vue"].createElementBlock;
      var _sfc_main85 = /* @__PURE__ */ _defineComponent85({
        name: "DocumentAdd",
        __name: "document-add",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock85(), _createElementBlock85("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode85("path", {
              fill: "currentColor",
              d: "M832 384H576V128H192v768h640zm-26.496-64L640 154.496V320zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m320 512V448h64v128h128v64H544v128h-64V640H352v-64z"
            })
          ]));
        }
      }), document_add_default = _sfc_main85;
      const _defineComponent86 = window["Vue"].defineComponent;
      const _createElementVNode86 = window["Vue"].createElementVNode;
      const _openBlock86 = window["Vue"].openBlock;
      const _createElementBlock86 = window["Vue"].createElementBlock;
      var _sfc_main86 = /* @__PURE__ */ _defineComponent86({
        name: "DocumentChecked",
        __name: "document-checked",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock86(), _createElementBlock86("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode86("path", {
              fill: "currentColor",
              d: "M805.504 320 640 154.496V320zM832 384H576V128H192v768h640zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m318.4 582.144 180.992-180.992L704.64 510.4 478.4 736.64 320 578.304l45.248-45.312z"
            })
          ]));
        }
      }), document_checked_default = _sfc_main86;
      const _defineComponent87 = window["Vue"].defineComponent;
      const _createElementVNode87 = window["Vue"].createElementVNode;
      const _openBlock87 = window["Vue"].openBlock;
      const _createElementBlock87 = window["Vue"].createElementBlock;
      var _sfc_main87 = /* @__PURE__ */ _defineComponent87({
        name: "DocumentCopy",
        __name: "document-copy",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock87(), _createElementBlock87("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode87("path", {
              fill: "currentColor",
              d: "M128 320v576h576V320zm-32-64h640a32 32 0 0 1 32 32v640a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V288a32 32 0 0 1 32-32M960 96v704a32 32 0 0 1-32 32h-96v-64h64V128H384v64h-64V96a32 32 0 0 1 32-32h576a32 32 0 0 1 32 32M256 672h320v64H256zm0-192h320v64H256z"
            })
          ]));
        }
      }), document_copy_default = _sfc_main87;
      const _defineComponent88 = window["Vue"].defineComponent;
      const _createElementVNode88 = window["Vue"].createElementVNode;
      const _openBlock88 = window["Vue"].openBlock;
      const _createElementBlock88 = window["Vue"].createElementBlock;
      var _sfc_main88 = /* @__PURE__ */ _defineComponent88({
        name: "DocumentDelete",
        __name: "document-delete",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock88(), _createElementBlock88("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode88("path", {
              fill: "currentColor",
              d: "M805.504 320 640 154.496V320zM832 384H576V128H192v768h640zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m308.992 546.304-90.496-90.624 45.248-45.248 90.56 90.496 90.496-90.432 45.248 45.248-90.496 90.56 90.496 90.496-45.248 45.248-90.496-90.496-90.56 90.496-45.248-45.248z"
            })
          ]));
        }
      }), document_delete_default = _sfc_main88;
      const _defineComponent89 = window["Vue"].defineComponent;
      const _createElementVNode89 = window["Vue"].createElementVNode;
      const _openBlock89 = window["Vue"].openBlock;
      const _createElementBlock89 = window["Vue"].createElementBlock;
      var _sfc_main89 = /* @__PURE__ */ _defineComponent89({
        name: "DocumentRemove",
        __name: "document-remove",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock89(), _createElementBlock89("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode89("path", {
              fill: "currentColor",
              d: "M805.504 320 640 154.496V320zM832 384H576V128H192v768h640zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m192 512h320v64H352z"
            })
          ]));
        }
      }), document_remove_default = _sfc_main89;
      const _defineComponent90 = window["Vue"].defineComponent;
      const _createElementVNode90 = window["Vue"].createElementVNode;
      const _openBlock90 = window["Vue"].openBlock;
      const _createElementBlock90 = window["Vue"].createElementBlock;
      var _sfc_main90 = /* @__PURE__ */ _defineComponent90({
        name: "Document",
        __name: "document",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock90(), _createElementBlock90("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode90("path", {
              fill: "currentColor",
              d: "M832 384H576V128H192v768h640zm-26.496-64L640 154.496V320zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m160 448h384v64H320zm0-192h160v64H320zm0 384h384v64H320z"
            })
          ]));
        }
      }), document_default = _sfc_main90;
      const _defineComponent91 = window["Vue"].defineComponent;
      const _createElementVNode91 = window["Vue"].createElementVNode;
      const _openBlock91 = window["Vue"].openBlock;
      const _createElementBlock91 = window["Vue"].createElementBlock;
      var _sfc_main91 = /* @__PURE__ */ _defineComponent91({
        name: "Download",
        __name: "download",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock91(), _createElementBlock91("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode91("path", {
              fill: "currentColor",
              d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64m384-253.696 236.288-236.352 45.248 45.248L508.8 704 192 387.2l45.248-45.248L480 584.704V128h64z"
            })
          ]));
        }
      }), download_default = _sfc_main91;
      const _defineComponent92 = window["Vue"].defineComponent;
      const _createElementVNode92 = window["Vue"].createElementVNode;
      const _openBlock92 = window["Vue"].openBlock;
      const _createElementBlock92 = window["Vue"].createElementBlock;
      var _sfc_main92 = /* @__PURE__ */ _defineComponent92({
        name: "Drizzling",
        __name: "drizzling",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock92(), _createElementBlock92("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode92("path", {
              fill: "currentColor",
              d: "m739.328 291.328-35.2-6.592-12.8-33.408a192.064 192.064 0 0 0-365.952 23.232l-9.92 40.896-41.472 7.04a176.32 176.32 0 0 0-146.24 173.568c0 97.28 78.72 175.936 175.808 175.936h400a192 192 0 0 0 35.776-380.672M959.552 480a256 256 0 0 1-256 256h-400A239.81 239.81 0 0 1 63.744 496.192a240.32 240.32 0 0 1 199.488-236.8 256.128 256.128 0 0 1 487.872-30.976A256.064 256.064 0 0 1 959.552 480M288 800h64v64h-64zm192 0h64v64h-64zm-96 96h64v64h-64zm192 0h64v64h-64zm96-96h64v64h-64z"
            })
          ]));
        }
      }), drizzling_default = _sfc_main92;
      const _defineComponent93 = window["Vue"].defineComponent;
      const _createElementVNode93 = window["Vue"].createElementVNode;
      const _openBlock93 = window["Vue"].openBlock;
      const _createElementBlock93 = window["Vue"].createElementBlock;
      var _sfc_main93 = /* @__PURE__ */ _defineComponent93({
        name: "EditPen",
        __name: "edit-pen",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock93(), _createElementBlock93("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode93("path", {
              fill: "currentColor",
              d: "m199.04 672.64 193.984 112 224-387.968-193.92-112-224 388.032zm-23.872 60.16 32.896 148.288 144.896-45.696zM455.04 229.248l193.92 112 56.704-98.112-193.984-112zM104.32 708.8l384-665.024 304.768 175.936L409.152 884.8h.064l-248.448 78.336zm384 254.272v-64h448v64z"
            })
          ]));
        }
      }), edit_pen_default = _sfc_main93;
      const _defineComponent94 = window["Vue"].defineComponent;
      const _createElementVNode94 = window["Vue"].createElementVNode;
      const _openBlock94 = window["Vue"].openBlock;
      const _createElementBlock94 = window["Vue"].createElementBlock;
      var _sfc_main94 = /* @__PURE__ */ _defineComponent94({
        name: "Edit",
        __name: "edit",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock94(), _createElementBlock94("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode94("path", {
              fill: "currentColor",
              d: "M832 512a32 32 0 1 1 64 0v352a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h352a32 32 0 0 1 0 64H192v640h640z"
            }),
            _createElementVNode94("path", {
              fill: "currentColor",
              d: "m469.952 554.24 52.8-7.552L847.104 222.4a32 32 0 1 0-45.248-45.248L477.44 501.44l-7.552 52.8zm422.4-422.4a96 96 0 0 1 0 135.808l-331.84 331.84a32 32 0 0 1-18.112 9.088L436.8 623.68a32 32 0 0 1-36.224-36.224l15.104-105.6a32 32 0 0 1 9.024-18.112l331.904-331.84a96 96 0 0 1 135.744 0z"
            })
          ]));
        }
      }), edit_default = _sfc_main94;
      const _defineComponent95 = window["Vue"].defineComponent;
      const _createElementVNode95 = window["Vue"].createElementVNode;
      const _openBlock95 = window["Vue"].openBlock;
      const _createElementBlock95 = window["Vue"].createElementBlock;
      var _sfc_main95 = /* @__PURE__ */ _defineComponent95({
        name: "ElemeFilled",
        __name: "eleme-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock95(), _createElementBlock95("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode95("path", {
              fill: "currentColor",
              d: "M176 64h672c61.824 0 112 50.176 112 112v672a112 112 0 0 1-112 112H176A112 112 0 0 1 64 848V176c0-61.824 50.176-112 112-112m150.528 173.568c-152.896 99.968-196.544 304.064-97.408 456.96a330.69 330.69 0 0 0 456.96 96.64c9.216-5.888 17.6-11.776 25.152-18.56a18.24 18.24 0 0 0 4.224-24.32L700.352 724.8a47.55 47.55 0 0 0-65.536-14.272A234.56 234.56 0 0 1 310.592 641.6C240 533.248 271.104 387.968 379.456 316.48a234.3 234.3 0 0 1 276.352 15.168c1.664.832 2.56 2.56 3.392 4.224 5.888 8.384 3.328 19.328-5.12 25.216L456.832 489.6a47.55 47.55 0 0 0-14.336 65.472l16 24.384c5.888 8.384 16.768 10.88 25.216 5.056l308.224-199.936a19.584 19.584 0 0 0 6.72-23.488v-.896c-4.992-9.216-10.048-17.6-15.104-26.88-99.968-151.168-304.064-194.88-456.96-95.744zM786.88 504.704l-62.208 40.32c-8.32 5.888-10.88 16.768-4.992 25.216L760 632.32c5.888 8.448 16.768 11.008 25.152 5.12l31.104-20.16a55.36 55.36 0 0 0 16-76.48l-20.224-31.04a19.52 19.52 0 0 0-25.152-5.12z"
            })
          ]));
        }
      }), eleme_filled_default = _sfc_main95;
      const _defineComponent96 = window["Vue"].defineComponent;
      const _createElementVNode96 = window["Vue"].createElementVNode;
      const _openBlock96 = window["Vue"].openBlock;
      const _createElementBlock96 = window["Vue"].createElementBlock;
      var _sfc_main96 = /* @__PURE__ */ _defineComponent96({
        name: "Eleme",
        __name: "eleme",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock96(), _createElementBlock96("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode96("path", {
              fill: "currentColor",
              d: "M300.032 188.8c174.72-113.28 408-63.36 522.24 109.44 5.76 10.56 11.52 20.16 17.28 30.72v.96a22.4 22.4 0 0 1-7.68 26.88l-352.32 228.48c-9.6 6.72-22.08 3.84-28.8-5.76l-18.24-27.84a54.336 54.336 0 0 1 16.32-74.88l225.6-146.88c9.6-6.72 12.48-19.2 5.76-28.8-.96-1.92-1.92-3.84-3.84-4.8a267.84 267.84 0 0 0-315.84-17.28c-123.84 81.6-159.36 247.68-78.72 371.52a268.096 268.096 0 0 0 370.56 78.72 54.336 54.336 0 0 1 74.88 16.32l17.28 26.88c5.76 9.6 3.84 21.12-4.8 27.84-8.64 7.68-18.24 14.4-28.8 21.12a377.92 377.92 0 0 1-522.24-110.4c-113.28-174.72-63.36-408 111.36-522.24m526.08 305.28a22.336 22.336 0 0 1 28.8 5.76l23.04 35.52a63.23 63.23 0 0 1-18.24 87.36l-35.52 23.04c-9.6 6.72-22.08 3.84-28.8-5.76l-46.08-71.04c-6.72-9.6-3.84-22.08 5.76-28.8z"
            })
          ]));
        }
      }), eleme_default = _sfc_main96;
      const _defineComponent97 = window["Vue"].defineComponent;
      const _createElementVNode97 = window["Vue"].createElementVNode;
      const _openBlock97 = window["Vue"].openBlock;
      const _createElementBlock97 = window["Vue"].createElementBlock;
      var _sfc_main97 = /* @__PURE__ */ _defineComponent97({
        name: "ElementPlus",
        __name: "element-plus",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock97(), _createElementBlock97("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode97("path", {
              fill: "currentColor",
              d: "M839.7 734.7c0 33.3-17.9 41-17.9 41S519.7 949.8 499.2 960c-10.2 5.1-20.5 5.1-30.7 0 0 0-314.9-184.3-325.1-192-5.1-5.1-10.2-12.8-12.8-20.5V368.6c0-17.9 20.5-28.2 20.5-28.2L466 158.6q19.2-7.65 38.4 0s279 161.3 309.8 179.2c17.9 7.7 28.2 25.6 25.6 46.1-.1-5-.1 317.5-.1 350.8M714.2 371.2c-64-35.8-217.6-125.4-217.6-125.4-7.7-5.1-20.5-5.1-30.7 0L217.6 389.1s-17.9 10.2-17.9 23v297c0 5.1 5.1 12.8 7.7 17.9 7.7 5.1 256 148.5 256 148.5 7.7 5.1 17.9 5.1 25.6 0 15.4-7.7 250.9-145.9 250.9-145.9s12.8-5.1 12.8-30.7v-74.2l-276.5 169v-64c0-17.9 7.7-30.7 20.5-46.1L745 535c5.1-7.7 10.2-20.5 10.2-30.7v-66.6l-279 169v-69.1c0-15.4 5.1-30.7 17.9-38.4zM919 135.7c0-5.1-5.1-7.7-7.7-7.7h-58.9V66.6c0-5.1-5.1-5.1-10.2-5.1l-30.7 5.1c-5.1 0-5.1 2.6-5.1 5.1V128h-56.3c-5.1 0-5.1 5.1-7.7 5.1v38.4h69.1v64c0 5.1 5.1 5.1 10.2 5.1l30.7-5.1c5.1 0 5.1-2.6 5.1-5.1v-56.3h64z"
            })
          ]));
        }
      }), element_plus_default = _sfc_main97;
      const _defineComponent98 = window["Vue"].defineComponent;
      const _createElementVNode98 = window["Vue"].createElementVNode;
      const _openBlock98 = window["Vue"].openBlock;
      const _createElementBlock98 = window["Vue"].createElementBlock;
      var _sfc_main98 = /* @__PURE__ */ _defineComponent98({
        name: "Expand",
        __name: "expand",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock98(), _createElementBlock98("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode98("path", {
              fill: "currentColor",
              d: "M128 192h768v128H128zm0 256h512v128H128zm0 256h768v128H128zm576-352 192 160-192 128z"
            })
          ]));
        }
      }), expand_default = _sfc_main98;
      const _defineComponent99 = window["Vue"].defineComponent;
      const _createElementVNode99 = window["Vue"].createElementVNode;
      const _openBlock99 = window["Vue"].openBlock;
      const _createElementBlock99 = window["Vue"].createElementBlock;
      var _sfc_main99 = /* @__PURE__ */ _defineComponent99({
        name: "Failed",
        __name: "failed",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock99(), _createElementBlock99("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode99("path", {
              fill: "currentColor",
              d: "m557.248 608 135.744-135.744-45.248-45.248-135.68 135.744-135.808-135.68-45.248 45.184L466.752 608l-135.68 135.68 45.184 45.312L512 653.248l135.744 135.744 45.248-45.248L557.312 608zM704 192h160v736H160V192h160v64h384zm-320 0V96h256v96z"
            })
          ]));
        }
      }), failed_default = _sfc_main99;
      const _defineComponent100 = window["Vue"].defineComponent;
      const _createElementVNode100 = window["Vue"].createElementVNode;
      const _openBlock100 = window["Vue"].openBlock;
      const _createElementBlock100 = window["Vue"].createElementBlock;
      var _sfc_main100 = /* @__PURE__ */ _defineComponent100({
        name: "Female",
        __name: "female",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock100(), _createElementBlock100("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode100("path", {
              fill: "currentColor",
              d: "M512 640a256 256 0 1 0 0-512 256 256 0 0 0 0 512m0 64a320 320 0 1 1 0-640 320 320 0 0 1 0 640"
            }),
            _createElementVNode100("path", {
              fill: "currentColor",
              d: "M512 640q32 0 32 32v256q0 32-32 32t-32-32V672q0-32 32-32"
            }),
            _createElementVNode100("path", {
              fill: "currentColor",
              d: "M352 800h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32"
            })
          ]));
        }
      }), female_default = _sfc_main100;
      const _defineComponent101 = window["Vue"].defineComponent;
      const _createElementVNode101 = window["Vue"].createElementVNode;
      const _openBlock101 = window["Vue"].openBlock;
      const _createElementBlock101 = window["Vue"].createElementBlock;
      var _sfc_main101 = /* @__PURE__ */ _defineComponent101({
        name: "Files",
        __name: "files",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock101(), _createElementBlock101("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode101("path", {
              fill: "currentColor",
              d: "M128 384v448h768V384zm-32-64h832a32 32 0 0 1 32 32v512a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V352a32 32 0 0 1 32-32m64-128h704v64H160zm96-128h512v64H256z"
            })
          ]));
        }
      }), files_default = _sfc_main101;
      const _defineComponent102 = window["Vue"].defineComponent;
      const _createElementVNode102 = window["Vue"].createElementVNode;
      const _openBlock102 = window["Vue"].openBlock;
      const _createElementBlock102 = window["Vue"].createElementBlock;
      var _sfc_main102 = /* @__PURE__ */ _defineComponent102({
        name: "Film",
        __name: "film",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock102(), _createElementBlock102("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode102("path", {
              fill: "currentColor",
              d: "M160 160v704h704V160zm-32-64h768a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H128a32 32 0 0 1-32-32V128a32 32 0 0 1 32-32"
            }),
            _createElementVNode102("path", {
              fill: "currentColor",
              d: "M320 288V128h64v352h256V128h64v160h160v64H704v128h160v64H704v128h160v64H704v160h-64V544H384v352h-64V736H128v-64h192V544H128v-64h192V352H128v-64z"
            })
          ]));
        }
      }), film_default = _sfc_main102;
      const _defineComponent103 = window["Vue"].defineComponent;
      const _createElementVNode103 = window["Vue"].createElementVNode;
      const _openBlock103 = window["Vue"].openBlock;
      const _createElementBlock103 = window["Vue"].createElementBlock;
      var _sfc_main103 = /* @__PURE__ */ _defineComponent103({
        name: "Filter",
        __name: "filter",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock103(), _createElementBlock103("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode103("path", {
              fill: "currentColor",
              d: "M384 523.392V928a32 32 0 0 0 46.336 28.608l192-96A32 32 0 0 0 640 832V523.392l280.768-343.104a32 32 0 1 0-49.536-40.576l-288 352A32 32 0 0 0 576 512v300.224l-128 64V512a32 32 0 0 0-7.232-20.288L195.52 192H704a32 32 0 1 0 0-64H128a32 32 0 0 0-24.768 52.288z"
            })
          ]));
        }
      }), filter_default = _sfc_main103;
      const _defineComponent104 = window["Vue"].defineComponent;
      const _createElementVNode104 = window["Vue"].createElementVNode;
      const _openBlock104 = window["Vue"].openBlock;
      const _createElementBlock104 = window["Vue"].createElementBlock;
      var _sfc_main104 = /* @__PURE__ */ _defineComponent104({
        name: "Finished",
        __name: "finished",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock104(), _createElementBlock104("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode104("path", {
              fill: "currentColor",
              d: "M280.768 753.728 691.456 167.04a32 32 0 1 1 52.416 36.672L314.24 817.472a32 32 0 0 1-45.44 7.296l-230.4-172.8a32 32 0 0 1 38.4-51.2zM736 448a32 32 0 1 1 0-64h192a32 32 0 1 1 0 64zM608 640a32 32 0 0 1 0-64h319.936a32 32 0 1 1 0 64zM480 832a32 32 0 1 1 0-64h447.936a32 32 0 1 1 0 64z"
            })
          ]));
        }
      }), finished_default = _sfc_main104;
      const _defineComponent105 = window["Vue"].defineComponent;
      const _createElementVNode105 = window["Vue"].createElementVNode;
      const _openBlock105 = window["Vue"].openBlock;
      const _createElementBlock105 = window["Vue"].createElementBlock;
      var _sfc_main105 = /* @__PURE__ */ _defineComponent105({
        name: "FirstAidKit",
        __name: "first-aid-kit",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock105(), _createElementBlock105("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode105("path", {
              fill: "currentColor",
              d: "M192 256a64 64 0 0 0-64 64v448a64 64 0 0 0 64 64h640a64 64 0 0 0 64-64V320a64 64 0 0 0-64-64zm0-64h640a128 128 0 0 1 128 128v448a128 128 0 0 1-128 128H192A128 128 0 0 1 64 768V320a128 128 0 0 1 128-128"
            }),
            _createElementVNode105("path", {
              fill: "currentColor",
              d: "M544 512h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96v-96a32 32 0 0 1 64 0zM352 128v64h320v-64zm-32-64h384a32 32 0 0 1 32 32v128a32 32 0 0 1-32 32H320a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32"
            })
          ]));
        }
      }), first_aid_kit_default = _sfc_main105;
      const _defineComponent106 = window["Vue"].defineComponent;
      const _createElementVNode106 = window["Vue"].createElementVNode;
      const _openBlock106 = window["Vue"].openBlock;
      const _createElementBlock106 = window["Vue"].createElementBlock;
      var _sfc_main106 = /* @__PURE__ */ _defineComponent106({
        name: "Flag",
        __name: "flag",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock106(), _createElementBlock106("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode106("path", {
              fill: "currentColor",
              d: "M288 128h608L736 384l160 256H288v320h-96V64h96z"
            })
          ]));
        }
      }), flag_default = _sfc_main106;
      const _defineComponent107 = window["Vue"].defineComponent;
      const _createElementVNode107 = window["Vue"].createElementVNode;
      const _openBlock107 = window["Vue"].openBlock;
      const _createElementBlock107 = window["Vue"].createElementBlock;
      var _sfc_main107 = /* @__PURE__ */ _defineComponent107({
        name: "Fold",
        __name: "fold",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock107(), _createElementBlock107("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode107("path", {
              fill: "currentColor",
              d: "M896 192H128v128h768zm0 256H384v128h512zm0 256H128v128h768zM320 384 128 512l192 128z"
            })
          ]));
        }
      }), fold_default = _sfc_main107;
      const _defineComponent108 = window["Vue"].defineComponent;
      const _createElementVNode108 = window["Vue"].createElementVNode;
      const _openBlock108 = window["Vue"].openBlock;
      const _createElementBlock108 = window["Vue"].createElementBlock;
      var _sfc_main108 = /* @__PURE__ */ _defineComponent108({
        name: "FolderAdd",
        __name: "folder-add",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock108(), _createElementBlock108("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode108("path", {
              fill: "currentColor",
              d: "M128 192v640h768V320H485.76L357.504 192zm-32-64h287.872l128.384 128H928a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32m384 416V416h64v128h128v64H544v128h-64V608H352v-64z"
            })
          ]));
        }
      }), folder_add_default = _sfc_main108;
      const _defineComponent109 = window["Vue"].defineComponent;
      const _createElementVNode109 = window["Vue"].createElementVNode;
      const _openBlock109 = window["Vue"].openBlock;
      const _createElementBlock109 = window["Vue"].createElementBlock;
      var _sfc_main109 = /* @__PURE__ */ _defineComponent109({
        name: "FolderChecked",
        __name: "folder-checked",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock109(), _createElementBlock109("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode109("path", {
              fill: "currentColor",
              d: "M128 192v640h768V320H485.76L357.504 192zm-32-64h287.872l128.384 128H928a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32m414.08 502.144 180.992-180.992L736.32 494.4 510.08 720.64l-158.4-158.336 45.248-45.312z"
            })
          ]));
        }
      }), folder_checked_default = _sfc_main109;
      const _defineComponent110 = window["Vue"].defineComponent;
      const _createElementVNode110 = window["Vue"].createElementVNode;
      const _openBlock110 = window["Vue"].openBlock;
      const _createElementBlock110 = window["Vue"].createElementBlock;
      var _sfc_main110 = /* @__PURE__ */ _defineComponent110({
        name: "FolderDelete",
        __name: "folder-delete",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock110(), _createElementBlock110("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode110("path", {
              fill: "currentColor",
              d: "M128 192v640h768V320H485.76L357.504 192zm-32-64h287.872l128.384 128H928a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32m370.752 448-90.496-90.496 45.248-45.248L512 530.752l90.496-90.496 45.248 45.248L557.248 576l90.496 90.496-45.248 45.248L512 621.248l-90.496 90.496-45.248-45.248z"
            })
          ]));
        }
      }), folder_delete_default = _sfc_main110;
      const _defineComponent111 = window["Vue"].defineComponent;
      const _createElementVNode111 = window["Vue"].createElementVNode;
      const _openBlock111 = window["Vue"].openBlock;
      const _createElementBlock111 = window["Vue"].createElementBlock;
      var _sfc_main111 = /* @__PURE__ */ _defineComponent111({
        name: "FolderOpened",
        __name: "folder-opened",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock111(), _createElementBlock111("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode111("path", {
              fill: "currentColor",
              d: "M878.08 448H241.92l-96 384h636.16zM832 384v-64H485.76L357.504 192H128v448l57.92-231.744A32 32 0 0 1 216.96 384zm-24.96 512H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h287.872l128.384 128H864a32 32 0 0 1 32 32v96h23.04a32 32 0 0 1 31.04 39.744l-112 448A32 32 0 0 1 807.04 896"
            })
          ]));
        }
      }), folder_opened_default = _sfc_main111;
      const _defineComponent112 = window["Vue"].defineComponent;
      const _createElementVNode112 = window["Vue"].createElementVNode;
      const _openBlock112 = window["Vue"].openBlock;
      const _createElementBlock112 = window["Vue"].createElementBlock;
      var _sfc_main112 = /* @__PURE__ */ _defineComponent112({
        name: "FolderRemove",
        __name: "folder-remove",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock112(), _createElementBlock112("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode112("path", {
              fill: "currentColor",
              d: "M128 192v640h768V320H485.76L357.504 192zm-32-64h287.872l128.384 128H928a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32m256 416h320v64H352z"
            })
          ]));
        }
      }), folder_remove_default = _sfc_main112;
      const _defineComponent113 = window["Vue"].defineComponent;
      const _createElementVNode113 = window["Vue"].createElementVNode;
      const _openBlock113 = window["Vue"].openBlock;
      const _createElementBlock113 = window["Vue"].createElementBlock;
      var _sfc_main113 = /* @__PURE__ */ _defineComponent113({
        name: "Folder",
        __name: "folder",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock113(), _createElementBlock113("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode113("path", {
              fill: "currentColor",
              d: "M128 192v640h768V320H485.76L357.504 192zm-32-64h287.872l128.384 128H928a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32"
            })
          ]));
        }
      }), folder_default = _sfc_main113;
      const _defineComponent114 = window["Vue"].defineComponent;
      const _createElementVNode114 = window["Vue"].createElementVNode;
      const _openBlock114 = window["Vue"].openBlock;
      const _createElementBlock114 = window["Vue"].createElementBlock;
      var _sfc_main114 = /* @__PURE__ */ _defineComponent114({
        name: "Food",
        __name: "food",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock114(), _createElementBlock114("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode114("path", {
              fill: "currentColor",
              d: "M128 352.576V352a288 288 0 0 1 491.072-204.224 192 192 0 0 1 274.24 204.48 64 64 0 0 1 57.216 74.24C921.6 600.512 850.048 710.656 736 756.992V800a96 96 0 0 1-96 96H384a96 96 0 0 1-96-96v-43.008c-114.048-46.336-185.6-156.48-214.528-330.496A64 64 0 0 1 128 352.64zm64-.576h64a160 160 0 0 1 320 0h64a224 224 0 0 0-448 0m128 0h192a96 96 0 0 0-192 0m439.424 0h68.544A128.256 128.256 0 0 0 704 192c-15.36 0-29.952 2.688-43.52 7.616 11.328 18.176 20.672 37.76 27.84 58.304A64.128 64.128 0 0 1 759.424 352M672 768H352v32a32 32 0 0 0 32 32h256a32 32 0 0 0 32-32zm-342.528-64h365.056c101.504-32.64 165.76-124.928 192.896-288H136.576c27.136 163.072 91.392 255.36 192.896 288"
            })
          ]));
        }
      }), food_default = _sfc_main114;
      const _defineComponent115 = window["Vue"].defineComponent;
      const _createElementVNode115 = window["Vue"].createElementVNode;
      const _openBlock115 = window["Vue"].openBlock;
      const _createElementBlock115 = window["Vue"].createElementBlock;
      var _sfc_main115 = /* @__PURE__ */ _defineComponent115({
        name: "Football",
        __name: "football",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock115(), _createElementBlock115("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode115("path", {
              fill: "currentColor",
              d: "M512 960a448 448 0 1 1 0-896 448 448 0 0 1 0 896m0-64a384 384 0 1 0 0-768 384 384 0 0 0 0 768"
            }),
            _createElementVNode115("path", {
              fill: "currentColor",
              d: "M186.816 268.288c16-16.384 31.616-31.744 46.976-46.08 17.472 30.656 39.808 58.112 65.984 81.28l-32.512 56.448a386 386 0 0 1-80.448-91.648m653.696-5.312a385.9 385.9 0 0 1-83.776 96.96l-32.512-56.384a322.9 322.9 0 0 0 68.48-85.76c15.552 14.08 31.488 29.12 47.808 45.184M465.984 445.248l11.136-63.104a323.6 323.6 0 0 0 69.76 0l11.136 63.104a388 388 0 0 1-92.032 0m-62.72-12.8A381.8 381.8 0 0 1 320 396.544l32-55.424a320 320 0 0 0 62.464 27.712l-11.2 63.488zm300.8-35.84a381.8 381.8 0 0 1-83.328 35.84l-11.2-63.552A320 320 0 0 0 672 341.184l32 55.424zm-520.768 364.8a385.9 385.9 0 0 1 83.968-97.28l32.512 56.32c-26.88 23.936-49.856 52.352-67.52 84.032-16-13.44-32.32-27.712-48.96-43.072m657.536.128a1443 1443 0 0 1-49.024 43.072 321.4 321.4 0 0 0-67.584-84.16l32.512-56.32c33.216 27.456 61.696 60.352 84.096 97.408M465.92 578.752a388 388 0 0 1 92.032 0l-11.136 63.104a323.6 323.6 0 0 0-69.76 0zm-62.72 12.8 11.2 63.552a320 320 0 0 0-62.464 27.712L320 627.392a381.8 381.8 0 0 1 83.264-35.84zm300.8 35.84-32 55.424a318.3 318.3 0 0 0-62.528-27.712l11.2-63.488c29.44 8.64 57.28 20.736 83.264 35.776z"
            })
          ]));
        }
      }), football_default = _sfc_main115;
      const _defineComponent116 = window["Vue"].defineComponent;
      const _createElementVNode116 = window["Vue"].createElementVNode;
      const _openBlock116 = window["Vue"].openBlock;
      const _createElementBlock116 = window["Vue"].createElementBlock;
      var _sfc_main116 = /* @__PURE__ */ _defineComponent116({
        name: "ForkSpoon",
        __name: "fork-spoon",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock116(), _createElementBlock116("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode116("path", {
              fill: "currentColor",
              d: "M256 410.304V96a32 32 0 0 1 64 0v314.304a96 96 0 0 0 64-90.56V96a32 32 0 0 1 64 0v223.744a160 160 0 0 1-128 156.8V928a32 32 0 1 1-64 0V476.544a160 160 0 0 1-128-156.8V96a32 32 0 0 1 64 0v223.744a96 96 0 0 0 64 90.56M672 572.48C581.184 552.128 512 446.848 512 320c0-141.44 85.952-256 192-256s192 114.56 192 256c0 126.848-69.184 232.128-160 252.48V928a32 32 0 1 1-64 0zM704 512c66.048 0 128-82.56 128-192s-61.952-192-128-192-128 82.56-128 192 61.952 192 128 192"
            })
          ]));
        }
      }), fork_spoon_default = _sfc_main116;
      const _defineComponent117 = window["Vue"].defineComponent;
      const _createElementVNode117 = window["Vue"].createElementVNode;
      const _openBlock117 = window["Vue"].openBlock;
      const _createElementBlock117 = window["Vue"].createElementBlock;
      var _sfc_main117 = /* @__PURE__ */ _defineComponent117({
        name: "Fries",
        __name: "fries",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock117(), _createElementBlock117("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode117("path", {
              fill: "currentColor",
              d: "M608 224v-64a32 32 0 0 0-64 0v336h26.88A64 64 0 0 0 608 484.096zm101.12 160A64 64 0 0 0 672 395.904V384h64V224a32 32 0 1 0-64 0v160zm74.88 0a92.928 92.928 0 0 1 91.328 110.08l-60.672 323.584A96 96 0 0 1 720.32 896H303.68a96 96 0 0 1-94.336-78.336L148.672 494.08A92.928 92.928 0 0 1 240 384h-16V224a96 96 0 0 1 188.608-25.28A95.74 95.74 0 0 1 480 197.44V160a96 96 0 0 1 188.608-25.28A96 96 0 0 1 800 224v160zM670.784 512a128 128 0 0 1-99.904 48H453.12a128 128 0 0 1-99.84-48H352v-1.536a128 128 0 0 1-9.984-14.976L314.88 448H240a28.928 28.928 0 0 0-28.48 34.304L241.088 640h541.824l29.568-157.696A28.928 28.928 0 0 0 784 448h-74.88l-27.136 47.488A132 132 0 0 1 672 510.464V512zM480 288a32 32 0 0 0-64 0v196.096A64 64 0 0 0 453.12 496H480zm-128 96V224a32 32 0 0 0-64 0v160zh-37.12A64 64 0 0 1 352 395.904zm-98.88 320 19.072 101.888A32 32 0 0 0 303.68 832h416.64a32 32 0 0 0 31.488-26.112L770.88 704z"
            })
          ]));
        }
      }), fries_default = _sfc_main117;
      const _defineComponent118 = window["Vue"].defineComponent;
      const _createElementVNode118 = window["Vue"].createElementVNode;
      const _openBlock118 = window["Vue"].openBlock;
      const _createElementBlock118 = window["Vue"].createElementBlock;
      var _sfc_main118 = /* @__PURE__ */ _defineComponent118({
        name: "FullScreen",
        __name: "full-screen",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock118(), _createElementBlock118("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode118("path", {
              fill: "currentColor",
              d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64z"
            })
          ]));
        }
      }), full_screen_default = _sfc_main118;
      const _defineComponent119 = window["Vue"].defineComponent;
      const _createElementVNode119 = window["Vue"].createElementVNode;
      const _openBlock119 = window["Vue"].openBlock;
      const _createElementBlock119 = window["Vue"].createElementBlock;
      var _sfc_main119 = /* @__PURE__ */ _defineComponent119({
        name: "GobletFull",
        __name: "goblet-full",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock119(), _createElementBlock119("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode119("path", {
              fill: "currentColor",
              d: "M256 320h512c0-78.592-12.608-142.4-36.928-192h-434.24C269.504 192.384 256 256.256 256 320m503.936 64H264.064a256.128 256.128 0 0 0 495.872 0M544 638.4V896h96a32 32 0 1 1 0 64H384a32 32 0 1 1 0-64h96V638.4A320 320 0 0 1 192 320c0-85.632 21.312-170.944 64-256h512c42.688 64.32 64 149.632 64 256a320 320 0 0 1-288 318.4"
            })
          ]));
        }
      }), goblet_full_default = _sfc_main119;
      const _defineComponent120 = window["Vue"].defineComponent;
      const _createElementVNode120 = window["Vue"].createElementVNode;
      const _openBlock120 = window["Vue"].openBlock;
      const _createElementBlock120 = window["Vue"].createElementBlock;
      var _sfc_main120 = /* @__PURE__ */ _defineComponent120({
        name: "GobletSquareFull",
        __name: "goblet-square-full",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock120(), _createElementBlock120("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode120("path", {
              fill: "currentColor",
              d: "M256 270.912c10.048 6.72 22.464 14.912 28.992 18.624a220.16 220.16 0 0 0 114.752 30.72c30.592 0 49.408-9.472 91.072-41.152l.64-.448c52.928-40.32 82.368-55.04 132.288-54.656 55.552.448 99.584 20.8 142.72 57.408l1.536 1.28V128H256zm.96 76.288C266.368 482.176 346.88 575.872 512 576c157.44.064 237.952-85.056 253.248-209.984a952 952 0 0 1-40.192-35.712c-32.704-27.776-63.36-41.92-101.888-42.24-31.552-.256-50.624 9.28-93.12 41.6l-.576.448c-52.096 39.616-81.024 54.208-129.792 54.208-54.784 0-100.48-13.376-142.784-37.056zM480 638.848C250.624 623.424 192 442.496 192 319.68V96a32 32 0 0 1 32-32h576a32 32 0 0 1 32 32v224c0 122.816-58.624 303.68-288 318.912V896h96a32 32 0 1 1 0 64H384a32 32 0 1 1 0-64h96z"
            })
          ]));
        }
      }), goblet_square_full_default = _sfc_main120;
      const _defineComponent121 = window["Vue"].defineComponent;
      const _createElementVNode121 = window["Vue"].createElementVNode;
      const _openBlock121 = window["Vue"].openBlock;
      const _createElementBlock121 = window["Vue"].createElementBlock;
      var _sfc_main121 = /* @__PURE__ */ _defineComponent121({
        name: "GobletSquare",
        __name: "goblet-square",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock121(), _createElementBlock121("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode121("path", {
              fill: "currentColor",
              d: "M544 638.912V896h96a32 32 0 1 1 0 64H384a32 32 0 1 1 0-64h96V638.848C250.624 623.424 192 442.496 192 319.68V96a32 32 0 0 1 32-32h576a32 32 0 0 1 32 32v224c0 122.816-58.624 303.68-288 318.912M256 319.68c0 149.568 80 256.192 256 256.256C688.128 576 768 469.568 768 320V128H256z"
            })
          ]));
        }
      }), goblet_square_default = _sfc_main121;
      const _defineComponent122 = window["Vue"].defineComponent;
      const _createElementVNode122 = window["Vue"].createElementVNode;
      const _openBlock122 = window["Vue"].openBlock;
      const _createElementBlock122 = window["Vue"].createElementBlock;
      var _sfc_main122 = /* @__PURE__ */ _defineComponent122({
        name: "Goblet",
        __name: "goblet",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock122(), _createElementBlock122("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode122("path", {
              fill: "currentColor",
              d: "M544 638.4V896h96a32 32 0 1 1 0 64H384a32 32 0 1 1 0-64h96V638.4A320 320 0 0 1 192 320c0-85.632 21.312-170.944 64-256h512c42.688 64.32 64 149.632 64 256a320 320 0 0 1-288 318.4M256 320a256 256 0 1 0 512 0c0-78.592-12.608-142.4-36.928-192h-434.24C269.504 192.384 256 256.256 256 320"
            })
          ]));
        }
      }), goblet_default = _sfc_main122;
      const _defineComponent123 = window["Vue"].defineComponent;
      const _createElementVNode123 = window["Vue"].createElementVNode;
      const _openBlock123 = window["Vue"].openBlock;
      const _createElementBlock123 = window["Vue"].createElementBlock;
      var _sfc_main123 = /* @__PURE__ */ _defineComponent123({
        name: "GoldMedal",
        __name: "gold-medal",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock123(), _createElementBlock123("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            "xml:space": "preserve",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode123("path", {
              fill: "currentColor",
              d: "m772.13 452.84 53.86-351.81c1.32-10.01-1.17-18.68-7.49-26.02S804.35 64 795.01 64H228.99v-.01h-.06c-9.33 0-17.15 3.67-23.49 11.01s-8.83 16.01-7.49 26.02l53.87 351.89C213.54 505.73 193.59 568.09 192 640c2 90.67 33.17 166.17 93.5 226.5S421.33 957.99 512 960c90.67-2 166.17-33.17 226.5-93.5 60.33-60.34 91.49-135.83 93.5-226.5-1.59-71.94-21.56-134.32-59.87-187.16M640.01 128h117.02l-39.01 254.02c-20.75-10.64-40.74-19.73-59.94-27.28-5.92-3-11.95-5.8-18.08-8.41V128zM576 128v198.76c-13.18-2.58-26.74-4.43-40.67-5.55-8.07-.8-15.85-1.2-23.33-1.2-10.54 0-21.09.66-31.64 1.96a360 360 0 0 0-32.36 4.79V128zm-192 0h.04v218.3c-6.22 2.66-12.34 5.5-18.36 8.56-19.13 7.54-39.02 16.6-59.66 27.16L267.01 128zm308.99 692.99c-48 48-108.33 73-180.99 75.01-72.66-2.01-132.99-27.01-180.99-75.01S258.01 712.66 256 640c2.01-72.66 27.01-132.99 75.01-180.99 19.67-19.67 41.41-35.47 65.22-47.41 38.33-15.04 71.15-23.92 98.44-26.65 5.07-.41 10.2-.7 15.39-.88.63-.01 1.28-.03 1.91-.03.66 0 1.35.03 2.02.04 5.11.17 10.15.46 15.13.86 27.4 2.71 60.37 11.65 98.91 26.79 23.71 11.93 45.36 27.69 64.96 47.29 48 48 73 108.33 75.01 180.99-2.01 72.65-27.01 132.98-75.01 180.98"
            }),
            _createElementVNode123("path", {
              fill: "currentColor",
              d: "M544 480H416v64h64v192h-64v64h192v-64h-64z"
            })
          ]));
        }
      }), gold_medal_default = _sfc_main123;
      const _defineComponent124 = window["Vue"].defineComponent;
      const _createElementVNode124 = window["Vue"].createElementVNode;
      const _openBlock124 = window["Vue"].openBlock;
      const _createElementBlock124 = window["Vue"].createElementBlock;
      var _sfc_main124 = /* @__PURE__ */ _defineComponent124({
        name: "GoodsFilled",
        __name: "goods-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock124(), _createElementBlock124("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode124("path", {
              fill: "currentColor",
              d: "M192 352h640l64 544H128zm128 224h64V448h-64zm320 0h64V448h-64zM384 288h-64a192 192 0 1 1 384 0h-64a128 128 0 1 0-256 0"
            })
          ]));
        }
      }), goods_filled_default = _sfc_main124;
      const _defineComponent125 = window["Vue"].defineComponent;
      const _createElementVNode125 = window["Vue"].createElementVNode;
      const _openBlock125 = window["Vue"].openBlock;
      const _createElementBlock125 = window["Vue"].createElementBlock;
      var _sfc_main125 = /* @__PURE__ */ _defineComponent125({
        name: "Goods",
        __name: "goods",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock125(), _createElementBlock125("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode125("path", {
              fill: "currentColor",
              d: "M320 288v-22.336C320 154.688 405.504 64 512 64s192 90.688 192 201.664v22.4h131.072a32 32 0 0 1 31.808 28.8l57.6 576a32 32 0 0 1-31.808 35.2H131.328a32 32 0 0 1-31.808-35.2l57.6-576a32 32 0 0 1 31.808-28.8H320zm64 0h256v-22.336C640 189.248 582.272 128 512 128s-128 61.248-128 137.664v22.4zm-64 64H217.92l-51.2 512h690.56l-51.264-512H704v96a32 32 0 1 1-64 0v-96H384v96a32 32 0 0 1-64 0z"
            })
          ]));
        }
      }), goods_default = _sfc_main125;
      const _defineComponent126 = window["Vue"].defineComponent;
      const _createElementVNode126 = window["Vue"].createElementVNode;
      const _openBlock126 = window["Vue"].openBlock;
      const _createElementBlock126 = window["Vue"].createElementBlock;
      var _sfc_main126 = /* @__PURE__ */ _defineComponent126({
        name: "Grape",
        __name: "grape",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock126(), _createElementBlock126("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode126("path", {
              fill: "currentColor",
              d: "M544 195.2a160 160 0 0 1 96 60.8 160 160 0 1 1 146.24 254.976 160 160 0 0 1-128 224 160 160 0 1 1-292.48 0 160 160 0 0 1-128-224A160 160 0 1 1 384 256a160 160 0 0 1 96-60.8V128h-64a32 32 0 0 1 0-64h192a32 32 0 0 1 0 64h-64zM512 448a96 96 0 1 0 0-192 96 96 0 0 0 0 192m-256 0a96 96 0 1 0 0-192 96 96 0 0 0 0 192m128 224a96 96 0 1 0 0-192 96 96 0 0 0 0 192m128 224a96 96 0 1 0 0-192 96 96 0 0 0 0 192m128-224a96 96 0 1 0 0-192 96 96 0 0 0 0 192m128-224a96 96 0 1 0 0-192 96 96 0 0 0 0 192"
            })
          ]));
        }
      }), grape_default = _sfc_main126;
      const _defineComponent127 = window["Vue"].defineComponent;
      const _createElementVNode127 = window["Vue"].createElementVNode;
      const _openBlock127 = window["Vue"].openBlock;
      const _createElementBlock127 = window["Vue"].createElementBlock;
      var _sfc_main127 = /* @__PURE__ */ _defineComponent127({
        name: "Grid",
        __name: "grid",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock127(), _createElementBlock127("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode127("path", {
              fill: "currentColor",
              d: "M640 384v256H384V384zm64 0h192v256H704zm-64 512H384V704h256zm64 0V704h192v192zm-64-768v192H384V128zm64 0h192v192H704zM320 384v256H128V384zm0 512H128V704h192zm0-768v192H128V128z"
            })
          ]));
        }
      }), grid_default = _sfc_main127;
      const _defineComponent128 = window["Vue"].defineComponent;
      const _createElementVNode128 = window["Vue"].createElementVNode;
      const _openBlock128 = window["Vue"].openBlock;
      const _createElementBlock128 = window["Vue"].createElementBlock;
      var _sfc_main128 = /* @__PURE__ */ _defineComponent128({
        name: "Guide",
        __name: "guide",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock128(), _createElementBlock128("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode128("path", {
              fill: "currentColor",
              d: "M640 608h-64V416h64zm0 160v160a32 32 0 0 1-32 32H416a32 32 0 0 1-32-32V768h64v128h128V768zM384 608V416h64v192zm256-352h-64V128H448v128h-64V96a32 32 0 0 1 32-32h192a32 32 0 0 1 32 32z"
            }),
            _createElementVNode128("path", {
              fill: "currentColor",
              d: "m220.8 256-71.232 80 71.168 80H768V256zm-14.4-64H800a32 32 0 0 1 32 32v224a32 32 0 0 1-32 32H206.4a32 32 0 0 1-23.936-10.752l-99.584-112a32 32 0 0 1 0-42.496l99.584-112A32 32 0 0 1 206.4 192m678.784 496-71.104 80H266.816V608h547.2zm-56.768-144H234.88a32 32 0 0 0-32 32v224a32 32 0 0 0 32 32h593.6a32 32 0 0 0 23.936-10.752l99.584-112a32 32 0 0 0 0-42.496l-99.584-112A32 32 0 0 0 828.48 544z"
            })
          ]));
        }
      }), guide_default = _sfc_main128;
      const _defineComponent129 = window["Vue"].defineComponent;
      const _createElementVNode129 = window["Vue"].createElementVNode;
      const _openBlock129 = window["Vue"].openBlock;
      const _createElementBlock129 = window["Vue"].createElementBlock;
      var _sfc_main129 = /* @__PURE__ */ _defineComponent129({
        name: "Handbag",
        __name: "handbag",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock129(), _createElementBlock129("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            "xml:space": "preserve",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode129("path", {
              fill: "currentColor",
              d: "M887.01 264.99c-6-5.99-13.67-8.99-23.01-8.99H704c-1.34-54.68-20.01-100.01-56-136s-81.32-54.66-136-56c-54.68 1.34-100.01 20.01-136 56s-54.66 81.32-56 136H160c-9.35 0-17.02 3-23.01 8.99-5.99 6-8.99 13.67-8.99 23.01v640c0 9.35 2.99 17.02 8.99 23.01S150.66 960 160 960h704c9.35 0 17.02-2.99 23.01-8.99S896 937.34 896 928V288c0-9.35-2.99-17.02-8.99-23.01M421.5 165.5c24.32-24.34 54.49-36.84 90.5-37.5 35.99.68 66.16 13.18 90.5 37.5s36.84 54.49 37.5 90.5H384c.68-35.99 13.18-66.16 37.5-90.5M832 896H192V320h128v128h64V320h256v128h64V320h128z"
            })
          ]));
        }
      }), handbag_default = _sfc_main129;
      const _defineComponent130 = window["Vue"].defineComponent;
      const _createElementVNode130 = window["Vue"].createElementVNode;
      const _openBlock130 = window["Vue"].openBlock;
      const _createElementBlock130 = window["Vue"].createElementBlock;
      var _sfc_main130 = /* @__PURE__ */ _defineComponent130({
        name: "Headset",
        __name: "headset",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock130(), _createElementBlock130("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode130("path", {
              fill: "currentColor",
              d: "M896 529.152V512a384 384 0 1 0-768 0v17.152A128 128 0 0 1 320 640v128a128 128 0 1 1-256 0V512a448 448 0 1 1 896 0v256a128 128 0 1 1-256 0V640a128 128 0 0 1 192-110.848M896 640a64 64 0 0 0-128 0v128a64 64 0 0 0 128 0zm-768 0v128a64 64 0 0 0 128 0V640a64 64 0 1 0-128 0"
            })
          ]));
        }
      }), headset_default = _sfc_main130;
      const _defineComponent131 = window["Vue"].defineComponent;
      const _createElementVNode131 = window["Vue"].createElementVNode;
      const _openBlock131 = window["Vue"].openBlock;
      const _createElementBlock131 = window["Vue"].createElementBlock;
      var _sfc_main131 = /* @__PURE__ */ _defineComponent131({
        name: "HelpFilled",
        __name: "help-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock131(), _createElementBlock131("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode131("path", {
              fill: "currentColor",
              d: "M926.784 480H701.312A192.51 192.51 0 0 0 544 322.688V97.216A416.064 416.064 0 0 1 926.784 480m0 64A416.064 416.064 0 0 1 544 926.784V701.312A192.51 192.51 0 0 0 701.312 544zM97.28 544h225.472A192.51 192.51 0 0 0 480 701.312v225.472A416.064 416.064 0 0 1 97.216 544zm0-64A416.064 416.064 0 0 1 480 97.216v225.472A192.51 192.51 0 0 0 322.688 480H97.216z"
            })
          ]));
        }
      }), help_filled_default = _sfc_main131;
      const _defineComponent132 = window["Vue"].defineComponent;
      const _createElementVNode132 = window["Vue"].createElementVNode;
      const _openBlock132 = window["Vue"].openBlock;
      const _createElementBlock132 = window["Vue"].createElementBlock;
      var _sfc_main132 = /* @__PURE__ */ _defineComponent132({
        name: "Help",
        __name: "help",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock132(), _createElementBlock132("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode132("path", {
              fill: "currentColor",
              d: "m759.936 805.248-90.944-91.008A254.9 254.9 0 0 1 512 768a254.9 254.9 0 0 1-156.992-53.76l-90.944 91.008A382.46 382.46 0 0 0 512 896c94.528 0 181.12-34.176 247.936-90.752m45.312-45.312A382.46 382.46 0 0 0 896 512c0-94.528-34.176-181.12-90.752-247.936l-91.008 90.944C747.904 398.4 768 452.864 768 512s-20.096 113.6-53.76 156.992zm-45.312-541.184A382.46 382.46 0 0 0 512 128c-94.528 0-181.12 34.176-247.936 90.752l90.944 91.008A254.9 254.9 0 0 1 512 256c59.136 0 113.6 20.096 156.992 53.76zm-541.184 45.312A382.46 382.46 0 0 0 128 512c0 94.528 34.176 181.12 90.752 247.936l91.008-90.944A254.9 254.9 0 0 1 256 512c0-59.136 20.096-113.6 53.76-156.992zm417.28 394.496a194.6 194.6 0 0 0 22.528-22.528C686.912 602.56 704 559.232 704 512a191.23 191.23 0 0 0-67.968-146.56A191.3 191.3 0 0 0 512 320a191.23 191.23 0 0 0-146.56 67.968C337.088 421.44 320 464.768 320 512a191.23 191.23 0 0 0 67.968 146.56C421.44 686.912 464.768 704 512 704c47.296 0 90.56-17.088 124.032-45.44M512 960a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            })
          ]));
        }
      }), help_default = _sfc_main132;
      const _defineComponent133 = window["Vue"].defineComponent;
      const _createElementVNode133 = window["Vue"].createElementVNode;
      const _openBlock133 = window["Vue"].openBlock;
      const _createElementBlock133 = window["Vue"].createElementBlock;
      var _sfc_main133 = /* @__PURE__ */ _defineComponent133({
        name: "Hide",
        __name: "hide",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock133(), _createElementBlock133("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode133("path", {
              fill: "currentColor",
              d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4s-12.8-9.6-22.4-9.6-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176S0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4s3.2 16 9.6 22.4 12.8 9.6 22.4 9.6 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4m-646.4 528Q115.2 579.2 76.8 512q43.2-72 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4m140.8-96Q352 555.2 352 512c0-44.8 16-83.2 48-112s67.2-48 112-48c28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6q-43.2 72-153.6 172.8c-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176S1024 528 1024 512s-48.001-73.6-134.401-176"
            }),
            _createElementVNode133("path", {
              fill: "currentColor",
              d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112s-67.2 48-112 48"
            })
          ]));
        }
      }), hide_default = _sfc_main133;
      const _defineComponent134 = window["Vue"].defineComponent;
      const _createElementVNode134 = window["Vue"].createElementVNode;
      const _openBlock134 = window["Vue"].openBlock;
      const _createElementBlock134 = window["Vue"].createElementBlock;
      var _sfc_main134 = /* @__PURE__ */ _defineComponent134({
        name: "Histogram",
        __name: "histogram",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock134(), _createElementBlock134("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode134("path", {
              fill: "currentColor",
              d: "M416 896V128h192v768zm-288 0V448h192v448zm576 0V320h192v576z"
            })
          ]));
        }
      }), histogram_default = _sfc_main134;
      const _defineComponent135 = window["Vue"].defineComponent;
      const _createElementVNode135 = window["Vue"].createElementVNode;
      const _openBlock135 = window["Vue"].openBlock;
      const _createElementBlock135 = window["Vue"].createElementBlock;
      var _sfc_main135 = /* @__PURE__ */ _defineComponent135({
        name: "HomeFilled",
        __name: "home-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock135(), _createElementBlock135("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode135("path", {
              fill: "currentColor",
              d: "M512 128 128 447.936V896h255.936V640H640v256h255.936V447.936z"
            })
          ]));
        }
      }), home_filled_default = _sfc_main135;
      const _defineComponent136 = window["Vue"].defineComponent;
      const _createElementVNode136 = window["Vue"].createElementVNode;
      const _openBlock136 = window["Vue"].openBlock;
      const _createElementBlock136 = window["Vue"].createElementBlock;
      var _sfc_main136 = /* @__PURE__ */ _defineComponent136({
        name: "HotWater",
        __name: "hot-water",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock136(), _createElementBlock136("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode136("path", {
              fill: "currentColor",
              d: "M273.067 477.867h477.866V409.6H273.067zm0 68.266v51.2A187.733 187.733 0 0 0 460.8 785.067h102.4a187.733 187.733 0 0 0 187.733-187.734v-51.2zm-34.134-204.8h546.134a34.133 34.133 0 0 1 34.133 34.134v221.866a256 256 0 0 1-256 256H460.8a256 256 0 0 1-256-256V375.467a34.133 34.133 0 0 1 34.133-34.134M512 34.133a34.133 34.133 0 0 1 34.133 34.134v170.666a34.133 34.133 0 0 1-68.266 0V68.267A34.133 34.133 0 0 1 512 34.133M375.467 102.4a34.133 34.133 0 0 1 34.133 34.133v102.4a34.133 34.133 0 0 1-68.267 0v-102.4a34.133 34.133 0 0 1 34.134-34.133m273.066 0a34.133 34.133 0 0 1 34.134 34.133v102.4a34.133 34.133 0 1 1-68.267 0v-102.4a34.133 34.133 0 0 1 34.133-34.133M170.667 921.668h682.666a34.133 34.133 0 1 1 0 68.267H170.667a34.133 34.133 0 1 1 0-68.267"
            })
          ]));
        }
      }), hot_water_default = _sfc_main136;
      const _defineComponent137 = window["Vue"].defineComponent;
      const _createElementVNode137 = window["Vue"].createElementVNode;
      const _openBlock137 = window["Vue"].openBlock;
      const _createElementBlock137 = window["Vue"].createElementBlock;
      var _sfc_main137 = /* @__PURE__ */ _defineComponent137({
        name: "House",
        __name: "house",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock137(), _createElementBlock137("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode137("path", {
              fill: "currentColor",
              d: "M192 413.952V896h640V413.952L512 147.328zM139.52 374.4l352-293.312a32 32 0 0 1 40.96 0l352 293.312A32 32 0 0 1 896 398.976V928a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V398.976a32 32 0 0 1 11.52-24.576"
            })
          ]));
        }
      }), house_default = _sfc_main137;
      const _defineComponent138 = window["Vue"].defineComponent;
      const _createElementVNode138 = window["Vue"].createElementVNode;
      const _openBlock138 = window["Vue"].openBlock;
      const _createElementBlock138 = window["Vue"].createElementBlock;
      var _sfc_main138 = /* @__PURE__ */ _defineComponent138({
        name: "IceCreamRound",
        __name: "ice-cream-round",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock138(), _createElementBlock138("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode138("path", {
              fill: "currentColor",
              d: "m308.352 489.344 226.304 226.304a32 32 0 0 0 45.248 0L783.552 512A192 192 0 1 0 512 240.448L308.352 444.16a32 32 0 0 0 0 45.248zm135.744 226.304L308.352 851.392a96 96 0 0 1-135.744-135.744l135.744-135.744-45.248-45.248a96 96 0 0 1 0-135.808L466.752 195.2A256 256 0 0 1 828.8 557.248L625.152 760.96a96 96 0 0 1-135.808 0l-45.248-45.248zM398.848 670.4 353.6 625.152 217.856 760.896a32 32 0 0 0 45.248 45.248zm248.96-384.64a32 32 0 0 1 0 45.248L466.624 512a32 32 0 1 1-45.184-45.248l180.992-181.056a32 32 0 0 1 45.248 0zm90.496 90.496a32 32 0 0 1 0 45.248L557.248 602.496A32 32 0 1 1 512 557.248l180.992-180.992a32 32 0 0 1 45.312 0"
            })
          ]));
        }
      }), ice_cream_round_default = _sfc_main138;
      const _defineComponent139 = window["Vue"].defineComponent;
      const _createElementVNode139 = window["Vue"].createElementVNode;
      const _openBlock139 = window["Vue"].openBlock;
      const _createElementBlock139 = window["Vue"].createElementBlock;
      var _sfc_main139 = /* @__PURE__ */ _defineComponent139({
        name: "IceCreamSquare",
        __name: "ice-cream-square",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock139(), _createElementBlock139("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode139("path", {
              fill: "currentColor",
              d: "M416 640h256a32 32 0 0 0 32-32V160a32 32 0 0 0-32-32H352a32 32 0 0 0-32 32v448a32 32 0 0 0 32 32zm192 64v160a96 96 0 0 1-192 0V704h-64a96 96 0 0 1-96-96V160a96 96 0 0 1 96-96h320a96 96 0 0 1 96 96v448a96 96 0 0 1-96 96zm-64 0h-64v160a32 32 0 1 0 64 0z"
            })
          ]));
        }
      }), ice_cream_square_default = _sfc_main139;
      const _defineComponent140 = window["Vue"].defineComponent;
      const _createElementVNode140 = window["Vue"].createElementVNode;
      const _openBlock140 = window["Vue"].openBlock;
      const _createElementBlock140 = window["Vue"].createElementBlock;
      var _sfc_main140 = /* @__PURE__ */ _defineComponent140({
        name: "IceCream",
        __name: "ice-cream",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock140(), _createElementBlock140("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode140("path", {
              fill: "currentColor",
              d: "M128.64 448a208 208 0 0 1 193.536-191.552 224 224 0 0 1 445.248 15.488A208.13 208.13 0 0 1 894.784 448H896L548.8 983.68a32 32 0 0 1-53.248.704L128 448zm64.256 0h286.208a144 144 0 0 0-286.208 0m351.36 0h286.272a144 144 0 0 0-286.272 0m-294.848 64 271.808 396.608L778.24 512zM511.68 352.64a207.87 207.87 0 0 1 189.184-96.192 160 160 0 0 0-314.752 5.632c52.608 12.992 97.28 46.08 125.568 90.56"
            })
          ]));
        }
      }), ice_cream_default = _sfc_main140;
      const _defineComponent141 = window["Vue"].defineComponent;
      const _createElementVNode141 = window["Vue"].createElementVNode;
      const _openBlock141 = window["Vue"].openBlock;
      const _createElementBlock141 = window["Vue"].createElementBlock;
      var _sfc_main141 = /* @__PURE__ */ _defineComponent141({
        name: "IceDrink",
        __name: "ice-drink",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock141(), _createElementBlock141("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode141("path", {
              fill: "currentColor",
              d: "M512 448v128h239.68l16.064-128zm-64 0H256.256l16.064 128H448zm64-255.36V384h247.744A256.13 256.13 0 0 0 512 192.64m-64 8.064A256.45 256.45 0 0 0 264.256 384H448zm64-72.064A320.13 320.13 0 0 1 825.472 384H896a32 32 0 1 1 0 64h-64v1.92l-56.96 454.016A64 64 0 0 1 711.552 960H312.448a64 64 0 0 1-63.488-56.064L192 449.92V448h-64a32 32 0 0 1 0-64h70.528A320.38 320.38 0 0 1 448 135.04V96a96 96 0 0 1 96-96h128a32 32 0 1 1 0 64H544a32 32 0 0 0-32 32zM743.68 640H280.32l32.128 256h399.104z"
            })
          ]));
        }
      }), ice_drink_default = _sfc_main141;
      const _defineComponent142 = window["Vue"].defineComponent;
      const _createElementVNode142 = window["Vue"].createElementVNode;
      const _openBlock142 = window["Vue"].openBlock;
      const _createElementBlock142 = window["Vue"].createElementBlock;
      var _sfc_main142 = /* @__PURE__ */ _defineComponent142({
        name: "IceTea",
        __name: "ice-tea",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock142(), _createElementBlock142("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode142("path", {
              fill: "currentColor",
              d: "M197.696 259.648a320.128 320.128 0 0 1 628.608 0A96 96 0 0 1 896 352v64a96 96 0 0 1-71.616 92.864l-49.408 395.072A64 64 0 0 1 711.488 960H312.512a64 64 0 0 1-63.488-56.064l-49.408-395.072A96 96 0 0 1 128 416v-64a96 96 0 0 1 69.696-92.352M264.064 256h495.872a256.128 256.128 0 0 0-495.872 0m495.424 256H264.512l48 384h398.976zM224 448h576a32 32 0 0 0 32-32v-64a32 32 0 0 0-32-32H224a32 32 0 0 0-32 32v64a32 32 0 0 0 32 32m160 192h64v64h-64zm192 64h64v64h-64zm-128 64h64v64h-64zm64-192h64v64h-64z"
            })
          ]));
        }
      }), ice_tea_default = _sfc_main142;
      const _defineComponent143 = window["Vue"].defineComponent;
      const _createElementVNode143 = window["Vue"].createElementVNode;
      const _openBlock143 = window["Vue"].openBlock;
      const _createElementBlock143 = window["Vue"].createElementBlock;
      var _sfc_main143 = /* @__PURE__ */ _defineComponent143({
        name: "InfoFilled",
        __name: "info-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock143(), _createElementBlock143("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode143("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.99 12.99 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
            })
          ]));
        }
      }), info_filled_default = _sfc_main143;
      const _defineComponent144 = window["Vue"].defineComponent;
      const _createElementVNode144 = window["Vue"].createElementVNode;
      const _openBlock144 = window["Vue"].openBlock;
      const _createElementBlock144 = window["Vue"].createElementBlock;
      var _sfc_main144 = /* @__PURE__ */ _defineComponent144({
        name: "Iphone",
        __name: "iphone",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock144(), _createElementBlock144("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode144("path", {
              fill: "currentColor",
              d: "M224 768v96.064a64 64 0 0 0 64 64h448a64 64 0 0 0 64-64V768zm0-64h576V160a64 64 0 0 0-64-64H288a64 64 0 0 0-64 64zm32 288a96 96 0 0 1-96-96V128a96 96 0 0 1 96-96h512a96 96 0 0 1 96 96v768a96 96 0 0 1-96 96zm304-144a48 48 0 1 1-96 0 48 48 0 0 1 96 0"
            })
          ]));
        }
      }), iphone_default = _sfc_main144;
      const _defineComponent145 = window["Vue"].defineComponent;
      const _createElementVNode145 = window["Vue"].createElementVNode;
      const _openBlock145 = window["Vue"].openBlock;
      const _createElementBlock145 = window["Vue"].createElementBlock;
      var _sfc_main145 = /* @__PURE__ */ _defineComponent145({
        name: "Key",
        __name: "key",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock145(), _createElementBlock145("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode145("path", {
              fill: "currentColor",
              d: "M448 456.064V96a32 32 0 0 1 32-32.064L672 64a32 32 0 0 1 0 64H512v128h160a32 32 0 0 1 0 64H512v128a256 256 0 1 1-64 8.064M512 896a192 192 0 1 0 0-384 192 192 0 0 0 0 384"
            })
          ]));
        }
      }), key_default = _sfc_main145;
      const _defineComponent146 = window["Vue"].defineComponent;
      const _createElementVNode146 = window["Vue"].createElementVNode;
      const _openBlock146 = window["Vue"].openBlock;
      const _createElementBlock146 = window["Vue"].createElementBlock;
      var _sfc_main146 = /* @__PURE__ */ _defineComponent146({
        name: "KnifeFork",
        __name: "knife-fork",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock146(), _createElementBlock146("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode146("path", {
              fill: "currentColor",
              d: "M256 410.56V96a32 32 0 0 1 64 0v314.56A96 96 0 0 0 384 320V96a32 32 0 0 1 64 0v224a160 160 0 0 1-128 156.8V928a32 32 0 1 1-64 0V476.8A160 160 0 0 1 128 320V96a32 32 0 0 1 64 0v224a96 96 0 0 0 64 90.56m384-250.24V544h126.72c-3.328-78.72-12.928-147.968-28.608-207.744-14.336-54.528-46.848-113.344-98.112-175.872zM640 608v320a32 32 0 1 1-64 0V64h64c85.312 89.472 138.688 174.848 160 256s32 177.152 32 288z"
            })
          ]));
        }
      }), knife_fork_default = _sfc_main146;
      const _defineComponent147 = window["Vue"].defineComponent;
      const _createElementVNode147 = window["Vue"].createElementVNode;
      const _openBlock147 = window["Vue"].openBlock;
      const _createElementBlock147 = window["Vue"].createElementBlock;
      var _sfc_main147 = /* @__PURE__ */ _defineComponent147({
        name: "Lightning",
        __name: "lightning",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock147(), _createElementBlock147("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode147("path", {
              fill: "currentColor",
              d: "M288 671.36v64.128A239.81 239.81 0 0 1 63.744 496.192a240.32 240.32 0 0 1 199.488-236.8 256.128 256.128 0 0 1 487.872-30.976A256.064 256.064 0 0 1 736 734.016v-64.768a192 192 0 0 0 3.328-377.92l-35.2-6.592-12.8-33.408a192.064 192.064 0 0 0-365.952 23.232l-9.92 40.896-41.472 7.04a176.32 176.32 0 0 0-146.24 173.568c0 91.968 70.464 167.36 160.256 175.232z"
            }),
            _createElementVNode147("path", {
              fill: "currentColor",
              d: "M416 736a32 32 0 0 1-27.776-47.872l128-224a32 32 0 1 1 55.552 31.744L471.168 672H608a32 32 0 0 1 27.776 47.872l-128 224a32 32 0 1 1-55.68-31.744L552.96 736z"
            })
          ]));
        }
      }), lightning_default = _sfc_main147;
      const _defineComponent148 = window["Vue"].defineComponent;
      const _createElementVNode148 = window["Vue"].createElementVNode;
      const _openBlock148 = window["Vue"].openBlock;
      const _createElementBlock148 = window["Vue"].createElementBlock;
      var _sfc_main148 = /* @__PURE__ */ _defineComponent148({
        name: "Link",
        __name: "link",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock148(), _createElementBlock148("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode148("path", {
              fill: "currentColor",
              d: "M715.648 625.152 670.4 579.904l90.496-90.56c75.008-74.944 85.12-186.368 22.656-248.896-62.528-62.464-173.952-52.352-248.96 22.656L444.16 353.6l-45.248-45.248 90.496-90.496c100.032-99.968 251.968-110.08 339.456-22.656 87.488 87.488 77.312 239.424-22.656 339.456l-90.496 90.496zm-90.496 90.496-90.496 90.496C434.624 906.112 282.688 916.224 195.2 828.8c-87.488-87.488-77.312-239.424 22.656-339.456l90.496-90.496 45.248 45.248-90.496 90.56c-75.008 74.944-85.12 186.368-22.656 248.896 62.528 62.464 173.952 52.352 248.96-22.656l90.496-90.496zm0-362.048 45.248 45.248L398.848 670.4 353.6 625.152z"
            })
          ]));
        }
      }), link_default = _sfc_main148;
      const _defineComponent149 = window["Vue"].defineComponent;
      const _createElementVNode149 = window["Vue"].createElementVNode;
      const _openBlock149 = window["Vue"].openBlock;
      const _createElementBlock149 = window["Vue"].createElementBlock;
      var _sfc_main149 = /* @__PURE__ */ _defineComponent149({
        name: "List",
        __name: "list",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock149(), _createElementBlock149("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode149("path", {
              fill: "currentColor",
              d: "M704 192h160v736H160V192h160v64h384zM288 512h448v-64H288zm0 256h448v-64H288zm96-576V96h256v96z"
            })
          ]));
        }
      }), list_default = _sfc_main149;
      const _defineComponent150 = window["Vue"].defineComponent;
      const _createElementVNode150 = window["Vue"].createElementVNode;
      const _openBlock150 = window["Vue"].openBlock;
      const _createElementBlock150 = window["Vue"].createElementBlock;
      var _sfc_main150 = /* @__PURE__ */ _defineComponent150({
        name: "Loading",
        __name: "loading",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock150(), _createElementBlock150("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode150("path", {
              fill: "currentColor",
              d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248m452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248M828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0"
            })
          ]));
        }
      }), loading_default = _sfc_main150;
      const _defineComponent151 = window["Vue"].defineComponent;
      const _createElementVNode151 = window["Vue"].createElementVNode;
      const _openBlock151 = window["Vue"].openBlock;
      const _createElementBlock151 = window["Vue"].createElementBlock;
      var _sfc_main151 = /* @__PURE__ */ _defineComponent151({
        name: "LocationFilled",
        __name: "location-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock151(), _createElementBlock151("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode151("path", {
              fill: "currentColor",
              d: "M512 928c23.936 0 117.504-68.352 192.064-153.152C803.456 661.888 864 535.808 864 416c0-189.632-155.84-320-352-320S160 226.368 160 416c0 120.32 60.544 246.4 159.936 359.232C394.432 859.84 488 928 512 928m0-435.2a64 64 0 1 0 0-128 64 64 0 0 0 0 128m0 140.8a204.8 204.8 0 1 1 0-409.6 204.8 204.8 0 0 1 0 409.6"
            })
          ]));
        }
      }), location_filled_default = _sfc_main151;
      const _defineComponent152 = window["Vue"].defineComponent;
      const _createElementVNode152 = window["Vue"].createElementVNode;
      const _openBlock152 = window["Vue"].openBlock;
      const _createElementBlock152 = window["Vue"].createElementBlock;
      var _sfc_main152 = /* @__PURE__ */ _defineComponent152({
        name: "LocationInformation",
        __name: "location-information",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock152(), _createElementBlock152("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode152("path", {
              fill: "currentColor",
              d: "M288 896h448q32 0 32 32t-32 32H288q-32 0-32-32t32-32"
            }),
            _createElementVNode152("path", {
              fill: "currentColor",
              d: "M800 416a288 288 0 1 0-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416M512 960C277.312 746.688 160 565.312 160 416a352 352 0 0 1 704 0c0 149.312-117.312 330.688-352 544"
            }),
            _createElementVNode152("path", {
              fill: "currentColor",
              d: "M512 512a96 96 0 1 0 0-192 96 96 0 0 0 0 192m0 64a160 160 0 1 1 0-320 160 160 0 0 1 0 320"
            })
          ]));
        }
      }), location_information_default = _sfc_main152;
      const _defineComponent153 = window["Vue"].defineComponent;
      const _createElementVNode153 = window["Vue"].createElementVNode;
      const _openBlock153 = window["Vue"].openBlock;
      const _createElementBlock153 = window["Vue"].createElementBlock;
      var _sfc_main153 = /* @__PURE__ */ _defineComponent153({
        name: "Location",
        __name: "location",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock153(), _createElementBlock153("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode153("path", {
              fill: "currentColor",
              d: "M800 416a288 288 0 1 0-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416M512 960C277.312 746.688 160 565.312 160 416a352 352 0 0 1 704 0c0 149.312-117.312 330.688-352 544"
            }),
            _createElementVNode153("path", {
              fill: "currentColor",
              d: "M512 512a96 96 0 1 0 0-192 96 96 0 0 0 0 192m0 64a160 160 0 1 1 0-320 160 160 0 0 1 0 320"
            })
          ]));
        }
      }), location_default = _sfc_main153;
      const _defineComponent154 = window["Vue"].defineComponent;
      const _createElementVNode154 = window["Vue"].createElementVNode;
      const _openBlock154 = window["Vue"].openBlock;
      const _createElementBlock154 = window["Vue"].createElementBlock;
      var _sfc_main154 = /* @__PURE__ */ _defineComponent154({
        name: "Lock",
        __name: "lock",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock154(), _createElementBlock154("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode154("path", {
              fill: "currentColor",
              d: "M224 448a32 32 0 0 0-32 32v384a32 32 0 0 0 32 32h576a32 32 0 0 0 32-32V480a32 32 0 0 0-32-32zm0-64h576a96 96 0 0 1 96 96v384a96 96 0 0 1-96 96H224a96 96 0 0 1-96-96V480a96 96 0 0 1 96-96"
            }),
            _createElementVNode154("path", {
              fill: "currentColor",
              d: "M512 544a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V576a32 32 0 0 1 32-32m192-160v-64a192 192 0 1 0-384 0v64zM512 64a256 256 0 0 1 256 256v128H256V320A256 256 0 0 1 512 64"
            })
          ]));
        }
      }), lock_default = _sfc_main154;
      const _defineComponent155 = window["Vue"].defineComponent;
      const _createElementVNode155 = window["Vue"].createElementVNode;
      const _openBlock155 = window["Vue"].openBlock;
      const _createElementBlock155 = window["Vue"].createElementBlock;
      var _sfc_main155 = /* @__PURE__ */ _defineComponent155({
        name: "Lollipop",
        __name: "lollipop",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock155(), _createElementBlock155("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode155("path", {
              fill: "currentColor",
              d: "M513.28 448a64 64 0 1 1 76.544 49.728A96 96 0 0 0 768 448h64a160 160 0 0 1-320 0zm-126.976-29.696a256 256 0 1 0 43.52-180.48A256 256 0 0 1 832 448h-64a192 192 0 0 0-381.696-29.696m105.664 249.472L285.696 874.048a96 96 0 0 1-135.68-135.744l206.208-206.272a320 320 0 1 1 135.744 135.744m-54.464-36.032a322 322 0 0 1-45.248-45.248L195.2 783.552a32 32 0 1 0 45.248 45.248l197.056-197.12z"
            })
          ]));
        }
      }), lollipop_default = _sfc_main155;
      const _defineComponent156 = window["Vue"].defineComponent;
      const _createElementVNode156 = window["Vue"].createElementVNode;
      const _openBlock156 = window["Vue"].openBlock;
      const _createElementBlock156 = window["Vue"].createElementBlock;
      var _sfc_main156 = /* @__PURE__ */ _defineComponent156({
        name: "MagicStick",
        __name: "magic-stick",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock156(), _createElementBlock156("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode156("path", {
              fill: "currentColor",
              d: "M512 64h64v192h-64zm0 576h64v192h-64zM160 480v-64h192v64zm576 0v-64h192v64zM249.856 199.04l45.248-45.184L430.848 289.6 385.6 334.848 249.856 199.104zM657.152 606.4l45.248-45.248 135.744 135.744-45.248 45.248zM114.048 923.2 68.8 877.952l316.8-316.8 45.248 45.248zM702.4 334.848 657.152 289.6l135.744-135.744 45.248 45.248z"
            })
          ]));
        }
      }), magic_stick_default = _sfc_main156;
      const _defineComponent157 = window["Vue"].defineComponent;
      const _createElementVNode157 = window["Vue"].createElementVNode;
      const _openBlock157 = window["Vue"].openBlock;
      const _createElementBlock157 = window["Vue"].createElementBlock;
      var _sfc_main157 = /* @__PURE__ */ _defineComponent157({
        name: "Magnet",
        __name: "magnet",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock157(), _createElementBlock157("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode157("path", {
              fill: "currentColor",
              d: "M832 320V192H704v320a192 192 0 1 1-384 0V192H192v128h128v64H192v128a320 320 0 0 0 640 0V384H704v-64zM640 512V128h256v384a384 384 0 1 1-768 0V128h256v384a128 128 0 1 0 256 0"
            })
          ]));
        }
      }), magnet_default = _sfc_main157;
      const _defineComponent158 = window["Vue"].defineComponent;
      const _createElementVNode158 = window["Vue"].createElementVNode;
      const _openBlock158 = window["Vue"].openBlock;
      const _createElementBlock158 = window["Vue"].createElementBlock;
      var _sfc_main158 = /* @__PURE__ */ _defineComponent158({
        name: "Male",
        __name: "male",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock158(), _createElementBlock158("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode158("path", {
              fill: "currentColor",
              d: "M399.5 849.5a225 225 0 1 0 0-450 225 225 0 0 0 0 450m0 56.25a281.25 281.25 0 1 1 0-562.5 281.25 281.25 0 0 1 0 562.5m253.125-787.5h225q28.125 0 28.125 28.125T877.625 174.5h-225q-28.125 0-28.125-28.125t28.125-28.125"
            }),
            _createElementVNode158("path", {
              fill: "currentColor",
              d: "M877.625 118.25q28.125 0 28.125 28.125v225q0 28.125-28.125 28.125T849.5 371.375v-225q0-28.125 28.125-28.125"
            }),
            _createElementVNode158("path", {
              fill: "currentColor",
              d: "M604.813 458.9 565.1 419.131l292.613-292.668 39.825 39.824z"
            })
          ]));
        }
      }), male_default = _sfc_main158;
      const _defineComponent159 = window["Vue"].defineComponent;
      const _createElementVNode159 = window["Vue"].createElementVNode;
      const _openBlock159 = window["Vue"].openBlock;
      const _createElementBlock159 = window["Vue"].createElementBlock;
      var _sfc_main159 = /* @__PURE__ */ _defineComponent159({
        name: "Management",
        __name: "management",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock159(), _createElementBlock159("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode159("path", {
              fill: "currentColor",
              d: "M576 128v288l96-96 96 96V128h128v768H320V128zm-448 0h128v768H128z"
            })
          ]));
        }
      }), management_default = _sfc_main159;
      const _defineComponent160 = window["Vue"].defineComponent;
      const _createElementVNode160 = window["Vue"].createElementVNode;
      const _openBlock160 = window["Vue"].openBlock;
      const _createElementBlock160 = window["Vue"].createElementBlock;
      var _sfc_main160 = /* @__PURE__ */ _defineComponent160({
        name: "MapLocation",
        __name: "map-location",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock160(), _createElementBlock160("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode160("path", {
              fill: "currentColor",
              d: "M800 416a288 288 0 1 0-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416M512 960C277.312 746.688 160 565.312 160 416a352 352 0 0 1 704 0c0 149.312-117.312 330.688-352 544"
            }),
            _createElementVNode160("path", {
              fill: "currentColor",
              d: "M512 448a64 64 0 1 0 0-128 64 64 0 0 0 0 128m0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256m345.6 192L960 960H672v-64H352v64H64l102.4-256zm-68.928 0H235.328l-76.8 192h706.944z"
            })
          ]));
        }
      }), map_location_default = _sfc_main160;
      const _defineComponent161 = window["Vue"].defineComponent;
      const _createElementVNode161 = window["Vue"].createElementVNode;
      const _openBlock161 = window["Vue"].openBlock;
      const _createElementBlock161 = window["Vue"].createElementBlock;
      var _sfc_main161 = /* @__PURE__ */ _defineComponent161({
        name: "Medal",
        __name: "medal",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock161(), _createElementBlock161("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode161("path", {
              fill: "currentColor",
              d: "M512 896a256 256 0 1 0 0-512 256 256 0 0 0 0 512m0 64a320 320 0 1 1 0-640 320 320 0 0 1 0 640"
            }),
            _createElementVNode161("path", {
              fill: "currentColor",
              d: "M576 128H448v200a286.7 286.7 0 0 1 64-8c19.52 0 40.832 2.688 64 8zm64 0v219.648c24.448 9.088 50.56 20.416 78.4 33.92L757.44 128zm-256 0H266.624l39.04 253.568c27.84-13.504 53.888-24.832 78.336-33.92zM229.312 64h565.376a32 32 0 0 1 31.616 36.864L768 480c-113.792-64-199.104-96-256-96s-142.208 32-256 96l-58.304-379.136A32 32 0 0 1 229.312 64"
            })
          ]));
        }
      }), medal_default = _sfc_main161;
      const _defineComponent162 = window["Vue"].defineComponent;
      const _createElementVNode162 = window["Vue"].createElementVNode;
      const _openBlock162 = window["Vue"].openBlock;
      const _createElementBlock162 = window["Vue"].createElementBlock;
      var _sfc_main162 = /* @__PURE__ */ _defineComponent162({
        name: "Memo",
        __name: "memo",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock162(), _createElementBlock162("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            "xml:space": "preserve",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode162("path", {
              fill: "currentColor",
              d: "M480 320h192c21.33 0 32-10.67 32-32s-10.67-32-32-32H480c-21.33 0-32 10.67-32 32s10.67 32 32 32"
            }),
            _createElementVNode162("path", {
              fill: "currentColor",
              d: "M887.01 72.99C881.01 67 873.34 64 864 64H160c-9.35 0-17.02 3-23.01 8.99C131 78.99 128 86.66 128 96v832c0 9.35 2.99 17.02 8.99 23.01S150.66 960 160 960h704c9.35 0 17.02-2.99 23.01-8.99S896 937.34 896 928V96c0-9.35-3-17.02-8.99-23.01M192 896V128h96v768zm640 0H352V128h480z"
            }),
            _createElementVNode162("path", {
              fill: "currentColor",
              d: "M480 512h192c21.33 0 32-10.67 32-32s-10.67-32-32-32H480c-21.33 0-32 10.67-32 32s10.67 32 32 32m0 192h192c21.33 0 32-10.67 32-32s-10.67-32-32-32H480c-21.33 0-32 10.67-32 32s10.67 32 32 32"
            })
          ]));
        }
      }), memo_default = _sfc_main162;
      const _defineComponent163 = window["Vue"].defineComponent;
      const _createElementVNode163 = window["Vue"].createElementVNode;
      const _openBlock163 = window["Vue"].openBlock;
      const _createElementBlock163 = window["Vue"].createElementBlock;
      var _sfc_main163 = /* @__PURE__ */ _defineComponent163({
        name: "Menu",
        __name: "menu",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock163(), _createElementBlock163("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode163("path", {
              fill: "currentColor",
              d: "M160 448a32 32 0 0 1-32-32V160.064a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V416a32 32 0 0 1-32 32zm448 0a32 32 0 0 1-32-32V160.064a32 32 0 0 1 32-32h255.936a32 32 0 0 1 32 32V416a32 32 0 0 1-32 32zM160 896a32 32 0 0 1-32-32V608a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32v256a32 32 0 0 1-32 32zm448 0a32 32 0 0 1-32-32V608a32 32 0 0 1 32-32h255.936a32 32 0 0 1 32 32v256a32 32 0 0 1-32 32z"
            })
          ]));
        }
      }), menu_default = _sfc_main163;
      const _defineComponent164 = window["Vue"].defineComponent;
      const _createElementVNode164 = window["Vue"].createElementVNode;
      const _openBlock164 = window["Vue"].openBlock;
      const _createElementBlock164 = window["Vue"].createElementBlock;
      var _sfc_main164 = /* @__PURE__ */ _defineComponent164({
        name: "MessageBox",
        __name: "message-box",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock164(), _createElementBlock164("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode164("path", {
              fill: "currentColor",
              d: "M288 384h448v64H288zm96-128h256v64H384zM131.456 512H384v128h256V512h252.544L721.856 192H302.144zM896 576H704v128H320V576H128v256h768zM275.776 128h472.448a32 32 0 0 1 28.608 17.664l179.84 359.552A32 32 0 0 1 960 519.552V864a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V519.552a32 32 0 0 1 3.392-14.336l179.776-359.552A32 32 0 0 1 275.776 128"
            })
          ]));
        }
      }), message_box_default = _sfc_main164;
      const _defineComponent165 = window["Vue"].defineComponent;
      const _createElementVNode165 = window["Vue"].createElementVNode;
      const _openBlock165 = window["Vue"].openBlock;
      const _createElementBlock165 = window["Vue"].createElementBlock;
      var _sfc_main165 = /* @__PURE__ */ _defineComponent165({
        name: "Message",
        __name: "message",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock165(), _createElementBlock165("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode165("path", {
              fill: "currentColor",
              d: "M128 224v512a64 64 0 0 0 64 64h640a64 64 0 0 0 64-64V224zm0-64h768a64 64 0 0 1 64 64v512a128 128 0 0 1-128 128H192A128 128 0 0 1 64 736V224a64 64 0 0 1 64-64"
            }),
            _createElementVNode165("path", {
              fill: "currentColor",
              d: "M904 224 656.512 506.88a192 192 0 0 1-289.024 0L120 224zm-698.944 0 210.56 240.704a128 128 0 0 0 192.704 0L818.944 224z"
            })
          ]));
        }
      }), message_default = _sfc_main165;
      const _defineComponent166 = window["Vue"].defineComponent;
      const _createElementVNode166 = window["Vue"].createElementVNode;
      const _openBlock166 = window["Vue"].openBlock;
      const _createElementBlock166 = window["Vue"].createElementBlock;
      var _sfc_main166 = /* @__PURE__ */ _defineComponent166({
        name: "Mic",
        __name: "mic",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock166(), _createElementBlock166("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode166("path", {
              fill: "currentColor",
              d: "M480 704h160a64 64 0 0 0 64-64v-32h-96a32 32 0 0 1 0-64h96v-96h-96a32 32 0 0 1 0-64h96v-96h-96a32 32 0 0 1 0-64h96v-32a64 64 0 0 0-64-64H384a64 64 0 0 0-64 64v32h96a32 32 0 0 1 0 64h-96v96h96a32 32 0 0 1 0 64h-96v96h96a32 32 0 0 1 0 64h-96v32a64 64 0 0 0 64 64zm64 64v128h192a32 32 0 1 1 0 64H288a32 32 0 1 1 0-64h192V768h-96a128 128 0 0 1-128-128V192A128 128 0 0 1 384 64h256a128 128 0 0 1 128 128v448a128 128 0 0 1-128 128z"
            })
          ]));
        }
      }), mic_default = _sfc_main166;
      const _defineComponent167 = window["Vue"].defineComponent;
      const _createElementVNode167 = window["Vue"].createElementVNode;
      const _openBlock167 = window["Vue"].openBlock;
      const _createElementBlock167 = window["Vue"].createElementBlock;
      var _sfc_main167 = /* @__PURE__ */ _defineComponent167({
        name: "Microphone",
        __name: "microphone",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock167(), _createElementBlock167("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode167("path", {
              fill: "currentColor",
              d: "M512 128a128 128 0 0 0-128 128v256a128 128 0 1 0 256 0V256a128 128 0 0 0-128-128m0-64a192 192 0 0 1 192 192v256a192 192 0 1 1-384 0V256A192 192 0 0 1 512 64m-32 832v-64a288 288 0 0 1-288-288v-32a32 32 0 0 1 64 0v32a224 224 0 0 0 224 224h64a224 224 0 0 0 224-224v-32a32 32 0 1 1 64 0v32a288 288 0 0 1-288 288v64h64a32 32 0 1 1 0 64H416a32 32 0 1 1 0-64z"
            })
          ]));
        }
      }), microphone_default = _sfc_main167;
      const _defineComponent168 = window["Vue"].defineComponent;
      const _createElementVNode168 = window["Vue"].createElementVNode;
      const _openBlock168 = window["Vue"].openBlock;
      const _createElementBlock168 = window["Vue"].createElementBlock;
      var _sfc_main168 = /* @__PURE__ */ _defineComponent168({
        name: "MilkTea",
        __name: "milk-tea",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock168(), _createElementBlock168("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode168("path", {
              fill: "currentColor",
              d: "M416 128V96a96 96 0 0 1 96-96h128a32 32 0 1 1 0 64H512a32 32 0 0 0-32 32v32h320a96 96 0 0 1 11.712 191.296l-39.68 581.056A64 64 0 0 1 708.224 960H315.776a64 64 0 0 1-63.872-59.648l-39.616-581.056A96 96 0 0 1 224 128zM276.48 320l39.296 576h392.448l4.8-70.784a224.064 224.064 0 0 1 30.016-439.808L747.52 320zM224 256h576a32 32 0 1 0 0-64H224a32 32 0 0 0 0 64m493.44 503.872 21.12-309.12a160 160 0 0 0-21.12 309.12"
            })
          ]));
        }
      }), milk_tea_default = _sfc_main168;
      const _defineComponent169 = window["Vue"].defineComponent;
      const _createElementVNode169 = window["Vue"].createElementVNode;
      const _openBlock169 = window["Vue"].openBlock;
      const _createElementBlock169 = window["Vue"].createElementBlock;
      var _sfc_main169 = /* @__PURE__ */ _defineComponent169({
        name: "Minus",
        __name: "minus",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock169(), _createElementBlock169("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode169("path", {
              fill: "currentColor",
              d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
            })
          ]));
        }
      }), minus_default = _sfc_main169;
      const _defineComponent170 = window["Vue"].defineComponent;
      const _createElementVNode170 = window["Vue"].createElementVNode;
      const _openBlock170 = window["Vue"].openBlock;
      const _createElementBlock170 = window["Vue"].createElementBlock;
      var _sfc_main170 = /* @__PURE__ */ _defineComponent170({
        name: "Money",
        __name: "money",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock170(), _createElementBlock170("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode170("path", {
              fill: "currentColor",
              d: "M256 640v192h640V384H768v-64h150.976c14.272 0 19.456 1.472 24.64 4.288a29.06 29.06 0 0 1 12.16 12.096c2.752 5.184 4.224 10.368 4.224 24.64v493.952c0 14.272-1.472 19.456-4.288 24.64a29.06 29.06 0 0 1-12.096 12.16c-5.184 2.752-10.368 4.224-24.64 4.224H233.024c-14.272 0-19.456-1.472-24.64-4.288a29.06 29.06 0 0 1-12.16-12.096c-2.688-5.184-4.224-10.368-4.224-24.576V640z"
            }),
            _createElementVNode170("path", {
              fill: "currentColor",
              d: "M768 192H128v448h640zm64-22.976v493.952c0 14.272-1.472 19.456-4.288 24.64a29.06 29.06 0 0 1-12.096 12.16c-5.184 2.752-10.368 4.224-24.64 4.224H105.024c-14.272 0-19.456-1.472-24.64-4.288a29.06 29.06 0 0 1-12.16-12.096C65.536 682.432 64 677.248 64 663.04V169.024c0-14.272 1.472-19.456 4.288-24.64a29.06 29.06 0 0 1 12.096-12.16C85.568 129.536 90.752 128 104.96 128h685.952c14.272 0 19.456 1.472 24.64 4.288a29.06 29.06 0 0 1 12.16 12.096c2.752 5.184 4.224 10.368 4.224 24.64z"
            }),
            _createElementVNode170("path", {
              fill: "currentColor",
              d: "M448 576a160 160 0 1 1 0-320 160 160 0 0 1 0 320m0-64a96 96 0 1 0 0-192 96 96 0 0 0 0 192"
            })
          ]));
        }
      }), money_default = _sfc_main170;
      const _defineComponent171 = window["Vue"].defineComponent;
      const _createElementVNode171 = window["Vue"].createElementVNode;
      const _openBlock171 = window["Vue"].openBlock;
      const _createElementBlock171 = window["Vue"].createElementBlock;
      var _sfc_main171 = /* @__PURE__ */ _defineComponent171({
        name: "Monitor",
        __name: "monitor",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock171(), _createElementBlock171("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode171("path", {
              fill: "currentColor",
              d: "M544 768v128h192a32 32 0 1 1 0 64H288a32 32 0 1 1 0-64h192V768H192A128 128 0 0 1 64 640V256a128 128 0 0 1 128-128h640a128 128 0 0 1 128 128v384a128 128 0 0 1-128 128zM192 192a64 64 0 0 0-64 64v384a64 64 0 0 0 64 64h640a64 64 0 0 0 64-64V256a64 64 0 0 0-64-64z"
            })
          ]));
        }
      }), monitor_default = _sfc_main171;
      const _defineComponent172 = window["Vue"].defineComponent;
      const _createElementVNode172 = window["Vue"].createElementVNode;
      const _openBlock172 = window["Vue"].openBlock;
      const _createElementBlock172 = window["Vue"].createElementBlock;
      var _sfc_main172 = /* @__PURE__ */ _defineComponent172({
        name: "MoonNight",
        __name: "moon-night",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock172(), _createElementBlock172("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode172("path", {
              fill: "currentColor",
              d: "M384 512a448 448 0 0 1 215.872-383.296A384 384 0 0 0 213.76 640h188.8A448.3 448.3 0 0 1 384 512M171.136 704a448 448 0 0 1 636.992-575.296A384 384 0 0 0 499.328 704h-328.32z"
            }),
            _createElementVNode172("path", {
              fill: "currentColor",
              d: "M32 640h960q32 0 32 32t-32 32H32q-32 0-32-32t32-32m128 128h384a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64m160 127.68 224 .256a32 32 0 0 1 32 32V928a32 32 0 0 1-32 32l-224-.384a32 32 0 0 1-32-32v-.064a32 32 0 0 1 32-32z"
            })
          ]));
        }
      }), moon_night_default = _sfc_main172;
      const _defineComponent173 = window["Vue"].defineComponent;
      const _createElementVNode173 = window["Vue"].createElementVNode;
      const _openBlock173 = window["Vue"].openBlock;
      const _createElementBlock173 = window["Vue"].createElementBlock;
      var _sfc_main173 = /* @__PURE__ */ _defineComponent173({
        name: "Moon",
        __name: "moon",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock173(), _createElementBlock173("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode173("path", {
              fill: "currentColor",
              d: "M240.448 240.448a384 384 0 1 0 559.424 525.696 448 448 0 0 1-542.016-542.08 391 391 0 0 0-17.408 16.384m181.056 362.048a384 384 0 0 0 525.632 16.384A448 448 0 1 1 405.056 76.8a384 384 0 0 0 16.448 525.696"
            })
          ]));
        }
      }), moon_default = _sfc_main173;
      const _defineComponent174 = window["Vue"].defineComponent;
      const _createElementVNode174 = window["Vue"].createElementVNode;
      const _openBlock174 = window["Vue"].openBlock;
      const _createElementBlock174 = window["Vue"].createElementBlock;
      var _sfc_main174 = /* @__PURE__ */ _defineComponent174({
        name: "MoreFilled",
        __name: "more-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock174(), _createElementBlock174("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode174("path", {
              fill: "currentColor",
              d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224"
            })
          ]));
        }
      }), more_filled_default = _sfc_main174;
      const _defineComponent175 = window["Vue"].defineComponent;
      const _createElementVNode175 = window["Vue"].createElementVNode;
      const _openBlock175 = window["Vue"].openBlock;
      const _createElementBlock175 = window["Vue"].createElementBlock;
      var _sfc_main175 = /* @__PURE__ */ _defineComponent175({
        name: "More",
        __name: "more",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock175(), _createElementBlock175("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode175("path", {
              fill: "currentColor",
              d: "M176 416a112 112 0 1 0 0 224 112 112 0 0 0 0-224m0 64a48 48 0 1 1 0 96 48 48 0 0 1 0-96m336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224m0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96m336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224m0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96"
            })
          ]));
        }
      }), more_default = _sfc_main175;
      const _defineComponent176 = window["Vue"].defineComponent;
      const _createElementVNode176 = window["Vue"].createElementVNode;
      const _openBlock176 = window["Vue"].openBlock;
      const _createElementBlock176 = window["Vue"].createElementBlock;
      var _sfc_main176 = /* @__PURE__ */ _defineComponent176({
        name: "MostlyCloudy",
        __name: "mostly-cloudy",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock176(), _createElementBlock176("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode176("path", {
              fill: "currentColor",
              d: "M737.216 357.952 704 349.824l-11.776-32a192.064 192.064 0 0 0-367.424 23.04l-8.96 39.04-39.04 8.96A192.064 192.064 0 0 0 320 768h368a207.81 207.81 0 0 0 207.808-208 208.32 208.32 0 0 0-158.592-202.048m15.168-62.208A272.32 272.32 0 0 1 959.744 560a271.81 271.81 0 0 1-271.552 272H320a256 256 0 0 1-57.536-505.536 256.128 256.128 0 0 1 489.92-30.72"
            })
          ]));
        }
      }), mostly_cloudy_default = _sfc_main176;
      const _defineComponent177 = window["Vue"].defineComponent;
      const _createElementVNode177 = window["Vue"].createElementVNode;
      const _openBlock177 = window["Vue"].openBlock;
      const _createElementBlock177 = window["Vue"].createElementBlock;
      var _sfc_main177 = /* @__PURE__ */ _defineComponent177({
        name: "Mouse",
        __name: "mouse",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock177(), _createElementBlock177("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode177("path", {
              fill: "currentColor",
              d: "M438.144 256c-68.352 0-92.736 4.672-117.76 18.112q-30.144 16.128-46.272 46.272C260.672 345.408 256 369.792 256 438.144v275.712c0 68.352 4.672 92.736 18.112 117.76q16.128 30.144 46.272 46.272C345.408 891.328 369.792 896 438.144 896h147.712c68.352 0 92.736-4.672 117.76-18.112q30.144-16.128 46.272-46.272C763.328 806.592 768 782.208 768 713.856V438.144c0-68.352-4.672-92.736-18.112-117.76a110.46 110.46 0 0 0-46.272-46.272C678.592 260.672 654.208 256 585.856 256zm0-64h147.712c85.568 0 116.608 8.96 147.904 25.6 31.36 16.768 55.872 41.344 72.576 72.64C823.104 321.536 832 352.576 832 438.08v275.84c0 85.504-8.96 116.544-25.6 147.84a174.46 174.46 0 0 1-72.64 72.576C702.464 951.104 671.424 960 585.92 960H438.08c-85.504 0-116.544-8.96-147.84-25.6a174.46 174.46 0 0 1-72.64-72.704c-16.768-31.296-25.664-62.336-25.664-147.84v-275.84c0-85.504 8.96-116.544 25.6-147.84a174.46 174.46 0 0 1 72.768-72.576c31.232-16.704 62.272-25.6 147.776-25.6z"
            }),
            _createElementVNode177("path", {
              fill: "currentColor",
              d: "M512 320q32 0 32 32v128q0 32-32 32t-32-32V352q0-32 32-32m32-96a32 32 0 0 1-64 0v-64a32 32 0 0 0-32-32h-96a32 32 0 0 1 0-64h96a96 96 0 0 1 96 96z"
            })
          ]));
        }
      }), mouse_default = _sfc_main177;
      const _defineComponent178 = window["Vue"].defineComponent;
      const _createElementVNode178 = window["Vue"].createElementVNode;
      const _openBlock178 = window["Vue"].openBlock;
      const _createElementBlock178 = window["Vue"].createElementBlock;
      var _sfc_main178 = /* @__PURE__ */ _defineComponent178({
        name: "Mug",
        __name: "mug",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock178(), _createElementBlock178("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode178("path", {
              fill: "currentColor",
              d: "M736 800V160H160v640a64 64 0 0 0 64 64h448a64 64 0 0 0 64-64m64-544h63.552a96 96 0 0 1 96 96v224a96 96 0 0 1-96 96H800v128a128 128 0 0 1-128 128H224A128 128 0 0 1 96 800V128a32 32 0 0 1 32-32h640a32 32 0 0 1 32 32zm0 64v288h63.552a32 32 0 0 0 32-32V352a32 32 0 0 0-32-32z"
            })
          ]));
        }
      }), mug_default = _sfc_main178;
      const _defineComponent179 = window["Vue"].defineComponent;
      const _createElementVNode179 = window["Vue"].createElementVNode;
      const _openBlock179 = window["Vue"].openBlock;
      const _createElementBlock179 = window["Vue"].createElementBlock;
      var _sfc_main179 = /* @__PURE__ */ _defineComponent179({
        name: "MuteNotification",
        __name: "mute-notification",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock179(), _createElementBlock179("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode179("path", {
              fill: "currentColor",
              d: "m241.216 832 63.616-64H768V448c0-42.368-10.24-82.304-28.48-117.504l46.912-47.232C815.36 331.392 832 387.84 832 448v320h96a32 32 0 1 1 0 64zm-90.24 0H96a32 32 0 1 1 0-64h96V448a320.13 320.13 0 0 1 256-313.6V128a64 64 0 1 1 128 0v6.4a319.55 319.55 0 0 1 171.648 97.088l-45.184 45.44A256 256 0 0 0 256 448v278.336L151.04 832zM448 896h128a64 64 0 0 1-128 0"
            }),
            _createElementVNode179("path", {
              fill: "currentColor",
              d: "M150.72 859.072a32 32 0 0 1-45.44-45.056l704-708.544a32 32 0 0 1 45.44 45.056z"
            })
          ]));
        }
      }), mute_notification_default = _sfc_main179;
      const _defineComponent180 = window["Vue"].defineComponent;
      const _createElementVNode180 = window["Vue"].createElementVNode;
      const _openBlock180 = window["Vue"].openBlock;
      const _createElementBlock180 = window["Vue"].createElementBlock;
      var _sfc_main180 = /* @__PURE__ */ _defineComponent180({
        name: "Mute",
        __name: "mute",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock180(), _createElementBlock180("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode180("path", {
              fill: "currentColor",
              d: "m412.16 592.128-45.44 45.44A191.23 191.23 0 0 1 320 512V256a192 192 0 1 1 384 0v44.352l-64 64V256a128 128 0 1 0-256 0v256c0 30.336 10.56 58.24 28.16 80.128m51.968 38.592A128 128 0 0 0 640 512v-57.152l64-64V512a192 192 0 0 1-287.68 166.528zM314.88 779.968l46.144-46.08A223 223 0 0 0 480 768h64a224 224 0 0 0 224-224v-32a32 32 0 1 1 64 0v32a288 288 0 0 1-288 288v64h64a32 32 0 1 1 0 64H416a32 32 0 1 1 0-64h64v-64c-61.44 0-118.4-19.2-165.12-52.032M266.752 737.6A286.98 286.98 0 0 1 192 544v-32a32 32 0 0 1 64 0v32c0 56.832 21.184 108.8 56.064 148.288z"
            }),
            _createElementVNode180("path", {
              fill: "currentColor",
              d: "M150.72 859.072a32 32 0 0 1-45.44-45.056l704-708.544a32 32 0 0 1 45.44 45.056z"
            })
          ]));
        }
      }), mute_default = _sfc_main180;
      const _defineComponent181 = window["Vue"].defineComponent;
      const _createElementVNode181 = window["Vue"].createElementVNode;
      const _openBlock181 = window["Vue"].openBlock;
      const _createElementBlock181 = window["Vue"].createElementBlock;
      var _sfc_main181 = /* @__PURE__ */ _defineComponent181({
        name: "NoSmoking",
        __name: "no-smoking",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock181(), _createElementBlock181("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode181("path", {
              fill: "currentColor",
              d: "M440.256 576H256v128h56.256l-64 64H224a32 32 0 0 1-32-32V544a32 32 0 0 1 32-32h280.256zm143.488 128H704V583.744L775.744 512H928a32 32 0 0 1 32 32v192a32 32 0 0 1-32 32H519.744zM768 576v128h128V576zm-29.696-207.552 45.248 45.248-497.856 497.856-45.248-45.248zM256 64h64v320h-64zM128 192h64v192h-64zM64 512h64v256H64z"
            })
          ]));
        }
      }), no_smoking_default = _sfc_main181;
      const _defineComponent182 = window["Vue"].defineComponent;
      const _createElementVNode182 = window["Vue"].createElementVNode;
      const _openBlock182 = window["Vue"].openBlock;
      const _createElementBlock182 = window["Vue"].createElementBlock;
      var _sfc_main182 = /* @__PURE__ */ _defineComponent182({
        name: "Notebook",
        __name: "notebook",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock182(), _createElementBlock182("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode182("path", {
              fill: "currentColor",
              d: "M192 128v768h640V128zm-32-64h704a32 32 0 0 1 32 32v832a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32"
            }),
            _createElementVNode182("path", {
              fill: "currentColor",
              d: "M672 128h64v768h-64zM96 192h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32m0 192h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32m0 192h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32m0 192h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32"
            })
          ]));
        }
      }), notebook_default = _sfc_main182;
      const _defineComponent183 = window["Vue"].defineComponent;
      const _createElementVNode183 = window["Vue"].createElementVNode;
      const _openBlock183 = window["Vue"].openBlock;
      const _createElementBlock183 = window["Vue"].createElementBlock;
      var _sfc_main183 = /* @__PURE__ */ _defineComponent183({
        name: "Notification",
        __name: "notification",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock183(), _createElementBlock183("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode183("path", {
              fill: "currentColor",
              d: "M512 128v64H256a64 64 0 0 0-64 64v512a64 64 0 0 0 64 64h512a64 64 0 0 0 64-64V512h64v256a128 128 0 0 1-128 128H256a128 128 0 0 1-128-128V256a128 128 0 0 1 128-128z"
            }),
            _createElementVNode183("path", {
              fill: "currentColor",
              d: "M768 384a128 128 0 1 0 0-256 128 128 0 0 0 0 256m0 64a192 192 0 1 1 0-384 192 192 0 0 1 0 384"
            })
          ]));
        }
      }), notification_default = _sfc_main183;
      const _defineComponent184 = window["Vue"].defineComponent;
      const _createElementVNode184 = window["Vue"].createElementVNode;
      const _openBlock184 = window["Vue"].openBlock;
      const _createElementBlock184 = window["Vue"].createElementBlock;
      var _sfc_main184 = /* @__PURE__ */ _defineComponent184({
        name: "Odometer",
        __name: "odometer",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock184(), _createElementBlock184("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode184("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            _createElementVNode184("path", {
              fill: "currentColor",
              d: "M192 512a320 320 0 1 1 640 0 32 32 0 1 1-64 0 256 256 0 1 0-512 0 32 32 0 0 1-64 0"
            }),
            _createElementVNode184("path", {
              fill: "currentColor",
              d: "M570.432 627.84A96 96 0 1 1 509.568 608l60.992-187.776A32 32 0 1 1 631.424 440l-60.992 187.776zM502.08 734.464a32 32 0 1 0 19.84-60.928 32 32 0 0 0-19.84 60.928"
            })
          ]));
        }
      }), odometer_default = _sfc_main184;
      const _defineComponent185 = window["Vue"].defineComponent;
      const _createElementVNode185 = window["Vue"].createElementVNode;
      const _openBlock185 = window["Vue"].openBlock;
      const _createElementBlock185 = window["Vue"].createElementBlock;
      var _sfc_main185 = /* @__PURE__ */ _defineComponent185({
        name: "OfficeBuilding",
        __name: "office-building",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock185(), _createElementBlock185("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode185("path", {
              fill: "currentColor",
              d: "M192 128v704h384V128zm-32-64h448a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32"
            }),
            _createElementVNode185("path", {
              fill: "currentColor",
              d: "M256 256h256v64H256zm0 192h256v64H256zm0 192h256v64H256zm384-128h128v64H640zm0 128h128v64H640zM64 832h896v64H64z"
            }),
            _createElementVNode185("path", {
              fill: "currentColor",
              d: "M640 384v448h192V384zm-32-64h256a32 32 0 0 1 32 32v512a32 32 0 0 1-32 32H608a32 32 0 0 1-32-32V352a32 32 0 0 1 32-32"
            })
          ]));
        }
      }), office_building_default = _sfc_main185;
      const _defineComponent186 = window["Vue"].defineComponent;
      const _createElementVNode186 = window["Vue"].createElementVNode;
      const _openBlock186 = window["Vue"].openBlock;
      const _createElementBlock186 = window["Vue"].createElementBlock;
      var _sfc_main186 = /* @__PURE__ */ _defineComponent186({
        name: "Open",
        __name: "open",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock186(), _createElementBlock186("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode186("path", {
              fill: "currentColor",
              d: "M329.956 257.138a254.862 254.862 0 0 0 0 509.724h364.088a254.862 254.862 0 0 0 0-509.724zm0-72.818h364.088a327.68 327.68 0 1 1 0 655.36H329.956a327.68 327.68 0 1 1 0-655.36"
            }),
            _createElementVNode186("path", {
              fill: "currentColor",
              d: "M694.044 621.227a109.227 109.227 0 1 0 0-218.454 109.227 109.227 0 0 0 0 218.454m0 72.817a182.044 182.044 0 1 1 0-364.088 182.044 182.044 0 0 1 0 364.088"
            })
          ]));
        }
      }), open_default = _sfc_main186;
      const _defineComponent187 = window["Vue"].defineComponent;
      const _createElementVNode187 = window["Vue"].createElementVNode;
      const _openBlock187 = window["Vue"].openBlock;
      const _createElementBlock187 = window["Vue"].createElementBlock;
      var _sfc_main187 = /* @__PURE__ */ _defineComponent187({
        name: "Operation",
        __name: "operation",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock187(), _createElementBlock187("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode187("path", {
              fill: "currentColor",
              d: "M389.44 768a96.064 96.064 0 0 1 181.12 0H896v64H570.56a96.064 96.064 0 0 1-181.12 0H128v-64zm192-288a96.064 96.064 0 0 1 181.12 0H896v64H762.56a96.064 96.064 0 0 1-181.12 0H128v-64zm-320-288a96.064 96.064 0 0 1 181.12 0H896v64H442.56a96.064 96.064 0 0 1-181.12 0H128v-64z"
            })
          ]));
        }
      }), operation_default = _sfc_main187;
      const _defineComponent188 = window["Vue"].defineComponent;
      const _createElementVNode188 = window["Vue"].createElementVNode;
      const _openBlock188 = window["Vue"].openBlock;
      const _createElementBlock188 = window["Vue"].createElementBlock;
      var _sfc_main188 = /* @__PURE__ */ _defineComponent188({
        name: "Opportunity",
        __name: "opportunity",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock188(), _createElementBlock188("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode188("path", {
              fill: "currentColor",
              d: "M384 960v-64h192.064v64zm448-544a350.66 350.66 0 0 1-128.32 271.424C665.344 719.04 640 763.776 640 813.504V832H320v-14.336c0-48-19.392-95.36-57.216-124.992a351.55 351.55 0 0 1-128.448-344.256c25.344-136.448 133.888-248.128 269.76-276.48A352.384 352.384 0 0 1 832 416m-544 32c0-132.288 75.904-224 192-224v-64c-154.432 0-256 122.752-256 288z"
            })
          ]));
        }
      }), opportunity_default = _sfc_main188;
      const _defineComponent189 = window["Vue"].defineComponent;
      const _createElementVNode189 = window["Vue"].createElementVNode;
      const _openBlock189 = window["Vue"].openBlock;
      const _createElementBlock189 = window["Vue"].createElementBlock;
      var _sfc_main189 = /* @__PURE__ */ _defineComponent189({
        name: "Orange",
        __name: "orange",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock189(), _createElementBlock189("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode189("path", {
              fill: "currentColor",
              d: "M544 894.72a382.34 382.34 0 0 0 215.936-89.472L577.024 622.272c-10.24 6.016-21.248 10.688-33.024 13.696v258.688zm261.248-134.784A382.34 382.34 0 0 0 894.656 544H635.968c-3.008 11.776-7.68 22.848-13.696 33.024zM894.656 480a382.34 382.34 0 0 0-89.408-215.936L622.272 446.976c6.016 10.24 10.688 21.248 13.696 33.024zm-134.72-261.248A382.34 382.34 0 0 0 544 129.344v258.688c11.776 3.008 22.848 7.68 33.024 13.696zM480 129.344a382.34 382.34 0 0 0-215.936 89.408l182.912 182.976c10.24-6.016 21.248-10.688 33.024-13.696zm-261.248 134.72A382.34 382.34 0 0 0 129.344 480h258.688c3.008-11.776 7.68-22.848 13.696-33.024zM129.344 544a382.34 382.34 0 0 0 89.408 215.936l182.976-182.912A127.2 127.2 0 0 1 388.032 544zm134.72 261.248A382.34 382.34 0 0 0 480 894.656V635.968a127.2 127.2 0 0 1-33.024-13.696zM512 960a448 448 0 1 1 0-896 448 448 0 0 1 0 896m0-384a64 64 0 1 0 0-128 64 64 0 0 0 0 128"
            })
          ]));
        }
      }), orange_default = _sfc_main189;
      const _defineComponent190 = window["Vue"].defineComponent;
      const _createElementVNode190 = window["Vue"].createElementVNode;
      const _openBlock190 = window["Vue"].openBlock;
      const _createElementBlock190 = window["Vue"].createElementBlock;
      var _sfc_main190 = /* @__PURE__ */ _defineComponent190({
        name: "Paperclip",
        __name: "paperclip",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock190(), _createElementBlock190("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode190("path", {
              fill: "currentColor",
              d: "M602.496 240.448A192 192 0 1 1 874.048 512l-316.8 316.8A256 256 0 0 1 195.2 466.752L602.496 59.456l45.248 45.248L240.448 512A192 192 0 0 0 512 783.552l316.8-316.8a128 128 0 1 0-181.056-181.056L353.6 579.904a32 32 0 1 0 45.248 45.248l294.144-294.144 45.312 45.248L444.096 670.4a96 96 0 1 1-135.744-135.744z"
            })
          ]));
        }
      }), paperclip_default = _sfc_main190;
      const _defineComponent191 = window["Vue"].defineComponent;
      const _createElementVNode191 = window["Vue"].createElementVNode;
      const _openBlock191 = window["Vue"].openBlock;
      const _createElementBlock191 = window["Vue"].createElementBlock;
      var _sfc_main191 = /* @__PURE__ */ _defineComponent191({
        name: "PartlyCloudy",
        __name: "partly-cloudy",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock191(), _createElementBlock191("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode191("path", {
              fill: "currentColor",
              d: "M598.4 895.872H328.192a256 256 0 0 1-34.496-510.528A352 352 0 1 1 598.4 895.872m-271.36-64h272.256a288 288 0 1 0-248.512-417.664L335.04 445.44l-34.816 3.584a192 192 0 0 0 26.88 382.848z"
            }),
            _createElementVNode191("path", {
              fill: "currentColor",
              d: "M139.84 501.888a256 256 0 1 1 417.856-277.12c-17.728 2.176-38.208 8.448-61.504 18.816A192 192 0 1 0 189.12 460.48a6004 6004 0 0 0-49.28 41.408"
            })
          ]));
        }
      }), partly_cloudy_default = _sfc_main191;
      const _defineComponent192 = window["Vue"].defineComponent;
      const _createElementVNode192 = window["Vue"].createElementVNode;
      const _openBlock192 = window["Vue"].openBlock;
      const _createElementBlock192 = window["Vue"].createElementBlock;
      var _sfc_main192 = /* @__PURE__ */ _defineComponent192({
        name: "Pear",
        __name: "pear",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock192(), _createElementBlock192("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode192("path", {
              fill: "currentColor",
              d: "M542.336 258.816a443 443 0 0 0-9.024 25.088 32 32 0 1 1-60.8-20.032l1.088-3.328a162.69 162.69 0 0 0-122.048 131.392l-17.088 102.72-20.736 15.36C256.192 552.704 224 610.88 224 672c0 120.576 126.4 224 288 224s288-103.424 288-224c0-61.12-32.192-119.296-89.728-161.92l-20.736-15.424-17.088-102.72a162.69 162.69 0 0 0-130.112-133.12m-40.128-66.56c7.936-15.552 16.576-30.08 25.92-43.776 23.296-33.92 49.408-59.776 78.528-77.12a32 32 0 1 1 32.704 55.04c-20.544 12.224-40.064 31.552-58.432 58.304a317 317 0 0 0-9.792 15.104 226.69 226.69 0 0 1 164.48 181.568l12.8 77.248C819.456 511.36 864 587.392 864 672c0 159.04-157.568 288-352 288S160 831.04 160 672c0-84.608 44.608-160.64 115.584-213.376l12.8-77.248a226.624 226.624 0 0 1 213.76-189.184z"
            })
          ]));
        }
      }), pear_default = _sfc_main192;
      const _defineComponent193 = window["Vue"].defineComponent;
      const _createElementVNode193 = window["Vue"].createElementVNode;
      const _openBlock193 = window["Vue"].openBlock;
      const _createElementBlock193 = window["Vue"].createElementBlock;
      var _sfc_main193 = /* @__PURE__ */ _defineComponent193({
        name: "PhoneFilled",
        __name: "phone-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock193(), _createElementBlock193("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode193("path", {
              fill: "currentColor",
              d: "M199.232 125.568 90.624 379.008a32 32 0 0 0 6.784 35.2l512.384 512.384a32 32 0 0 0 35.2 6.784l253.44-108.608a32 32 0 0 0 10.048-52.032L769.6 633.92a32 32 0 0 0-36.928-5.952l-130.176 65.088-271.488-271.552 65.024-130.176a32 32 0 0 0-5.952-36.928L251.2 115.52a32 32 0 0 0-51.968 10.048"
            })
          ]));
        }
      }), phone_filled_default = _sfc_main193;
      const _defineComponent194 = window["Vue"].defineComponent;
      const _createElementVNode194 = window["Vue"].createElementVNode;
      const _openBlock194 = window["Vue"].openBlock;
      const _createElementBlock194 = window["Vue"].createElementBlock;
      var _sfc_main194 = /* @__PURE__ */ _defineComponent194({
        name: "Phone",
        __name: "phone",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock194(), _createElementBlock194("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode194("path", {
              fill: "currentColor",
              d: "M79.36 432.256 591.744 944.64a32 32 0 0 0 35.2 6.784l253.44-108.544a32 32 0 0 0 9.984-52.032l-153.856-153.92a32 32 0 0 0-36.928-6.016l-69.888 34.944L358.08 394.24l35.008-69.888a32 32 0 0 0-5.952-36.928L233.152 133.568a32 32 0 0 0-52.032 10.048L72.512 397.056a32 32 0 0 0 6.784 35.2zm60.48-29.952 81.536-190.08L325.568 316.48l-24.64 49.216-20.608 41.216 32.576 32.64 271.552 271.552 32.64 32.64 41.216-20.672 49.28-24.576 104.192 104.128-190.08 81.472zM512 320v-64a256 256 0 0 1 256 256h-64a192 192 0 0 0-192-192m0-192V64a448 448 0 0 1 448 448h-64a384 384 0 0 0-384-384"
            })
          ]));
        }
      }), phone_default = _sfc_main194;
      const _defineComponent195 = window["Vue"].defineComponent;
      const _createElementVNode195 = window["Vue"].createElementVNode;
      const _openBlock195 = window["Vue"].openBlock;
      const _createElementBlock195 = window["Vue"].createElementBlock;
      var _sfc_main195 = /* @__PURE__ */ _defineComponent195({
        name: "PictureFilled",
        __name: "picture-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock195(), _createElementBlock195("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode195("path", {
              fill: "currentColor",
              d: "M96 896a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h832a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32zm315.52-228.48-68.928-68.928a32 32 0 0 0-45.248 0L128 768.064h778.688l-242.112-290.56a32 32 0 0 0-49.216 0L458.752 665.408a32 32 0 0 1-47.232 2.112M256 384a96 96 0 1 0 192.064-.064A96 96 0 0 0 256 384"
            })
          ]));
        }
      }), picture_filled_default = _sfc_main195;
      const _defineComponent196 = window["Vue"].defineComponent;
      const _createElementVNode196 = window["Vue"].createElementVNode;
      const _openBlock196 = window["Vue"].openBlock;
      const _createElementBlock196 = window["Vue"].createElementBlock;
      var _sfc_main196 = /* @__PURE__ */ _defineComponent196({
        name: "PictureRounded",
        __name: "picture-rounded",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock196(), _createElementBlock196("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode196("path", {
              fill: "currentColor",
              d: "M512 128a384 384 0 1 0 0 768 384 384 0 0 0 0-768m0-64a448 448 0 1 1 0 896 448 448 0 0 1 0-896"
            }),
            _createElementVNode196("path", {
              fill: "currentColor",
              d: "M640 288q64 0 64 64t-64 64-64-64 64-64M214.656 790.656l-45.312-45.312 185.664-185.6a96 96 0 0 1 123.712-10.24l138.24 98.688a32 32 0 0 0 39.872-2.176L906.688 422.4l42.624 47.744L699.52 693.696a96 96 0 0 1-119.808 6.592l-138.24-98.752a32 32 0 0 0-41.152 3.456l-185.664 185.6z"
            })
          ]));
        }
      }), picture_rounded_default = _sfc_main196;
      const _defineComponent197 = window["Vue"].defineComponent;
      const _createElementVNode197 = window["Vue"].createElementVNode;
      const _openBlock197 = window["Vue"].openBlock;
      const _createElementBlock197 = window["Vue"].createElementBlock;
      var _sfc_main197 = /* @__PURE__ */ _defineComponent197({
        name: "Picture",
        __name: "picture",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock197(), _createElementBlock197("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode197("path", {
              fill: "currentColor",
              d: "M160 160v704h704V160zm-32-64h768a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H128a32 32 0 0 1-32-32V128a32 32 0 0 1 32-32"
            }),
            _createElementVNode197("path", {
              fill: "currentColor",
              d: "M384 288q64 0 64 64t-64 64-64-64 64-64M185.408 876.992l-50.816-38.912L350.72 556.032a96 96 0 0 1 134.592-17.856l1.856 1.472 122.88 99.136a32 32 0 0 0 44.992-4.864l216-269.888 49.92 39.936-215.808 269.824-.256.32a96 96 0 0 1-135.04 14.464l-122.88-99.072-.64-.512a32 32 0 0 0-44.8 5.952z"
            })
          ]));
        }
      }), picture_default = _sfc_main197;
      const _defineComponent198 = window["Vue"].defineComponent;
      const _createElementVNode198 = window["Vue"].createElementVNode;
      const _openBlock198 = window["Vue"].openBlock;
      const _createElementBlock198 = window["Vue"].createElementBlock;
      var _sfc_main198 = /* @__PURE__ */ _defineComponent198({
        name: "PieChart",
        __name: "pie-chart",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock198(), _createElementBlock198("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode198("path", {
              fill: "currentColor",
              d: "M448 68.48v64.832A384.128 384.128 0 0 0 512 896a384.13 384.13 0 0 0 378.688-320h64.768A448.128 448.128 0 0 1 64 512 448.13 448.13 0 0 1 448 68.48"
            }),
            _createElementVNode198("path", {
              fill: "currentColor",
              d: "M576 97.28V448h350.72A384.064 384.064 0 0 0 576 97.28M512 64V33.152A448 448 0 0 1 990.848 512H512z"
            })
          ]));
        }
      }), pie_chart_default = _sfc_main198;
      const _defineComponent199 = window["Vue"].defineComponent;
      const _createElementVNode199 = window["Vue"].createElementVNode;
      const _openBlock199 = window["Vue"].openBlock;
      const _createElementBlock199 = window["Vue"].createElementBlock;
      var _sfc_main199 = /* @__PURE__ */ _defineComponent199({
        name: "Place",
        __name: "place",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock199(), _createElementBlock199("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode199("path", {
              fill: "currentColor",
              d: "M512 512a192 192 0 1 0 0-384 192 192 0 0 0 0 384m0 64a256 256 0 1 1 0-512 256 256 0 0 1 0 512"
            }),
            _createElementVNode199("path", {
              fill: "currentColor",
              d: "M512 512a32 32 0 0 1 32 32v256a32 32 0 1 1-64 0V544a32 32 0 0 1 32-32"
            }),
            _createElementVNode199("path", {
              fill: "currentColor",
              d: "M384 649.088v64.96C269.76 732.352 192 771.904 192 800c0 37.696 139.904 96 320 96s320-58.304 320-96c0-28.16-77.76-67.648-192-85.952v-64.96C789.12 671.04 896 730.368 896 800c0 88.32-171.904 160-384 160s-384-71.68-384-160c0-69.696 106.88-128.96 256-150.912"
            })
          ]));
        }
      }), place_default = _sfc_main199;
      const _defineComponent200 = window["Vue"].defineComponent;
      const _createElementVNode200 = window["Vue"].createElementVNode;
      const _openBlock200 = window["Vue"].openBlock;
      const _createElementBlock200 = window["Vue"].createElementBlock;
      var _sfc_main200 = /* @__PURE__ */ _defineComponent200({
        name: "Platform",
        __name: "platform",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock200(), _createElementBlock200("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode200("path", {
              fill: "currentColor",
              d: "M448 832v-64h128v64h192v64H256v-64zM128 704V128h768v576z"
            })
          ]));
        }
      }), platform_default = _sfc_main200;
      const _defineComponent201 = window["Vue"].defineComponent;
      const _createElementVNode201 = window["Vue"].createElementVNode;
      const _openBlock201 = window["Vue"].openBlock;
      const _createElementBlock201 = window["Vue"].createElementBlock;
      var _sfc_main201 = /* @__PURE__ */ _defineComponent201({
        name: "Plus",
        __name: "plus",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock201(), _createElementBlock201("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode201("path", {
              fill: "currentColor",
              d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
            })
          ]));
        }
      }), plus_default = _sfc_main201;
      const _defineComponent202 = window["Vue"].defineComponent;
      const _createElementVNode202 = window["Vue"].createElementVNode;
      const _openBlock202 = window["Vue"].openBlock;
      const _createElementBlock202 = window["Vue"].createElementBlock;
      var _sfc_main202 = /* @__PURE__ */ _defineComponent202({
        name: "Pointer",
        __name: "pointer",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock202(), _createElementBlock202("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode202("path", {
              fill: "currentColor",
              d: "M511.552 128c-35.584 0-64.384 28.8-64.384 64.448v516.48L274.048 570.88a94.27 94.27 0 0 0-112.896-3.456 44.416 44.416 0 0 0-8.96 62.208L332.8 870.4A64 64 0 0 0 384 896h512V575.232a64 64 0 0 0-45.632-61.312l-205.952-61.76A96 96 0 0 1 576 360.192V192.448C576 156.8 547.2 128 511.552 128M359.04 556.8l24.128 19.2V192.448a128.448 128.448 0 1 1 256.832 0v167.744a32 32 0 0 0 22.784 30.656l206.016 61.76A128 128 0 0 1 960 575.232V896a64 64 0 0 1-64 64H384a128 128 0 0 1-102.4-51.2L101.056 668.032A108.416 108.416 0 0 1 128 512.512a158.27 158.27 0 0 1 185.984 8.32z"
            })
          ]));
        }
      }), pointer_default = _sfc_main202;
      const _defineComponent203 = window["Vue"].defineComponent;
      const _createElementVNode203 = window["Vue"].createElementVNode;
      const _openBlock203 = window["Vue"].openBlock;
      const _createElementBlock203 = window["Vue"].createElementBlock;
      var _sfc_main203 = /* @__PURE__ */ _defineComponent203({
        name: "Position",
        __name: "position",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock203(), _createElementBlock203("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode203("path", {
              fill: "currentColor",
              d: "m249.6 417.088 319.744 43.072 39.168 310.272L845.12 178.88zm-129.024 47.168a32 32 0 0 1-7.68-61.44l777.792-311.04a32 32 0 0 1 41.6 41.6l-310.336 775.68a32 32 0 0 1-61.44-7.808L512 516.992z"
            })
          ]));
        }
      }), position_default = _sfc_main203;
      const _defineComponent204 = window["Vue"].defineComponent;
      const _createElementVNode204 = window["Vue"].createElementVNode;
      const _openBlock204 = window["Vue"].openBlock;
      const _createElementBlock204 = window["Vue"].createElementBlock;
      var _sfc_main204 = /* @__PURE__ */ _defineComponent204({
        name: "Postcard",
        __name: "postcard",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock204(), _createElementBlock204("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode204("path", {
              fill: "currentColor",
              d: "M160 224a32 32 0 0 0-32 32v512a32 32 0 0 0 32 32h704a32 32 0 0 0 32-32V256a32 32 0 0 0-32-32zm0-64h704a96 96 0 0 1 96 96v512a96 96 0 0 1-96 96H160a96 96 0 0 1-96-96V256a96 96 0 0 1 96-96"
            }),
            _createElementVNode204("path", {
              fill: "currentColor",
              d: "M704 320a64 64 0 1 1 0 128 64 64 0 0 1 0-128M288 448h256q32 0 32 32t-32 32H288q-32 0-32-32t32-32m0 128h256q32 0 32 32t-32 32H288q-32 0-32-32t32-32"
            })
          ]));
        }
      }), postcard_default = _sfc_main204;
      const _defineComponent205 = window["Vue"].defineComponent;
      const _createElementVNode205 = window["Vue"].createElementVNode;
      const _openBlock205 = window["Vue"].openBlock;
      const _createElementBlock205 = window["Vue"].createElementBlock;
      var _sfc_main205 = /* @__PURE__ */ _defineComponent205({
        name: "Pouring",
        __name: "pouring",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock205(), _createElementBlock205("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode205("path", {
              fill: "currentColor",
              d: "m739.328 291.328-35.2-6.592-12.8-33.408a192.064 192.064 0 0 0-365.952 23.232l-9.92 40.896-41.472 7.04a176.32 176.32 0 0 0-146.24 173.568c0 97.28 78.72 175.936 175.808 175.936h400a192 192 0 0 0 35.776-380.672M959.552 480a256 256 0 0 1-256 256h-400A239.81 239.81 0 0 1 63.744 496.192a240.32 240.32 0 0 1 199.488-236.8 256.128 256.128 0 0 1 487.872-30.976A256.064 256.064 0 0 1 959.552 480M224 800a32 32 0 0 1 32 32v96a32 32 0 1 1-64 0v-96a32 32 0 0 1 32-32m192 0a32 32 0 0 1 32 32v96a32 32 0 1 1-64 0v-96a32 32 0 0 1 32-32m192 0a32 32 0 0 1 32 32v96a32 32 0 1 1-64 0v-96a32 32 0 0 1 32-32m192 0a32 32 0 0 1 32 32v96a32 32 0 1 1-64 0v-96a32 32 0 0 1 32-32"
            })
          ]));
        }
      }), pouring_default = _sfc_main205;
      const _defineComponent206 = window["Vue"].defineComponent;
      const _createElementVNode206 = window["Vue"].createElementVNode;
      const _openBlock206 = window["Vue"].openBlock;
      const _createElementBlock206 = window["Vue"].createElementBlock;
      var _sfc_main206 = /* @__PURE__ */ _defineComponent206({
        name: "Present",
        __name: "present",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock206(), _createElementBlock206("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode206("path", {
              fill: "currentColor",
              d: "M480 896V640H192v-64h288V320H192v576zm64 0h288V320H544v256h288v64H544zM128 256h768v672a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32z"
            }),
            _createElementVNode206("path", {
              fill: "currentColor",
              d: "M96 256h832q32 0 32 32t-32 32H96q-32 0-32-32t32-32"
            }),
            _createElementVNode206("path", {
              fill: "currentColor",
              d: "M416 256a64 64 0 1 0 0-128 64 64 0 0 0 0 128m0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256"
            }),
            _createElementVNode206("path", {
              fill: "currentColor",
              d: "M608 256a64 64 0 1 0 0-128 64 64 0 0 0 0 128m0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256"
            })
          ]));
        }
      }), present_default = _sfc_main206;
      const _defineComponent207 = window["Vue"].defineComponent;
      const _createElementVNode207 = window["Vue"].createElementVNode;
      const _openBlock207 = window["Vue"].openBlock;
      const _createElementBlock207 = window["Vue"].createElementBlock;
      var _sfc_main207 = /* @__PURE__ */ _defineComponent207({
        name: "PriceTag",
        __name: "price-tag",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock207(), _createElementBlock207("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode207("path", {
              fill: "currentColor",
              d: "M224 318.336V896h576V318.336L552.512 115.84a64 64 0 0 0-81.024 0zM593.024 66.304l259.2 212.096A32 32 0 0 1 864 303.168V928a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V303.168a32 32 0 0 1 11.712-24.768l259.2-212.096a128 128 0 0 1 162.112 0"
            }),
            _createElementVNode207("path", {
              fill: "currentColor",
              d: "M512 448a64 64 0 1 0 0-128 64 64 0 0 0 0 128m0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256"
            })
          ]));
        }
      }), price_tag_default = _sfc_main207;
      const _defineComponent208 = window["Vue"].defineComponent;
      const _createElementVNode208 = window["Vue"].createElementVNode;
      const _openBlock208 = window["Vue"].openBlock;
      const _createElementBlock208 = window["Vue"].createElementBlock;
      var _sfc_main208 = /* @__PURE__ */ _defineComponent208({
        name: "Printer",
        __name: "printer",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock208(), _createElementBlock208("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode208("path", {
              fill: "currentColor",
              d: "M256 768H105.024c-14.272 0-19.456-1.472-24.64-4.288a29.06 29.06 0 0 1-12.16-12.096C65.536 746.432 64 741.248 64 727.04V379.072c0-42.816 4.48-58.304 12.8-73.984 8.384-15.616 20.672-27.904 36.288-36.288 15.68-8.32 31.168-12.8 73.984-12.8H256V64h512v192h68.928c42.816 0 58.304 4.48 73.984 12.8 15.616 8.384 27.904 20.672 36.288 36.288 8.32 15.68 12.8 31.168 12.8 73.984v347.904c0 14.272-1.472 19.456-4.288 24.64a29.06 29.06 0 0 1-12.096 12.16c-5.184 2.752-10.368 4.224-24.64 4.224H768v192H256zm64-192v320h384V576zm-64 128V512h512v192h128V379.072c0-29.376-1.408-36.48-5.248-43.776a23.3 23.3 0 0 0-10.048-10.048c-7.232-3.84-14.4-5.248-43.776-5.248H187.072c-29.376 0-36.48 1.408-43.776 5.248a23.3 23.3 0 0 0-10.048 10.048c-3.84 7.232-5.248 14.4-5.248 43.776V704zm64-448h384V128H320zm-64 128h64v64h-64zm128 0h64v64h-64z"
            })
          ]));
        }
      }), printer_default = _sfc_main208;
      const _defineComponent209 = window["Vue"].defineComponent;
      const _createElementVNode209 = window["Vue"].createElementVNode;
      const _openBlock209 = window["Vue"].openBlock;
      const _createElementBlock209 = window["Vue"].createElementBlock;
      var _sfc_main209 = /* @__PURE__ */ _defineComponent209({
        name: "Promotion",
        __name: "promotion",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock209(), _createElementBlock209("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode209("path", {
              fill: "currentColor",
              d: "m64 448 832-320-128 704-446.08-243.328L832 192 242.816 545.472zm256 512V657.024L512 768z"
            })
          ]));
        }
      }), promotion_default = _sfc_main209;
      const _defineComponent210 = window["Vue"].defineComponent;
      const _createElementVNode210 = window["Vue"].createElementVNode;
      const _openBlock210 = window["Vue"].openBlock;
      const _createElementBlock210 = window["Vue"].createElementBlock;
      var _sfc_main210 = /* @__PURE__ */ _defineComponent210({
        name: "QuartzWatch",
        __name: "quartz-watch",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock210(), _createElementBlock210("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            "xml:space": "preserve",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode210("path", {
              fill: "currentColor",
              d: "M422.02 602.01v-.03c-6.68-5.99-14.35-8.83-23.01-8.51q-13.005.48-22.5 10.02c-6.33 6.36-9.5 13.7-9.5 22.02s3 15.82 8.99 22.5c8.68 8.68 19.02 11.35 31.01 8s19.49-10.85 22.5-22.5.51-22.15-7.49-31.49zM384 512c0-9.35-3-17.02-8.99-23.01-6-5.99-13.66-8.99-23.01-8.99s-17.02 3-23.01 8.99c-5.99 6-8.99 13.66-8.99 23.01s3 17.02 8.99 23.01c6 5.99 13.66 8.99 23.01 8.99s17.02-3 23.01-8.99c5.99-6 8.99-13.67 8.99-23.01m6.53-82.49c11.65 3.01 22.15.51 31.49-7.49h.04c5.99-6.68 8.83-14.34 8.51-23.01s-3.66-16.16-10.02-22.5c-6.36-6.33-13.7-9.5-22.02-9.5s-15.82 3-22.5 8.99c-8.68 8.69-11.35 19.02-8 31.01q5.025 17.985 22.5 22.5m242.94 0q17.505-4.545 22.02-22.02c3.01-11.65.51-22.15-7.49-31.49h.01c-6.68-5.99-14.18-8.99-22.5-8.99s-15.66 3.16-22.02 9.5q-9.54 9.51-10.02 22.5c-.32 8.66 2.52 16.33 8.51 23.01 9.32 8.02 19.82 10.52 31.49 7.49M512 640c-9.35 0-17.02 3-23.01 8.99-5.99 6-8.99 13.66-8.99 23.01s3 17.02 8.99 23.01c6 5.99 13.67 8.99 23.01 8.99 9.35 0 17.02-3 23.01-8.99 5.99-6 8.99-13.66 8.99-23.01s-3-17.02-8.99-23.01c-6-5.99-13.66-8.99-23.01-8.99m183.01-151.01c-6-5.99-13.66-8.99-23.01-8.99s-17.02 3-23.01 8.99c-5.99 6-8.99 13.66-8.99 23.01s3 17.02 8.99 23.01c6 5.99 13.66 8.99 23.01 8.99s17.02-3 23.01-8.99c5.99-6 8.99-13.67 8.99-23.01 0-9.35-3-17.02-8.99-23.01"
            }),
            _createElementVNode210("path", {
              fill: "currentColor",
              d: "M832 512c-2-90.67-33.17-166.17-93.5-226.5-20.43-20.42-42.6-37.49-66.5-51.23V64H352v170.26c-23.9 13.74-46.07 30.81-66.5 51.24-60.33 60.33-91.49 135.83-93.5 226.5 2 90.67 33.17 166.17 93.5 226.5 20.43 20.43 42.6 37.5 66.5 51.24V960h320V789.74c23.9-13.74 46.07-30.81 66.5-51.24 60.33-60.34 91.49-135.83 93.5-226.5M416 128h192v78.69c-29.85-9.03-61.85-13.93-96-14.69-34.15.75-66.15 5.65-96 14.68zm192 768H416v-78.68c29.85 9.03 61.85 13.93 96 14.68 34.15-.75 66.15-5.65 96-14.68zm-96-128c-72.66-2.01-132.99-27.01-180.99-75.01S258.01 584.66 256 512c2.01-72.66 27.01-132.99 75.01-180.99S439.34 258.01 512 256c72.66 2.01 132.99 27.01 180.99 75.01S765.99 439.34 768 512c-2.01 72.66-27.01 132.99-75.01 180.99S584.66 765.99 512 768"
            }),
            _createElementVNode210("path", {
              fill: "currentColor",
              d: "M512 320c-9.35 0-17.02 3-23.01 8.99-5.99 6-8.99 13.66-8.99 23.01s3 17.02 8.99 23.01c6 5.99 13.67 8.99 23.01 8.99 9.35 0 17.02-3 23.01-8.99 5.99-6 8.99-13.66 8.99-23.01s-3-17.02-8.99-23.01c-6-5.99-13.66-8.99-23.01-8.99m112.99 273.5c-8.66-.32-16.33 2.52-23.01 8.51-7.98 9.32-10.48 19.82-7.49 31.49s10.49 19.17 22.5 22.5 22.35.66 31.01-8v.04c5.99-6.68 8.99-14.18 8.99-22.5s-3.16-15.66-9.5-22.02-13.84-9.7-22.5-10.02"
            })
          ]));
        }
      }), quartz_watch_default = _sfc_main210;
      const _defineComponent211 = window["Vue"].defineComponent;
      const _createElementVNode211 = window["Vue"].createElementVNode;
      const _openBlock211 = window["Vue"].openBlock;
      const _createElementBlock211 = window["Vue"].createElementBlock;
      var _sfc_main211 = /* @__PURE__ */ _defineComponent211({
        name: "QuestionFilled",
        __name: "question-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock211(), _createElementBlock211("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode211("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592q0-64.416-42.24-101.376c-28.16-25.344-65.472-37.312-111.232-37.312m-12.672 406.208a54.27 54.27 0 0 0-38.72 14.784 49.4 49.4 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.85 54.85 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.97 51.97 0 0 0-15.488-38.016 55.94 55.94 0 0 0-39.424-14.784"
            })
          ]));
        }
      }), question_filled_default = _sfc_main211;
      const _defineComponent212 = window["Vue"].defineComponent;
      const _createElementVNode212 = window["Vue"].createElementVNode;
      const _openBlock212 = window["Vue"].openBlock;
      const _createElementBlock212 = window["Vue"].createElementBlock;
      var _sfc_main212 = /* @__PURE__ */ _defineComponent212({
        name: "Rank",
        __name: "rank",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock212(), _createElementBlock212("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode212("path", {
              fill: "currentColor",
              d: "m186.496 544 41.408 41.344a32 32 0 1 1-45.248 45.312l-96-96a32 32 0 0 1 0-45.312l96-96a32 32 0 1 1 45.248 45.312L186.496 480h290.816V186.432l-41.472 41.472a32 32 0 1 1-45.248-45.184l96-96.128a32 32 0 0 1 45.312 0l96 96.064a32 32 0 0 1-45.248 45.184l-41.344-41.28V480H832l-41.344-41.344a32 32 0 0 1 45.248-45.312l96 96a32 32 0 0 1 0 45.312l-96 96a32 32 0 0 1-45.248-45.312L832 544H541.312v293.44l41.344-41.28a32 32 0 1 1 45.248 45.248l-96 96a32 32 0 0 1-45.312 0l-96-96a32 32 0 1 1 45.312-45.248l41.408 41.408V544z"
            })
          ]));
        }
      }), rank_default = _sfc_main212;
      const _defineComponent213 = window["Vue"].defineComponent;
      const _createElementVNode213 = window["Vue"].createElementVNode;
      const _openBlock213 = window["Vue"].openBlock;
      const _createElementBlock213 = window["Vue"].createElementBlock;
      var _sfc_main213 = /* @__PURE__ */ _defineComponent213({
        name: "ReadingLamp",
        __name: "reading-lamp",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock213(), _createElementBlock213("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode213("path", {
              fill: "currentColor",
              d: "M352 896h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32m-44.672-768-99.52 448h608.384l-99.52-448zm-25.6-64h460.608a32 32 0 0 1 31.232 25.088l113.792 512A32 32 0 0 1 856.128 640H167.872a32 32 0 0 1-31.232-38.912l113.792-512A32 32 0 0 1 281.664 64z"
            }),
            _createElementVNode213("path", {
              fill: "currentColor",
              d: "M672 576q32 0 32 32v128q0 32-32 32t-32-32V608q0-32 32-32m-192-.064h64V960h-64z"
            })
          ]));
        }
      }), reading_lamp_default = _sfc_main213;
      const _defineComponent214 = window["Vue"].defineComponent;
      const _createElementVNode214 = window["Vue"].createElementVNode;
      const _openBlock214 = window["Vue"].openBlock;
      const _createElementBlock214 = window["Vue"].createElementBlock;
      var _sfc_main214 = /* @__PURE__ */ _defineComponent214({
        name: "Reading",
        __name: "reading",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock214(), _createElementBlock214("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode214("path", {
              fill: "currentColor",
              d: "m512 863.36 384-54.848v-638.72L525.568 222.72a96 96 0 0 1-27.136 0L128 169.792v638.72zM137.024 106.432l370.432 52.928a32 32 0 0 0 9.088 0l370.432-52.928A64 64 0 0 1 960 169.792v638.72a64 64 0 0 1-54.976 63.36l-388.48 55.488a32 32 0 0 1-9.088 0l-388.48-55.488A64 64 0 0 1 64 808.512v-638.72a64 64 0 0 1 73.024-63.36"
            }),
            _createElementVNode214("path", {
              fill: "currentColor",
              d: "M480 192h64v704h-64z"
            })
          ]));
        }
      }), reading_default = _sfc_main214;
      const _defineComponent215 = window["Vue"].defineComponent;
      const _createElementVNode215 = window["Vue"].createElementVNode;
      const _openBlock215 = window["Vue"].openBlock;
      const _createElementBlock215 = window["Vue"].createElementBlock;
      var _sfc_main215 = /* @__PURE__ */ _defineComponent215({
        name: "RefreshLeft",
        __name: "refresh-left",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock215(), _createElementBlock215("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode215("path", {
              fill: "currentColor",
              d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
            })
          ]));
        }
      }), refresh_left_default = _sfc_main215;
      const _defineComponent216 = window["Vue"].defineComponent;
      const _createElementVNode216 = window["Vue"].createElementVNode;
      const _openBlock216 = window["Vue"].openBlock;
      const _createElementBlock216 = window["Vue"].createElementBlock;
      var _sfc_main216 = /* @__PURE__ */ _defineComponent216({
        name: "RefreshRight",
        __name: "refresh-right",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock216(), _createElementBlock216("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode216("path", {
              fill: "currentColor",
              d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88"
            })
          ]));
        }
      }), refresh_right_default = _sfc_main216;
      const _defineComponent217 = window["Vue"].defineComponent;
      const _createElementVNode217 = window["Vue"].createElementVNode;
      const _openBlock217 = window["Vue"].openBlock;
      const _createElementBlock217 = window["Vue"].createElementBlock;
      var _sfc_main217 = /* @__PURE__ */ _defineComponent217({
        name: "Refresh",
        __name: "refresh",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock217(), _createElementBlock217("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode217("path", {
              fill: "currentColor",
              d: "M771.776 794.88A384 384 0 0 1 128 512h64a320 320 0 0 0 555.712 216.448H654.72a32 32 0 1 1 0-64h149.056a32 32 0 0 1 32 32v148.928a32 32 0 1 1-64 0v-50.56zM276.288 295.616h92.992a32 32 0 0 1 0 64H220.16a32 32 0 0 1-32-32V178.56a32 32 0 0 1 64 0v50.56A384 384 0 0 1 896.128 512h-64a320 320 0 0 0-555.776-216.384z"
            })
          ]));
        }
      }), refresh_default = _sfc_main217;
      const _defineComponent218 = window["Vue"].defineComponent;
      const _createElementVNode218 = window["Vue"].createElementVNode;
      const _openBlock218 = window["Vue"].openBlock;
      const _createElementBlock218 = window["Vue"].createElementBlock;
      var _sfc_main218 = /* @__PURE__ */ _defineComponent218({
        name: "Refrigerator",
        __name: "refrigerator",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock218(), _createElementBlock218("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode218("path", {
              fill: "currentColor",
              d: "M256 448h512V160a32 32 0 0 0-32-32H288a32 32 0 0 0-32 32zm0 64v352a32 32 0 0 0 32 32h448a32 32 0 0 0 32-32V512zm32-448h448a96 96 0 0 1 96 96v704a96 96 0 0 1-96 96H288a96 96 0 0 1-96-96V160a96 96 0 0 1 96-96m32 224h64v96h-64zm0 288h64v96h-64z"
            })
          ]));
        }
      }), refrigerator_default = _sfc_main218;
      const _defineComponent219 = window["Vue"].defineComponent;
      const _createElementVNode219 = window["Vue"].createElementVNode;
      const _openBlock219 = window["Vue"].openBlock;
      const _createElementBlock219 = window["Vue"].createElementBlock;
      var _sfc_main219 = /* @__PURE__ */ _defineComponent219({
        name: "RemoveFilled",
        __name: "remove-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock219(), _createElementBlock219("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode219("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896M288 512a38.4 38.4 0 0 0 38.4 38.4h371.2a38.4 38.4 0 0 0 0-76.8H326.4A38.4 38.4 0 0 0 288 512"
            })
          ]));
        }
      }), remove_filled_default = _sfc_main219;
      const _defineComponent220 = window["Vue"].defineComponent;
      const _createElementVNode220 = window["Vue"].createElementVNode;
      const _openBlock220 = window["Vue"].openBlock;
      const _createElementBlock220 = window["Vue"].createElementBlock;
      var _sfc_main220 = /* @__PURE__ */ _defineComponent220({
        name: "Remove",
        __name: "remove",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock220(), _createElementBlock220("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode220("path", {
              fill: "currentColor",
              d: "M352 480h320a32 32 0 1 1 0 64H352a32 32 0 0 1 0-64"
            }),
            _createElementVNode220("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            })
          ]));
        }
      }), remove_default = _sfc_main220;
      const _defineComponent221 = window["Vue"].defineComponent;
      const _createElementVNode221 = window["Vue"].createElementVNode;
      const _openBlock221 = window["Vue"].openBlock;
      const _createElementBlock221 = window["Vue"].createElementBlock;
      var _sfc_main221 = /* @__PURE__ */ _defineComponent221({
        name: "Right",
        __name: "right",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock221(), _createElementBlock221("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode221("path", {
              fill: "currentColor",
              d: "M754.752 480H160a32 32 0 1 0 0 64h594.752L521.344 777.344a32 32 0 0 0 45.312 45.312l288-288a32 32 0 0 0 0-45.312l-288-288a32 32 0 1 0-45.312 45.312z"
            })
          ]));
        }
      }), right_default = _sfc_main221;
      const _defineComponent222 = window["Vue"].defineComponent;
      const _createElementVNode222 = window["Vue"].createElementVNode;
      const _openBlock222 = window["Vue"].openBlock;
      const _createElementBlock222 = window["Vue"].createElementBlock;
      var _sfc_main222 = /* @__PURE__ */ _defineComponent222({
        name: "ScaleToOriginal",
        __name: "scale-to-original",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock222(), _createElementBlock222("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode222("path", {
              fill: "currentColor",
              d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.12 30.12 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.12 30.12 0 0 0-30.118-30.118m-361.412 0a30.12 30.12 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.12 30.12 0 0 0-30.118-30.118M512 361.412a30.12 30.12 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.12 30.12 0 0 0 512 361.412M512 512a30.12 30.12 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.12 30.12 0 0 0 512 512"
            })
          ]));
        }
      }), scale_to_original_default = _sfc_main222;
      const _defineComponent223 = window["Vue"].defineComponent;
      const _createElementVNode223 = window["Vue"].createElementVNode;
      const _openBlock223 = window["Vue"].openBlock;
      const _createElementBlock223 = window["Vue"].createElementBlock;
      var _sfc_main223 = /* @__PURE__ */ _defineComponent223({
        name: "School",
        __name: "school",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock223(), _createElementBlock223("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode223("path", {
              fill: "currentColor",
              d: "M224 128v704h576V128zm-32-64h640a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32"
            }),
            _createElementVNode223("path", {
              fill: "currentColor",
              d: "M64 832h896v64H64zm256-640h128v96H320z"
            }),
            _createElementVNode223("path", {
              fill: "currentColor",
              d: "M384 832h256v-64a128 128 0 1 0-256 0zm128-256a192 192 0 0 1 192 192v128H320V768a192 192 0 0 1 192-192M320 384h128v96H320zm256-192h128v96H576zm0 192h128v96H576z"
            })
          ]));
        }
      }), school_default = _sfc_main223;
      const _defineComponent224 = window["Vue"].defineComponent;
      const _createElementVNode224 = window["Vue"].createElementVNode;
      const _openBlock224 = window["Vue"].openBlock;
      const _createElementBlock224 = window["Vue"].createElementBlock;
      var _sfc_main224 = /* @__PURE__ */ _defineComponent224({
        name: "Scissor",
        __name: "scissor",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock224(), _createElementBlock224("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode224("path", {
              fill: "currentColor",
              d: "m512.064 578.368-106.88 152.768a160 160 0 1 1-23.36-78.208L472.96 522.56 196.864 128.256a32 32 0 1 1 52.48-36.736l393.024 561.344a160 160 0 1 1-23.36 78.208l-106.88-152.704zm54.4-189.248 208.384-297.6a32 32 0 0 1 52.48 36.736l-221.76 316.672-39.04-55.808zm-376.32 425.856a96 96 0 1 0 110.144-157.248 96 96 0 0 0-110.08 157.248zm643.84 0a96 96 0 1 0-110.08-157.248 96 96 0 0 0 110.08 157.248"
            })
          ]));
        }
      }), scissor_default = _sfc_main224;
      const _defineComponent225 = window["Vue"].defineComponent;
      const _createElementVNode225 = window["Vue"].createElementVNode;
      const _openBlock225 = window["Vue"].openBlock;
      const _createElementBlock225 = window["Vue"].createElementBlock;
      var _sfc_main225 = /* @__PURE__ */ _defineComponent225({
        name: "Search",
        __name: "search",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock225(), _createElementBlock225("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode225("path", {
              fill: "currentColor",
              d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704"
            })
          ]));
        }
      }), search_default = _sfc_main225;
      const _defineComponent226 = window["Vue"].defineComponent;
      const _createElementVNode226 = window["Vue"].createElementVNode;
      const _openBlock226 = window["Vue"].openBlock;
      const _createElementBlock226 = window["Vue"].createElementBlock;
      var _sfc_main226 = /* @__PURE__ */ _defineComponent226({
        name: "Select",
        __name: "select",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock226(), _createElementBlock226("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode226("path", {
              fill: "currentColor",
              d: "M77.248 415.04a64 64 0 0 1 90.496 0l226.304 226.304L846.528 188.8a64 64 0 1 1 90.56 90.496l-543.04 543.04-316.8-316.8a64 64 0 0 1 0-90.496"
            })
          ]));
        }
      }), select_default = _sfc_main226;
      const _defineComponent227 = window["Vue"].defineComponent;
      const _createElementVNode227 = window["Vue"].createElementVNode;
      const _openBlock227 = window["Vue"].openBlock;
      const _createElementBlock227 = window["Vue"].createElementBlock;
      var _sfc_main227 = /* @__PURE__ */ _defineComponent227({
        name: "Sell",
        __name: "sell",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock227(), _createElementBlock227("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode227("path", {
              fill: "currentColor",
              d: "M704 288h131.072a32 32 0 0 1 31.808 28.8L886.4 512h-64.384l-16-160H704v96a32 32 0 1 1-64 0v-96H384v96a32 32 0 0 1-64 0v-96H217.92l-51.2 512H512v64H131.328a32 32 0 0 1-31.808-35.2l57.6-576a32 32 0 0 1 31.808-28.8H320v-22.336C320 154.688 405.504 64 512 64s192 90.688 192 201.664v22.4zm-64 0v-22.336C640 189.248 582.272 128 512 128s-128 61.248-128 137.664v22.4h256zm201.408 483.84L768 698.496V928a32 32 0 1 1-64 0V698.496l-73.344 73.344a32 32 0 1 1-45.248-45.248l128-128a32 32 0 0 1 45.248 0l128 128a32 32 0 1 1-45.248 45.248"
            })
          ]));
        }
      }), sell_default = _sfc_main227;
      const _defineComponent228 = window["Vue"].defineComponent;
      const _createElementVNode228 = window["Vue"].createElementVNode;
      const _openBlock228 = window["Vue"].openBlock;
      const _createElementBlock228 = window["Vue"].createElementBlock;
      var _sfc_main228 = /* @__PURE__ */ _defineComponent228({
        name: "SemiSelect",
        __name: "semi-select",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock228(), _createElementBlock228("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode228("path", {
              fill: "currentColor",
              d: "M128 448h768q64 0 64 64t-64 64H128q-64 0-64-64t64-64"
            })
          ]));
        }
      }), semi_select_default = _sfc_main228;
      const _defineComponent229 = window["Vue"].defineComponent;
      const _createElementVNode229 = window["Vue"].createElementVNode;
      const _openBlock229 = window["Vue"].openBlock;
      const _createElementBlock229 = window["Vue"].createElementBlock;
      var _sfc_main229 = /* @__PURE__ */ _defineComponent229({
        name: "Service",
        __name: "service",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock229(), _createElementBlock229("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode229("path", {
              fill: "currentColor",
              d: "M864 409.6a192 192 0 0 1-37.888 349.44A256.064 256.064 0 0 1 576 960h-96a32 32 0 1 1 0-64h96a192.06 192.06 0 0 0 181.12-128H736a32 32 0 0 1-32-32V416a32 32 0 0 1 32-32h32c10.368 0 20.544.832 30.528 2.432a288 288 0 0 0-573.056 0A193 193 0 0 1 256 384h32a32 32 0 0 1 32 32v320a32 32 0 0 1-32 32h-32a192 192 0 0 1-96-358.4 352 352 0 0 1 704 0M256 448a128 128 0 1 0 0 256zm640 128a128 128 0 0 0-128-128v256a128 128 0 0 0 128-128"
            })
          ]));
        }
      }), service_default = _sfc_main229;
      const _defineComponent230 = window["Vue"].defineComponent;
      const _createElementVNode230 = window["Vue"].createElementVNode;
      const _openBlock230 = window["Vue"].openBlock;
      const _createElementBlock230 = window["Vue"].createElementBlock;
      var _sfc_main230 = /* @__PURE__ */ _defineComponent230({
        name: "SetUp",
        __name: "set-up",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock230(), _createElementBlock230("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode230("path", {
              fill: "currentColor",
              d: "M224 160a64 64 0 0 0-64 64v576a64 64 0 0 0 64 64h576a64 64 0 0 0 64-64V224a64 64 0 0 0-64-64zm0-64h576a128 128 0 0 1 128 128v576a128 128 0 0 1-128 128H224A128 128 0 0 1 96 800V224A128 128 0 0 1 224 96"
            }),
            _createElementVNode230("path", {
              fill: "currentColor",
              d: "M384 416a64 64 0 1 0 0-128 64 64 0 0 0 0 128m0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256"
            }),
            _createElementVNode230("path", {
              fill: "currentColor",
              d: "M480 320h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32m160 416a64 64 0 1 0 0-128 64 64 0 0 0 0 128m0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256"
            }),
            _createElementVNode230("path", {
              fill: "currentColor",
              d: "M288 640h256q32 0 32 32t-32 32H288q-32 0-32-32t32-32"
            })
          ]));
        }
      }), set_up_default = _sfc_main230;
      const _defineComponent231 = window["Vue"].defineComponent;
      const _createElementVNode231 = window["Vue"].createElementVNode;
      const _openBlock231 = window["Vue"].openBlock;
      const _createElementBlock231 = window["Vue"].createElementBlock;
      var _sfc_main231 = /* @__PURE__ */ _defineComponent231({
        name: "Setting",
        __name: "setting",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock231(), _createElementBlock231("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode231("path", {
              fill: "currentColor",
              d: "M600.704 64a32 32 0 0 1 30.464 22.208l35.2 109.376c14.784 7.232 28.928 15.36 42.432 24.512l112.384-24.192a32 32 0 0 1 34.432 15.36L944.32 364.8a32 32 0 0 1-4.032 37.504l-77.12 85.12a357 357 0 0 1 0 49.024l77.12 85.248a32 32 0 0 1 4.032 37.504l-88.704 153.6a32 32 0 0 1-34.432 15.296L708.8 803.904c-13.44 9.088-27.648 17.28-42.368 24.512l-35.264 109.376A32 32 0 0 1 600.704 960H423.296a32 32 0 0 1-30.464-22.208L357.696 828.48a352 352 0 0 1-42.56-24.64l-112.32 24.256a32 32 0 0 1-34.432-15.36L79.68 659.2a32 32 0 0 1 4.032-37.504l77.12-85.248a357 357 0 0 1 0-48.896l-77.12-85.248A32 32 0 0 1 79.68 364.8l88.704-153.6a32 32 0 0 1 34.432-15.296l112.32 24.256c13.568-9.152 27.776-17.408 42.56-24.64l35.2-109.312A32 32 0 0 1 423.232 64H600.64zm-23.424 64H446.72l-36.352 113.088-24.512 11.968a294 294 0 0 0-34.816 20.096l-22.656 15.36-116.224-25.088-65.28 113.152 79.68 88.192-1.92 27.136a293 293 0 0 0 0 40.192l1.92 27.136-79.808 88.192 65.344 113.152 116.224-25.024 22.656 15.296a294 294 0 0 0 34.816 20.096l24.512 11.968L446.72 896h130.688l36.48-113.152 24.448-11.904a288 288 0 0 0 34.752-20.096l22.592-15.296 116.288 25.024 65.28-113.152-79.744-88.192 1.92-27.136a293 293 0 0 0 0-40.256l-1.92-27.136 79.808-88.128-65.344-113.152-116.288 24.96-22.592-15.232a288 288 0 0 0-34.752-20.096l-24.448-11.904L577.344 128zM512 320a192 192 0 1 1 0 384 192 192 0 0 1 0-384m0 64a128 128 0 1 0 0 256 128 128 0 0 0 0-256"
            })
          ]));
        }
      }), setting_default = _sfc_main231;
      const _defineComponent232 = window["Vue"].defineComponent;
      const _createElementVNode232 = window["Vue"].createElementVNode;
      const _openBlock232 = window["Vue"].openBlock;
      const _createElementBlock232 = window["Vue"].createElementBlock;
      var _sfc_main232 = /* @__PURE__ */ _defineComponent232({
        name: "Share",
        __name: "share",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock232(), _createElementBlock232("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode232("path", {
              fill: "currentColor",
              d: "m679.872 348.8-301.76 188.608a127.8 127.8 0 0 1 5.12 52.16l279.936 104.96a128 128 0 1 1-22.464 59.904l-279.872-104.96a128 128 0 1 1-16.64-166.272l301.696-188.608a128 128 0 1 1 33.92 54.272z"
            })
          ]));
        }
      }), share_default = _sfc_main232;
      const _defineComponent233 = window["Vue"].defineComponent;
      const _createElementVNode233 = window["Vue"].createElementVNode;
      const _openBlock233 = window["Vue"].openBlock;
      const _createElementBlock233 = window["Vue"].createElementBlock;
      var _sfc_main233 = /* @__PURE__ */ _defineComponent233({
        name: "Ship",
        __name: "ship",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock233(), _createElementBlock233("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode233("path", {
              fill: "currentColor",
              d: "M512 386.88V448h405.568a32 32 0 0 1 30.72 40.768l-76.48 267.968A192 192 0 0 1 687.168 896H336.832a192 192 0 0 1-184.64-139.264L75.648 488.768A32 32 0 0 1 106.368 448H448V117.888a32 32 0 0 1 47.36-28.096l13.888 7.616L512 96v2.88l231.68 126.4a32 32 0 0 1-2.048 57.216zm0-70.272 144.768-65.792L512 171.84zM512 512H148.864l18.24 64H856.96l18.24-64zM185.408 640l28.352 99.2A128 128 0 0 0 336.832 832h350.336a128 128 0 0 0 123.072-92.8l28.352-99.2z"
            })
          ]));
        }
      }), ship_default = _sfc_main233;
      const _defineComponent234 = window["Vue"].defineComponent;
      const _createElementVNode234 = window["Vue"].createElementVNode;
      const _openBlock234 = window["Vue"].openBlock;
      const _createElementBlock234 = window["Vue"].createElementBlock;
      var _sfc_main234 = /* @__PURE__ */ _defineComponent234({
        name: "Shop",
        __name: "shop",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock234(), _createElementBlock234("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode234("path", {
              fill: "currentColor",
              d: "M704 704h64v192H256V704h64v64h384zm188.544-152.192C894.528 559.616 896 567.616 896 576a96 96 0 1 1-192 0 96 96 0 1 1-192 0 96 96 0 1 1-192 0 96 96 0 1 1-192 0c0-8.384 1.408-16.384 3.392-24.192L192 128h640z"
            })
          ]));
        }
      }), shop_default = _sfc_main234;
      const _defineComponent235 = window["Vue"].defineComponent;
      const _createElementVNode235 = window["Vue"].createElementVNode;
      const _openBlock235 = window["Vue"].openBlock;
      const _createElementBlock235 = window["Vue"].createElementBlock;
      var _sfc_main235 = /* @__PURE__ */ _defineComponent235({
        name: "ShoppingBag",
        __name: "shopping-bag",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock235(), _createElementBlock235("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode235("path", {
              fill: "currentColor",
              d: "M704 320v96a32 32 0 0 1-32 32h-32V320H384v128h-32a32 32 0 0 1-32-32v-96H192v576h640V320zm-384-64a192 192 0 1 1 384 0h160a32 32 0 0 1 32 32v640a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V288a32 32 0 0 1 32-32zm64 0h256a128 128 0 1 0-256 0"
            }),
            _createElementVNode235("path", {
              fill: "currentColor",
              d: "M192 704h640v64H192z"
            })
          ]));
        }
      }), shopping_bag_default = _sfc_main235;
      const _defineComponent236 = window["Vue"].defineComponent;
      const _createElementVNode236 = window["Vue"].createElementVNode;
      const _openBlock236 = window["Vue"].openBlock;
      const _createElementBlock236 = window["Vue"].createElementBlock;
      var _sfc_main236 = /* @__PURE__ */ _defineComponent236({
        name: "ShoppingCartFull",
        __name: "shopping-cart-full",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock236(), _createElementBlock236("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode236("path", {
              fill: "currentColor",
              d: "M432 928a48 48 0 1 1 0-96 48 48 0 0 1 0 96m320 0a48 48 0 1 1 0-96 48 48 0 0 1 0 96M96 128a32 32 0 0 1 0-64h160a32 32 0 0 1 31.36 25.728L320.64 256H928a32 32 0 0 1 31.296 38.72l-96 448A32 32 0 0 1 832 768H384a32 32 0 0 1-31.36-25.728L229.76 128zm314.24 576h395.904l82.304-384H333.44z"
            }),
            _createElementVNode236("path", {
              fill: "currentColor",
              d: "M699.648 256 608 145.984 516.352 256zm-140.8-151.04a64 64 0 0 1 98.304 0L836.352 320H379.648z"
            })
          ]));
        }
      }), shopping_cart_full_default = _sfc_main236;
      const _defineComponent237 = window["Vue"].defineComponent;
      const _createElementVNode237 = window["Vue"].createElementVNode;
      const _openBlock237 = window["Vue"].openBlock;
      const _createElementBlock237 = window["Vue"].createElementBlock;
      var _sfc_main237 = /* @__PURE__ */ _defineComponent237({
        name: "ShoppingCart",
        __name: "shopping-cart",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock237(), _createElementBlock237("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode237("path", {
              fill: "currentColor",
              d: "M432 928a48 48 0 1 1 0-96 48 48 0 0 1 0 96m320 0a48 48 0 1 1 0-96 48 48 0 0 1 0 96M96 128a32 32 0 0 1 0-64h160a32 32 0 0 1 31.36 25.728L320.64 256H928a32 32 0 0 1 31.296 38.72l-96 448A32 32 0 0 1 832 768H384a32 32 0 0 1-31.36-25.728L229.76 128zm314.24 576h395.904l82.304-384H333.44z"
            })
          ]));
        }
      }), shopping_cart_default = _sfc_main237;
      const _defineComponent238 = window["Vue"].defineComponent;
      const _createElementVNode238 = window["Vue"].createElementVNode;
      const _openBlock238 = window["Vue"].openBlock;
      const _createElementBlock238 = window["Vue"].createElementBlock;
      var _sfc_main238 = /* @__PURE__ */ _defineComponent238({
        name: "ShoppingTrolley",
        __name: "shopping-trolley",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock238(), _createElementBlock238("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            "xml:space": "preserve",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode238("path", {
              fill: "currentColor",
              d: "M368 833c-13.3 0-24.5 4.5-33.5 13.5S321 866.7 321 880s4.5 24.5 13.5 33.5 20.2 13.8 33.5 14.5c13.3-.7 24.5-5.5 33.5-14.5S415 893.3 415 880s-4.5-24.5-13.5-33.5S381.3 833 368 833m439-193c7.4 0 13.8-2.2 19.5-6.5S836 623.3 838 616l112-448c2-10-.2-19.2-6.5-27.5S929 128 919 128H96c-9.3 0-17 3-23 9s-9 13.7-9 23 3 17 9 23 13.7 9 23 9h96v576h672c9.3 0 17-3 23-9s9-13.7 9-23-3-17-9-23-13.7-9-23-9H256v-64zM256 192h622l-96 384H256zm432 641c-13.3 0-24.5 4.5-33.5 13.5S641 866.7 641 880s4.5 24.5 13.5 33.5 20.2 13.8 33.5 14.5c13.3-.7 24.5-5.5 33.5-14.5S735 893.3 735 880s-4.5-24.5-13.5-33.5S701.3 833 688 833"
            })
          ]));
        }
      }), shopping_trolley_default = _sfc_main238;
      const _defineComponent239 = window["Vue"].defineComponent;
      const _createElementVNode239 = window["Vue"].createElementVNode;
      const _openBlock239 = window["Vue"].openBlock;
      const _createElementBlock239 = window["Vue"].createElementBlock;
      var _sfc_main239 = /* @__PURE__ */ _defineComponent239({
        name: "Smoking",
        __name: "smoking",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock239(), _createElementBlock239("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode239("path", {
              fill: "currentColor",
              d: "M256 576v128h640V576zm-32-64h704a32 32 0 0 1 32 32v192a32 32 0 0 1-32 32H224a32 32 0 0 1-32-32V544a32 32 0 0 1 32-32"
            }),
            _createElementVNode239("path", {
              fill: "currentColor",
              d: "M704 576h64v128h-64zM256 64h64v320h-64zM128 192h64v192h-64zM64 512h64v256H64z"
            })
          ]));
        }
      }), smoking_default = _sfc_main239;
      const _defineComponent240 = window["Vue"].defineComponent;
      const _createElementVNode240 = window["Vue"].createElementVNode;
      const _openBlock240 = window["Vue"].openBlock;
      const _createElementBlock240 = window["Vue"].createElementBlock;
      var _sfc_main240 = /* @__PURE__ */ _defineComponent240({
        name: "Soccer",
        __name: "soccer",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock240(), _createElementBlock240("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode240("path", {
              fill: "currentColor",
              d: "M418.496 871.04 152.256 604.8c-16.512 94.016-2.368 178.624 42.944 224 44.928 44.928 129.344 58.752 223.296 42.24m72.32-18.176a573.06 573.06 0 0 0 224.832-137.216 573.1 573.1 0 0 0 137.216-224.832L533.888 171.84a578.56 578.56 0 0 0-227.52 138.496A567.7 567.7 0 0 0 170.432 532.48zM871.04 418.496c16.512-93.952 2.688-178.368-42.24-223.296-44.544-44.544-128.704-58.048-222.592-41.536zM149.952 874.048c-112.96-112.96-88.832-408.96 111.168-608.96C461.056 65.152 760.96 36.928 874.048 149.952c113.024 113.024 86.784 411.008-113.152 610.944s-497.92 226.112-610.944 113.152m452.544-497.792 22.656-22.656a32 32 0 0 1 45.248 45.248l-22.656 22.656 45.248 45.248A32 32 0 1 1 647.744 512l-45.248-45.248L557.248 512l45.248 45.248a32 32 0 1 1-45.248 45.248L512 557.248l-45.248 45.248L512 647.744a32 32 0 1 1-45.248 45.248l-45.248-45.248-22.656 22.656a32 32 0 1 1-45.248-45.248l22.656-22.656-45.248-45.248A32 32 0 1 1 376.256 512l45.248 45.248L466.752 512l-45.248-45.248a32 32 0 1 1 45.248-45.248L512 466.752l45.248-45.248L512 376.256a32 32 0 0 1 45.248-45.248z"
            })
          ]));
        }
      }), soccer_default = _sfc_main240;
      const _defineComponent241 = window["Vue"].defineComponent;
      const _createElementVNode241 = window["Vue"].createElementVNode;
      const _openBlock241 = window["Vue"].openBlock;
      const _createElementBlock241 = window["Vue"].createElementBlock;
      var _sfc_main241 = /* @__PURE__ */ _defineComponent241({
        name: "SoldOut",
        __name: "sold-out",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock241(), _createElementBlock241("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode241("path", {
              fill: "currentColor",
              d: "M704 288h131.072a32 32 0 0 1 31.808 28.8L886.4 512h-64.384l-16-160H704v96a32 32 0 1 1-64 0v-96H384v96a32 32 0 0 1-64 0v-96H217.92l-51.2 512H512v64H131.328a32 32 0 0 1-31.808-35.2l57.6-576a32 32 0 0 1 31.808-28.8H320v-22.336C320 154.688 405.504 64 512 64s192 90.688 192 201.664v22.4zm-64 0v-22.336C640 189.248 582.272 128 512 128s-128 61.248-128 137.664v22.4h256zm201.408 476.16a32 32 0 1 1 45.248 45.184l-128 128a32 32 0 0 1-45.248 0l-128-128a32 32 0 1 1 45.248-45.248L704 837.504V608a32 32 0 1 1 64 0v229.504l73.408-73.408z"
            })
          ]));
        }
      }), sold_out_default = _sfc_main241;
      const _defineComponent242 = window["Vue"].defineComponent;
      const _createElementVNode242 = window["Vue"].createElementVNode;
      const _openBlock242 = window["Vue"].openBlock;
      const _createElementBlock242 = window["Vue"].createElementBlock;
      var _sfc_main242 = /* @__PURE__ */ _defineComponent242({
        name: "SortDown",
        __name: "sort-down",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock242(), _createElementBlock242("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode242("path", {
              fill: "currentColor",
              d: "M576 96v709.568L333.312 562.816A32 32 0 1 0 288 608l297.408 297.344A32 32 0 0 0 640 882.688V96a32 32 0 0 0-64 0"
            })
          ]));
        }
      }), sort_down_default = _sfc_main242;
      const _defineComponent243 = window["Vue"].defineComponent;
      const _createElementVNode243 = window["Vue"].createElementVNode;
      const _openBlock243 = window["Vue"].openBlock;
      const _createElementBlock243 = window["Vue"].createElementBlock;
      var _sfc_main243 = /* @__PURE__ */ _defineComponent243({
        name: "SortUp",
        __name: "sort-up",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock243(), _createElementBlock243("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode243("path", {
              fill: "currentColor",
              d: "M384 141.248V928a32 32 0 1 0 64 0V218.56l242.688 242.688A32 32 0 1 0 736 416L438.592 118.656A32 32 0 0 0 384 141.248"
            })
          ]));
        }
      }), sort_up_default = _sfc_main243;
      const _defineComponent244 = window["Vue"].defineComponent;
      const _createElementVNode244 = window["Vue"].createElementVNode;
      const _openBlock244 = window["Vue"].openBlock;
      const _createElementBlock244 = window["Vue"].createElementBlock;
      var _sfc_main244 = /* @__PURE__ */ _defineComponent244({
        name: "Sort",
        __name: "sort",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock244(), _createElementBlock244("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode244("path", {
              fill: "currentColor",
              d: "M384 96a32 32 0 0 1 64 0v786.752a32 32 0 0 1-54.592 22.656L95.936 608a32 32 0 0 1 0-45.312h.128a32 32 0 0 1 45.184 0L384 805.632zm192 45.248a32 32 0 0 1 54.592-22.592L928.064 416a32 32 0 0 1 0 45.312h-.128a32 32 0 0 1-45.184 0L640 218.496V928a32 32 0 1 1-64 0z"
            })
          ]));
        }
      }), sort_default = _sfc_main244;
      const _defineComponent245 = window["Vue"].defineComponent;
      const _createElementVNode245 = window["Vue"].createElementVNode;
      const _openBlock245 = window["Vue"].openBlock;
      const _createElementBlock245 = window["Vue"].createElementBlock;
      var _sfc_main245 = /* @__PURE__ */ _defineComponent245({
        name: "Stamp",
        __name: "stamp",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock245(), _createElementBlock245("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode245("path", {
              fill: "currentColor",
              d: "M624 475.968V640h144a128 128 0 0 1 128 128H128a128 128 0 0 1 128-128h144V475.968a192 192 0 1 1 224 0M128 896v-64h768v64z"
            })
          ]));
        }
      }), stamp_default = _sfc_main245;
      const _defineComponent246 = window["Vue"].defineComponent;
      const _createElementVNode246 = window["Vue"].createElementVNode;
      const _openBlock246 = window["Vue"].openBlock;
      const _createElementBlock246 = window["Vue"].createElementBlock;
      var _sfc_main246 = /* @__PURE__ */ _defineComponent246({
        name: "StarFilled",
        __name: "star-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock246(), _createElementBlock246("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode246("path", {
              fill: "currentColor",
              d: "M313.6 924.48a70.4 70.4 0 0 1-74.152-5.365 70.4 70.4 0 0 1-27.992-68.875l37.888-220.928L88.96 472.96a70.4 70.4 0 0 1 3.788-104.225A70.4 70.4 0 0 1 128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 0 1 100.246-28.595 70.4 70.4 0 0 1 25.962 28.595l99.2 200.96 221.824 32.256a70.4 70.4 0 0 1 39.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 0 1-102.144 74.24L512 820.096l-198.4 104.32z"
            })
          ]));
        }
      }), star_filled_default = _sfc_main246;
      const _defineComponent247 = window["Vue"].defineComponent;
      const _createElementVNode247 = window["Vue"].createElementVNode;
      const _openBlock247 = window["Vue"].openBlock;
      const _createElementBlock247 = window["Vue"].createElementBlock;
      var _sfc_main247 = /* @__PURE__ */ _defineComponent247({
        name: "Star",
        __name: "star",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock247(), _createElementBlock247("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode247("path", {
              fill: "currentColor",
              d: "m512 747.84 228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72zM313.6 924.48a70.4 70.4 0 0 1-102.144-74.24l37.888-220.928L88.96 472.96A70.4 70.4 0 0 1 128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 0 1 126.208 0l99.2 200.96 221.824 32.256a70.4 70.4 0 0 1 39.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 0 1-102.144 74.24L512 820.096l-198.4 104.32z"
            })
          ]));
        }
      }), star_default = _sfc_main247;
      const _defineComponent248 = window["Vue"].defineComponent;
      const _createElementVNode248 = window["Vue"].createElementVNode;
      const _openBlock248 = window["Vue"].openBlock;
      const _createElementBlock248 = window["Vue"].createElementBlock;
      var _sfc_main248 = /* @__PURE__ */ _defineComponent248({
        name: "Stopwatch",
        __name: "stopwatch",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock248(), _createElementBlock248("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode248("path", {
              fill: "currentColor",
              d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
            }),
            _createElementVNode248("path", {
              fill: "currentColor",
              d: "M672 234.88c-39.168 174.464-80 298.624-122.688 372.48-64 110.848-202.624 30.848-138.624-80C453.376 453.44 540.48 355.968 672 234.816z"
            })
          ]));
        }
      }), stopwatch_default = _sfc_main248;
      const _defineComponent249 = window["Vue"].defineComponent;
      const _createElementVNode249 = window["Vue"].createElementVNode;
      const _openBlock249 = window["Vue"].openBlock;
      const _createElementBlock249 = window["Vue"].createElementBlock;
      var _sfc_main249 = /* @__PURE__ */ _defineComponent249({
        name: "SuccessFilled",
        __name: "success-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock249(), _createElementBlock249("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode249("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.27 38.27 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
            })
          ]));
        }
      }), success_filled_default = _sfc_main249;
      const _defineComponent250 = window["Vue"].defineComponent;
      const _createElementVNode250 = window["Vue"].createElementVNode;
      const _openBlock250 = window["Vue"].openBlock;
      const _createElementBlock250 = window["Vue"].createElementBlock;
      var _sfc_main250 = /* @__PURE__ */ _defineComponent250({
        name: "Sugar",
        __name: "sugar",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock250(), _createElementBlock250("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode250("path", {
              fill: "currentColor",
              d: "m801.728 349.184 4.48 4.48a128 128 0 0 1 0 180.992L534.656 806.144a128 128 0 0 1-181.056 0l-4.48-4.48-19.392 109.696a64 64 0 0 1-108.288 34.176L78.464 802.56a64 64 0 0 1 34.176-108.288l109.76-19.328-4.544-4.544a128 128 0 0 1 0-181.056l271.488-271.488a128 128 0 0 1 181.056 0l4.48 4.48 19.392-109.504a64 64 0 0 1 108.352-34.048l142.592 143.04a64 64 0 0 1-34.24 108.16zm-548.8 198.72h447.168v2.24l60.8-60.8a63.8 63.8 0 0 0 18.752-44.416h-426.88l-89.664 89.728a64 64 0 0 0-10.24 13.248zm0 64q4.128 7.104 10.176 13.248l135.744 135.744a64 64 0 0 0 90.496 0L638.4 611.904zm490.048-230.976L625.152 263.104a64 64 0 0 0-90.496 0L416.768 380.928zM123.712 757.312l142.976 142.976 24.32-137.6a25.6 25.6 0 0 0-29.696-29.632zm633.6-633.344-24.32 137.472a25.6 25.6 0 0 0 29.632 29.632l137.28-24.064-142.656-143.04z"
            })
          ]));
        }
      }), sugar_default = _sfc_main250;
      const _defineComponent251 = window["Vue"].defineComponent;
      const _createElementVNode251 = window["Vue"].createElementVNode;
      const _openBlock251 = window["Vue"].openBlock;
      const _createElementBlock251 = window["Vue"].createElementBlock;
      var _sfc_main251 = /* @__PURE__ */ _defineComponent251({
        name: "SuitcaseLine",
        __name: "suitcase-line",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock251(), _createElementBlock251("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            "xml:space": "preserve",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode251("path", {
              fill: "currentColor",
              d: "M922.5 229.5c-24.32-24.34-54.49-36.84-90.5-37.5H704v-64c-.68-17.98-7.02-32.98-19.01-44.99S658.01 64.66 640 64H384c-17.98.68-32.98 7.02-44.99 19.01S320.66 110 320 128v64H192c-35.99.68-66.16 13.18-90.5 37.5S64.66 283.99 64 320v448c.68 35.99 13.18 66.16 37.5 90.5s54.49 36.84 90.5 37.5h640c35.99-.68 66.16-13.18 90.5-37.5s36.84-54.49 37.5-90.5V320c-.68-35.99-13.18-66.16-37.5-90.5M384 128h256v64H384zM256 832h-64c-17.98-.68-32.98-7.02-44.99-19.01S128.66 786.01 128 768V448h128zm448 0H320V448h384zm192-64c-.68 17.98-7.02 32.98-19.01 44.99S850.01 831.34 832 832h-64V448h128zm0-384H128v-64c.69-17.98 7.02-32.98 19.01-44.99S173.99 256.66 192 256h640c17.98.69 32.98 7.02 44.99 19.01S895.34 301.99 896 320z"
            })
          ]));
        }
      }), suitcase_line_default = _sfc_main251;
      const _defineComponent252 = window["Vue"].defineComponent;
      const _createElementVNode252 = window["Vue"].createElementVNode;
      const _openBlock252 = window["Vue"].openBlock;
      const _createElementBlock252 = window["Vue"].createElementBlock;
      var _sfc_main252 = /* @__PURE__ */ _defineComponent252({
        name: "Suitcase",
        __name: "suitcase",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock252(), _createElementBlock252("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode252("path", {
              fill: "currentColor",
              d: "M128 384h768v-64a64 64 0 0 0-64-64H192a64 64 0 0 0-64 64zm0 64v320a64 64 0 0 0 64 64h640a64 64 0 0 0 64-64V448zm64-256h640a128 128 0 0 1 128 128v448a128 128 0 0 1-128 128H192A128 128 0 0 1 64 768V320a128 128 0 0 1 128-128"
            }),
            _createElementVNode252("path", {
              fill: "currentColor",
              d: "M384 128v64h256v-64zm0-64h256a64 64 0 0 1 64 64v64a64 64 0 0 1-64 64H384a64 64 0 0 1-64-64v-64a64 64 0 0 1 64-64"
            })
          ]));
        }
      }), suitcase_default = _sfc_main252;
      const _defineComponent253 = window["Vue"].defineComponent;
      const _createElementVNode253 = window["Vue"].createElementVNode;
      const _openBlock253 = window["Vue"].openBlock;
      const _createElementBlock253 = window["Vue"].createElementBlock;
      var _sfc_main253 = /* @__PURE__ */ _defineComponent253({
        name: "Sunny",
        __name: "sunny",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock253(), _createElementBlock253("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode253("path", {
              fill: "currentColor",
              d: "M512 704a192 192 0 1 0 0-384 192 192 0 0 0 0 384m0 64a256 256 0 1 1 0-512 256 256 0 0 1 0 512m0-704a32 32 0 0 1 32 32v64a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 768a32 32 0 0 1 32 32v64a32 32 0 1 1-64 0v-64a32 32 0 0 1 32-32M195.2 195.2a32 32 0 0 1 45.248 0l45.248 45.248a32 32 0 1 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248m543.104 543.104a32 32 0 0 1 45.248 0l45.248 45.248a32 32 0 0 1-45.248 45.248l-45.248-45.248a32 32 0 0 1 0-45.248M64 512a32 32 0 0 1 32-32h64a32 32 0 0 1 0 64H96a32 32 0 0 1-32-32m768 0a32 32 0 0 1 32-32h64a32 32 0 1 1 0 64h-64a32 32 0 0 1-32-32M195.2 828.8a32 32 0 0 1 0-45.248l45.248-45.248a32 32 0 0 1 45.248 45.248L240.448 828.8a32 32 0 0 1-45.248 0m543.104-543.104a32 32 0 0 1 0-45.248l45.248-45.248a32 32 0 0 1 45.248 45.248l-45.248 45.248a32 32 0 0 1-45.248 0"
            })
          ]));
        }
      }), sunny_default = _sfc_main253;
      const _defineComponent254 = window["Vue"].defineComponent;
      const _createElementVNode254 = window["Vue"].createElementVNode;
      const _openBlock254 = window["Vue"].openBlock;
      const _createElementBlock254 = window["Vue"].createElementBlock;
      var _sfc_main254 = /* @__PURE__ */ _defineComponent254({
        name: "Sunrise",
        __name: "sunrise",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock254(), _createElementBlock254("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode254("path", {
              fill: "currentColor",
              d: "M32 768h960a32 32 0 1 1 0 64H32a32 32 0 1 1 0-64m129.408-96a352 352 0 0 1 701.184 0h-64.32a288 288 0 0 0-572.544 0zM512 128a32 32 0 0 1 32 32v96a32 32 0 0 1-64 0v-96a32 32 0 0 1 32-32m407.296 168.704a32 32 0 0 1 0 45.248l-67.84 67.84a32 32 0 1 1-45.248-45.248l67.84-67.84a32 32 0 0 1 45.248 0m-814.592 0a32 32 0 0 1 45.248 0l67.84 67.84a32 32 0 1 1-45.248 45.248l-67.84-67.84a32 32 0 0 1 0-45.248"
            })
          ]));
        }
      }), sunrise_default = _sfc_main254;
      const _defineComponent255 = window["Vue"].defineComponent;
      const _createElementVNode255 = window["Vue"].createElementVNode;
      const _openBlock255 = window["Vue"].openBlock;
      const _createElementBlock255 = window["Vue"].createElementBlock;
      var _sfc_main255 = /* @__PURE__ */ _defineComponent255({
        name: "Sunset",
        __name: "sunset",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock255(), _createElementBlock255("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode255("path", {
              fill: "currentColor",
              d: "M82.56 640a448 448 0 1 1 858.88 0h-67.2a384 384 0 1 0-724.288 0zM32 704h960q32 0 32 32t-32 32H32q-32 0-32-32t32-32m256 128h448q32 0 32 32t-32 32H288q-32 0-32-32t32-32"
            })
          ]));
        }
      }), sunset_default = _sfc_main255;
      const _defineComponent256 = window["Vue"].defineComponent;
      const _createElementVNode256 = window["Vue"].createElementVNode;
      const _openBlock256 = window["Vue"].openBlock;
      const _createElementBlock256 = window["Vue"].createElementBlock;
      var _sfc_main256 = /* @__PURE__ */ _defineComponent256({
        name: "SwitchButton",
        __name: "switch-button",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock256(), _createElementBlock256("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode256("path", {
              fill: "currentColor",
              d: "M352 159.872V230.4a352 352 0 1 0 320 0v-70.528A416.128 416.128 0 0 1 512 960a416 416 0 0 1-160-800.128"
            }),
            _createElementVNode256("path", {
              fill: "currentColor",
              d: "M512 64q32 0 32 32v320q0 32-32 32t-32-32V96q0-32 32-32"
            })
          ]));
        }
      }), switch_button_default = _sfc_main256;
      const _defineComponent257 = window["Vue"].defineComponent;
      const _createElementVNode257 = window["Vue"].createElementVNode;
      const _openBlock257 = window["Vue"].openBlock;
      const _createElementBlock257 = window["Vue"].createElementBlock;
      var _sfc_main257 = /* @__PURE__ */ _defineComponent257({
        name: "SwitchFilled",
        __name: "switch-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock257(), _createElementBlock257("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            "xml:space": "preserve",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode257("path", {
              fill: "currentColor",
              d: "M247.47 358.4v.04c.07 19.17 7.72 37.53 21.27 51.09s31.92 21.2 51.09 21.27c39.86 0 72.41-32.6 72.41-72.4s-32.6-72.36-72.41-72.36-72.36 32.55-72.36 72.36"
            }),
            _createElementVNode257("path", {
              fill: "currentColor",
              d: "M492.38 128H324.7c-52.16 0-102.19 20.73-139.08 57.61a196.66 196.66 0 0 0-57.61 139.08V698.7c-.01 25.84 5.08 51.42 14.96 75.29s24.36 45.56 42.63 63.83 39.95 32.76 63.82 42.65a196.7 196.7 0 0 0 75.28 14.98h167.68c3.03 0 5.46-2.43 5.46-5.42V133.42c.6-2.99-1.83-5.42-5.46-5.42m-56.11 705.88H324.7c-17.76.13-35.36-3.33-51.75-10.18s-31.22-16.94-43.61-29.67c-25.3-25.35-39.81-59.1-39.81-95.32V324.69c-.13-17.75 3.33-35.35 10.17-51.74a131.7 131.7 0 0 1 29.64-43.62c25.39-25.3 59.14-39.81 95.36-39.81h111.57zm402.12-647.67a196.66 196.66 0 0 0-139.08-57.61H580.48c-3.03 0-4.82 2.43-4.82 4.82v757.16c-.6 2.99 1.79 5.42 5.42 5.42h118.23a196.7 196.7 0 0 0 139.08-57.61A196.66 196.66 0 0 0 896 699.31V325.29a196.7 196.7 0 0 0-57.61-139.08m-111.3 441.92c-42.83 0-77.82-34.99-77.82-77.82s34.98-77.82 77.82-77.82c42.83 0 77.82 34.99 77.82 77.82s-34.99 77.82-77.82 77.82"
            })
          ]));
        }
      }), switch_filled_default = _sfc_main257;
      const _defineComponent258 = window["Vue"].defineComponent;
      const _createElementVNode258 = window["Vue"].createElementVNode;
      const _openBlock258 = window["Vue"].openBlock;
      const _createElementBlock258 = window["Vue"].createElementBlock;
      var _sfc_main258 = /* @__PURE__ */ _defineComponent258({
        name: "Switch",
        __name: "switch",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock258(), _createElementBlock258("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode258("path", {
              fill: "currentColor",
              d: "M118.656 438.656a32 32 0 0 1 0-45.248L416 96l4.48-3.776A32 32 0 0 1 461.248 96l3.712 4.48a32.064 32.064 0 0 1-3.712 40.832L218.56 384H928a32 32 0 1 1 0 64H141.248a32 32 0 0 1-22.592-9.344M64 608a32 32 0 0 1 32-32h786.752a32 32 0 0 1 22.656 54.592L608 928l-4.48 3.776a32.064 32.064 0 0 1-40.832-49.024L805.632 640H96a32 32 0 0 1-32-32"
            })
          ]));
        }
      }), switch_default = _sfc_main258;
      const _defineComponent259 = window["Vue"].defineComponent;
      const _createElementVNode259 = window["Vue"].createElementVNode;
      const _openBlock259 = window["Vue"].openBlock;
      const _createElementBlock259 = window["Vue"].createElementBlock;
      var _sfc_main259 = /* @__PURE__ */ _defineComponent259({
        name: "TakeawayBox",
        __name: "takeaway-box",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock259(), _createElementBlock259("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode259("path", {
              fill: "currentColor",
              d: "M832 384H192v448h640zM96 320h832V128H96zm800 64v480a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V384H64a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32h896a32 32 0 0 1 32 32v256a32 32 0 0 1-32 32zM416 512h192a32 32 0 0 1 0 64H416a32 32 0 0 1 0-64"
            })
          ]));
        }
      }), takeaway_box_default = _sfc_main259;
      const _defineComponent260 = window["Vue"].defineComponent;
      const _createElementVNode260 = window["Vue"].createElementVNode;
      const _openBlock260 = window["Vue"].openBlock;
      const _createElementBlock260 = window["Vue"].createElementBlock;
      var _sfc_main260 = /* @__PURE__ */ _defineComponent260({
        name: "Ticket",
        __name: "ticket",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock260(), _createElementBlock260("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode260("path", {
              fill: "currentColor",
              d: "M640 832H64V640a128 128 0 1 0 0-256V192h576v160h64V192h256v192a128 128 0 1 0 0 256v192H704V672h-64zm0-416v192h64V416z"
            })
          ]));
        }
      }), ticket_default = _sfc_main260;
      const _defineComponent261 = window["Vue"].defineComponent;
      const _createElementVNode261 = window["Vue"].createElementVNode;
      const _openBlock261 = window["Vue"].openBlock;
      const _createElementBlock261 = window["Vue"].createElementBlock;
      var _sfc_main261 = /* @__PURE__ */ _defineComponent261({
        name: "Tickets",
        __name: "tickets",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock261(), _createElementBlock261("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode261("path", {
              fill: "currentColor",
              d: "M192 128v768h640V128zm-32-64h704a32 32 0 0 1 32 32v832a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m160 448h384v64H320zm0-192h192v64H320zm0 384h384v64H320z"
            })
          ]));
        }
      }), tickets_default = _sfc_main261;
      const _defineComponent262 = window["Vue"].defineComponent;
      const _createElementVNode262 = window["Vue"].createElementVNode;
      const _openBlock262 = window["Vue"].openBlock;
      const _createElementBlock262 = window["Vue"].createElementBlock;
      var _sfc_main262 = /* @__PURE__ */ _defineComponent262({
        name: "Timer",
        __name: "timer",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock262(), _createElementBlock262("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode262("path", {
              fill: "currentColor",
              d: "M512 896a320 320 0 1 0 0-640 320 320 0 0 0 0 640m0 64a384 384 0 1 1 0-768 384 384 0 0 1 0 768"
            }),
            _createElementVNode262("path", {
              fill: "currentColor",
              d: "M512 320a32 32 0 0 1 32 32l-.512 224a32 32 0 1 1-64 0L480 352a32 32 0 0 1 32-32"
            }),
            _createElementVNode262("path", {
              fill: "currentColor",
              d: "M448 576a64 64 0 1 0 128 0 64 64 0 1 0-128 0m96-448v128h-64V128h-96a32 32 0 0 1 0-64h256a32 32 0 1 1 0 64z"
            })
          ]));
        }
      }), timer_default = _sfc_main262;
      const _defineComponent263 = window["Vue"].defineComponent;
      const _createElementVNode263 = window["Vue"].createElementVNode;
      const _openBlock263 = window["Vue"].openBlock;
      const _createElementBlock263 = window["Vue"].createElementBlock;
      var _sfc_main263 = /* @__PURE__ */ _defineComponent263({
        name: "ToiletPaper",
        __name: "toilet-paper",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock263(), _createElementBlock263("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode263("path", {
              fill: "currentColor",
              d: "M595.2 128H320a192 192 0 0 0-192 192v576h384V352c0-90.496 32.448-171.2 83.2-224M736 64c123.712 0 224 128.96 224 288S859.712 640 736 640H576v320H64V320A256 256 0 0 1 320 64zM576 352v224h160c84.352 0 160-97.28 160-224s-75.648-224-160-224-160 97.28-160 224"
            }),
            _createElementVNode263("path", {
              fill: "currentColor",
              d: "M736 448c-35.328 0-64-43.008-64-96s28.672-96 64-96 64 43.008 64 96-28.672 96-64 96"
            })
          ]));
        }
      }), toilet_paper_default = _sfc_main263;
      const _defineComponent264 = window["Vue"].defineComponent;
      const _createElementVNode264 = window["Vue"].createElementVNode;
      const _openBlock264 = window["Vue"].openBlock;
      const _createElementBlock264 = window["Vue"].createElementBlock;
      var _sfc_main264 = /* @__PURE__ */ _defineComponent264({
        name: "Tools",
        __name: "tools",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock264(), _createElementBlock264("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode264("path", {
              fill: "currentColor",
              d: "M764.416 254.72a351.7 351.7 0 0 1 86.336 149.184H960v192.064H850.752a351.7 351.7 0 0 1-86.336 149.312l54.72 94.72-166.272 96-54.592-94.72a352.64 352.64 0 0 1-172.48 0L371.136 936l-166.272-96 54.72-94.72a351.7 351.7 0 0 1-86.336-149.312H64v-192h109.248a351.7 351.7 0 0 1 86.336-149.312L204.8 160l166.208-96h.192l54.656 94.592a352.64 352.64 0 0 1 172.48 0L652.8 64h.128L819.2 160l-54.72 94.72zM704 499.968a192 192 0 1 0-384 0 192 192 0 0 0 384 0"
            })
          ]));
        }
      }), tools_default = _sfc_main264;
      const _defineComponent265 = window["Vue"].defineComponent;
      const _createElementVNode265 = window["Vue"].createElementVNode;
      const _openBlock265 = window["Vue"].openBlock;
      const _createElementBlock265 = window["Vue"].createElementBlock;
      var _sfc_main265 = /* @__PURE__ */ _defineComponent265({
        name: "TopLeft",
        __name: "top-left",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock265(), _createElementBlock265("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode265("path", {
              fill: "currentColor",
              d: "M256 256h416a32 32 0 1 0 0-64H224a32 32 0 0 0-32 32v448a32 32 0 0 0 64 0z"
            }),
            _createElementVNode265("path", {
              fill: "currentColor",
              d: "M246.656 201.344a32 32 0 0 0-45.312 45.312l544 544a32 32 0 0 0 45.312-45.312z"
            })
          ]));
        }
      }), top_left_default = _sfc_main265;
      const _defineComponent266 = window["Vue"].defineComponent;
      const _createElementVNode266 = window["Vue"].createElementVNode;
      const _openBlock266 = window["Vue"].openBlock;
      const _createElementBlock266 = window["Vue"].createElementBlock;
      var _sfc_main266 = /* @__PURE__ */ _defineComponent266({
        name: "TopRight",
        __name: "top-right",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock266(), _createElementBlock266("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode266("path", {
              fill: "currentColor",
              d: "M768 256H353.6a32 32 0 1 1 0-64H800a32 32 0 0 1 32 32v448a32 32 0 0 1-64 0z"
            }),
            _createElementVNode266("path", {
              fill: "currentColor",
              d: "M777.344 201.344a32 32 0 0 1 45.312 45.312l-544 544a32 32 0 0 1-45.312-45.312z"
            })
          ]));
        }
      }), top_right_default = _sfc_main266;
      const _defineComponent267 = window["Vue"].defineComponent;
      const _createElementVNode267 = window["Vue"].createElementVNode;
      const _openBlock267 = window["Vue"].openBlock;
      const _createElementBlock267 = window["Vue"].createElementBlock;
      var _sfc_main267 = /* @__PURE__ */ _defineComponent267({
        name: "Top",
        __name: "top",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock267(), _createElementBlock267("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode267("path", {
              fill: "currentColor",
              d: "M572.235 205.282v600.365a30.118 30.118 0 1 1-60.235 0V205.282L292.382 438.633a28.913 28.913 0 0 1-42.646 0 33.43 33.43 0 0 1 0-45.236l271.058-288.045a28.913 28.913 0 0 1 42.647 0L834.5 393.397a33.43 33.43 0 0 1 0 45.176 28.913 28.913 0 0 1-42.647 0l-219.618-233.23z"
            })
          ]));
        }
      }), top_default = _sfc_main267;
      const _defineComponent268 = window["Vue"].defineComponent;
      const _createElementVNode268 = window["Vue"].createElementVNode;
      const _openBlock268 = window["Vue"].openBlock;
      const _createElementBlock268 = window["Vue"].createElementBlock;
      var _sfc_main268 = /* @__PURE__ */ _defineComponent268({
        name: "TrendCharts",
        __name: "trend-charts",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock268(), _createElementBlock268("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode268("path", {
              fill: "currentColor",
              d: "M128 896V128h768v768zm291.712-327.296 128 102.4 180.16-201.792-47.744-42.624-139.84 156.608-128-102.4-180.16 201.792 47.744 42.624zM816 352a48 48 0 1 0-96 0 48 48 0 0 0 96 0"
            })
          ]));
        }
      }), trend_charts_default = _sfc_main268;
      const _defineComponent269 = window["Vue"].defineComponent;
      const _createElementVNode269 = window["Vue"].createElementVNode;
      const _openBlock269 = window["Vue"].openBlock;
      const _createElementBlock269 = window["Vue"].createElementBlock;
      var _sfc_main269 = /* @__PURE__ */ _defineComponent269({
        name: "TrophyBase",
        __name: "trophy-base",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock269(), _createElementBlock269("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            "xml:space": "preserve",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode269("path", {
              fill: "currentColor",
              d: "M918.4 201.6c-6.4-6.4-12.8-9.6-22.4-9.6H768V96c0-9.6-3.2-16-9.6-22.4S745.6 64 736 64H288c-9.6 0-16 3.2-22.4 9.6S256 86.4 256 96v96H128c-9.6 0-16 3.2-22.4 9.6S96 217.6 96 224c3.2 108.8 25.6 185.6 64 224 34.4 34.4 77.56 55.65 127.65 61.99 10.91 20.44 24.78 39.25 41.95 56.41 40.86 40.86 91 65.47 150.4 71.9V768h-96c-9.6 0-16 3.2-22.4 9.6S352 790.4 352 800s3.2 16 9.6 22.4 12.8 9.6 22.4 9.6h256c9.6 0 16-3.2 22.4-9.6s9.6-12.8 9.6-22.4-3.2-16-9.6-22.4-12.8-9.6-22.4-9.6h-96V637.26c59.4-7.71 109.54-30.01 150.4-70.86 17.2-17.2 31.51-36.06 42.81-56.55 48.93-6.51 90.02-27.7 126.79-61.85 38.4-38.4 60.8-112 64-224 0-6.4-3.2-16-9.6-22.4M256 438.4c-19.2-6.4-35.2-19.2-51.2-35.2-22.4-22.4-35.2-70.4-41.6-147.2H256zm390.4 80C608 553.6 566.4 576 512 576s-99.2-19.2-134.4-57.6S320 438.4 320 384V128h384v256q0 81.6-57.6 134.4m172.8-115.2c-16 16-32 25.6-51.2 35.2V256h92.8c-6.4 76.8-19.2 124.8-41.6 147.2M768 896H256c-9.6 0-16 3.2-22.4 9.6S224 918.4 224 928s3.2 16 9.6 22.4 12.8 9.6 22.4 9.6h512c9.6 0 16-3.2 22.4-9.6s9.6-12.8 9.6-22.4-3.2-16-9.6-22.4-12.8-9.6-22.4-9.6"
            })
          ]));
        }
      }), trophy_base_default = _sfc_main269;
      const _defineComponent270 = window["Vue"].defineComponent;
      const _createElementVNode270 = window["Vue"].createElementVNode;
      const _openBlock270 = window["Vue"].openBlock;
      const _createElementBlock270 = window["Vue"].createElementBlock;
      var _sfc_main270 = /* @__PURE__ */ _defineComponent270({
        name: "Trophy",
        __name: "trophy",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock270(), _createElementBlock270("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode270("path", {
              fill: "currentColor",
              d: "M480 896V702.08A256.26 256.26 0 0 1 264.064 512h-32.64a96 96 0 0 1-91.968-68.416L93.632 290.88a76.8 76.8 0 0 1 73.6-98.88H256V96a32 32 0 0 1 32-32h448a32 32 0 0 1 32 32v96h88.768a76.8 76.8 0 0 1 73.6 98.88L884.48 443.52A96 96 0 0 1 792.576 512h-32.64A256.26 256.26 0 0 1 544 702.08V896h128a32 32 0 1 1 0 64H352a32 32 0 1 1 0-64zm224-448V128H320v320a192 192 0 1 0 384 0m64 0h24.576a32 32 0 0 0 30.656-22.784l45.824-152.768A12.8 12.8 0 0 0 856.768 256H768zm-512 0V256h-88.768a12.8 12.8 0 0 0-12.288 16.448l45.824 152.768A32 32 0 0 0 231.424 448z"
            })
          ]));
        }
      }), trophy_default = _sfc_main270;
      const _defineComponent271 = window["Vue"].defineComponent;
      const _createElementVNode271 = window["Vue"].createElementVNode;
      const _openBlock271 = window["Vue"].openBlock;
      const _createElementBlock271 = window["Vue"].createElementBlock;
      var _sfc_main271 = /* @__PURE__ */ _defineComponent271({
        name: "TurnOff",
        __name: "turn-off",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock271(), _createElementBlock271("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode271("path", {
              fill: "currentColor",
              d: "M329.956 257.138a254.862 254.862 0 0 0 0 509.724h364.088a254.862 254.862 0 0 0 0-509.724zm0-72.818h364.088a327.68 327.68 0 1 1 0 655.36H329.956a327.68 327.68 0 1 1 0-655.36"
            }),
            _createElementVNode271("path", {
              fill: "currentColor",
              d: "M329.956 621.227a109.227 109.227 0 1 0 0-218.454 109.227 109.227 0 0 0 0 218.454m0 72.817a182.044 182.044 0 1 1 0-364.088 182.044 182.044 0 0 1 0 364.088"
            })
          ]));
        }
      }), turn_off_default = _sfc_main271;
      const _defineComponent272 = window["Vue"].defineComponent;
      const _createElementVNode272 = window["Vue"].createElementVNode;
      const _openBlock272 = window["Vue"].openBlock;
      const _createElementBlock272 = window["Vue"].createElementBlock;
      var _sfc_main272 = /* @__PURE__ */ _defineComponent272({
        name: "Umbrella",
        __name: "umbrella",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock272(), _createElementBlock272("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode272("path", {
              fill: "currentColor",
              d: "M320 768a32 32 0 1 1 64 0 64 64 0 0 0 128 0V512H64a448 448 0 1 1 896 0H576v256a128 128 0 1 1-256 0m570.688-320a384.128 384.128 0 0 0-757.376 0z"
            })
          ]));
        }
      }), umbrella_default = _sfc_main272;
      const _defineComponent273 = window["Vue"].defineComponent;
      const _createElementVNode273 = window["Vue"].createElementVNode;
      const _openBlock273 = window["Vue"].openBlock;
      const _createElementBlock273 = window["Vue"].createElementBlock;
      var _sfc_main273 = /* @__PURE__ */ _defineComponent273({
        name: "Unlock",
        __name: "unlock",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock273(), _createElementBlock273("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode273("path", {
              fill: "currentColor",
              d: "M224 448a32 32 0 0 0-32 32v384a32 32 0 0 0 32 32h576a32 32 0 0 0 32-32V480a32 32 0 0 0-32-32zm0-64h576a96 96 0 0 1 96 96v384a96 96 0 0 1-96 96H224a96 96 0 0 1-96-96V480a96 96 0 0 1 96-96"
            }),
            _createElementVNode273("path", {
              fill: "currentColor",
              d: "M512 544a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V576a32 32 0 0 1 32-32m178.304-295.296A192.064 192.064 0 0 0 320 320v64h352l96 38.4V448H256V320a256 256 0 0 1 493.76-95.104z"
            })
          ]));
        }
      }), unlock_default = _sfc_main273;
      const _defineComponent274 = window["Vue"].defineComponent;
      const _createElementVNode274 = window["Vue"].createElementVNode;
      const _openBlock274 = window["Vue"].openBlock;
      const _createElementBlock274 = window["Vue"].createElementBlock;
      var _sfc_main274 = /* @__PURE__ */ _defineComponent274({
        name: "UploadFilled",
        __name: "upload-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock274(), _createElementBlock274("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode274("path", {
              fill: "currentColor",
              d: "M544 864V672h128L512 480 352 672h128v192H320v-1.6c-5.376.32-10.496 1.6-16 1.6A240 240 0 0 1 64 624c0-123.136 93.12-223.488 212.608-237.248A239.81 239.81 0 0 1 512 192a239.87 239.87 0 0 1 235.456 194.752c119.488 13.76 212.48 114.112 212.48 237.248a240 240 0 0 1-240 240c-5.376 0-10.56-1.28-16-1.6v1.6z"
            })
          ]));
        }
      }), upload_filled_default = _sfc_main274;
      const _defineComponent275 = window["Vue"].defineComponent;
      const _createElementVNode275 = window["Vue"].createElementVNode;
      const _openBlock275 = window["Vue"].openBlock;
      const _createElementBlock275 = window["Vue"].createElementBlock;
      var _sfc_main275 = /* @__PURE__ */ _defineComponent275({
        name: "Upload",
        __name: "upload",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock275(), _createElementBlock275("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode275("path", {
              fill: "currentColor",
              d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64m384-578.304V704h-64V247.296L237.248 490.048 192 444.8 508.8 128l316.8 316.8-45.312 45.248z"
            })
          ]));
        }
      }), upload_default = _sfc_main275;
      const _defineComponent276 = window["Vue"].defineComponent;
      const _createElementVNode276 = window["Vue"].createElementVNode;
      const _openBlock276 = window["Vue"].openBlock;
      const _createElementBlock276 = window["Vue"].createElementBlock;
      var _sfc_main276 = /* @__PURE__ */ _defineComponent276({
        name: "UserFilled",
        __name: "user-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock276(), _createElementBlock276("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode276("path", {
              fill: "currentColor",
              d: "M288 320a224 224 0 1 0 448 0 224 224 0 1 0-448 0m544 608H160a32 32 0 0 1-32-32v-96a160 160 0 0 1 160-160h448a160 160 0 0 1 160 160v96a32 32 0 0 1-32 32z"
            })
          ]));
        }
      }), user_filled_default = _sfc_main276;
      const _defineComponent277 = window["Vue"].defineComponent;
      const _createElementVNode277 = window["Vue"].createElementVNode;
      const _openBlock277 = window["Vue"].openBlock;
      const _createElementBlock277 = window["Vue"].createElementBlock;
      var _sfc_main277 = /* @__PURE__ */ _defineComponent277({
        name: "User",
        __name: "user",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock277(), _createElementBlock277("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode277("path", {
              fill: "currentColor",
              d: "M512 512a192 192 0 1 0 0-384 192 192 0 0 0 0 384m0 64a256 256 0 1 1 0-512 256 256 0 0 1 0 512m320 320v-96a96 96 0 0 0-96-96H288a96 96 0 0 0-96 96v96a32 32 0 1 1-64 0v-96a160 160 0 0 1 160-160h448a160 160 0 0 1 160 160v96a32 32 0 1 1-64 0"
            })
          ]));
        }
      }), user_default = _sfc_main277;
      const _defineComponent278 = window["Vue"].defineComponent;
      const _createElementVNode278 = window["Vue"].createElementVNode;
      const _openBlock278 = window["Vue"].openBlock;
      const _createElementBlock278 = window["Vue"].createElementBlock;
      var _sfc_main278 = /* @__PURE__ */ _defineComponent278({
        name: "Van",
        __name: "van",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock278(), _createElementBlock278("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode278("path", {
              fill: "currentColor",
              d: "M128.896 736H96a32 32 0 0 1-32-32V224a32 32 0 0 1 32-32h576a32 32 0 0 1 32 32v96h164.544a32 32 0 0 1 31.616 27.136l54.144 352A32 32 0 0 1 922.688 736h-91.52a144 144 0 1 1-286.272 0H415.104a144 144 0 1 1-286.272 0zm23.36-64a143.872 143.872 0 0 1 239.488 0H568.32c17.088-25.6 42.24-45.376 71.744-55.808V256H128v416zm655.488 0h77.632l-19.648-128H704v64.896A144 144 0 0 1 807.744 672m48.128-192-14.72-96H704v96zM688 832a80 80 0 1 0 0-160 80 80 0 0 0 0 160m-416 0a80 80 0 1 0 0-160 80 80 0 0 0 0 160"
            })
          ]));
        }
      }), van_default = _sfc_main278;
      const _defineComponent279 = window["Vue"].defineComponent;
      const _createElementVNode279 = window["Vue"].createElementVNode;
      const _openBlock279 = window["Vue"].openBlock;
      const _createElementBlock279 = window["Vue"].createElementBlock;
      var _sfc_main279 = /* @__PURE__ */ _defineComponent279({
        name: "VideoCameraFilled",
        __name: "video-camera-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock279(), _createElementBlock279("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode279("path", {
              fill: "currentColor",
              d: "m768 576 192-64v320l-192-64v96a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V480a32 32 0 0 1 32-32h640a32 32 0 0 1 32 32zM192 768v64h384v-64zm192-480a160 160 0 0 1 320 0 160 160 0 0 1-320 0m64 0a96 96 0 1 0 192.064-.064A96 96 0 0 0 448 288m-320 32a128 128 0 1 1 256.064.064A128 128 0 0 1 128 320m64 0a64 64 0 1 0 128 0 64 64 0 0 0-128 0"
            })
          ]));
        }
      }), video_camera_filled_default = _sfc_main279;
      const _defineComponent280 = window["Vue"].defineComponent;
      const _createElementVNode280 = window["Vue"].createElementVNode;
      const _openBlock280 = window["Vue"].openBlock;
      const _createElementBlock280 = window["Vue"].createElementBlock;
      var _sfc_main280 = /* @__PURE__ */ _defineComponent280({
        name: "VideoCamera",
        __name: "video-camera",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock280(), _createElementBlock280("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode280("path", {
              fill: "currentColor",
              d: "M704 768V256H128v512zm64-416 192-96v512l-192-96v128a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V224a32 32 0 0 1 32-32h640a32 32 0 0 1 32 32zm0 71.552v176.896l128 64V359.552zM192 320h192v64H192z"
            })
          ]));
        }
      }), video_camera_default = _sfc_main280;
      const _defineComponent281 = window["Vue"].defineComponent;
      const _createElementVNode281 = window["Vue"].createElementVNode;
      const _openBlock281 = window["Vue"].openBlock;
      const _createElementBlock281 = window["Vue"].createElementBlock;
      var _sfc_main281 = /* @__PURE__ */ _defineComponent281({
        name: "VideoPause",
        __name: "video-pause",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock281(), _createElementBlock281("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode281("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 832a384 384 0 0 0 0-768 384 384 0 0 0 0 768m-96-544q32 0 32 32v256q0 32-32 32t-32-32V384q0-32 32-32m192 0q32 0 32 32v256q0 32-32 32t-32-32V384q0-32 32-32"
            })
          ]));
        }
      }), video_pause_default = _sfc_main281;
      const _defineComponent282 = window["Vue"].defineComponent;
      const _createElementVNode282 = window["Vue"].createElementVNode;
      const _openBlock282 = window["Vue"].openBlock;
      const _createElementBlock282 = window["Vue"].createElementBlock;
      var _sfc_main282 = /* @__PURE__ */ _defineComponent282({
        name: "VideoPlay",
        __name: "video-play",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock282(), _createElementBlock282("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode282("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 832a384 384 0 0 0 0-768 384 384 0 0 0 0 768m-48-247.616L668.608 512 464 375.616zm10.624-342.656 249.472 166.336a48 48 0 0 1 0 79.872L474.624 718.272A48 48 0 0 1 400 678.336V345.6a48 48 0 0 1 74.624-39.936z"
            })
          ]));
        }
      }), video_play_default = _sfc_main282;
      const _defineComponent283 = window["Vue"].defineComponent;
      const _createElementVNode283 = window["Vue"].createElementVNode;
      const _openBlock283 = window["Vue"].openBlock;
      const _createElementBlock283 = window["Vue"].createElementBlock;
      var _sfc_main283 = /* @__PURE__ */ _defineComponent283({
        name: "View",
        __name: "view",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock283(), _createElementBlock283("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode283("path", {
              fill: "currentColor",
              d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288m0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.19 160.19 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
            })
          ]));
        }
      }), view_default = _sfc_main283;
      const _defineComponent284 = window["Vue"].defineComponent;
      const _createElementVNode284 = window["Vue"].createElementVNode;
      const _openBlock284 = window["Vue"].openBlock;
      const _createElementBlock284 = window["Vue"].createElementBlock;
      var _sfc_main284 = /* @__PURE__ */ _defineComponent284({
        name: "WalletFilled",
        __name: "wallet-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock284(), _createElementBlock284("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode284("path", {
              fill: "currentColor",
              d: "M688 512a112 112 0 1 0 0 224h208v160H128V352h768v160zm32 160h-32a48 48 0 0 1 0-96h32a48 48 0 0 1 0 96m-80-544 128 160H384z"
            })
          ]));
        }
      }), wallet_filled_default = _sfc_main284;
      const _defineComponent285 = window["Vue"].defineComponent;
      const _createElementVNode285 = window["Vue"].createElementVNode;
      const _openBlock285 = window["Vue"].openBlock;
      const _createElementBlock285 = window["Vue"].createElementBlock;
      var _sfc_main285 = /* @__PURE__ */ _defineComponent285({
        name: "Wallet",
        __name: "wallet",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock285(), _createElementBlock285("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode285("path", {
              fill: "currentColor",
              d: "M640 288h-64V128H128v704h384v32a32 32 0 0 0 32 32H96a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32h512a32 32 0 0 1 32 32z"
            }),
            _createElementVNode285("path", {
              fill: "currentColor",
              d: "M128 320v512h768V320zm-32-64h832a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V288a32 32 0 0 1 32-32"
            }),
            _createElementVNode285("path", {
              fill: "currentColor",
              d: "M704 640a64 64 0 1 1 0-128 64 64 0 0 1 0 128"
            })
          ]));
        }
      }), wallet_default = _sfc_main285;
      const _defineComponent286 = window["Vue"].defineComponent;
      const _createElementVNode286 = window["Vue"].createElementVNode;
      const _openBlock286 = window["Vue"].openBlock;
      const _createElementBlock286 = window["Vue"].createElementBlock;
      var _sfc_main286 = /* @__PURE__ */ _defineComponent286({
        name: "WarnTriangleFilled",
        __name: "warn-triangle-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock286(), _createElementBlock286("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            "xml:space": "preserve",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode286("path", {
              fill: "currentColor",
              d: "M928.99 755.83 574.6 203.25c-12.89-20.16-36.76-32.58-62.6-32.58s-49.71 12.43-62.6 32.58L95.01 755.83c-12.91 20.12-12.9 44.91.01 65.03 12.92 20.12 36.78 32.51 62.59 32.49h708.78c25.82.01 49.68-12.37 62.59-32.49s12.92-44.91.01-65.03M554.67 768h-85.33v-85.33h85.33zm0-426.67v298.66h-85.33V341.32z"
            })
          ]));
        }
      }), warn_triangle_filled_default = _sfc_main286;
      const _defineComponent287 = window["Vue"].defineComponent;
      const _createElementVNode287 = window["Vue"].createElementVNode;
      const _openBlock287 = window["Vue"].openBlock;
      const _createElementBlock287 = window["Vue"].createElementBlock;
      var _sfc_main287 = /* @__PURE__ */ _defineComponent287({
        name: "WarningFilled",
        __name: "warning-filled",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock287(), _createElementBlock287("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode287("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.43 58.43 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.43 58.43 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
            })
          ]));
        }
      }), warning_filled_default = _sfc_main287;
      const _defineComponent288 = window["Vue"].defineComponent;
      const _createElementVNode288 = window["Vue"].createElementVNode;
      const _openBlock288 = window["Vue"].openBlock;
      const _createElementBlock288 = window["Vue"].createElementBlock;
      var _sfc_main288 = /* @__PURE__ */ _defineComponent288({
        name: "Warning",
        __name: "warning",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock288(), _createElementBlock288("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode288("path", {
              fill: "currentColor",
              d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 832a384 384 0 0 0 0-768 384 384 0 0 0 0 768m48-176a48 48 0 1 1-96 0 48 48 0 0 1 96 0m-48-464a32 32 0 0 1 32 32v288a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32"
            })
          ]));
        }
      }), warning_default = _sfc_main288;
      const _defineComponent289 = window["Vue"].defineComponent;
      const _createElementVNode289 = window["Vue"].createElementVNode;
      const _openBlock289 = window["Vue"].openBlock;
      const _createElementBlock289 = window["Vue"].createElementBlock;
      var _sfc_main289 = /* @__PURE__ */ _defineComponent289({
        name: "Watch",
        __name: "watch",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock289(), _createElementBlock289("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode289("path", {
              fill: "currentColor",
              d: "M512 768a256 256 0 1 0 0-512 256 256 0 0 0 0 512m0 64a320 320 0 1 1 0-640 320 320 0 0 1 0 640"
            }),
            _createElementVNode289("path", {
              fill: "currentColor",
              d: "M480 352a32 32 0 0 1 32 32v160a32 32 0 0 1-64 0V384a32 32 0 0 1 32-32"
            }),
            _createElementVNode289("path", {
              fill: "currentColor",
              d: "M480 512h128q32 0 32 32t-32 32H480q-32 0-32-32t32-32m128-256V128H416v128h-64V64h320v192zM416 768v128h192V768h64v192H352V768z"
            })
          ]));
        }
      }), watch_default = _sfc_main289;
      const _defineComponent290 = window["Vue"].defineComponent;
      const _createElementVNode290 = window["Vue"].createElementVNode;
      const _openBlock290 = window["Vue"].openBlock;
      const _createElementBlock290 = window["Vue"].createElementBlock;
      var _sfc_main290 = /* @__PURE__ */ _defineComponent290({
        name: "Watermelon",
        __name: "watermelon",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock290(), _createElementBlock290("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode290("path", {
              fill: "currentColor",
              d: "m683.072 600.32-43.648 162.816-61.824-16.512 53.248-198.528L576 493.248l-158.4 158.4-45.248-45.248 158.4-158.4-55.616-55.616-198.528 53.248-16.512-61.824 162.816-43.648L282.752 200A384 384 0 0 0 824 741.248zm231.552 141.056a448 448 0 1 1-632-632z"
            })
          ]));
        }
      }), watermelon_default = _sfc_main290;
      const _defineComponent291 = window["Vue"].defineComponent;
      const _createElementVNode291 = window["Vue"].createElementVNode;
      const _openBlock291 = window["Vue"].openBlock;
      const _createElementBlock291 = window["Vue"].createElementBlock;
      var _sfc_main291 = /* @__PURE__ */ _defineComponent291({
        name: "WindPower",
        __name: "wind-power",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock291(), _createElementBlock291("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode291("path", {
              fill: "currentColor",
              d: "M160 64q32 0 32 32v832q0 32-32 32t-32-32V96q0-32 32-32m416 354.624 128-11.584V168.96l-128-11.52v261.12zm-64 5.824V151.552L320 134.08V160h-64V64l616.704 56.064A96 96 0 0 1 960 215.68v144.64a96 96 0 0 1-87.296 95.616L256 512V224h64v217.92zm256-23.232 98.88-8.96A32 32 0 0 0 896 360.32V215.68a32 32 0 0 0-29.12-31.872l-98.88-8.96z"
            })
          ]));
        }
      }), wind_power_default = _sfc_main291;
      const _defineComponent292 = window["Vue"].defineComponent;
      const _createElementVNode292 = window["Vue"].createElementVNode;
      const _openBlock292 = window["Vue"].openBlock;
      const _createElementBlock292 = window["Vue"].createElementBlock;
      var _sfc_main292 = /* @__PURE__ */ _defineComponent292({
        name: "ZoomIn",
        __name: "zoom-in",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock292(), _createElementBlock292("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode292("path", {
              fill: "currentColor",
              d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704m-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64z"
            })
          ]));
        }
      }), zoom_in_default = _sfc_main292;
      const _defineComponent293 = window["Vue"].defineComponent;
      const _createElementVNode293 = window["Vue"].createElementVNode;
      const _openBlock293 = window["Vue"].openBlock;
      const _createElementBlock293 = window["Vue"].createElementBlock;
      var _sfc_main293 = /* @__PURE__ */ _defineComponent293({
        name: "ZoomOut",
        __name: "zoom-out",
        setup(__props) {
          return (_ctx, _cache) => (_openBlock293(), _createElementBlock293("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
          }, [
            _createElementVNode293("path", {
              fill: "currentColor",
              d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704M352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64"
            })
          ]));
        }
      }), zoom_out_default = _sfc_main293;
      const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        AddLocation: add_location_default,
        Aim: aim_default,
        AlarmClock: alarm_clock_default,
        Apple: apple_default,
        ArrowDown: arrow_down_default,
        ArrowDownBold: arrow_down_bold_default,
        ArrowLeft: arrow_left_default,
        ArrowLeftBold: arrow_left_bold_default,
        ArrowRight: arrow_right_default,
        ArrowRightBold: arrow_right_bold_default,
        ArrowUp: arrow_up_default,
        ArrowUpBold: arrow_up_bold_default,
        Avatar: avatar_default,
        Back: back_default,
        Baseball: baseball_default,
        Basketball: basketball_default,
        Bell: bell_default,
        BellFilled: bell_filled_default,
        Bicycle: bicycle_default,
        Bottom: bottom_default,
        BottomLeft: bottom_left_default,
        BottomRight: bottom_right_default,
        Bowl: bowl_default,
        Box: box_default,
        Briefcase: briefcase_default,
        Brush: brush_default,
        BrushFilled: brush_filled_default,
        Burger: burger_default,
        Calendar: calendar_default,
        Camera: camera_default,
        CameraFilled: camera_filled_default,
        CaretBottom: caret_bottom_default,
        CaretLeft: caret_left_default,
        CaretRight: caret_right_default,
        CaretTop: caret_top_default,
        Cellphone: cellphone_default,
        ChatDotRound: chat_dot_round_default,
        ChatDotSquare: chat_dot_square_default,
        ChatLineRound: chat_line_round_default,
        ChatLineSquare: chat_line_square_default,
        ChatRound: chat_round_default,
        ChatSquare: chat_square_default,
        Check: check_default,
        Checked: checked_default,
        Cherry: cherry_default,
        Chicken: chicken_default,
        ChromeFilled: chrome_filled_default,
        CircleCheck: circle_check_default,
        CircleCheckFilled: circle_check_filled_default,
        CircleClose: circle_close_default,
        CircleCloseFilled: circle_close_filled_default,
        CirclePlus: circle_plus_default,
        CirclePlusFilled: circle_plus_filled_default,
        Clock: clock_default,
        Close: close_default,
        CloseBold: close_bold_default,
        Cloudy: cloudy_default,
        Coffee: coffee_default,
        CoffeeCup: coffee_cup_default,
        Coin: coin_default,
        ColdDrink: cold_drink_default,
        Collection: collection_default,
        CollectionTag: collection_tag_default,
        Comment: comment_default,
        Compass: compass_default,
        Connection: connection_default,
        Coordinate: coordinate_default,
        CopyDocument: copy_document_default,
        Cpu: cpu_default,
        CreditCard: credit_card_default,
        Crop: crop_default,
        DArrowLeft: d_arrow_left_default,
        DArrowRight: d_arrow_right_default,
        DCaret: d_caret_default,
        DataAnalysis: data_analysis_default,
        DataBoard: data_board_default,
        DataLine: data_line_default,
        Delete: delete_default,
        DeleteFilled: delete_filled_default,
        DeleteLocation: delete_location_default,
        Dessert: dessert_default,
        Discount: discount_default,
        Dish: dish_default,
        DishDot: dish_dot_default,
        Document: document_default,
        DocumentAdd: document_add_default,
        DocumentChecked: document_checked_default,
        DocumentCopy: document_copy_default,
        DocumentDelete: document_delete_default,
        DocumentRemove: document_remove_default,
        Download: download_default,
        Drizzling: drizzling_default,
        Edit: edit_default,
        EditPen: edit_pen_default,
        Eleme: eleme_default,
        ElemeFilled: eleme_filled_default,
        ElementPlus: element_plus_default,
        Expand: expand_default,
        Failed: failed_default,
        Female: female_default,
        Files: files_default,
        Film: film_default,
        Filter: filter_default,
        Finished: finished_default,
        FirstAidKit: first_aid_kit_default,
        Flag: flag_default,
        Fold: fold_default,
        Folder: folder_default,
        FolderAdd: folder_add_default,
        FolderChecked: folder_checked_default,
        FolderDelete: folder_delete_default,
        FolderOpened: folder_opened_default,
        FolderRemove: folder_remove_default,
        Food: food_default,
        Football: football_default,
        ForkSpoon: fork_spoon_default,
        Fries: fries_default,
        FullScreen: full_screen_default,
        Goblet: goblet_default,
        GobletFull: goblet_full_default,
        GobletSquare: goblet_square_default,
        GobletSquareFull: goblet_square_full_default,
        GoldMedal: gold_medal_default,
        Goods: goods_default,
        GoodsFilled: goods_filled_default,
        Grape: grape_default,
        Grid: grid_default,
        Guide: guide_default,
        Handbag: handbag_default,
        Headset: headset_default,
        Help: help_default,
        HelpFilled: help_filled_default,
        Hide: hide_default,
        Histogram: histogram_default,
        HomeFilled: home_filled_default,
        HotWater: hot_water_default,
        House: house_default,
        IceCream: ice_cream_default,
        IceCreamRound: ice_cream_round_default,
        IceCreamSquare: ice_cream_square_default,
        IceDrink: ice_drink_default,
        IceTea: ice_tea_default,
        InfoFilled: info_filled_default,
        Iphone: iphone_default,
        Key: key_default,
        KnifeFork: knife_fork_default,
        Lightning: lightning_default,
        Link: link_default,
        List: list_default,
        Loading: loading_default,
        Location: location_default,
        LocationFilled: location_filled_default,
        LocationInformation: location_information_default,
        Lock: lock_default,
        Lollipop: lollipop_default,
        MagicStick: magic_stick_default,
        Magnet: magnet_default,
        Male: male_default,
        Management: management_default,
        MapLocation: map_location_default,
        Medal: medal_default,
        Memo: memo_default,
        Menu: menu_default,
        Message: message_default,
        MessageBox: message_box_default,
        Mic: mic_default,
        Microphone: microphone_default,
        MilkTea: milk_tea_default,
        Minus: minus_default,
        Money: money_default,
        Monitor: monitor_default,
        Moon: moon_default,
        MoonNight: moon_night_default,
        More: more_default,
        MoreFilled: more_filled_default,
        MostlyCloudy: mostly_cloudy_default,
        Mouse: mouse_default,
        Mug: mug_default,
        Mute: mute_default,
        MuteNotification: mute_notification_default,
        NoSmoking: no_smoking_default,
        Notebook: notebook_default,
        Notification: notification_default,
        Odometer: odometer_default,
        OfficeBuilding: office_building_default,
        Open: open_default,
        Operation: operation_default,
        Opportunity: opportunity_default,
        Orange: orange_default,
        Paperclip: paperclip_default,
        PartlyCloudy: partly_cloudy_default,
        Pear: pear_default,
        Phone: phone_default,
        PhoneFilled: phone_filled_default,
        Picture: picture_default,
        PictureFilled: picture_filled_default,
        PictureRounded: picture_rounded_default,
        PieChart: pie_chart_default,
        Place: place_default,
        Platform: platform_default,
        Plus: plus_default,
        Pointer: pointer_default,
        Position: position_default,
        Postcard: postcard_default,
        Pouring: pouring_default,
        Present: present_default,
        PriceTag: price_tag_default,
        Printer: printer_default,
        Promotion: promotion_default,
        QuartzWatch: quartz_watch_default,
        QuestionFilled: question_filled_default,
        Rank: rank_default,
        Reading: reading_default,
        ReadingLamp: reading_lamp_default,
        Refresh: refresh_default,
        RefreshLeft: refresh_left_default,
        RefreshRight: refresh_right_default,
        Refrigerator: refrigerator_default,
        Remove: remove_default,
        RemoveFilled: remove_filled_default,
        Right: right_default,
        ScaleToOriginal: scale_to_original_default,
        School: school_default,
        Scissor: scissor_default,
        Search: search_default,
        Select: select_default,
        Sell: sell_default,
        SemiSelect: semi_select_default,
        Service: service_default,
        SetUp: set_up_default,
        Setting: setting_default,
        Share: share_default,
        Ship: ship_default,
        Shop: shop_default,
        ShoppingBag: shopping_bag_default,
        ShoppingCart: shopping_cart_default,
        ShoppingCartFull: shopping_cart_full_default,
        ShoppingTrolley: shopping_trolley_default,
        Smoking: smoking_default,
        Soccer: soccer_default,
        SoldOut: sold_out_default,
        Sort: sort_default,
        SortDown: sort_down_default,
        SortUp: sort_up_default,
        Stamp: stamp_default,
        Star: star_default,
        StarFilled: star_filled_default,
        Stopwatch: stopwatch_default,
        SuccessFilled: success_filled_default,
        Sugar: sugar_default,
        Suitcase: suitcase_default,
        SuitcaseLine: suitcase_line_default,
        Sunny: sunny_default,
        Sunrise: sunrise_default,
        Sunset: sunset_default,
        Switch: switch_default,
        SwitchButton: switch_button_default,
        SwitchFilled: switch_filled_default,
        TakeawayBox: takeaway_box_default,
        Ticket: ticket_default,
        Tickets: tickets_default,
        Timer: timer_default,
        ToiletPaper: toilet_paper_default,
        Tools: tools_default,
        Top: top_default,
        TopLeft: top_left_default,
        TopRight: top_right_default,
        TrendCharts: trend_charts_default,
        Trophy: trophy_default,
        TrophyBase: trophy_base_default,
        TurnOff: turn_off_default,
        Umbrella: umbrella_default,
        Unlock: unlock_default,
        Upload: upload_default,
        UploadFilled: upload_filled_default,
        User: user_default,
        UserFilled: user_filled_default,
        Van: van_default,
        VideoCamera: video_camera_default,
        VideoCameraFilled: video_camera_filled_default,
        VideoPause: video_pause_default,
        VideoPlay: video_play_default,
        View: view_default,
        Wallet: wallet_default,
        WalletFilled: wallet_filled_default,
        WarnTriangleFilled: warn_triangle_filled_default,
        Warning: warning_default,
        WarningFilled: warning_filled_default,
        Watch: watch_default,
        Watermelon: watermelon_default,
        WindPower: wind_power_default,
        ZoomIn: zoom_in_default,
        ZoomOut: zoom_out_default
      }, Symbol.toStringTag, { value: "Module" }));
      exports("ElementPlusIconsVue", index);
    }
  };
});
